/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/main/java/org/junit/runner/Result.java;<<<<<<< MINE
			if (!fIgnoredDuringExecution)
				fCount++;
			fIgnoredDuringExecution= false;
=======
			fCount++;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
    public static final byte DOLLAR_BYTE = DOLLAR.getBytes(CHARSET)[0];
    public static final byte ASTERISK_BYTE = ASTERISK.getBytes(CHARSET)[0];
    public static final byte PLUS_BYTE = PLUS.getBytes(CHARSET)[0];
    public static final byte MINUS_BYTE = MINUS.getBytes(CHARSET)[0];
    public static final byte COLON_BYTE = COLON.getBytes(CHARSET)[0];

    public void sendCommand(DataOutputStream os, String name, String... args) {
	    StringBuilder sb = new StringBuilder();
	    sb.append(ASTERISK);
	    sb.append((new Integer(args.length + 1)).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(DOLLAR);
	    sb.append((new Integer(name.length())).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(name);
	    sb.append(COMMAND_DELIMITER);

	    for (String arg : args) {
		int size = arg.getBytes(CHARSET).length;

		sb.append(DOLLAR);
		sb.append((new Integer(size)).toString());
		sb.append(COMMAND_DELIMITER);
		sb.append(arg);
		sb.append(COMMAND_DELIMITER);
	    }

		try {
		    os.write(sb.toString().getBytes(CHARSET));
	    /*
	    os.write(ASTERISK_BYTE);
	    os.write((new Integer(args.length + 1)).toString()
		    .getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(DOLLAR_BYTE);
	    os.write((new Integer(name.length())).toString().getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(name.getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);

	    for (String arg : args) {
		byte[] barg = arg.getBytes(CHARSET);

		os.write(DOLLAR_BYTE);
		os.write((new Integer(barg.length)).toString()
			.getBytes(CHARSET));
		os.write(COMMAND_DELIMITER_BYTES);
		os.write(barg);
		os.write(COMMAND_DELIMITER_BYTES);
	    }
	    */
	} catch (IOException e) {
	    throw new JedisException(e);
	}
    }

    public void processError(DataInputStream is) {
	String message = readLine(is);
	throw new JedisException(message);
    }

    private String readLine(DataInputStream is) {
	byte b;
	byte c;
	StringBuilder sb = new StringBuilder();

	try {
	    while ((b = is.readByte()) != -1) {
		if (b == '\r') {
		    c = is.readByte();
		    if (c == '\n') {
			break;
		    }
		    sb.append((char) b);
		    sb.append((char) c);
		} else {
		    sb.append((char) b);
		}
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return sb.toString();
    }

    private Object process(DataInputStream is) {
	try {
	    byte b = is.readByte();
	    if (b == MINUS_BYTE) {
		processError(is);
	    } else if (b == ASTERISK_BYTE) {
		return processMultiBulkReply(is);
	    } else if (b == COLON_BYTE) {
		return processInteger(is);
	    } else if (b == DOLLAR_BYTE) {
		return processBulkReply(is);
	    } else if (b == PLUS_BYTE) {
		return processStatusCodeReply(is);
	    } else {
		throw new JedisException("Unknown reply: " + (char) b);
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return null;
    }

    private Object processStatusCodeReply(DataInputStream is) {
	String ret = null;
	ret = readLine(is);
	return ret;
    }

    private Object processBulkReply(DataInputStream is) {
	int len = Integer.parseInt(readLine(is));
	if (len == -1) {
	    return null;
	}
	byte[] read = new byte[len];
	int offset = 0;
	try {
		while(offset < len) {
		    offset += is.read(read, offset, (len - offset));
		}
	    // read 2 more bytes for the command delimiter
	    is.read();
	    is.read();
	} catch (IOException e) {
	    throw new JedisException(e);
	}

	return new String(read, CHARSET);
    }

    private Object processInteger(DataInputStream is) {
	int ret = 0;
	String num = readLine(is);
	ret = Integer.parseInt(num);
	return ret;
    }

    private Object processMultiBulkReply(DataInputStream is) {
	int num = Integer.parseInt(readLine(is));
	if (num == -1) {
	    return null;
	}
	List<Object> ret = new ArrayList<Object>();
	for (int i = 0; i < num; i++) {
	    ret.add(process(is));
	}
	return ret;
=======
    public static final byte DOLLAR_BYTE = '$';
    public static final byte ASTERISK_BYTE = '*';
    public static final byte PLUS_BYTE = '+';
    public static final byte MINUS_BYTE = '-';
    public static final byte COLON_BYTE = ':';

    public void sendCommand(RedisOutputStream os, String name, String... args) {
        try {
            os.write(ASTERISK_BYTE);
            os.writeIntCrLf(args.length + 1);
            os.write(DOLLAR_BYTE);
            os.writeIntCrLf(name.length());
            os.writeAsciiCrLf(name);

            for (String str : args) {
                os.write(DOLLAR_BYTE);
                final int size = RedisOutputStream.utf8Length(str);
                os.writeIntCrLf(size);
                if (size == str.length())
                    os.writeAsciiCrLf(str);
                else {
                    os.writeUtf8CrLf(str);
                }
            }
            os.flush();
        } catch (IOException e) {
            throw new JedisException(e);
        }
    }

    private void processError(RedisInputStream is) {
        String message = is.readLine();
        throw new JedisException(message);
    }

    private Object process(RedisInputStream is) {
        try {
            byte b = is.readByte();
            if (b == MINUS_BYTE) {
                processError(is);
            } else if (b == ASTERISK_BYTE) {
                return processMultiBulkReply(is);
            } else if (b == COLON_BYTE) {
                return processInteger(is);
            } else if (b == DOLLAR_BYTE) {
                return processBulkReply(is);
            } else if (b == PLUS_BYTE) {
                return processStatusCodeReply(is);
            } else {
                throw new JedisException("Unknown reply: " + (char) b);
            }
        } catch (IOException e) {
            throw new JedisException(e);
        }
        return null;
    }

    private String processStatusCodeReply(RedisInputStream is) {
        return is.readLine();
    }

    private String processBulkReply(RedisInputStream is) {
        int len = Integer.parseInt(is.readLine());
        if (len == -1) {
            return null;
        }
        byte[] read = new byte[len];
        int offset = 0;
        try {
            while (offset < len) {
                offset += is.read(read, offset, (len - offset));
            }
            // read 2 more bytes for the command delimiter
            is.readByte();
            is.readByte();
        } catch (IOException e) {
            throw new JedisException(e);
        }

        return new String(read, CHARSET);
    }

    private Integer processInteger(RedisInputStream is) {
        String num = is.readLine();
        return Integer.valueOf(num);
    }

    private List<Object> processMultiBulkReply(RedisInputStream is) {
        int num = Integer.parseInt(is.readLine());
        if (num == -1) {
            return null;
        }
        List<Object> ret = new ArrayList<Object>(num);
        for (int i = 0; i < num; i++) {
            ret.add(process(is));
        }
        return ret;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/test/java/redis/clients/jedis/tests/ProtocolTest.java;<<<<<<< MINE
    public void fragmentedBulkReply() {
    	FragmentedByteArrayInputStream fis = new FragmentedByteArrayInputStream("$30\r\n012345678901234567890123456789\r\n".getBytes());
    	Protocol protocol = new Protocol();
    	String response = (String) protocol.read(new DataInputStream(fis));
    	assertEquals("012345678901234567890123456789", response);
    	assertEquals(3, fis.getReadMethodCallCount());
    }

    
    @Test
=======
    public void fragmentedBulkReply() {
    	FragmentedByteArrayInputStream fis = new FragmentedByteArrayInputStream("$30\r\n012345678901234567890123456789\r\n".getBytes());
    	Protocol protocol = new Protocol();
    	String response = (String) protocol.read(new RedisInputStream(fis));
    	assertEquals("012345678901234567890123456789", response);
//    	assertEquals(3, fis.getReadMethodCallCount());
    }

    
    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
			return Description.createTestDescription(test.getClass(), getName(test));
=======
			return Description.createTestDescription(getEffectiveClass(test), getName(test));
		}

		@SuppressWarnings("unchecked")
		private Class<? extends Test> getEffectiveClass(Test test) {
			// TODO (Feb 23, 2009 11:45:54 PM): Think hard about this.
			if ("warning".equals(getName(test)))
				try {
					return (Class<? extends Test>) Class.forName(fTest.toString());
				} catch (ClassNotFoundException e) {
					return test.getClass();
				}
			return test.getClass();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	public static TestListener createAdaptingListener(final RunNotifier notifier) {
=======
	public TestListener createAdaptingListener(final RunNotifier notifier) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	private static Description makeDescription(Test test) {
=======
	// TODO (Feb 23, 2009 10:57:14 PM): V
	public static Description makeDescription(Test test) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
			for (int i= 0; i < n; i++)
				description.addChild(makeDescription(ts.testAt(i)));
=======
			for (int i= 0; i < n; i++) {
				Description made= makeDescription(ts.testAt(i));
				// TODO (Feb 23, 2009 11:25:23 PM): this is doing Max's work for it.  Max should get rid of these when sorting i
				if (!made.toString().startsWith("warning("))			
					description.addChild(made);
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	private Test getTest() {
=======
	// TODO (Feb 23, 2009 10:57:26 PM): V
	public Test getTest() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private EachTestNotifier makeNotifier(FrameworkMethod method,
=======
	protected EachTestNotifier makeNotifier(FrameworkMethod method,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
		addFirstListener(listener);
=======
		fNotifier.addFirstListener(listener);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
	//TODO javadoc
	public static Filter matchDescription(final Description desiredDescription) {
=======
	
	/**
	 * Returns a {@code Filter} that only runs the single method described by
	 * {@code desiredDescription}
	 */
	public static Filter matchMethodDescription(final Description desiredDescription) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
			: null;
=======
			: toString();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/Request.java;<<<<<<< MINE
		return filterWith(Filter.matchDescription(desiredDescription));
=======
		return filterWith(Filter.matchMethodDescription(desiredDescription));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	protected Map<String, Long> fDurations= new HashMap<String, Long>();
	protected Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();
	private final String fFolder;
	
	private MaxCore(String folder) {
		fFolder= folder;
=======
	public MaxCore(File storedResults) {
		fHistory = MaxHistory.forFolder(storedResults);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private MaxCore() {
		// TODO: ensure fresh
		this("MaxCore");
=======
	public Result run(Class<?> testClass) {
		return run(Request.aClass(testClass));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		core.addListener(new RememberingListener());
=======
		core.addListener(fHistory.listener());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public String getFolder() {
		return fFolder;
	}

	public void forget() {
		new File(fFolder).delete();
	}

	private Request sortRequest(Request request) {
=======
	// TODO (Feb 23, 2009 10:14:05 PM): publicized for squeeze
	public Request sortRequest(Request request) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		Collections.sort(leaves, new TestComparator());
=======
		Collections.sort(leaves, fHistory.testComparator());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private Request constructLeafRequest(List<Description> leaves) {
=======
	// TODO (Feb 23, 2009 10:42:05 PM): V
	public Request constructLeafRequest(List<Description> leaves) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private Runner buildRunner(Description each) {
=======
	// TODO (Feb 23, 2009 11:17:01 PM): V
	public Runner buildRunner(Description each) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		return Request.method(type, each.getMethodName()).getRunner();
	}

	private void save() throws FileNotFoundException, IOException {
		ObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(fFolder + ".ser"));
		stream.writeObject(this);
		stream.close();
=======
		String methodName= each.getMethodName();
		if (methodName == null)
			return Request.aClass(type).getRunner();
		return Request.method(type, methodName).getRunner();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		private Long getFailure(Description key) {
			Long result= getFailureTimestamp(key);
			if (result == null) 
				return 0L; // 0 = "never failed (that I know about)"
			return result;
		}
	}
	
	private List<Description> findLeaves(Request request) {
=======
	// TODO (Feb 23, 2009 10:40:23 PM): V
	public List<Description> findLeaves(Request request) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private void findLeaves(Description description, List<Description> results) {
=======
	// TODO (Feb 23, 2009 10:50:48 PM): V
	public void findLeaves(Description description, List<Description> results) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
	@Test/*(timeout=1500)*/ public void testsRunInParallel() {
=======
	@Test public void testsRunInParallel() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
		assertThat(end - start, greaterThanOrEquals(1000));
=======
		assertThat(end - start, betweenInclusive(1000, 1500));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
	private Matcher<Long> greaterThanOrEquals(final long l) {
=======
	private Matcher<Long> betweenInclusive(final long min, final long max) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
				return item >= l;
=======
				return item >= min && item <= max;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
				description.appendText("greater than or equal" + l);
=======
				description.appendText("between " + min + " and " + max);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;<<<<<<< MINE
		fMax= MaxCore.createFresh();
=======
		fMaxFile= new File("MaxCore.ser");
		if (fMaxFile.exists())
			fMaxFile.delete();
		fMax= MaxCore.storedLocally(fMaxFile);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;<<<<<<< MINE
		fMax.forget();
=======
		fMaxFile.delete();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		fMax= MaxCore.createFresh();
=======
		fMaxFile= new File("MaxCore.ser");
		if (fMaxFile.exists())
			fMaxFile.delete();
		fMax= MaxCore.storedLocally(fMaxFile);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		fMax.forget();
=======
		fMaxFile.delete();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
	
	@Test public void saffSqueezeExample() throws Exception {
		final Description method= Description.createTestDescription(TwoOldTests.class, "testOne");
		Filter filter= Filter.matchDescription(method);
=======

	@Test
	public void saffSqueezeExample() throws Exception {
		final Description method= Description.createTestDescription(
				TwoOldTests.class, "testOne");
		Filter filter= Filter.matchMethodDescription(method);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		// TODO (Nov 18, 2008 4:42:43 PM): DUP above
		Class<AllTests> testClass= AllTests.class;
		assertFilterLeavesTestUnscathed(testClass);
=======
		assertFilterLeavesTestUnscathed(AllTests.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	JUnit38SortingTest.class
=======
	JUnit38SortingTest.class,
	MaxComputerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
				save();
=======
				fHistory.save();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jeromq/revisions/rev_422e861_d89fa27/rev_422e861-d89fa27/src/test/java/org/jeromq/TestZLoop.java;<<<<<<< MINE
        loop.pollerEnd(poll_input);
        ctx.destroy();
        //  @end
        printf ("OK\n");
    }
    
    @Test(timeout = 1000)
    public void testZLoopEndReactorFromTimer() {
        printf (" * zloop end reactor from timer: ");
        int rc = 0;
        //  @selftest
        ZContext ctx = new ZContext ();
        assert (ctx != null);
        
        Socket output = ctx.createSocket(ZMQ.PAIR);
        assert (output != null);
        output.bind("inproc://zloop.test");
        Socket input = ctx.createSocket(ZMQ.PAIR);
        assert (input != null);
        input.connect( "inproc://zloop.test");

        ZLoop loop = ZLoop.instance();
        assert (loop != null);
        loop.verbose (true);
        
        ZLoop.IZLoopHandler s_timer_event = new ZLoop.IZLoopHandler() {

            @Override
            public int handle(ZLoop loop, PollItem item, Object arg) {
                ((Socket)arg).send("PING", 0);
                return 0;
            }
        };
        
        ZLoop.IZLoopHandler s_socket_event = new ZLoop.IZLoopHandler() {

            @Override
            public int handle(ZLoop loop, PollItem item, Object arg) {
                //  After 10 msecs, fire an event that ends the reactor
            	ZLoop.IZLoopHandler s_shutdown_event = new ZLoop.IZLoopHandler() {
                    @Override
                    public int handle(ZLoop loop, PollItem item, Object arg) {
                    	//  Just end the reactor
                        return -1;
                    }
                };
                loop.timer(10, 1, s_shutdown_event, s_shutdown_event);
                return 0;
            }
        };

        //  Fire event that sends a ping message to output
        loop.timer (0, 1, s_timer_event, output);
        
        //  When we get the ping message, end the reactor
        PollItem poll_input = new PollItem( input, ZMQ.POLLIN );
        rc = loop.poller (poll_input, s_socket_event, null);
        assert (rc == 0);
        loop.start ();

        loop.pollerEnd(poll_input);
=======
        loop.pollerEnd(poll_input);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jeromq/revisions/rev_422e861_d89fa27/rev_422e861-d89fa27/src/test/java/org/jeromq/TestZLoop.java;<<<<<<< MINE
        System.out.println(s);
=======
        System.out.print(s);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.5";
=======
		return "4.6-RC1";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
					Assert.assertEquals((Double)expected, (Double)actual, fDelta);
=======
					if (expected instanceof Double)
						Assert.assertEquals((Double)expected, (Double)actual, fDelta);
					else
						Assert.assertEquals((Float)expected, (Float)actual, fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ef92925_469dcc7/rev_ef92925-469dcc7/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.6-RC1";
=======
		return "4.6";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
    public JedisPool(ShardInfo shardInfo) {
=======
    public JedisPool(JedisShardInfo shardInfo) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public ShardedJedis(List<ShardInfo> shards, Hashing algo) {
=======
    public ShardedJedis(List<JedisShardInfo> shards, Hashing algo) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
	for (Jedis jedis : getAllShards()) {
	    jedis.disconnect();
=======
	for (JedisShardInfo jedis : getAllShards()) {
	    jedis.getResource().disconnect();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    protected Jedis create(ShardInfo shard) {
=======
    protected Jedis create(JedisShardInfo shard) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Jedis(ShardInfo shardInfo) {
=======
    public Jedis(JedisShardInfo shardInfo) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
	try {
	    connect();
	} catch (UnknownHostException e) {
	    throw new JedisException("Could not connect to redis-server", e);
	} catch (IOException e) {
	    throw new JedisException("Could not connect to redis-server", e);
	}
=======
		try {
			connect();
		} catch (UnknownHostException e) {
			throw new JedisException("Could not connect to redis-server", e);
		} catch (IOException e) {
			throw new JedisException("Could not connect to redis-server", e);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
    public Integer getIntegerReply() {
=======
    public int getIntegerReply() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
	return (Integer) protocol.read(inputStream);
=======
	return ((Integer) protocol.read(inputStream)).intValue();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    public Sharded(List<ShardInfo> shards) {
	initialize(shards);
=======
    public Sharded(List<S> shards) {
        this(shards, Hashing.MURMUR_HASH); // MD5 is really not good as we works with 64-bits not 128
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    public Sharded(List<ShardInfo> shards, Hashing algo) {
	initialize(shards);
=======
    public Sharded(List<S> shards, Hashing algo) {
        this.algo = algo;
        initialize(shards);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    private void initialize(List<ShardInfo> shards) {
	nodes = new TreeMap<Long, ShardInfo>();
	resources = new HashMap<ShardInfo, T>();
=======
    private void initialize(List<S> shards) {
        nodes = new TreeMap<Long, S>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	for (ShardInfo shard : shards) {
	    totalWeight += shard.getWeight();
	}
=======
        for (ShardInfo shard : shards) {
            totalWeight += shard.getWeight();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	for (ShardInfo shard : shards) {
	    double factor = Math
		    .floor(((double) (40 * shards.size() * DEFAULT_WEIGHT))
			    / (double) totalWeight);

	    for (long j = 0; j < factor; j++) {
		byte[] d = md5.digest((shard.toString() + "-" + j).getBytes());
		for (int h = 0; h < 4; h++) {
		    Long k = ((long) (d[3 + h * 4] & 0xFF) << 24)
			    | ((long) (d[2 + h * 4] & 0xFF) << 16)
			    | ((long) (d[1 + h * 4] & 0xFF) << 8)
			    | ((long) (d[0 + h * 4] & 0xFF));
		    nodes.put(k, shard);
		}
	    }
	    resources.put(shard, create(shard));
	}
=======
        long floor = Long.MIN_VALUE;
        for (int i = 0; i != shards.size(); ++i) {
            final S shardInfo = shards.get(i);
            shardInfo.initResource();
            nodes.put(floor, shardInfo);
            floor += 4 * oneForthOfStep * shardInfo.getWeight(); // *4 to compensate 62 vs 64
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    public ShardInfo getShardInfo(String key) {
	long hv = calculateHash(key);

	return nodes.get(findPointFor(hv));
=======
    public R getShard(String key) {
        return nodes.floorEntry(algo.hash(key)).getValue().getResource();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    private Long calculateHash(String key) {
	return algo.hash(key);
=======
    public S getShardInfo(String key) {
        return nodes.floorEntry(algo.hash(key)).getValue();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    private Long findPointFor(Long hashK) {
	Long k = nodes.ceilingKey(hashK);

	if (k == null) {
	    k = nodes.firstKey();
	}

	return k;
    }

    public T getShard(String key) {
	ShardInfo shard = getShardInfo(key);
	return resources.get(shard);
    }

    protected abstract T create(ShardInfo shard);

    public Collection<T> getAllShards() {
	return resources.values();
=======
    public Collection<S> getAllShards() {
        return Collections.unmodifiableCollection(nodes.values());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public String getHost() {
	return host;
=======
    public ShardInfo() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public int getPort() {
	return port;
=======
    public ShardInfo(int weight) {
        this.weight = weight;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public int getTimeout() {
	return timeout;
    }

    public ShardInfo(String host) {
	this(host, Protocol.DEFAULT_PORT);
=======
    public int getWeight() {
        return this.weight;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public ShardInfo(String host, int port) {
	this(host, port, 2000);
=======
    public T getResource() {
        return resource;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    @Override
    public int hashCode() {
	final int prime = 31;
	int result = 1;
	result = prime * result + ((host == null) ? 0 : host.hashCode());
	result = prime * result + port;
	result = prime * result + timeout;
	result = prime * result + weight;
	return result;
=======
    public void initResource () {
        resource = createResource();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	List<ShardInfo> shards = new ArrayList<ShardInfo>();
	shards.add(new ShardInfo(redis1.host, redis1.port));
	shards.add(new ShardInfo(redis2.host, redis2.port));
=======
	List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
	shards.add(new JedisShardInfo(redis1.host, redis1.port));
	shards.add(new JedisShardInfo(redis2.host, redis2.port));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	si = new ShardInfo(redis2.host, redis2.port);
=======
	si = new JedisShardInfo(redis2.host, redis2.port);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	si = new ShardInfo(redis2.host, redis2.port);
=======
	si = new JedisShardInfo(redis2.host, redis2.port);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	totalWeight = 0;
=======
        int totalWeight = 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	MessageDigest md5;
	try {
	    md5 = MessageDigest.getInstance("MD5");
	} catch (NoSuchAlgorithmException e) {
	    throw new IllegalStateException("++++ no md5 algorythm found");
	}
=======
        long oneForthOfStep = (1L << 62) / totalWeight; // 62 vs 64 to normalize math in Long
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
		ExecutorService service= Executors.newSingleThreadExecutor();
		Callable<Object> callable= new Callable<Object>() {
			public Object call() throws Exception {
=======
		Thread thread= new Thread() {
			@Override
			public void run() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
					throw new ExecutionException(e);
=======
					fThrown= e;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
		Future<Object> result= service.submit(callable);
		service.shutdown();
		try {
			boolean terminated= service.awaitTermination(fTimeout,
					TimeUnit.MILLISECONDS);
			if (!terminated)
				service.shutdownNow();
			result.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation
		} catch (TimeoutException e) {
			throw new Exception(String.format(
					"test timed out after %d milliseconds", fTimeout));
		} catch (ExecutionException e) {
			throw unwrap(e);
		}
	}

	private Throwable unwrap(Throwable e) {
		if (e instanceof ExecutionException)
			return unwrap(e.getCause());
		return e;
=======
		thread.start();
		thread.join(fTimeout);
		if (fFinished)
			return;
		if (fThrown != null)
			throw fThrown;
		Exception exception= new Exception(String.format(
				"test timed out after %d milliseconds", fTimeout));
		exception.setStackTrace(thread.getStackTrace());
		throw exception;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;<<<<<<< MINE
		assertTrue(writer.toString().contains("infiniteLoop")); // Make sure we have the stalled frame on the stack somewhere
=======
		assertThat(buffer.toString(), containsString("infiniteLoop")); // Make sure we have the stalled frame on the stack somewhere
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Jedis(JedisShardInfo shardInfo) {
        client = new Client(shardInfo.getHost(), shardInfo.getPort());
        client.setTimeout(shardInfo.getTimeout());
        this.password = shardInfo.getPassword();
    }

    public String ping() {
        runChecks();
        client.ping();
        return client.getStatusCodeReply();
=======
    public Jedis(final JedisShardInfo shardInfo) {
    	super(shardInfo);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Transaction multi() {
        client.multi();
        client.getStatusCodeReply();
        return new Transaction(client);
    }

    public List<Object> multi(TransactionBlock jedisTransaction) {
        List<Object> results = null;
        try {
            jedisTransaction.setClient(client);
            multi();
            jedisTransaction.execute();
            results = jedisTransaction.exec();
        } catch (Exception ex) {
            client.discard();
        }
        return results;
    }

    private void runChecks() {
        if (client.isInMulti()) {
            throw new JedisException(
                    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
        }
        try {
            this.connect();
        } catch (UnknownHostException e) {
            throw new JedisException(e);
        } catch (IOException e) {
            throw new JedisException(e);
        }
    }

    public void connect() throws UnknownHostException, IOException {
        if (!client.isConnected()) {
            client.connect();
            if (this.password != null) {
                this.auth(this.password);
            }
        }
    }

    public void disconnect() throws IOException {
        client.disconnect();
    }

    public String watch(String key) {
=======
    public String watch(final String key) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(String password) {
        runChecks();
        client.auth(password);
        return client.getStatusCodeReply();
    }

    public List<Object> pipelined(JedisPipeline jedisPipeline) {
        jedisPipeline.setClient(client);
        jedisPipeline.execute();
        return client.getAll();
    }

    public void subscribe(JedisPubSub jedisPubSub, String... channels) {
        client.setTimeoutInfinite();
        jedisPubSub.proceed(client, channels);
        client.rollbackTimeout();
    }

    public Integer publish(String channel, String message) {
        client.publish(channel, message);
        return client.getIntegerReply();
    }

    public void psubscribe(JedisPubSub jedisPubSub, String... patterns) {
        client.setTimeoutInfinite();
        jedisPubSub.proceedWithPatterns(client, patterns);
        client.rollbackTimeout();
    }

    public Integer zcount(String key, double min, double max) {
        runChecks();
=======
    public Integer zcount(final String key, final double min, final double max) {
        checkIsInMulti();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
    protected Connection sendCommand(String name, String... args) {
        protocol.sendCommand(outputStream, name, args);
=======
    protected Connection sendCommand(final Command cmd, final String... args) {
    	final byte[][] bargs = new byte[args.length][];
    	for(int i=0; i < args.length; i++) {
    		bargs[i] = args[i].getBytes(Protocol.UTF8);
    	}
    	return sendCommand(cmd, bargs);
    }

    protected Connection sendCommand(final Command cmd, final byte[]... args) {
        try {
            connect();
        } catch (UnknownHostException e) {
            throw new JedisException("Could not connect to redis-server", e);
        } catch (IOException e) {
            throw new JedisException("Could not connect to redis-server", e);
        }
        protocol.sendCommand(outputStream, cmd, args);
        pipelinedCommands++;
        return this;
    }

    protected Connection sendCommand(final Command cmd) {
        try {
            connect();
        } catch (UnknownHostException e) {
            throw new JedisException("Could not connect to redis-server", e);
        } catch (IOException e) {
            throw new JedisException("Could not connect to redis-server", e);
        }
        protocol.sendCommand(outputStream, cmd, new byte[0][]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.6";
=======
		return "4.7-SNAPSHOT-20090428-1600";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/AfterClass.java;<<<<<<< MINE
 *    DatabaseConnection database;
=======
 *    private static DatabaseConnection database;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	MaxComputerTest.class
=======
	MaxComputerTest.class,
	InterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Transaction.java;<<<<<<< MINE
    public String setbit(String key, long offset, boolean value) {
=======
    public void setbit(String key, long offset, String value) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        while (pipelinedCommands > 0) {
=======
        while (pipelinedCommands > except) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.7-SNAPSHOT-20090428-1600";
=======
		return "4.7-SNAPSHOT-20090507-1339";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
	// TODO (Sep 8, 2008 4:36:12 PM): check structure
	
	/**
	 * Asserts that two object arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown with the given message. If
	 * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,
	 * they are considered equal.
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expecteds
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            expected values.
	 * @param actuals
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            actual values
	 * @param criteria TODO
	 */
	public void internalArrayEquals(String message, Object expecteds,
			Object actuals) throws ArrayComparisonFailure {
		// TODO: DUP above
		// TODO (Sep 8, 2008 4:32:50 PM): Test that this fails sometimes
		// TODO (Sep 8, 2008 4:33:04 PM): Update javadoc
		
		if (expecteds == actuals)
			return;
		String header= message == null ? "" : message + ": ";
		
		int expectedsLength= Assert.assertArraysAreSameLength(expecteds, actuals,
				header);

		for (int i= 0; i < expectedsLength; i++) {
			Object expected= Array.get(expecteds, i);
			Object actual= Array.get(actuals, i);
			
			if (Assert.isArray(expected) && Assert.isArray(actual)) {
				try {
					internalArrayEquals(message, expected, actual);
				} catch (ArrayComparisonFailure e) {
					e.addDimension(i);
					throw e;
				}
			} else
				try {
					if (expected instanceof Double)
						Assert.assertEquals((Double)expected, (Double)actual, fDelta);
					else
						Assert.assertEquals((Float)expected, (Float)actual, fDelta);
				} catch (AssertionError e) {
					throw new ArrayComparisonFailure(header, e, i);
				}
		}
=======
	// TODO (Apr 29, 2009 4:43:46 PM): Look for missing JavaDoc
	@Override
	protected void assertElementsEqual(Object expected, Object actual) {
		if (expected instanceof Double)
			Assert.assertEquals((Double)expected, (Double)actual, fDelta);
		else
			Assert.assertEquals((Float)expected, (Float)actual, fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
		new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);
=======
		new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two double arrays are equal. If they are not, an
=======
	 * Asserts that two float arrays are equal. If they are not, an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with expected values.
=======
	 *            float array with expected values.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with actual values
=======
	 *            float array with actual values
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
		new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);
=======
		new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two double arrays are equal. If they are not, an
=======
	 * Asserts that two float arrays are equal. If they are not, an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with expected values.
=======
	 *            float array with expected values.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with actual values
=======
	 *            float array with actual values
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
		if (expecteds == actuals)
			return;
		String header= message == null ? "" : message + ": ";
		int expectedsLength= assertArraysAreSameLength(expecteds, actuals,
				header);

		for (int i= 0; i < expectedsLength; i++) {
			Object expected= Array.get(expecteds, i);
			Object actual= Array.get(actuals, i);
			// TODO (Nov 6, 2008 12:58:55 PM): Is this a DUP?
			if (isArray(expected) && isArray(actual)) {
				try {
					internalArrayEquals(message, expected, actual);
				} catch (ArrayComparisonFailure e) {
					e.addDimension(i);
					throw e;
				}
			} else
				try {
					assertEquals(expected, actual);
				} catch (AssertionError e) {
					throw new ArrayComparisonFailure(header, e, i);
				}
		}
	}
	
=======
		new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);
	}	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public Description describeChild(T child) {
			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
			return fDelegate.internalDescribeChild(child);
=======
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fCollator.process(callable);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public List<T> getChildren() {
			return fDelegate.internalGetChildren();
=======
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fCollator.results)
				try {
					each.get();
				} catch (Exception e) {
					e.printStackTrace();
				} 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
			}));
=======
			};
			fCollator.process(callable);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
					each.get(2000, TimeUnit.MILLISECONDS); // TODO(parallel) what should this really be?
=======
					each.get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	protected final TestClass getTestClass() {
=======
	public final TestClass getTestClass() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runner/Computer.java;<<<<<<< MINE
	public Suite getSuite(final RunnerBuilder builder,
=======
	public Runner getSuite(final RunnerBuilder builder,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
	protected Statement withAfters(FrameworkMethod method, Object target,
=======
	protected Statement withBefores(FrameworkMethod method, Object target,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
		return super.withAfters(method, target, intercept(statement, target, method));
=======
		return super.withBefores(method, target, intercept(statement, target, method));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fCollator.process(callable);
=======
		public Description describeChild(T child) {
			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
			return fDelegate.internalDescribeChild(child);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fCollator.results)
				try {
					each.get();
				} catch (Exception e) {
					e.printStackTrace();
				} 
=======
		public List<T> getChildren() {
			return fDelegate.internalGetChildren();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		protected void runChild(final FrameworkMethod method, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
=======
		public void runChild(final T child, final RunNotifier notifier) {
			fResults.add(fService.submit(new Callable<Object>() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
					superRunChild(method, notifier);
=======
					fDelegate.internalRunChild(child, notifier);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
			};
			fCollator.process(callable);
=======
			}));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
			for (Future<Object> each : fCollator.results)
=======
			for (Future<Object> each : fResults)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
				} 
=======
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	public Suite getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes) throws InitializationError {
		return fClasses
			? new ParallelSuite(builder, classes)
			: super.getSuite(builder, classes);
=======
	public Runner getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes)
			throws InitializationError {
		Suite suite= (Suite) super.getSuite(builder, classes);
		return fClasses ? parallelize(suite) : suite;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;<<<<<<< MINE
		protected void runChild(FrameworkMethod method, RunNotifier notifier) {
=======
		public void runChild(FrameworkMethod method, RunNotifier notifier) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	InterceptorTest.class
=======
	InterceptorTest.class,
	TimeoutInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		return fMethods
			? new ParallelRunner(testClass)
			: super.getRunner(builder, testClass);
	}

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}
	
	private static class ParallelCollator {
		private final List<Future<Object>> results = new ArrayList<Future<Object>>();
		private final ExecutorService service = Executors.newCachedThreadPool();

		public void process(Callable<Object> callable) {
			this.results.add(service.submit(callable));
		}
=======
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
	public void starting(FrameworkMethod method) {
=======
	public void starting(FrameworkMethod method) throws Exception {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
=======
	private boolean shouldParallelize(Runner runner) {
		if (runner instanceof ParentRunner) {
			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
			if (fClasses && parentRunner.isSuite())
				return true;
			if (fMethods && !parentRunner.isSuite())
				return true;
		}
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	ParallelMethodTest.class
=======
	ParallelMethodTest.class,
	ParentRunnerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
=======
	private boolean shouldParallelize(Runner runner) {
		if (runner instanceof ParentRunner) {
			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
			if (fClasses && parentRunner.isSuite())
				return true;
			if (fMethods && !parentRunner.isSuite())
				return true;
		}
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	TimeoutInterceptorTest.class
=======
	TimeoutInterceptorTest.class,
	ParallelClassTest.class,
	ParallelMethodTest.class,
	ParentRunnerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8aa25eb_58aa95c/rev_8aa25eb-58aa95c/src/main/java/redis/clients/jedis/Pipeline.java;<<<<<<< MINE
    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
=======
    //--
    public void zrevrangeByScore(String key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(byte[] key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, String max, String min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScore(byte[] key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(byte[] key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(byte[] key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrangeWithScores(String key, int start, int end) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		statement= new RunBefores(statement, befores, null);
		return statement;
=======
		return befores.isEmpty() ? statement :
			new RunBefores(statement, befores, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		statement= new RunAfters(statement, afters, null);
		return statement;
=======
		return afters.isEmpty() ? statement : 
			new RunAfters(statement, afters, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		return new RunBefores(statement, befores, target);
=======
		return befores.isEmpty() ? statement : 
			new RunBefores(statement, befores, target);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		return new RunAfters(statement, afters, target);
=======
		return afters.isEmpty() ? statement :
			new RunAfters(statement, afters, target);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	ParentRunnerTest.class
=======
	ParentRunnerTest.class,
	NameInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
	boolean isShadowedBy(List<FrameworkMethod> results) {
		for (FrameworkMethod each : results)
			if (isShadowedBy(each))
				return true;
		return false;
	}

	private boolean isShadowedBy(FrameworkMethod each) {
		if (!each.getName().equals(getName()))
=======
	public boolean isShadowedBy(FrameworkMethod other) {
		if (!other.getName().equals(getName()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
		if (each.getParameterTypes().length != getParameterTypes().length)
=======
		if (other.getParameterTypes().length != getParameterTypes().length)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
		for (int i= 0; i < each.getParameterTypes().length; i++)
			if (!each.getParameterTypes()[i].equals(getParameterTypes()[i]))
=======
		for (int i= 0; i < other.getParameterTypes().length; i++)
			if (!other.getParameterTypes()[i].equals(getParameterTypes()[i]))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		for (Class<?> eachClass : getSuperClasses(fClass))
=======
		for (Class<?> eachClass : getSuperClasses(fClass)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
				addToAnnotationLists(new FrameworkMethod(eachMethod));
=======
				addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);
			for (Field eachField : eachClass.getDeclaredFields())
				addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	private void addToAnnotationLists(FrameworkMethod testMethod) {
		for (Annotation each : computeAnnotations(testMethod))
			addToAnnotationList(each.annotationType(), testMethod);
	}

	/**
	 * Returns all of the annotations on {@code testMethod}
	 */
	protected Annotation[] computeAnnotations(FrameworkMethod testMethod) {
		return testMethod.getAnnotations();
=======
	// TODO (May 25, 2009 9:46:48 PM): move to FrameworkMember
	private <T extends FrameworkMember<T>> void addToAnnotationLists(T member, Map<Class<?>, List<T>> map) {
		for (Annotation each : member.getAnnotations()) {
			Class<? extends Annotation> type= each.annotationType();
			ensureKey(map, type);
			List<T> members= map.get(type);
			if (isShadowedBy(member, members))
				return;
			if (runsTopToBottom(type))
				members.add(0, member);
			else
				members.add(member);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	private void addToAnnotationList(Class<? extends Annotation> annotation,
			FrameworkMethod testMethod) {
		List<FrameworkMethod> methods= getAnnotatedMethods(annotation);
		if (testMethod.isShadowedBy(methods))
			return;
		if (runsTopToBottom(annotation))
			methods.add(0, testMethod);
		else
			methods.add(testMethod);
=======
	private <T extends FrameworkMember<T>> boolean isShadowedBy(T member, List<T> members) {
		for (T each : members)
			if (member.isShadowedBy(each))
				return true;
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	private void ensureKey(Class<? extends Annotation> annotation) {
		if (!fMethodsForAnnotations.containsKey(annotation))
			fMethodsForAnnotations.put(annotation,
					new ArrayList<FrameworkMethod>());
=======
	private <T> void ensureKey(Map<Class<?>, List<T>> map, Class<?> annotation) {
		if (!map.containsKey(annotation))
			map.put(annotation, new ArrayList<T>());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		ensureKey(annotationClass);
=======
		// TODO (May 25, 2009 10:02:46 PM): DUP
		ensureKey(fMethodsForAnnotations, annotationClass);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	
	private void validateConstructor(List<Throwable> errors) {
=======

	protected void validateConstructor(List<Throwable> errors) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestName.java;<<<<<<< MINE
	public void starting(FrameworkMethod method) throws Exception {
=======
	public void starting(FrameworkMethod method) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
	public void starting(FrameworkMethod method) throws Exception {
=======
	public void starting(FrameworkMethod method) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	private static <T> Runner parallelize(ParentRunner<T> runner) {
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runChild(final Runnable childStatement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						childStatement.run();
						return null;
					}
				}));
			}

			public void finished() {
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
		});
=======
	private static <T> Runner parallelize(Runner runner) {
		if (runner instanceof ParentRunner<?>) {
			((ParentRunner<?>) runner).setRunnerInterceptor(new RunnerInterceptor() {
				private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

				private final ExecutorService fService= Executors
						.newCachedThreadPool();

				public void runChild(final Runnable childStatement) {
					fResults.add(fService.submit(new Callable<Object>() {
						public Object call() throws Exception {
							childStatement.run();
							return null;
						}
					}));
				}

				public void finished() {
					for (Future<Object> each : fResults)
						try {
							each.get();
						} catch (Exception e) {
							e.printStackTrace();
						}
				}
			});
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
		assertThat(end - start, betweenInclusive(1000, 1500));
=======
		assertThat(end - start, betweenInclusive(1000, 1900));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	NameInterceptorTest.class
=======
	NameInterceptorTest.class,
	ExpectedExceptionInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.7-SNAPSHOT-20090511-2347";
=======
		return "4.7-SNAPSHOT-20090527-0039";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;<<<<<<< MINE
 * Tests if the argument is a string that contains a substring.
=======
 * @deprectated Use org.hamcrest.core.StringContains directly
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;<<<<<<< MINE
        return new StringContains(substring);
=======
        return CoreMatchers.containsString(substring);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;<<<<<<< MINE
		final Matcher<Iterable<T>> allItemsAre = not(hasItem(not(individual)));
		
		return new BaseMatcher<Iterable<T>>() {
			public boolean matches(Object item) {
				return allItemsAre.matches(item);
			}
			
			public void describeTo(Description description) {
				description.appendText("each ");
				individual.describeTo(description);
			}
		};
=======
		return Every.everyItem(individual);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> org.hamcrest.Matcher<java.lang.Iterable<T>> hasItem(T element) {
		return IsCollectionContaining.hasItem(element);
=======
	@Deprecated
	public static <T> Matcher<Iterable<? super T>> hasItem(T element) {
		return CoreMatchers.hasItem(element);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> org.hamcrest.Matcher<java.lang.Iterable<T>> hasItem(org.hamcrest.Matcher<? extends T> elementMatcher) {
		return IsCollectionContaining.hasItem(elementMatcher);
=======
	@Deprecated
    public static <T> Matcher<Iterable<? super T>> hasItem(Matcher<? super T> elementMatcher) {
		return CoreMatchers.hasItem(elementMatcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return IsCollectionContaining.hasItems(elements);
=======
		return CoreMatchers.hasItems(elements);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> org.hamcrest.Matcher<java.lang.Iterable<T>> hasItems(org.hamcrest.Matcher<? extends T>... elementMatchers) {
		return IsCollectionContaining.hasItems(elementMatchers);
=======
	@Deprecated
	public static <T> Matcher<Iterable<T>> hasItems(Matcher<? super T>... elementMatchers) {
		return CoreMatchers.hasItems(elementMatchers);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return Each.each(elementMatcher);
=======
		return CoreMatchers.everyItem(elementMatcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return StringContains.containsString(substring);
=======
		return CoreMatchers.containsString(substring);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> CombinableMatcher<T> both(Matcher<T> matcher) {
		return new CombinableMatcher<T>(matcher);
=======
	@Deprecated
	public static <T> CombinableMatcher<T> both(Matcher<? super T> matcher) {
		return CoreMatchers.both(matcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> CombinableMatcher<T> either(Matcher<T> matcher) {
		return new CombinableMatcher<T>(matcher);
=======
	@Deprecated
	public static <T> CombinableMatcher<T> either(Matcher<? super T> matcher) {
		return CoreMatchers.either(matcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/Assume.java;<<<<<<< MINE
		assumeThat(asList(objects), Each.each(notNullValue()));
=======
		assumeThat(asList(objects), everyItem(notNullValue()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java;<<<<<<< MINE
		return each(nullValue);
=======
		return everyItem(nullValue);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return CoreMatchers.hasItem(element);
=======
		return CoreMatchers.<T>hasItem(element);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return CoreMatchers.hasItem(elementMatcher);
=======
		return CoreMatchers.<T>hasItem(elementMatcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> Matcher<Iterable<T>> everyItem(final Matcher<T> elementMatcher) {
=======
	public static <T> Matcher<Iterable<T>> each(final Matcher<T> elementMatcher) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	@Deprecated
	public static <T> CombinableMatcher<T> both(Matcher<? super T> matcher) {
=======
	public static <T> CombinableMatcher<T> both(Matcher<T> matcher) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	 *   assertThat(string, both(containsString("a")).and(containsString("b")));
=======
	 *   assertThat(string, either(containsString("a")).or(containsString("b")));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	 * @deprecated Use org.hamcrest.CoreMatchers.either
=======
	 * 
	 * If you want to say either(is(3)).or(is(4)), and are prevented,
	 * please see isOneOf(...) below.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	@Deprecated
	public static <T> CombinableMatcher<T> either(Matcher<? super T> matcher) {
=======
	public static <T> CombinableMatcher<T> either(Matcher<T> matcher) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	}
	
	/**
	 * This is sugar for the situation where you want to specify
	 * a finite list of concrete objects that can match.
	 * For example:
	 * <pre>
	 *   assertThat(string, isOneOf("a", "b", "c"));
	 *   // is equivalent to
	 *   assertThat(string, anyOf(is("a"), is("b"), is("c")))
	 * </pre>
	 */
	public static <T> Matcher<T> isOneOf(T... objects) {
		List<Matcher<? super T>> matchers = new ArrayList<Matcher<? super T>>();
		for (T each : objects) {
			matchers.add(equalTo(each));
		}
		return anyOf(matchers);
	}
	
	/**
	 * Loosens type parameter, in order to use a Matcher 
	 * in a place where Java doesn't want to type-check:
	 *
	 * Goofy example:
	 * <pre>
	 *   assertThat(3, matches(containsString("a")));
	 * </pre>
	 * 
	 * Real example:
	 * <pre>
	 *   assertThat(3, either(matches(is(String.class))).or(
	 *		                  matches(is(Integer.class))));
	 * </pre>
	 */
	@SuppressWarnings("unchecked")
	public static <T> Matcher<T> matches(Matcher<?> matcher) {
		return (Matcher<T>)matcher;
	}
=======
	}
	
	/**
	 * This is sugar for the situation where 
	 * For example:
	 * <pre>
	 *   assertThat(string, eitherIs("a").or(is("b")));
	 * </pre>
	 */
	public static <T> Matcher<T> isOneOf(T... objects) {
		List<Matcher<? super T>> matchers = new ArrayList<Matcher<? super T>>();
		for (T each : objects) {
			matchers.add(is(each));
		}
		return anyOf(matchers);
	}
	
	/**
	 * Loosens type parameter, in order to use a Matcher 
	 * in a place where Java doesn't want to typecheck:
	 *
	 * Goofy example:
	 * <pre>
	 *   assertThat(3, matches(containsString("a")));
	 * </pre>
	 * 
	 * Real example:
	 * <pre>
	 *   assertThat(3, either(matches(is(String.class))).or(
	 *		                  matches(is(Integer.class))));
     *
	 * </pre>
	 */
	@SuppressWarnings("unchecked")
	public static <T> Matcher<T> matches(Matcher<?> matcher) {
		return (Matcher<T>)matcher;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
	}


=======
	}	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
		assertThat(3, both(is(Integer.class)).and(is(3)));
=======
		assertThat(3, both(any(Integer.class)).and(is(3)));
		assertThat("ab", both(containsString("a")).and(containsString("b")));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
		assertThat(3, either(is(3)).or(is(4)));
=======
		assertThat(3, either(sameInstance(3)).or(sameInstance(4)));
		assertThat(3, either(matches(is(String.class))).or(
				matches(is(Integer.class))));
		assertThat("a", either(sameInstance("a")).or(sameInstance("b")));
	}

	@SuppressWarnings("unchecked")
	@Test
	public void isOneOfPasses() {
		assertThat(3, isOneOf(3, 4));
		assertThat(Arrays.asList("a"), isOneOf(Arrays.asList("a"), Arrays
				.asList("b")));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
	
	@Test public void subclassesAreOkInSecondPositionOnly() {
		assertThat(3, both(is(Integer.class)).and(is(3)));
=======

	@Test
	public void superclassesAreOkInSecondPositionOnly() {
		assertThat("a", both(containsString("a")).and(is(String.class)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
		fType= type;
=======
		expect(instanceOf(type));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
	public void expectMessage(String message) {
		fMessage= message;
=======
	public void expectMessage(String substring) {
		expectMessage(containsString(substring));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
	private boolean noExpectedException() {
		return fType == null && fMessage == null;
=======
	public void expectMessage(Matcher<String> matcher) {
		expect(hasMessage(matcher));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
				if (noExpectedException())
=======
				if (fMatcher == null)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
				// TODO (May 26, 2009 11:46:31 PM): isInstance?
				if (fType != null && !fType.isAssignableFrom(e.getClass())) {
					String message= "Unexpected exception, expected<"
								+ fType.getName() + "> but was<"
								+ e.getClass().getName() + ">";
					throw new Exception(message, e);
				}
				if (fMessage != null && !getMessage(e).contains(fMessage)) {
					String message= "Unexpected exception message, expected<"
								+ fMessage + "> but was<"
								+ getMessage(e) + ">";
					throw new Exception(message, e);
				}
			}
			// TODO (May 26, 2009 11:54:22 PM): do I need complete
			if (complete && !noExpectedException()) {
				if (fType != null)
					throw new AssertionError("Expected exception: "
							+ fType.getName());
				else if (fMessage != null)
					throw new AssertionError("Expected exception with message: "
							+ fMessage);
				else
					throw new RuntimeException("How'd we get here?");
=======
				Assert.assertThat(e, matches(fMatcher));
				return;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Unexpected exception, expected<java.lang.NullPointerException> but was<java.lang.IllegalArgumentException>"));
=======
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Unexpected exception message, expected<expectedMessage> but was<actualMessage>"));
=======
				hasSingleFailureContaining("\"expectedMessage\"\n     but: getMessage() was \"actualMessage\""));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Expected exception: java.lang.NullPointerException"));
=======
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Expected exception with message: anything!"));
=======
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
		private String getMessage(Throwable e) {
			return e.getMessage() == null ? "" : e.getMessage();
		}
=======
	private Matcher<Throwable> hasMessage(Matcher<String> matcher) {
		return new FeatureMatcher<Throwable, String>(matcher,
				"exception with message", "getMessage()") {
			@Override
			protected String featureValueOf(Throwable actual) {
				return actual.getMessage();
			}
		};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
		assertThat(
				testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("Unexpected exception message, expected<anything!> but was<>"));
=======
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("but: getMessage() was null"));
	}

	public static class ExpectsMessageMatcher {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.7-SNAPSHOT-20090601-1258";
=======
		return "4.7-SNAPSHOT-20090604-0055";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:57:14 PM): V
	public static Description makeDescription(Test test) {
=======
	private static Description makeDescription(Test test) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
				// TODO (Feb 23, 2009 11:25:23 PM): this is doing Max's work for it.  Max should get rid of these when sorting i
				if (!made.toString().startsWith("warning("))			
					description.addChild(made);
=======
				description.addChild(made);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:57:26 PM): V
	public Test getTest() {
=======
	private Test getTest() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
		List<Throwable> fErrors = new ArrayList<Throwable>();
		fErrors.clear();
=======
		List<Throwable> errors = new ArrayList<Throwable>();
		errors.clear();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
			fErrors.add(e);
=======
			errors.add(e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
					fErrors.add(e);
=======
					errors.add(e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
		if (fErrors.isEmpty())
			return;
		if (fErrors.size() == 1)
			throw fErrors.get(0);
		throw new MultipleFailureException(fErrors);
=======
		MultipleFailureException.assertEmpty(errors);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	 * Asserts that two arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown with the given message. If
	 * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,
	 * they are considered equal.
=======
	 * Asserts that two arrays are equal, according to the criteria defined by
	 * the concrete subclass. If they are not, an {@link AssertionError} is
	 * thrown with the given message. If <code>expecteds</code> and
	 * <code>actuals</code> are <code>null</code>, they are considered equal.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
=======
	 *            the identifying message for the {@link AssertionError} (
	 *            <code>null</code> okay)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	public void arrayEquals(String message, Object expecteds,
			Object actuals) throws ArrayComparisonFailure {
		// TODO: DUP above
		// TODO (Sep 8, 2008 4:32:50 PM): Test that this fails sometimes
		// TODO (Sep 8, 2008 4:33:04 PM): Update javadoc
		
=======
	public void arrayEquals(String message, Object expecteds, Object actuals)
			throws ArrayComparisonFailure {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
			ensureKey(map, type);
			List<T> members= map.get(type);
			if (isShadowedBy(member, members))
=======
			List<T> members= getAnnotatedMembers(map, type);
			if (member.isShadowedBy(members))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		// TODO (May 25, 2009 10:02:46 PM): DUP
		ensureKey(fMethodsForAnnotations, annotationClass);
		return fMethodsForAnnotations.get(annotationClass);
=======
		return getAnnotatedMembers(fMethodsForAnnotations, annotationClass);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		// TODO (May 25, 2009 10:02:46 PM): DUP
		ensureKey(fFieldsForAnnotations, annotationClass);
		return fFieldsForAnnotations.get(annotationClass);
=======
		return getAnnotatedMembers(fFieldsForAnnotations, annotationClass);
	}

	private <T> List<T> getAnnotatedMembers(Map<Class<?>, List<T>> map,
			Class<? extends Annotation> type) {
		if (!map.containsKey(type))
			map.put(type, new ArrayList<T>());
		return map.get(type);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
	// TODO (May 25, 2009 9:45:43 PM): faking it
=======
	@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
		// TODO Auto-generated method stub
		return false;
=======
		return otherMember.getField().getName().equals(getField().getName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private void validateOnlyOneConstructor(List<Throwable> errors) {
=======
	/**
	 * Adds to {@code errors} if the test class has more than one constructor
	 * (do not override)
	 */
	protected void validateOnlyOneConstructor(List<Throwable> errors) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private void validateRuleField(Field field, List<Throwable> errors) {
		if (!MethodRule.class.isAssignableFrom(field.getType()))
=======
	private void validateInterceptorField(Field field, List<Throwable> errors) {
		if (!MethodRule.class.isAssignableFrom(field.getType()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		statement= withInterceptors(method, test, statement);
=======
		statement= withRules(method, test, statement);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
	 * @param computer TODO
=======
	 * @param computer Helps construct Runners from classes
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
	 * @param computer TODO
=======
	 * @param computer Helps construct Runners from classes
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	// TODO javadoc
=======
	/**
	 * @return If this describes a method invocation, 
	 * the class of the test instance.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	//TODO javadoc
=======
	/**
	 * @return If this describes a method invocation, 
	 * the name of the class of the test instance
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	
	// TODO javadoc
	public String getMethodName() {
		return parseMethod();
=======

	private Matcher methodStringMatcher() {
		return Pattern.compile("(.*)\\((.*)\\)").matcher(toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Request.java;<<<<<<< MINE
	 * @param computer TODO
=======
	 * @param computer Helps construct Runners from classes
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;<<<<<<< MINE
		return new PrintableResult(type);
=======
		return testResult(type, new Computer());
	}
	
	public static PrintableResult testResult(Class<?> type, Computer computer) {
		return new PrintableResult(type, computer);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;<<<<<<< MINE
	public PrintableResult(Class<?> type) {
		this(JUnitCore.runClasses(type));
=======
	public PrintableResult(Class<?> type, Computer computer) {
		this(JUnitCore.runClasses(computer, type));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public static MaxCore forFolder(String fileName) {
		return storedLocally(new File(fileName));
=======
	private static final String MALFORMED_JUNIT_3_TEST_CLASS_PREFIX= "malformed JUnit 3 test class: ";
	
	/**
	 * Create a new MaxCore from a serialized file stored at storedResults
	 * @deprecated use storedLocally()
	 */
	@Deprecated
	public static MaxCore forFolder(String folderName) {
		return storedLocally(new File(folderName));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public MaxCore(File storedResults) {
=======
	private MaxCore(File storedResults) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		try { 
			return core.run(sortRequest(request).getRunner());
		} finally {
			try {
				fHistory.save();
			} catch (FileNotFoundException e) {
				// TODO
				e.printStackTrace();
			} catch (IOException e) {
				// TODO
				e.printStackTrace();
			}
		}
=======
		return core.run(sortRequest(request).getRunner());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:14:05 PM): publicized for squeeze
=======
	/**
	 * @param request
	 * @return a new Request, which contains all of the same tests, but in a new order.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:42:05 PM): V
	public Request constructLeafRequest(List<Description> leaves) {
=======
	private Request constructLeafRequest(List<Description> leaves) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 11:17:01 PM): V
	public Runner buildRunner(Description each) {
=======
	private Runner buildRunner(Description each) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			try {
				// TODO (Nov 18, 2008 2:18:28 PM): move to Suite
				return new Suite(null, new Class<?>[0]);
			} catch (InitializationError e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
=======
			return Suite.emptySuite();
		if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX))
			// This is cheating, because it runs the whole class 
			// to get the warning for this method, but we can't do better, 
			// because JUnit 3.8's
			// thrown away which method the warning is for.
			return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:40:23 PM): V
	public List<Description> findLeaves(Request request) {
=======
	private List<Description> findLeaves(Request request) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		findLeaves(request.getRunner().getDescription(), results);
=======
		findLeaves(null, request.getRunner().getDescription(), results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:50:48 PM): V
	public void findLeaves(Description description, List<Description> results) {
=======
	private void findLeaves(Description parent, Description description, List<Description> results) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			results.add(description);
=======
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
			else
				results.add(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
				findLeaves(each, results);
=======
				findLeaves(description, each, results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public static MaxHistory forFolder(File storedResults) {
		try {
			if (storedResults.exists())
				return readHistory(storedResults);
		} catch (CouldNotReadCoreException e) {
			e.printStackTrace();
			storedResults.delete();
		}
		return new MaxHistory(storedResults);
	}
	
	private static MaxHistory readHistory(File storedResults) throws CouldNotReadCoreException {
		// TODO: rule of three
		// TODO: Really?
		ObjectInputStream stream;
		FileInputStream file= null;
		try {
			file= new FileInputStream(storedResults);
		} catch (FileNotFoundException e) {
			throw new CouldNotReadCoreException(e);
		}
=======
	private static MaxHistory readHistory(File storedResults)
			throws CouldNotReadCoreException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
			}
		} finally {
			try {
=======
			} finally {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public File getFile() {
		return fFolder;
=======
	private MaxHistory(File storedResults) {
		fHistoryStore= storedResults;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public void save() throws IOException {
=======
	private void save() throws IOException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
				fFolder));
=======
				fHistoryStore));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
														// possible time
=======
			// possible time
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
			int result= getFailure(o2).compareTo(getFailure(o1)); 
			return result != 0
				? result
				// Then shorter tests first
				: getTestDuration(o1).compareTo(getTestDuration(o2));
=======
			int result= getFailure(o2).compareTo(getFailure(o1));
			return result != 0 ? result
			// Then shorter tests first
					: getTestDuration(o1).compareTo(getTestDuration(o2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
			if (result == null) 
=======
			if (result == null)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE

	public RememberingListener listener() {
=======
	/**
	 * @return a listener that will update this history based on the test
	 *         results reported.
	 */
	public RunListener listener() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:41:36 PM): V
=======
	/**
	 * @return a comparator that ranks tests based on the JUnit Max sorting
	 *         rules, as described in the {@link MaxCore} class comment.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
	protected void validateZeroArgConstructor(List<Throwable> errors) {
		// constructor can have args
=======
	protected void validateConstructor(List<Throwable> errors) {
		validateOnlyOneConstructor(errors);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
		// TODO (Mar 10, 2009 10:47:34 AM): Import
		Assert.assertArrayEquals(new float[] {1.0f}, new float[] {1.0f}, 1.0f);
=======
		assertArrayEquals(new float[] {1.0f}, new float[] {1.0f}, 1.0f);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	RulesTest.class,
	TimeoutRuleTest.class,
=======
	InterceptorTest.class,
	TimeoutInterceptorTest.class,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	NameRulesTest.class,
	ExpectedExceptionRuleTest.class,
	TempFolderRuleTest.class,
	ExternalResourceRuleTest.class,
	VerifierRuleTest.class
=======
	NameInterceptorTest.class,
	ExpectedExceptionInterceptorTest.class,
	TempFolderInterceptorTest.class,
	ExternalResourceInterceptorTest.class,
	VerifierInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
	
	@Test(expected=IllegalArgumentException.class) public void complainIfMultipleConstructors() {
=======

	@Test(expected= IllegalArgumentException.class)
	public void complainIfMultipleConstructors() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
				stream= new ObjectInputStream(file);
			} catch (IOException e) {
				throw new CouldNotReadCoreException(e);
			}
			try {
				return (MaxHistory) stream.readObject();
			} catch (Exception e) {
				throw new CouldNotReadCoreException(e); //TODO think about what we can do better here
			} finally {
=======
				ObjectInputStream stream= new ObjectInputStream(file);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/junit/framework/Assert.java;<<<<<<< MINE
	 * Asserts that an object is null.
=======
	 * Asserts that an object is null. If it isn't an {@link AssertionError} is
	 * thrown.
	 * Message contains: Expected: <null> but was: object
	 * 
	 * @param object
	 *            Object to check or <code>null</code>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/junit/framework/Assert.java;<<<<<<< MINE
		assertNull(null, object);
=======
		String message = "Expected: <null> but was: " + object.toString();
		assertNull(message, object);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/runners/model/InitializationError.java;<<<<<<< MINE
		this(Arrays.<Throwable>asList(new Exception(string)));
=======
		this(new Exception(string));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	
	// TODO: rename var
	public Test asTest(Plan plan) {
		if (plan.isSuite())
			return createTest(plan);
		else
			return asSingleTest(plan.getDescription());
	}

	private Test asSingleTest(Description description) {
		if (!containsKey(description))
			put(description, createSingleTest(description));
		return get(description);
=======

	public List<Test> asTestList(Plan plan) {
		Description description= plan.getDescription();
		if (description.isTest())
			return Arrays.asList(asTestCase(description));
		else {
			List<Test> returnThis= new ArrayList<Test>();
			for (Plan child : plan.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	Test createTest(Plan plan) {
		Description description= plan.getDescription();
		if (plan.isTest())
			return createSingleTest(description);
		else {
			TestSuite suite = new TestSuite(description.getDisplayName());
			for (Plan child : plan.getChildren())
				suite.addTest(asTest(child));
			return suite;
		}
=======
	public Test asTest(Plan plan) {
		Description description= plan.getDescription();
		if (description.isSuite())
			return asTestSuite(plan);
		else
			return asTestCase(description);
	}

	private Test asTestSuite(Plan plan) {
		return createTestSuite(plan);
	}

	private Test createTestSuite(Plan plan) {
		TestSuite suite= new TestSuite(plan.getDescription().getDisplayName());
		for (Plan child : plan.getChildren())
			suite.addTest(asTest(child));
		return suite;
	}
	
	private Test asTestCase(Description description) {
		if (!containsKey(description))
			put(description, createTestCase(description));
		return get(description);
	}

	private Test createTestCase(Description description) {
		return new JUnit4TestCaseFacade(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();
=======
		fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		return fCache.asTestList(getDescription());
=======
		return fCache.asTestList(fRunner.getPlan());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		Description description= fRunner.getDescription();		
		return removeIgnored(description);
=======
		return fRunner.getDescription();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
	private Description removeIgnored(Description description) {
		if (isIgnored(description))
			return Description.EMPTY;
		Description result = description.childlessCopy();
		for (Description each : description.getChildren()) {
			Description child= removeIgnored(each);
			if (! child.isEmpty())
				result.addChild(child);
		}
		return result;
=======
	private Filter removeIgnored() {
		return new Filter() {			
			@Override
			public boolean shouldRun(Description description) {
				return !isIgnored(description);
			}
			
			@Override
			public String describe() {
				return "not ignored";
			}
		};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: unpublic!
	public RunnerScheduler fScheduler= new RunnerScheduler() {
=======
	private RunnerScheduler fScheduler= new RunnerScheduler() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * @throws InitializationError 
=======
	 * 
	 * @throws InitializationError
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).
	 * Default implementation adds an error for each method annotated with
	 * {@code @BeforeClass} or {@code @AfterClass} that is not
	 * {@code public static void} with no arguments.
=======
	 * Adds to {@code errors} a throwable for each problem noted with the test
	 * class (available from {@link #getTestClass()}). Default implementation
	 * adds an error for each method annotated with {@code @BeforeClass} or
	 * {@code @AfterClass} that is not {@code public static void} with no
	 * arguments.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,
			boolean isStatic, List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(annotation);
=======
	protected void validatePublicVoidNoArgMethods(
			Class<? extends Annotation> annotation, boolean isStatic,
			List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(
				annotation);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	/** 
	 * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. 
	 * Here is an outline of the implementation:
=======
	/**
	 * Constructs a {@code Statement} to run all of the tests in the test class.
	 * Override to add pre-/post-processing. Here is an outline of the
	 * implementation:
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> befores= fTestClass
=======
		List<FrameworkMethod> befores= getTestClass()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		return befores.isEmpty() ? statement :
			new RunBefores(statement, befores, null);
=======
		return befores.isEmpty() ? statement : new RunBefores(statement,
				befores, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> afters= fTestClass
=======
		List<FrameworkMethod> afters= getTestClass()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		return afters.isEmpty() ? statement : 
			new RunAfters(statement, afters, null);
=======
		return afters.isEmpty() ? statement : new RunAfters(statement, afters,
				null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: public?
	public void runChildren(final RunNotifier notifier) {
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
=======
	private void runChildren(final RunNotifier notifier) {
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (T child : getFilteredChildren())
=======
		for (T child : getCachedChildren())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		fFilter= filter;
=======
		for (Iterator<T> iter= getCachedChildren().iterator(); iter.hasNext();) {
			T each= iter.next();
			if (!filter.shouldRun(describeChild(each)))
				iter.remove();
			else
				try {
					filter.apply(each);
				} catch (NoTestsRemainException e) {
					iter.remove();
				}
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (T each : getChildren())
			if (shouldRun(each))
				return;
		throw new NoTestsRemainException();
=======
		if (getCachedChildren().isEmpty())
			throw new NoTestsRemainException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		fSorter= sorter;
=======
		Collections.sort(getCachedChildren(), comparator(sorter));
		for (T each : getCachedChildren()) {
			sorter.apply(each);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: public?
	public List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
=======
	private List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private Comparator<? super T> comparator() {
=======
	private Comparator<? super T> comparator(final Sorter sorter) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
				return fSorter.compare(describeChild(o1), describeChild(o2));
=======
				return sorter.compare(describeChild(o1), describeChild(o2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Sets a scheduler that determines the order and parallelization
	 * of children.  Highly experimental feature that may change.
=======
	 * Sets a scheduler that determines the order and parallelization of
	 * children. Highly experimental feature that may change.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		this.fScheduler = scheduler;
=======
		this.fScheduler= scheduler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		findLeaves(null, request.getRunner().getDescription(), results);
=======
		findLeaves(null, request.getRunner().getPlan(), results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private void findLeaves(Plan parent, Plan plan, List<Description> results) {
		if (plan.getChildren().isEmpty())
			if (plan.getDescription().toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent.getDescription()));
=======
	private void findLeaves(Description parent, Plan plan, List<Description> results) {
		Description description = plan.getDescription();
		if (plan.getChildren().isEmpty())
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			for (Plan each : plan.getChildren())
				findLeaves(plan, each, results);
=======
			for (Plan each : plan.getChildren())
				findLeaves(description, each, results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
	
	@Test public void failIfEverythingIsIgnoredOut() {
=======

	// when executing as JUnit 3, ignored tests are stripped out before execution
	@Test
	public void descriptionAndRunNotificationsAreConsistent() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		assertEquals(1, result.getFailureCount());
=======

		Runner runner= Request.aClass(CompatibilityTest.class).getRunner();
		Description description= runner.getDescription();
		assertEquals(1, description.getChildren().size());
		assertEquals("initializationError", description.getChildren().get(0)
				.getMethodName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before the previous step; if any throws an
=======
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned
	 * by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this
	 * class and superclasses before the previous step; if any throws an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before any of the previous steps; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
=======
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this
	 * class and superclasses before any of the previous steps; all AfterClass
	 * methods are always executed: exceptions thrown by previous steps are
	 * combined, if necessary, with exceptions from AfterClass methods into a
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before executing {@code statement}; if any throws an
	 * Exception, stop execution and pass the exception on.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; if any throws an Exception, stop execution and pass the exception on.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before executing {@code statement}; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
	 * {@link MultipleFailureException}.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; all AfterClass methods are always executed: exceptions thrown by
	 * previous steps are combined, if necessary, with exceptions from
	 * AfterClass methods into a {@link MultipleFailureException}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	static public Test createTest(Class<? extends TestCase> theClass, String name) {
		Constructor<? extends TestCase> constructor;
=======
	static public Test createTest(Class<?> theClass, String name) {
		Constructor<?> constructor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	public static Constructor<? extends TestCase> getTestConstructor(Class<? extends TestCase> theClass) throws NoSuchMethodException {
=======
	public static Constructor<?> getTestConstructor(Class<?> theClass) throws NoSuchMethodException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	 public TestSuite(final Class<? extends TestCase> theClass) {
=======
	public TestSuite(final Class<?> theClass) {
		addTestsFromTestCase(theClass);
	}

	private void addTestsFromTestCase(final Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
			addTest(new TestSuite(each.asSubclass(TestCase.class)));
=======
			addTest(testCaseForClass(each));
	}

	private Test testCaseForClass(Class<?> each) {
		if (TestCase.class.isAssignableFrom(each))
			return new TestSuite(each.asSubclass(TestCase.class));
		else
			return warning(each.getCanonicalName() + " does not extend TestCase");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	private void addTestMethod(Method m, List<String> names, Class<? extends TestCase> theClass) {
=======
	private void addTestMethod(Method m, List<String> names, Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
// This test case is obsolete, since the compiler will catch this error in 1.5
//	public void testNoTestCaseClass() {
//		Test t= new TestSuite(NoTestCaseClass.class);
//		t.run(fResult);
//		assertEquals(1, fResult.runCount());  // warning test
//		assertTrue(! fResult.wasSuccessful());
//	}
=======
	public void testNoTestCaseClass() {
		Test t= new TestSuite(NoTestCaseClass.class);
		t.run(fResult);
		assertEquals(1, fResult.runCount());  // warning test
		assertTrue(! fResult.wasSuccessful());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	public List<Test> asTestList(Plan plan) {
		Description description= plan.getDescription();
=======
	Test createTest(Description description) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			return Arrays.asList(asTestCase(description));
=======
			return new JUnit4TestCaseFacade(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			List<Test> returnThis= new ArrayList<Test>();
			for (Plan child : plan.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
=======
			TestSuite suite = new TestSuite(description.getDisplayName());
			for (Description child : description.getChildren())
				suite.addTest(asTest(child));
			return suite;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
				result.addError(asTestCase(failure.getDescription()), failure
						.getException());
=======
				result.addError(asTest(failure.getDescription()), failure.getException());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			public void testFinished(Description description) throws Exception {
				result.endTest(asTestCase(description));
=======
			public void testFinished(Description description)
					throws Exception {
				result.endTest(asTest(description));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			public void testStarted(Description description) throws Exception {
				result.startTest(asTestCase(description));
=======
			public void testStarted(Description description)
					throws Exception {
				result.startTest(asTest(description));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();
=======
		fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		return fCache.asTestList(fRunner.getPlan());
=======
		return fCache.asTestList(getDescription());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		return fRunner.getDescription();
=======
		Description description= fRunner.getDescription();		
		return removeIgnored(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
	private Filter removeIgnored() {
		return new Filter() {			
			@Override
			public boolean shouldRun(Description description) {
				return !isIgnored(description);
			}
			
			@Override
			public String describe() {
				return "not ignored";
			}
		};
=======
	private Description removeIgnored(Description description) {
		if (isIgnored(description))
			return Description.EMPTY;
		Description result = description.childlessCopy();
		for (Description each : description.getChildren()) {
			Description child= removeIgnored(each);
			if (! child.isEmpty())
				result.addChild(child);
		}
		return result;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	static public Test createTest(Class<? extends TestCase> theClass, String name) {
		Constructor<? extends TestCase> constructor;
=======
	static public Test createTest(Class<?> theClass, String name) {
		Constructor<?> constructor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	public static Constructor<? extends TestCase> getTestConstructor(Class<? extends TestCase> theClass) throws NoSuchMethodException {
=======
	public static Constructor<?> getTestConstructor(Class<?> theClass) throws NoSuchMethodException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	 public TestSuite(final Class<? extends TestCase> theClass) {
=======
	public TestSuite(final Class<?> theClass) {
		addTestsFromTestCase(theClass);
	}

	private void addTestsFromTestCase(final Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
			addTest(new TestSuite(each.asSubclass(TestCase.class)));
=======
			addTest(testCaseForClass(each));
	}

	private Test testCaseForClass(Class<?> each) {
		if (TestCase.class.isAssignableFrom(each))
			return new TestSuite(each.asSubclass(TestCase.class));
		else
			return warning(each.getCanonicalName() + " does not extend TestCase");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	private void addTestMethod(Method m, List<String> names, Class<? extends TestCase> theClass) {
=======
	private void addTestMethod(Method m, List<String> names, Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.8.1";
=======
		return "4.8.2";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private RunnerScheduler fScheduler= new RunnerScheduler() {
=======
	private RunnerScheduler fScheduler= new RunnerScheduler() {	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * 
	 * @throws InitializationError
=======
	 * @throws InitializationError 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Adds to {@code errors} a throwable for each problem noted with the test
	 * class (available from {@link #getTestClass()}). Default implementation
	 * adds an error for each method annotated with {@code @BeforeClass} or
	 * {@code @AfterClass} that is not {@code public static void} with no
	 * arguments.
=======
	 * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).
	 * Default implementation adds an error for each method annotated with
	 * {@code @BeforeClass} or {@code @AfterClass} that is not
	 * {@code public static void} with no arguments.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	protected void validatePublicVoidNoArgMethods(
			Class<? extends Annotation> annotation, boolean isStatic,
			List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(
				annotation);
=======
	protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,
			boolean isStatic, List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(annotation);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	/**
	 * Constructs a {@code Statement} to run all of the tests in the test class.
	 * Override to add pre-/post-processing. Here is an outline of the
	 * implementation:
=======
	/** 
	 * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. 
	 * Here is an outline of the implementation:
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(
				BeforeClass.class);
		return befores.isEmpty() ? statement : new RunBefores(statement,
				befores, null);
=======
		List<FrameworkMethod> befores= fTestClass
				.getAnnotatedMethods(BeforeClass.class);
		return befores.isEmpty() ? statement :
			new RunBefores(statement, befores, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(
				AfterClass.class);
		return afters.isEmpty() ? statement : new RunAfters(statement, afters,
				null);
=======
		List<FrameworkMethod> afters= fTestClass
				.getAnnotatedMethods(AfterClass.class);
		return afters.isEmpty() ? statement : 
			new RunAfters(statement, afters, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
=======
		for (final T each : getFilteredChildren())
			fScheduler.schedule(new Runnable() {			
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		if (fDescription == null) {
			// TODO: extract createDescription?
			fDescription= Description.createSuiteDescription(getName(), fTestClass.getAnnotations());
			for (T child : getCachedChildren())
				fDescription.addChild(describeChild(child));
		}
		return fDescription;
=======
		Description description= Description.createSuiteDescription(getName(),
				fTestClass.getAnnotations());
		for (T child : getFilteredChildren())
			description.addChild(describeChild(child));
		return description;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (Iterator<T> iter= getCachedChildren().iterator(); iter.hasNext();) {
			T each= iter.next();
			if (!filter.shouldRun(describeChild(each)))
				iter.remove();
			else
				try {
					filter.apply(each);
				} catch (NoTestsRemainException e) {
					iter.remove();
				}
		}
=======
		fFilter= filter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		fDescription = null;
		
		if (getCachedChildren().isEmpty())
			throw new NoTestsRemainException();
=======
		for (T each : getChildren())
			if (shouldRun(each))
				return;
		throw new NoTestsRemainException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		Collections.sort(getCachedChildren(), comparator(sorter));
		for (T each : getCachedChildren()) {
			sorter.apply(each);
		}
=======
		fSorter= sorter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
=======
	private List<T> getFilteredChildren() {
		ArrayList<T> filtered= new ArrayList<T>();
		for (T each : getChildren())
			if (shouldRun(each))
				try {
					filterChild(each);
					sortChild(each);
					filtered.add(each);
				} catch (NoTestsRemainException e) {
					// don't add it
				}
		Collections.sort(filtered, comparator());
		return filtered;
	}

	private void sortChild(T child) {
		fSorter.apply(child);
	}

	private void filterChild(T child) throws NoTestsRemainException {
		if (fFilter != null)
			fFilter.apply(child);
	}

	private boolean shouldRun(T each) {
		return fFilter == null || fFilter.shouldRun(describeChild(each));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private Comparator<? super T> comparator(final Sorter sorter) {
=======
	private Comparator<? super T> comparator() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
				return sorter.compare(describeChild(o1), describeChild(o2));
=======
				return fSorter.compare(describeChild(o1), describeChild(o2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Sets a scheduler that determines the order and parallelization of
	 * children. Highly experimental feature that may change.
=======
	 * Sets a scheduler that determines the order and parallelization
	 * of children.  Highly experimental feature that may change.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		this.fScheduler= scheduler;
=======
		this.fScheduler = scheduler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		Description description= Description.createTestDescription(
				getTestClass().getJavaClass(), testName(method), method
						.getAnnotations());
		description.setParent(getDescription());
		return description;
=======
		return Description.createTestDescription(getTestClass().getJavaClass(),
				testName(method), method.getAnnotations());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
			fNotifier.fireTestRunStarted(runner.getPlan());
=======
			fNotifier.fireTestRunStarted(runner.getDescription());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
 * The canonical case of filtering is when you want to run a single test method
 * in a class. Rather than introduce runner API just for that one case, JUnit
 * provides a general filtering mechanism.
 * 
 * If you want to filter the tests to be run, extend <code>Filter</code> and
 * apply an instance of your filter to the {@link org.junit.runner.Request}
 * before running it (see {@link org.junit.runner.JUnitCore#run(Request)}.
 * 
 * Alternatively, apply a <code>Filter</code> to a
 * {@link org.junit.runner.Runner} before running tests (for example, in
 * conjunction with {@link org.junit.runner.RunWith}.
=======
 * The canonical case of filtering is when you want to run a single test method in a class. Rather
 * than introduce runner API just for that one case, JUnit provides a general filtering mechanism.
 * If you want to filter the tests to be run, extend <code>Filter</code> and apply an instance of
 * your filter to the {@link org.junit.runner.Request} before running it (see 
 * {@link org.junit.runner.JUnitCore#run(Request)}. Alternatively, apply a <code>Filter</code> to 
 * a {@link org.junit.runner.Runner} before running tests (for example, in conjunction with 
 * {@link org.junit.runner.RunWith}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
				// TODO: DUP!
				return description.isSuite() || desiredDescription.equals(description);
=======
				if (description.isTest())
					return desiredDescription.equals(description);
				
				// explicitly check if any children want to run
				for (Description each : description.getChildren())
					if (shouldRun(each))
						return true;
				return false;					
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
	 * Indicates how to prune the tree of tests. The meaning of the boolean
	 * returned depends on whether {@code description} describes a leaf in the
	 * test tree ({@code Description.isTest} is true), or a suite ({@code
	 * Description.isSuite} is true).
	 * 
	 * If {@code description} is a leaf, then {@code shouldRun} returns false
	 * iff the test represented should not be run.
	 * 
	 * If {@code description} is a suite, then {@code shouldRun} may return
	 * false if it is cheap to determine that no leaf recursively included by
	 * this suite should be run. However, {@code shouldRun} may return true for
	 * a suite, and yet return false for every member of that suite, in which
	 * case the suite should throw {@link NoTestsRemainException} from the
	 * {@code filter} method.
	 *
	 * I apologize for any inconvenience caused by this specification. 
	 * 
	 * @param description
	 *            the description of the test to be run
	 * @return <code>true</code> if the test should be run.
	 * @author saff
=======
	 * @param description the description of the test to be run
	 * @return <code>true</code> if the test should be run
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
	 * Invoke with a {@link org.junit.runner.Runner} to cause all tests it
	 * intends to run to first be checked with the filter. Only those that pass
	 * the filter will be run.
	 * 
	 * @param child
	 *            the runner to be filtered by the receiver
	 * @throws NoTestsRemainException
	 *             if the receiver removes all tests
=======
	 * Invoke with a {@link org.junit.runner.Runner} to cause all tests it intends to run
	 * to first be checked with the filter. Only those that pass the filter will be run.
	 * @param child the runner to be filtered by the receiver
	 * @throws NoTestsRemainException if the receiver removes all tests
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
		// TODO: deprecate this, too
		fChildren.add(description);
		// description.setParent(this);
	}

	public void setParent(Description parent) {
		fParent = parent;
=======
		getChildren().add(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	@Deprecated public ArrayList<Description> getChildren() {
=======
	public ArrayList<Description> getChildren() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		findLeaves(null, request.getRunner().getPlan(), results);
=======
		findLeaves(null, request.getRunner().getDescription(), results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private void findLeaves(Plan parent, Plan plan, List<Description> results) {
		if (plan.getChildren().isEmpty())
			if (plan.getDescription().toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent.getDescription()));
=======
	private void findLeaves(Description parent, Description description, List<Description> results) {
		if (description.getChildren().isEmpty())
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
				results.add(plan.getDescription());
=======
				results.add(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			for (Plan each : plan.getChildren())
				findLeaves(plan, each, results);
=======
			for (Description each : description.getChildren())
				findLeaves(description, each, results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
		return new TheoryAnchor(method);
=======
		return new TheoryAnchor(method, getTestClass());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
		public TheoryAnchor(FrameworkMethod method) {
=======
		public TheoryAnchor(FrameworkMethod method, TestClass testClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java;<<<<<<< MINE
		Plan plan = runner.getPlan();
		assertEquals(1, plan.getChildren().size());
=======
		Description description = runner.getDescription();
		assertEquals(1, description.getChildren().size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;<<<<<<< MINE
		assertThat(new Theories(HasATheory.class).getPlan().getChildren()
				.size(), is(1));
=======
		assertThat(new Theories(HasATheory.class).getDescription()
				.getChildren().size(), is(1));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;<<<<<<< MINE
		assertThat(testResult(TheoriesMustBePublic.class),
=======
		assertThat(
				testResult(TheoriesMustBePublic.class),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;<<<<<<< MINE
		return new StubbedTheoryAnchor(method);
=======
		return new StubbedTheoryAnchor(method, getTestClass());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE
		@Category( { FastTests.class, SlowTests.class })
=======
		@Category({FastTests.class, SlowTests.class})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	@Test
	public void runMethodWithTwoCategories() {
=======
	
	@Test public void runMethodWithTwoCategories() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	@Test
	public void subclassesOfIncludedCategoriesAreRun() {
=======
	
	@Test public void subclassesOfIncludedCategoriesAreRun() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	@Test
	public void classesCanBeCategories() {
=======
	
	@Test public void classesCanBeCategories() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void makeSureSuiteIsCalled() {
=======
	
	@Test public void makeSureSuiteIsCalled() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		@Test
		public void sample() {
=======
		@Test public void sample() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void makeSureSuiteWorksWithJUnit4Classes() {
=======
	
	@Test public void makeSureSuiteWorksWithJUnit4Classes() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		@Ignore
		@Test
=======
		@Ignore	@Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

		Runner runner= Request.aClass(CompatibilityTest.class).getRunner();
		Plan plan= runner.getPlan();
		assertEquals(1, plan.getChildren().size());
		assertEquals("initializationError", plan.getChildren().get(0).getDescription()
				.getMethodName());
=======
		
		Description description= Request.aClass(CompatibilityTest.class).getRunner().getDescription();
		assertEquals(0, description.getChildren().size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		@Test
		public void sample() {
=======
		@Test public void sample() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void suiteIsUsedWithJUnit4Classes() {
=======
	
	@Test public void suiteIsUsedWithJUnit4Classes() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

		@Test
		public void sample() {
=======
		
		@Test public void sample() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

		@Ignore
		@Test
		public void ignore() {
=======
		
		@Ignore @Test public void ignore() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void makeSureSuiteNotUsedWithJUnit4Classes2() {
=======
	
	@Test public void makeSureSuiteNotUsedWithJUnit4Classes2() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;<<<<<<< MINE
		Plan plan= runner.getPlan();
		assertEquals("[0]", plan.getChildren().get(0).getDescription().getDisplayName());
=======
		Description description= runner.getDescription();
		assertEquals("[0]", description.getChildren().get(0).getDisplayName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned
	 * by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this
	 * class and superclasses before the previous step; if any throws an
=======
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before the previous step; if any throws an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this
	 * class and superclasses before any of the previous steps; all AfterClass
	 * methods are always executed: exceptions thrown by previous steps are
	 * combined, if necessary, with exceptions from AfterClass methods into a
=======
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before any of the previous steps; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; if any throws an Exception, stop execution and pass the exception on.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before executing {@code statement}; if any throws an
	 * Exception, stop execution and pass the exception on.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; all AfterClass methods are always executed: exceptions thrown by
	 * previous steps are combined, if necessary, with exceptions from
	 * AfterClass methods into a {@link MultipleFailureException}.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before executing {@code statement}; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
	 * {@link MultipleFailureException}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
// This test case is obsolete, since the compiler will catch this error in 1.5
//	public void testNoTestCaseClass() {
//		Test t= new TestSuite(NoTestCaseClass.class);
//		t.run(fResult);
//		assertEquals(1, fResult.runCount());  // warning test
//		assertTrue(! fResult.wasSuccessful());
//	}
=======
	public void testNoTestCaseClass() {
		Test t= new TestSuite(NoTestCaseClass.class);
		t.run(fResult);
		assertEquals(1, fResult.runCount());  // warning test
		assertTrue(! fResult.wasSuccessful());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
			fScheduler.schedule(new Runnable() {			
=======
 			fScheduler.schedule(new Runnable() {			
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		for (FrameworkField each : ruleFields())
			results.add(createRule(test, each));
=======
		for (FrameworkField each : ruleFields()) {
			if (MethodRule.class.isAssignableFrom(each.getType())) {
				results.add(createRule(test, each));
			}
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_5f25ca3_bed58a5/rev_5f25ca3-bed58a5/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
 * ways.  {@link org.junit.Rule} annotates method-level 
 * {@link TestRule}s, and {@link org.junit.ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
=======
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See the Javadoc for those annotations
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_0781e97_7f6173a/rev_0781e97-7f6173a/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
 * ways.  {@link org.junit.Rule} annotates method-level 
 * {@link TestRule}s, and {@link org.junit.ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
=======
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_fb723db_72ca494/rev_fb723db-72ca494/src/main/java/redis/clients/jedis/Response.java;<<<<<<< MINE
        	if (data instanceof JedisDataException){
        		throw new JedisDataException((JedisDataException)data);
=======
        	if(data != null ){
	        	if (data instanceof JedisDataException){
	        		throw new JedisDataException((JedisDataException)data);
	        	}
	            response = builder.build(data);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    }

    public Object eval(String script, int keyCount, String... params) {
    	client.setTimeoutInfinite();
        client.eval(script, keyCount, params);
        
        return getEvalResult();
    }
	
    private String[] getParams(List<String> keys, List<String> args){
    	int keyCount = keys.size();
		int argCount = args.size();
    	
    	String[] params = new String[keyCount + args.size()];
    	
    	for(int i=0;i<keyCount;i++)
    		params[i] = keys.get(i);
    	
    	for(int i=0;i<argCount;i++)
    		params[keyCount + i] = args.get(i);
    	
    	return params;
    }
    
    public Object eval(String script, List<String> keys, List<String> args) {
    	return eval(script, keys.size(), getParams(keys, args));
	}

	public Object eval(String script) {
		return eval(script,0);		
	}

	public Object evalsha(String script) {
		return evalsha(script,0);		
	}
    
    private Object getEvalResult(){
    	Object result = client.getOne();
        
        if(result instanceof byte[])
        	return SafeEncoder.encode((byte[])result);
        
        if(result instanceof List<?>) {
        	List<?> list = (List<?>)result;
        	List<String> listResult = new ArrayList<String>(list.size());
        	for(Object bin: list)
        		listResult.add(SafeEncoder.encode((byte[])bin));
        	
        	return listResult;
        }
        
        return result;
    }
    
    public Object evalsha(String sha1, List<String> keys, List<String> args) {
    	return evalsha(sha1, keys.size(), getParams(keys, args));
    }
    
	public Object evalsha(String sha1, int keyCount, String... params) {
		checkIsInMulti();
        client.evalsha(sha1, keyCount, params);
        
        return getEvalResult();
    }
	
	public Boolean scriptExists(String sha1){
		String[] a = new String[1];
		a[0] = sha1;
		return scriptExists(a).get(0);
    }

	public List<Boolean> scriptExists(String... sha1){
		client.scriptExists(sha1);
		List<Long> result = client.getIntegerMultiBulkReply();
		List<Boolean> exists = new ArrayList<Boolean>();
		
		for(Long value : result)
			exists.add(value == 1);
		
		return exists;
    }
	
    public String scriptLoad(String script){
    	client.scriptLoad(script);
    	return client.getBulkReply();
    }
=======
    }
    
    public List<Slowlog> slowlogGet() {
		client.slowlogGet();
		return Slowlog.from(client.getObjectMultiBulkReply());
	}
	
	public List<Slowlog> slowlogGet(long entries) {
		client.slowlogGet(entries);
		return Slowlog.from(client.getObjectMultiBulkReply());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT;
=======
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, SLOWLOG;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, FLUSH, EXISTS, LOAD, KILL;
=======
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LEN, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, RESET;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	client.configSet(parameter, value);
	return client.getStatusCodeReply();
    }

    public Object eval(String script, int keyCount, String... params) {
	client.setTimeoutInfinite();
	client.eval(script, keyCount, params);

	return getEvalResult();
    }

    private String[] getParams(List<String> keys, List<String> args) {
	int keyCount = keys.size();
	int argCount = args.size();

	String[] params = new String[keyCount + args.size()];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return params;
    }

    public Object eval(String script, List<String> keys, List<String> args) {
	return eval(script, keys.size(), getParams(keys, args));
    }

    public Object eval(String script) {
	return eval(script, 0);
    }

    public Object evalsha(String script) {
	return evalsha(script, 0);
    }

    private Object getEvalResult() {
	Object result = client.getOne();

	if (result instanceof byte[])
	    return SafeEncoder.encode((byte[]) result);

	if (result instanceof List<?>) {
	    List<?> list = (List<?>) result;
	    List<String> listResult = new ArrayList<String>(list.size());
	    for (Object bin : list)
		listResult.add(SafeEncoder.encode((byte[]) bin));

	    return listResult;
	}

	return result;
    }

    public Object evalsha(String sha1, List<String> keys, List<String> args) {
	return evalsha(sha1, keys.size(), getParams(keys, args));
    }

    public Object evalsha(String sha1, int keyCount, String... params) {
	checkIsInMulti();
	client.evalsha(sha1, keyCount, params);

	return getEvalResult();
    }

    public Boolean scriptExists(String sha1) {
	String[] a = new String[1];
	a[0] = sha1;
	return scriptExists(a).get(0);
    }

    public List<Boolean> scriptExists(String... sha1) {
	client.scriptExists(sha1);
	List<Long> result = client.getIntegerMultiBulkReply();
	List<Boolean> exists = new ArrayList<Boolean>();

	for (Long value : result)
	    exists.add(value == 1);

	return exists;
    }

    public String scriptLoad(String script) {
	client.scriptLoad(script);
	return client.getBulkReply();
    }

    public List<Slowlog> slowlogGet() {
	client.slowlogGet();
	return Slowlog.from(client.getObjectMultiBulkReply());
    }

    public List<Slowlog> slowlogGet(long entries) {
	client.slowlogGet(entries);
	return Slowlog.from(client.getObjectMultiBulkReply());
    }
=======
        client.configSet(parameter, value);
        return client.getStatusCodeReply();
    }

	public Long objectRefcount(String string) {
		client.objectRefcount(string);
		return client.getIntegerReply();
	}
	
	public String objectEncoding(String string) {
		client.objectEncoding(string);
		return client.getBulkReply();
	}

	public Long objectIdletime(String string) {
		client.objectIdletime(string);
		return client.getIntegerReply();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG;
=======
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, OBJECT;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, RESET, FLUSH, EXISTS, LOAD, KILL, LEN;
	public final byte[] raw;
=======
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, REFCOUNT, ENCODING, IDLETIME;
        public final byte[] raw;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<String> zrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrange(key, start, end);
=======
    public Set<String> zrange(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrange(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<String> zrevrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrange(key, start, end);
=======
    public Set<String> zrevrange(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrevrange(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<Tuple> zrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrangeWithScores(key, start, end);
=======
    public Set<Tuple> zrangeWithScores(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrangeWithScores(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<Tuple> zrevrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrangeWithScores(key, start, end);
=======
    public Set<Tuple> zrevrangeWithScores(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrevrangeWithScores(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Long zremrangeByRank(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zremrangeByRank(key, start, end);
=======
    public Long zremrangeByRank(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zremrangeByRank(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrange(final byte[] key, final int start, final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
=======
    public void zrange(final byte[] key, final long start, final long end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrange(final byte[] key, final int start, final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
=======
    public void zrevrange(final byte[] key, final long start, final long end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
=======
    public void zrangeWithScores(final byte[] key, final long start,
            final long end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
=======
    public void zrevrangeWithScores(final byte[] key, final long start,
            final long end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zremrangeByRank(final byte[] key, final int start, final int end) {
	sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
=======
    public void zremrangeByRank(final byte[] key, final long start, final long end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<String> zrange(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
=======
    public Set<String> zrange(final String key, final long start, final long end) {
        checkIsInMulti();
        client.zrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<String> zrevrange(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
=======
    public Set<String> zrevrange(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrevrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<Tuple> zrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
=======
    public Set<Tuple> zrangeWithScores(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<Tuple> zrevrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
=======
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrevrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Long zremrangeByRank(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
=======
    public Long zremrangeByRank(final String key, final long start, final long end) {
        checkIsInMulti();
        client.zremrangeByRank(key, start, end);
        return client.getIntegerReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrange(final String key, final int start, final int end) {
	zrange(SafeEncoder.encode(key), start, end);
=======
    public void zrange(final String key, final long start, final long end) {
        zrange(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrevrange(final String key, final int start, final int end) {
	zrevrange(SafeEncoder.encode(key), start, end);
=======
    public void zrevrange(final String key, final long start, final long end) {
        zrevrange(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrangeWithScores(final String key, final int start,
	    final int end) {
	zrangeWithScores(SafeEncoder.encode(key), start, end);
=======
    public void zrangeWithScores(final String key, final long start,
            final long end) {
        zrangeWithScores(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrevrangeWithScores(final String key, final int start,
	    final int end) {
	zrevrangeWithScores(SafeEncoder.encode(key), start, end);
=======
    public void zrevrangeWithScores(final String key, final long start,
            final long end) {
        zrevrangeWithScores(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zremrangeByRank(final String key, final int start, final int end) {
	zremrangeByRank(SafeEncoder.encode(key), start, end);
=======
    public void zremrangeByRank(final String key, final long start, final long end) {
        zremrangeByRank(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *             <code>assertEquals(double expected, double actual, double epsilon)</code>
=======
	 *             <code>assertEquals(double expected, double actual, double delta)</code>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *             <code>assertEquals(String message, double expected, double actual, double epsilon)</code>
=======
	 *             <code>assertEquals(String message, double expected, double actual, double delta)</code>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/ClassRule.java;<<<<<<< MINE
 * 	&#064;Rule
=======
 * 	&#064;ClassRule
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_610f7d4_69f5340/rev_610f7d4-69f5340/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCRBYFLOAT, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HINCRBYFLOAT, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zcount(final byte[] key, final double min, final double max) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZCOUNT, key, byteArrayMin, byteArrayMax);
    }

    public void zcount(final byte[] key, final byte min[], final byte max[]) {
        sendCommand(ZCOUNT, key, min, max);
    }

    public void zcount(final byte[] key, final String min, final String max) {
        sendCommand(ZCOUNT, key, min.getBytes(), max.getBytes());
=======
    public void zcount(final byte[] key, final byte[] min, final byte[] max) {
	sendCommand(ZCOUNT, key, min, max);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax);
=======
    public void zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScore(final byte[] key, final String max,
            final String min) {
        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes());
    }

    public void zrangeByScore(final byte[] key, final double min,
            final double max, final int offset, int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrangeByScore(final byte[] key, final byte min[],
            final byte max[], final int offset, int count) {

        sendCommand(ZRANGEBYSCORE, key, min, max,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrangeByScore(final byte[] key, final String min,
            final String max, final int offset, int count) {

        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
=======
    public void zrangeByScoreWithScores(final byte[] key, final byte[] min,
	    final byte[] max) {
	sendCommand(ZRANGEBYSCORE, key, min, max, WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScore(final byte[] key, final double max,
            final double min, final int offset, int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

     public void zrevrangeByScore(final byte[] key, final byte max[],
            final byte min[], final int offset, int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrevrangeByScore(final byte[] key, final String max,
            final String min, final int offset, int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
=======
    public void zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
	    final byte[] min) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min, WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final byte min[],
            final byte max[]) {

        sendCommand(ZRANGEBYSCORE, key, min, max,
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final String min,
            final String max) {

        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                WITHSCORES.raw);
=======
    public void zrangeByScoreWithScores(final byte[] key, final byte[] min,
	    final byte[] max, final int offset, final int count) {
	sendCommand(ZRANGEBYSCORE, key, min, max, LIMIT.raw,
		toByteArray(offset), toByteArray(count), WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final byte max[],
            final byte min[]) {
        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final String max,
            final String min) {
        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                WITHSCORES.raw);
=======
    public void zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
	    final byte[] min, final int offset, final int count) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min, LIMIT.raw,
		toByteArray(offset), toByteArray(count), WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max, final int offset, final int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final byte min[],
            final byte max[], final int offset, final int count) {
        sendCommand(ZRANGEBYSCORE, key, min, max,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final String min,
            final String max, final int offset, final int count) {
        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
=======
    public void zremrangeByRank(final byte[] key, final long start,
	    final long end) {
	sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min, final int offset, final int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final byte max[],
            final byte min[], final int offset, final int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final String max,
            final String min, final int offset, final int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zremrangeByRank(final byte[] key, final int start, final int end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
    }

    public void zremrangeByScore(final byte[] key, final double start,
            final double end) {
        sendCommand(ZREMRANGEBYSCORE, key, toByteArray(start), toByteArray(end));
=======
    public void zremrangeByScore(final byte[] key, final byte[] start,
	    final byte[] end) {
	sendCommand(ZREMRANGEBYSCORE, key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScore(final byte[] key, final double min,
            final double max) {
=======
    public void zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max) {
	sendCommand(ZRANGEBYSCORE, key, min, max);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/benchmark/PoolBenchmark.java;<<<<<<< MINE
	final JedisPool pool = new JedisPool(new GenericObjectPoolConfig(),
		hnp.host, hnp.port, 2000, "foobared");
	List<Thread> tds = new ArrayList<Thread>();

	final AtomicInteger ind = new AtomicInteger();
	for (int i = 0; i < 50; i++) {
	    Thread hj = new Thread(new Runnable() {
		public void run() {
		    for (int i = 0; (i = ind.getAndIncrement()) < TOTAL_OPERATIONS;) {
			try {
			    Jedis j = pool.getResource();
			    final String key = "foo" + i;
			    j.set(key, key);
			    j.get(key);
			    pool.returnResource(j);
			} catch (Exception e) {
			    e.printStackTrace();
			}
		    }
		}
	    });
	    tds.add(hj);
	    hj.start();
	}
=======
        final JedisPool pool = new JedisPool(new Config(), hnp.getHost(), hnp.getPort(),
                2000, "foobared");
        List<Thread> tds = new ArrayList<Thread>();

        final AtomicInteger ind = new AtomicInteger();
        for (int i = 0; i < 50; i++) {
            Thread hj = new Thread(new Runnable() {
                public void run() {
                    for (int i = 0; (i = ind.getAndIncrement()) < TOTAL_OPERATIONS;) {
                        try {
                            Jedis j = pool.getResource();
                            final String key = "foo" + i;
                            j.set(key, key);
                            j.get(key);
                            pool.returnResource(j);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            });
            tds.add(hj);
            hj.start();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "0");
	pool.returnResource(jedis);

	jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
=======
    	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");
        pool.returnResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.quit();
	pool.returnBrokenResource(jedis);

	jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
=======
    	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.quit();
        pool.returnBrokenResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisPool pool = new JedisPool(config, hnp.host, hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "0");

	Jedis newJedis = pool.getResource();
	newJedis.auth("foobared");
	newJedis.incr("foo");
=======
        Config config = new Config();
        config.maxActive = 1;
        config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
        JedisPool pool = new JedisPool(config, hnp.getHost(), hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");

        Jedis newJedis = pool.getResource();
        newJedis.auth("foobared");
        newJedis.incr("foo");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool0 = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared");
	Jedis jedis0 = pool0.getResource();
	jedis0.set("foo", "bar");
	assertEquals("bar", jedis0.get("foo"));
	pool0.returnResource(jedis0);
	pool0.destroy();

	JedisPool pool1 = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared", 1);
	Jedis jedis1 = pool1.getResource();
	assertNull(jedis1.get("foo"));
	pool1.returnResource(jedis1);
	pool1.destroy();
=======
        JedisPool pool0 = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000, "foobared");
        Jedis jedis0 = pool0.getResource();
        jedis0.set("foo", "bar");
        assertEquals( "bar", jedis0.get("foo") );
        pool0.returnResource(jedis0);
        pool0.destroy();

        JedisPool pool1 = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000, "foobared", 1);
        Jedis jedis1 = pool1.getResource();
        assertNull( jedis1.get("foo") );
        pool1.returnResource(jedis0);
        pool1.destroy();
    }

    @Test
    public void returnBinary() {
        JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000);
        BinaryJedis jedis = pool.getResource();
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/ShardedJedisPipelineTest.java;<<<<<<< MINE
	Jedis jedis = new Jedis(redis1.host, redis1.port);
	jedis.auth("foobared");
	jedis.flushAll();
	jedis.disconnect();
	jedis = new Jedis(redis2.host, redis2.port);
	jedis.auth("foobared");
	jedis.flushAll();
	jedis.disconnect();

	JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.host, redis1.port);
	JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.host, redis2.port);
	shardInfo1.setPassword("foobared");
	shardInfo2.setPassword("foobared");
	List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
	shards.add(shardInfo1);
	shards.add(shardInfo2);
	this.jedis = new ShardedJedis(shards);
=======
        Jedis jedis = new Jedis(redis1.getHost(), redis1.getPort());
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.getHost(), redis2.getPort());
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();

        JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.getHost(), redis1.getPort());
        JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.getHost(), redis2.getPort());
        shardInfo1.setPassword("foobared");
        shardInfo2.setPassword("foobared");
        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(shardInfo1);
        shards.add(shardInfo2);
        this.jedis = new ShardedJedis(shards);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT;
=======
	DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, CLUSTER, ASKING;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2cd3988_9995466/rev_2cd3988-9995466/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
				Assert.assertThat(e, fMatcher);
=======
				try {
					Assert.assertThat(e, fMatcher);
				} catch (AssertionError ae) {
					// add e as cause to have a complete error message in the
					// results
					ae.initCause(e);
					throw ae;
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2cd3988_9995466/rev_2cd3988-9995466/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
				Assert.assertThat(e, fMatcher);
=======
				try {
					Assert.assertThat(e, fMatcher);
				} catch (AssertionError ae) {
					// add e as cause to have a complete error message in the
					// results
					ae.initCause(e);
					throw ae;
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d7c5823_f11c162/rev_d7c5823-f11c162/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
	flush();
	pipelinedCommands--;
	return (List<Object>) Protocol.read(inputStream);
=======
        flush();
        pipelinedCommands--;
        return getRawObjectMultiBulkReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	return evalResult(client.getOne());
    }

    private Object evalResult(Object result) {
=======
	Object result = client.getOne();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    @Test
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }
=======
    @Test
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1",
		"key2", "1", "2");
	assertEquals(results.get(0), "key1");
	assertEquals(results.get(1), "key2");
	assertEquals(results.get(2), "1");
	assertEquals(results.get(3), "2");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    private <T> CombinableMatcher<List<T>> listWithItem(T expected) {
	return both(CoreMatchers.<List<T>>instanceOf(List.class)).and(hasItem(equalTo(expected)));
    }
=======
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
			Assert.assertEquals((Double)expected, (Double)actual, fDelta);
=======
			Assert.assertEquals((Double)expected, (Double)actual, (Double)fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
			Assert.assertEquals((Float)expected, (Float)actual, fDelta);
=======
			Assert.assertEquals((Float)expected, (Float)actual, (Float)fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two doubles or floats are equal to within a positive delta.
=======
	 * Asserts that two doubles are equal to within a positive delta.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two doubles or floats are equal to within a positive delta.
=======
	 * Asserts that two doubles are equal to within a positive delta.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_db76522_e7bc4f5/rev_db76522-e7bc4f5/src/main/java/redis/clients/jedis/JedisSlotBasedConnectionHandler.java;<<<<<<< MINE
    private Jedis currentConnection;

    public JedisSlotBasedConnectionHandler(Set<HostAndPort> nodes,
        final GenericObjectPoolConfig poolConfig) {
	super(nodes, poolConfig);
=======
    public JedisSlotBasedConnectionHandler(Set<HostAndPort> nodes) {
	super(nodes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e381886_3f6e3ef/rev_e381886-3f6e3ef/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	BlockJUnit4ClassRunnerTest.class,
	CauseMatcherTest.class
=======
	BlockJUnit4ClassRunnerTest.class,
	MethodSorterTest.class,
	TestedOnSupplierTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_167a782_81c8308/rev_167a782-81c8308/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
    public T runBinary(byte[] key) {
        if (key == null) {
            throw new JedisClusterException(
                "No way to dispatch this command to Redis Cluster.");
        }

        return runWithRetries(key, this.redirections, false, false);
    }
    
    public T runScript(String... keys) {
=======
    public T run(int keyCount, String... keys) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6106f5b_e1f50b5/rev_6106f5b-e1f50b5/src/main/java/redis/clients/jedis/ScanParams.java;<<<<<<< MINE
    public ScanParams match(final String pattern) {
=======
    public void match(final byte[] pattern) {
	params.add(MATCH.raw);
	params.add(pattern);
    }
    
    public void match(final String pattern) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0d5062c_6af41cd/rev_0d5062c-6af41cd/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
    public Response<String> lindex(String key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.STRING);
=======
    public Response<Double> incrByFloat(String key, double value) {
        getClient(key).incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double value) {
        getClient(key).incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<String> lindex(String key, int index) {
        getClient(key).lindex(key, index);
        return getResponse(BuilderFactory.STRING);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0d5062c_6af41cd/rev_0d5062c-6af41cd/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, PFADD, PFCOUNT, PFMERGE;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCRBYFLOAT, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HINCRBYFLOAT, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

    private void waitForClusterReady() throws InterruptedException {
	boolean clusterOk = false;
	while (!clusterOk) {
	    if (node1.clusterInfo().split("\n")[0].contains("ok")
		    && node2.clusterInfo().split("\n")[0].contains("ok")
		    && node3.clusterInfo().split("\n")[0].contains("ok")) {
		clusterOk = true;
=======
    private List<Integer> getSlotsBeingMigrated(String infoLine) {
	List<Integer> inconsistentSlots = new ArrayList<Integer>();
	
	String[] splitted = infoLine.split(" ");
	
	if (splitted.length > 8) {
	    for (int index = 8 ; index < splitted.length ; index++) {
		String info = splitted[index];
		Integer slot = getSlotFromMigrationInfo(info);
		if (slot != null) {
		    inconsistentSlots.add(slot);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
	    HostAndPort node = getHostAndPortFromNodeLine(nodeInfo, jedis);
        setNodeIfNotExist(node);

	    JedisPool nodePool = nodes.get(getNodeKey(node));
	    populateNodeSlots(nodeInfo, nodePool);
	}
    }
    
    private void setNodeIfNotExist(HostAndPort node) {
	String nodeKey = getNodeKey(node);
	if (nodes.containsKey(nodeKey))
	    return;
	
	JedisPool nodePool = new JedisPool(poolConfig, node.getHost(), node.getPort());
	nodes.put(nodeKey, nodePool);
    }
=======
	    ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
		    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
			    jedis.getClient().getPort()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return (List<byte[]>) Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return (List<byte[]>) readProtocolWithCheckingBroken();
    }

    public void resetPipelinedCount() {
	pipelinedCommands = 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return (List<Object>) Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return getRawObjectMultiBulkReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return readProtocolWithCheckingBroken();
    }

    public boolean isBroken() {
	return broken;
    }

    protected void flush() {
	try {
	    outputStream.flush();
	} catch (IOException ex) {
	    broken = true;
	    throw new JedisConnectionException(ex);
	}
    }

    protected Object readProtocolWithCheckingBroken() {
	try {
	    return Protocol.read(inputStream);
	} catch (JedisConnectionException exc) {
	    broken = true;
	    throw exc;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Entry<String, String>> hscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.hscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.sscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.zscan(key, cursor);
    }

    public ScanResult<Entry<String, String>> hscan(String key,
	    final String cursor) {
=======
    public ScanResult<Entry<String, String>> hscan(String key, final String cursor) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/ScanResult.java;<<<<<<< MINE
    
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531
     * @return int(currently), but will be changed to String, so be careful to prepare! 
     */
    public int getCursor() {
	return Integer.parseInt(getStringCursor());
    }

    /**
     * FIXME: This method should be changed to getCursor() on next major release
     */
    public String getStringCursor() {
	return SafeEncoder.encode(cursor);
    }
    
    public byte[] getCursorAsBytes() {
=======

    public String getCursor() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/rules/TestWatchman.java;<<<<<<< MINE
 * 
 * @deprecated Use {@link TestWatcher} (which implements {@link TestRule}) instead.
 * @since 4.7
=======
 *
 * @since 4.7
 * @deprecated {@link MethodRule} is deprecated.
 *             Use {@link TestWatcher} implements {@link TestRule} instead.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/Rule.java;<<<<<<< MINE
 * Annotates fields that reference rules or methods that return a rule. A field must be public, not
 * static, and a subtype of {@link org.junit.rules.TestRule} (preferred) or
 * {@link org.junit.rules.MethodRule}. A method must be public, not static
 * and must return a subtype of {@link org.junit.rules.TestRule} (preferred) or
 * {@link org.junit.rules.MethodRule}.<p>
 *
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link Before} methods, 
=======
 * Annotates fields that contain rules or methods that return a rule. A field must be public, not
 * static, and a subtype of {@link org.junit.rules.TestRule}. A method must be public, not static
 * and must return a subtype of {@link org.junit.rules.TestRule}.
 * The {@link org.junit.runners.model.Statement} passed
 * to the {@link org.junit.rules.TestRule} will run any {@link Before} methods,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/ClassRule.java;<<<<<<< MINE
 * a subtype of {@link org.junit.rules.TestRule}.<p>
 *
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods, 
=======
 * a subtype of {@link org.junit.rules.TestRule}
 * The {@link org.junit.runners.model.Statement} passed
 * to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/rules/MethodRule.java;<<<<<<< MINE
 * 
 * Note that {@link MethodRule} has been replaced by {@link TestRule},
 * which has the added benefit of supporting class rules.
=======
 *
 * Note that {@link MethodRule} is now deprecated, you should be using {@link TestRule} instead.
 *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/Rule.java;<<<<<<< MINE
 * 
 * For more information and more examples, see 
 * {@link org.junit.rules.TestRule}. 
=======
 *
 * For more information and more examples, see
 * {@link org.junit.rules.TestRule}.
 *
 * Note: for backwards compatibility, this annotation may also mark
 * fields or methods of type {@link org.junit.rules.MethodRule}, which will be honored.  However,
 * this is a deprecated interface and feature.
 *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, ZLEXCOUNT, ZRANGEBYLEX, ZREMRANGEBYLEX, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, PFADD, PFCOUNT, PFMERGE;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    public JedisSentinelPool(String masterName, Set<String> sentinels,
	    final GenericObjectPoolConfig poolConfig, int timeout,
	    final String password, final int database) {

	this.poolConfig = poolConfig;
	this.timeout = timeout;
	this.password = password;
	this.database = database;
=======
	public JedisSentinelPool(String masterName, Set<String> sentinels,
			final GenericObjectPoolConfig poolConfig, int timeout,
			final String password, final int database) {
		this.poolConfig = poolConfig;
		this.timeout = timeout;
		this.password = password;
		this.database = database;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
	HostAndPort master = initSentinels(sentinels, masterName);
	initPool(master);
    }

    private volatile JedisFactory factory;
    private volatile HostAndPort currentHostMaster;

    public void destroy() {
	for (MasterListener m : masterListeners) {
	    m.shutdown();
=======
		HostAndPort master = initSentinels(sentinels, masterName);
		initPool(master);
	}

	public void returnBrokenResource(final Jedis resource) {
		if (resource != null) {
			returnBrokenResourceObject(resource);
		}
	}

	public void returnResource(final Jedis resource) {
		if (resource != null) {
			resource.resetState();
			returnResourceObject(resource);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    private void initPool(HostAndPort master) {
	if (!master.equals(currentHostMaster)) {
	    currentHostMaster = master;
	    if (factory == null) {
	        factory = new JedisFactory(master.getHost(), master.getPort(),
	                                   timeout, password, database);
	        initPool(poolConfig, factory);
	    } else {
	        factory.setHostAndPort(currentHostMaster);
	        // although we clear the pool, we still have to check the returned object
	        // in getResource, this call only clears idle instances, not borrowed instances
	        internalPool.clear();
	    }

	    log.info("Created JedisPool to master at " + master);
=======
		super.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
		Jedis jedis = null;
		try {
		    jedis = new Jedis(hap.getHost(), hap.getPort());
=======
		log.info("Redis master running at " + master
				+ ", starting Sentinel listeners...");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
		    if (master == null) {
			master = toHostAndPort(jedis
				.sentinelGetMasterAddrByName(masterName));
			log.fine("Found Redis master at " + master);
			break outer;
		    }
		} catch (JedisConnectionException e) {
		    log.warning("Cannot connect to sentinel running @ " + hap
			    + ". Trying next one.");
		} finally {
		    if (jedis != null) {
	        jedis.close();
		    }
=======
		for (String sentinel : sentinels) {
			final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel
					.split(":")));
			MasterListener masterListener = new MasterListener(masterName,
					hap.getHost(), hap.getPort());
			masterListeners.add(masterListener);
			masterListener.start();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest.java;<<<<<<< MINE
    protected static HostAndPort master = HostAndPortUtil.getRedisServers()
	    .get(2);
    protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
	    .get(3);

    protected static HostAndPort sentinel1 = HostAndPortUtil
	    .getSentinelServers().get(1);
    protected static HostAndPort sentinel2 = HostAndPortUtil
            .getSentinelServers().get(3);

    protected static Jedis sentinelJedis1;
    protected static Jedis sentinelJedis2;

    protected Set<String> sentinels = new HashSet<String>();

    @Before
    public void setUp() throws Exception {
	sentinels.add(sentinel1.toString());
	sentinels.add(sentinel2.toString());

	sentinelJedis1 = new Jedis(sentinel1.getHost(), sentinel1.getPort());
	sentinelJedis2 = new Jedis(sentinel2.getHost(), sentinel2.getPort());
    }
    
    @Test
    public void checkCloseableConnections() throws Exception {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();

	JedisSentinelPool pool = new JedisSentinelPool(
		MASTER_NAME, sentinels, config, 1000, "foobared", 2);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.close();
	assertTrue(pool.isClosed());
    }

    @Test
    public void ensureSafeTwiceFailover() throws InterruptedException {
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		new GenericObjectPoolConfig(), 1000, "foobared", 2);

	forceFailover(pool);
	// after failover sentinel needs a bit of time to stabilize before a new failover
	Thread.sleep(100);
	forceFailover(pool);

	// you can test failover as much as possible
    }
    
    @Test
    public void returnResourceShouldResetState() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis jedis = pool.getResource();
	Jedis jedis2 = null;
	
	try {
	    jedis.set("hello", "jedis");
	    Transaction t = jedis.multi();
	    t.set("hello", "world");
	    pool.returnResource(jedis);
	    
	    jedis2 = pool.getResource();

	    assertTrue(jedis == jedis2);
	    assertEquals("jedis", jedis2.get("hello"));
	} catch (JedisConnectionException e) {
	    if (jedis2 != null) {
		pool.returnBrokenResource(jedis2);
		jedis2 = null;
	    }
	} finally {
	    if (jedis2 != null)
		pool.returnResource(jedis2);
	    
	    pool.destroy();
	}
    }
    
    @Test
    public void checkResourceIsCloseable() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis jedis = pool.getResource();
	try {
	    jedis.set("hello", "jedis");
	} finally {
	    jedis.close();
	}

	Jedis jedis2 = pool.getResource();
	try {
	    assertEquals(jedis, jedis2);
	} finally {
	    jedis2.close();
	}
    }

    @Test
    public void returnResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnResource(nullJedis);
	pool.destroy();
    }

    @Test
    public void returnBrokenResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnBrokenResource(nullJedis);
	pool.destroy();
    }

    private void forceFailover(JedisSentinelPool pool)
	    throws InterruptedException {
	HostAndPort oldMaster = pool.getCurrentHostMaster();

	// jedis connection should be master
	Jedis beforeFailoverJedis = pool.getResource();
	assertEquals("PONG", beforeFailoverJedis.ping());

	waitForFailover(pool, oldMaster);

	Jedis afterFailoverJedis = pool.getResource();
	assertEquals("PONG", afterFailoverJedis.ping());
	assertEquals("foobared", afterFailoverJedis.configGet("requirepass").get(1));
	assertEquals(2, afterFailoverJedis.getDB().intValue());
	
	// returning both connections to the pool should not throw
	beforeFailoverJedis.close();
	afterFailoverJedis.close();
    }

    private void waitForFailover(JedisSentinelPool pool, HostAndPort oldMaster)
	    throws InterruptedException {
	HostAndPort newMaster = JedisSentinelTestUtil
		.waitForNewPromotedMaster(MASTER_NAME, sentinelJedis1, sentinelJedis2);

	waitForJedisSentinelPoolRecognizeNewMaster(pool, newMaster);
    }

    private void waitForJedisSentinelPoolRecognizeNewMaster(
	    JedisSentinelPool pool, HostAndPort newMaster)
	    throws InterruptedException {

	while (true) {
	    HostAndPort currentHostMaster = pool.getCurrentHostMaster();

	    if (newMaster.equals(currentHostMaster))
		break;
=======
	protected static HostAndPort master = HostAndPortUtil.getRedisServers()
			.get(2);
	protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
			.get(3);
	protected static HostAndPort sentinel1 = HostAndPortUtil
			.getSentinelServers().get(1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
    private void discoverClusterNodesAndSlots(Jedis jedis) {
        String localNodes = jedis.clusterNodes();
        for (String nodeInfo : localNodes.split("\n")) {
            ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
                    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
                    jedis.getClient().getPort()));

            HostAndPort targetNode = clusterNodeInfo.getNode();
            setNodeIfNotExist(targetNode);
            assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);
        }
    }

    public void assignSlotToNode(int slot, HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}
	slots.put(slot, targetPool);
    }

    public void assignSlotsToNode(List<Integer> targetSlots,
	    HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}

	for (Integer slot : targetSlots) {
	    slots.put(slot, targetPool);
=======
    public void renewSlotCache() {
	for (JedisPool jp : cache.getNodes().values()) {
	    Jedis jedis = null;
	    try {
		jedis = jp.getResource();
		cache.discoverClusterSlots(jedis);
		break;
	    } finally {
		if (jedis != null) {
		    jedis.close();
		}
	    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	    int maxRedirections) {
	super(jedisClusterNode, timeout, maxRedirections);
=======
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
    this.connectionHandler = new JedisSlotBasedConnectionHandler(
            jedisClusterNode, poolConfig);
    this.timeout = timeout;
    this.maxRedirections = maxRedirections;
    }
    
    @Override
    public void close() {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(key);
=======
    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
	MultiKeyBinaryJedisClusterCommands, JedisClusterBinaryScriptingCommands {
=======
        JedisClusterBinaryScriptingCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
=======
        JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}

    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f7995a7_a8891cb/rev_f7995a7-a8891cb/src/test/java/redis/clients/jedis/tests/PipeliningTest.java;<<<<<<< MINE
	assertTrue(result.get(1) instanceof JedisDataException);
=======
        assertEquals("val1", result.get(0));

        assertTrue(result.get(1) instanceof JedisDataException);

        Map<String, String> hashMapReceived = (Map<String, String>)result.get(2);
        Iterator<String> iterator = hashMapReceived.keySet().iterator();
        String mapKey1 = iterator.next();
        String mapKey2 = iterator.next();
        assertFalse(iterator.hasNext());
        verifyHasBothValues(mapKey1, mapKey2, field1, field2);
        String mapValue1 = hashMapReceived.get(mapKey1);
        String mapValue2 = hashMapReceived.get(mapKey2);
        verifyHasBothValues(mapValue1, mapValue2, value1, value2);

        assertTrue(result.get(3) instanceof JedisDataException);
    }
    
    @Test
    public void testSyncWithNoCommandQueued() {
	// we need to test with fresh instance of Jedis
	Jedis jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	
	Pipeline pipeline = jedis2.pipelined();
	pipeline.sync();
	
	jedis2.close();
	
	jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	
	pipeline = jedis2.pipelined();
	List<Object> resp = pipeline.syncAndReturnAll();
	assertTrue(resp.isEmpty());
	
	jedis2.close();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_318adee_e012e06/rev_318adee-e012e06/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
        StopwatchTest.class,
        FilterOptionIntegrationTest.class,
        JUnitCommandLineParserTest.class,
        FilterFactoryFactoryTest.class,
        FilterFactoryParamsTest.class,
        CategoryFilterFactoryTest.class
=======
        StopwatchTest.class,
        RunNotifierTest.class,
        ConcurrentRunNotifierTest.class,
        SynchronizedRunListenerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
		// if asking success, reset asking flag
		asking = false;
	    }

	    return execute(connection);
	} catch (JedisConnectionException jce) {
	    if (tryRandomNode) {
		// maybe all connection is down
		throw jce;
	    }

	    releaseConnection(connection, true);
	    connection = null;

	    // retry with random connection
	    return runWithRetries(key, redirections--, true, asking);
	} catch (JedisRedirectionException jre) {
	    if (jre instanceof JedisAskDataException) {
		asking = true;
	    } else if (jre instanceof JedisMovedDataException) {
		// TODO : In antirez's redis-rb-cluster implementation, 
		// it rebuilds cluster's slot and node cache
	    }

	    this.connectionHandler.assignSlotToNode(jre.getSlot(),
		    jre.getTargetNode());

	    releaseConnection(connection, false);
	    connection = null;

	    return runWithRetries(key, redirections - 1, false, asking);
	} finally {
	    releaseConnection(connection, false);
	}

    }
    
    private void releaseConnection(Jedis connection, boolean broken) {
	if (connection != null) {
	    if (broken) {
		connectionHandler.returnBrokenConnection(connection);
	    } else {
		connectionHandler.returnConnection(connection);
	    }
	}
=======
  }

  private void releaseConnection(Jedis connection, boolean broken) {
    if (connection != null) {
      if (broken) {
        connectionHandler.returnBrokenConnection(connection);
      } else {
        connectionHandler.returnConnection(connection);
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    /**
     * Create a CRC16 checksum from the bytes.
     * implementation is from mp911de/lettuce, modified with some more optimizations
     * 
     * @param bytes
     * @return CRC16 as integer value
     * @see https://github.com/xetorthio/jedis/pull/733#issuecomment-55840331
     */
    public static int getCRC16(byte[] bytes, int s, int e) {
	int crc = 0x0000;

	for (int i = s; i < e; i++) {
	    crc = ((crc << 8) ^ LOOKUP_TABLE[((crc >>> 8) ^ (bytes[i] & 0xFF)) & 0xFF]);
	}
	return crc & 0xFFFF;
=======
    for (byte b : bytes) {
      crc = ((crc << 8) ^ LOOKUP_TABLE[((crc >>> 8) ^ (b & 0xFF)) & 0xFF]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/utils/JedisClusterCRC16Test.java;<<<<<<< MINE
    @Test
    public void testGetCRC16() throws Exception {
	Map<String, Integer> solutions = prepareSolutionSet();
	
	for (Entry<String, Integer> entry : solutions.entrySet()) {
	    // string version
	    String key = entry.getKey();
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(key));
	    
	    // byte array version
	    byte[] bytesKey = SafeEncoder.encode(key);
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(bytesKey));
	}
    }
    
    @Test
    public void testGetSlot() {
	assertEquals(7186, JedisClusterCRC16.getSlot("51"));
=======
  @Test
  public void testGetCRC16() throws Exception {
    Map<String, Integer> solutions = prepareSolutionSet();

    for (Entry<String, Integer> entry : solutions.entrySet()) {
      // string version
      assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(entry.getKey()));

      // byte array version
      assertEquals(entry.getValue().intValue(),
        JedisClusterCRC16.getCRC16(SafeEncoder.encode(entry.getKey())));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
    private static Jedis node1;
    private static Jedis node2;
    private static Jedis node3;
    private static Jedis node4;

    private HostAndPort nodeInfo1 = HostAndPortUtil.getClusterServers().get(0);
    private HostAndPort nodeInfo2 = HostAndPortUtil.getClusterServers().get(1);
    private HostAndPort nodeInfo3 = HostAndPortUtil.getClusterServers().get(2);
    private HostAndPort nodeInfo4 = HostAndPortUtil.getClusterServers().get(3);
    
    @Before
    public void setUp() throws InterruptedException {
	node1 = new Jedis(nodeInfo1.getHost(), nodeInfo1.getPort());
	node1.connect();
	node1.flushAll();

	node2 = new Jedis(nodeInfo2.getHost(), nodeInfo2.getPort());
	node2.connect();
	node2.flushAll();

	node3 = new Jedis(nodeInfo3.getHost(), nodeInfo3.getPort());
	node3.connect();
	node3.flushAll();
	
	node4 = new Jedis(nodeInfo4.getHost(), nodeInfo4.getPort());
	node4.connect();
	node4.flushAll();

	// ---- configure cluster

	// add nodes to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo2.getPort());
	node1.clusterMeet("127.0.0.1", nodeInfo3.getPort());

	// split available slots across the three nodes
	int slotsPerNode = JedisCluster.HASHSLOTS / 3;
	int[] node1Slots = new int[slotsPerNode];
	int[] node2Slots = new int[slotsPerNode+1];
	int[] node3Slots = new int[slotsPerNode];
	for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0 ; i < JedisCluster.HASHSLOTS; i++) {
	    if (i < slotsPerNode) {
		node1Slots[slot1++] = i;
	    } else if (i > slotsPerNode * 2) {
		node3Slots[slot3++] = i;
	    } else {
		node2Slots[slot2++] = i;
	    }
	}
	
	node1.clusterAddSlots(node1Slots);
	node2.clusterAddSlots(node2Slots);
	node3.clusterAddSlots(node3Slots);
	
	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
    }
    
    @AfterClass
    public static void cleanUp() {
	node1.flushDB();
	node2.flushDB();
	node3.flushDB();
	node4.flushDB();
	node1.clusterReset(Reset.SOFT);
	node2.clusterReset(Reset.SOFT);
	node3.clusterReset(Reset.SOFT);
	node4.clusterReset(Reset.SOFT);
    }

    @After
    public void tearDown() throws InterruptedException {
	cleanUp();
    }

    @Test(expected = JedisMovedDataException.class)
    public void testThrowMovedException() {
	node1.set("foo", "bar");
    }

    @Test
    public void testMovedExceptionParameters() {
	try {
	    node1.set("foo", "bar");
	} catch (JedisMovedDataException jme) {
	    assertEquals(12182, jme.getSlot());
	    assertEquals(new HostAndPort("127.0.0.1", 7381),
		    jme.getTargetNode());
	    return;
	}
	fail();
    }

    @Test(expected = JedisAskDataException.class)
    public void testThrowAskException() {
	int keySlot = JedisClusterCRC16.getSlot("test");
	String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
	node2.clusterSetSlotMigrating(keySlot, node3Id);
	node2.get("test");
    }

    @Test
    public void testDiscoverNodesAutomatically() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	assertEquals(3, jc.getClusterNodes().size());
    }

    @Test
    public void testCalculateConnectionPerSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	jc.set("test", "test");
	assertEquals("bar", node3.get("foo"));
	assertEquals("test", node2.get("test"));
    }

    @Test
    public void testRecalculateSlotsWhenMoved() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node2.clusterDelSlots(slot51);
	node3.clusterDelSlots(slot51);
	node3.clusterAddSlots(slot51);

	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test
    public void testAskResponse() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisClusterMaxRedirectionsException.class)
    public void testRedisClusterMaxRedirections() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	// This will cause an infinite redirection loop
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
    }
    
    @Test
    public void testRedisHashtag() {
	assertEquals(JedisClusterCRC16.getSlot("{bar"), JedisClusterCRC16.getSlot("foo{{bar}}zap"));
	assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"), JedisClusterCRC16.getSlot("{user1000}.followers"));
	assertNotEquals(JedisClusterCRC16.getSlot("foo{}{bar}"), JedisClusterCRC16.getSlot("bar"));
	assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"), JedisClusterCRC16.getSlot("bar"));
    }

    @Test
    public void testClusterForgetNode() throws InterruptedException {
	// at first, join node4 to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo4.getPort());
	
	String node7Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());
	
	JedisClusterTestUtil.assertNodeIsKnown(node3, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node2, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node1, node7Id, 1000);
	
	assertNodeHandshakeEnded(node3, 1000);
	assertNodeHandshakeEnded(node2, 1000);
	assertNodeHandshakeEnded(node1, 1000);
	
	assertEquals(4, node1.clusterNodes().split("\n").length);
	assertEquals(4, node2.clusterNodes().split("\n").length);
	assertEquals(4, node3.clusterNodes().split("\n").length);
	
	// do cluster forget
        node1.clusterForget(node7Id);
        node2.clusterForget(node7Id);
        node3.clusterForget(node7Id);
        
        JedisClusterTestUtil.assertNodeIsUnknown(node1, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node2, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node3, node7Id, 1000);
        
        assertEquals(3, node1.clusterNodes().split("\n").length);
        assertEquals(3, node2.clusterNodes().split("\n").length);
        assertEquals(3, node3.clusterNodes().split("\n").length);
    }
    
    @Test
    public void testClusterFlushSlots() {
	String slotRange = getNodeServingSlotRange(node1.clusterNodes()); 
	assertNotNull(slotRange);
	
	try {
	    node1.clusterFlushSlots();
	    assertNull(getNodeServingSlotRange(node1.clusterNodes()));
	} finally {
	    // rollback
	    String[] rangeInfo = slotRange.split("-");
	    int lower = Integer.parseInt(rangeInfo[0]);
	    int upper = Integer.parseInt(rangeInfo[1]);
	    
	    int[] node1Slots = new int[upper - lower + 1];
	    for (int i = 0 ; lower <= upper ; ) {
		node1Slots[i++] = lower++;
	    }
	    node1.clusterAddSlots(node1Slots);
	}
    }
    
    @Test
    public void testClusterKeySlot() {
	// It assumes JedisClusterCRC16 is correctly implemented
	assertEquals(node1.clusterKeySlot("foo{bar}zap}").intValue(), JedisClusterCRC16.getSlot("foo{bar}zap"));
	assertEquals(node1.clusterKeySlot("{user1000}.following").intValue(), JedisClusterCRC16.getSlot("{user1000}.following"));
    }
    
    @Test
    public void testClusterCountKeysInSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	for (int index = 0 ; index < 5 ; index++) {
	    jc.set("foo{bar}" + index, "hello");
	}
	
	int slot = JedisClusterCRC16.getSlot("foo{bar}");
	assertEquals(5, node1.clusterCountKeysInSlot(slot).intValue());
    }
    
    @Test
    public void testStableSlotWhenMigratingNodeOrImportingNodeIsNotSpecified() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	int slot51 = JedisClusterCRC16.getSlot("51");
	jc.set("51", "foo");
	// node2 is responsible of taking care of slot51 (7186)
	
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	assertEquals("foo", jc.get("51"));
	node3.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
	
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	//assertEquals("foo", jc.get("51")); // it leads Max Redirections
	node2.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

    @Test
    public void testCloseable() throws IOException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	
	JedisCluster jc = null;
	try {
	    jc = new JedisCluster(jedisClusterNode);
	    jc.set("51", "foo");
	} finally {
	    if (jc != null) {
		jc.close();
	    }
	}

	Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
	while (poolIterator.hasNext()) {
	    JedisPool pool = poolIterator.next();
	    try {
		pool.getResource();
		fail("JedisCluster's internal pools should be already destroyed");
	    } catch (JedisConnectionException e) {
		// ok to go...
	    }
	}
    }
    
    @Test
    public void testJedisClusterRunsWithMultithreaded() throws InterruptedException, ExecutionException, IOException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	final JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	
	ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 100, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10));
	List<Future<String>> futures = new ArrayList<Future<String>>();
	for (int i = 0 ; i < 50 ; i++) {
	    executor.submit(new Callable<String>() {
		@Override
		public String call() throws Exception {
		    // FIXME : invalidate slot cache from JedisCluster to test random connection also does work
		    return jc.get("foo");
		}
	    });
	}

	for (Future<String> future : futures) {
	    String value = future.get();
	    assertEquals("bar", value);
	}
	
	jc.close();
    }
    
    private static String getNodeServingSlotRange(String infoOutput) {
	// f4f3dc4befda352a4e0beccf29f5e8828438705d 127.0.0.1:7380 master - 0 1394372400827 0 connected 5461-10922
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("myself")) {
		try {
		    return infoLine.split(" ")[8];
		} catch (ArrayIndexOutOfBoundsException e) {
		    return null;
		}
	    }
	}
	return null;
    }
    
    private void assertNodeHandshakeEnded(Jedis node, int timeoutMs) {
	int sleepInterval = 100;
	for (int sleepTime = 0 ; sleepTime <= timeoutMs ; sleepTime += sleepInterval) {
	    boolean isHandshaking = isAnyNodeHandshaking(node);
	    if (!isHandshaking)
		return;
	    
	    try {
		Thread.sleep(sleepInterval);
	    } catch (InterruptedException e) {
	    }
	}
	
	throw new JedisException("Node handshaking is not ended");
    }
    
    private boolean isAnyNodeHandshaking(Jedis node) {
	String infoOutput = node.clusterNodes();
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("handshake")) {
		return true;
	    }
	}
	return false;
=======
  private static Jedis node1;
  private static Jedis node2;
  private static Jedis node3;
  private static Jedis node4;
  private String localHost = "127.0.0.1";

  private HostAndPort nodeInfo1 = HostAndPortUtil.getClusterServers().get(0);
  private HostAndPort nodeInfo2 = HostAndPortUtil.getClusterServers().get(1);
  private HostAndPort nodeInfo3 = HostAndPortUtil.getClusterServers().get(2);
  private HostAndPort nodeInfo4 = HostAndPortUtil.getClusterServers().get(3);
  protected Logger log = Logger.getLogger(getClass().getName());

  @Before
  public void setUp() throws InterruptedException {
    node1 = new Jedis(nodeInfo1.getHost(), nodeInfo1.getPort());
    node1.connect();
    node1.flushAll();

    node2 = new Jedis(nodeInfo2.getHost(), nodeInfo2.getPort());
    node2.connect();
    node2.flushAll();

    node3 = new Jedis(nodeInfo3.getHost(), nodeInfo3.getPort());
    node3.connect();
    node3.flushAll();

    node4 = new Jedis(nodeInfo4.getHost(), nodeInfo4.getPort());
    node4.connect();
    node4.flushAll();

    // ---- configure cluster

    // add nodes to cluster
    node1.clusterMeet(localHost, nodeInfo2.getPort());
    node1.clusterMeet(localHost, nodeInfo3.getPort());

    // split available slots across the three nodes
    int slotsPerNode = JedisCluster.HASHSLOTS / 3;
    int[] node1Slots = new int[slotsPerNode];
    int[] node2Slots = new int[slotsPerNode + 1];
    int[] node3Slots = new int[slotsPerNode];
    for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0; i < JedisCluster.HASHSLOTS; i++) {
      if (i < slotsPerNode) {
        node1Slots[slot1++] = i;
      } else if (i > slotsPerNode * 2) {
        node3Slots[slot3++] = i;
      } else {
        node2Slots[slot2++] = i;
      }
    }

    node1.clusterAddSlots(node1Slots);
    node2.clusterAddSlots(node2Slots);
    node3.clusterAddSlots(node3Slots);

    JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
  }

  @AfterClass
  public static void cleanUp() {
    node1.flushDB();
    node2.flushDB();
    node3.flushDB();
    node4.flushDB();
    node1.clusterReset(Reset.SOFT);
    node2.clusterReset(Reset.SOFT);
    node3.clusterReset(Reset.SOFT);
    node4.clusterReset(Reset.SOFT);
  }

  @After
  public void tearDown() throws InterruptedException {
    cleanUp();
  }

  @Test(expected = JedisMovedDataException.class)
  public void testThrowMovedException() {
    node1.set("foo", "bar");
  }

  @Test
  public void testMovedExceptionParameters() {
    try {
      node1.set("foo", "bar");
    } catch (JedisMovedDataException jme) {
      assertEquals(12182, jme.getSlot());
      assertEquals(new HostAndPort("127.0.0.1", 7381), jme.getTargetNode());
      return;
    }
    fail();
  }

  @Test(expected = JedisAskDataException.class)
  public void testThrowAskException() {
    int keySlot = JedisClusterCRC16.getSlot("test");
    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    node2.clusterSetSlotMigrating(keySlot, node3Id);
    node2.get("test");
  }

  @Test
  public void testDiscoverNodesAutomatically() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    assertEquals(3, jc.getClusterNodes().size());
  }

  @Test
  public void testCalculateConnectionPerSlot() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.set("foo", "bar");
    jc.set("test", "test");
    assertEquals("bar", node3.get("foo"));
    assertEquals("test", node2.get("test"));
  }

  /**
   * slot->nodes 15363 node3 e
   */
  @Test
  public void testMigrate() {
    log.info("test migrate slot");
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(nodeInfo1);
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    String node2Id = JedisClusterTestUtil.getNodeId(node2.clusterNodes());
    node3.clusterSetSlotMigrating(15363, node2Id);
    node2.clusterSetSlotImporting(15363, node3Id);
    try {
      node2.set("e", "e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }

    try {
      node3.set("e", "e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo2.getPort()), jae.getTargetNode());
    }

    jc.set("e", "e");

    try {
      node2.get("e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }
    try {
      node3.get("e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo2.getPort()), jae.getTargetNode());
    }

    assertEquals("e", jc.get("e"));

    node2.clusterSetSlotNode(15363, node2Id);
    node3.clusterSetSlotNode(15363, node2Id);
    // assertEquals("e", jc.get("e"));
    assertEquals("e", node2.get("e"));

    // assertEquals("e", node3.get("e"));

  }

  @Test
  public void testMigrateToNewNode() throws InterruptedException {
    log.info("test migrate slot to new node");
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(nodeInfo1);
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    node4.clusterMeet(localHost, nodeInfo1.getPort());

    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    String node4Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());
    JedisClusterTestUtil.waitForClusterReady(node4);
    node3.clusterSetSlotMigrating(15363, node4Id);
    node4.clusterSetSlotImporting(15363, node3Id);
    try {
      node4.set("e", "e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }

    try {
      node3.set("e", "e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo4.getPort()), jae.getTargetNode());
    }

    jc.set("e", "e");

    try {
      node4.get("e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }
    try {
      node3.get("e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo4.getPort()), jae.getTargetNode());
    }

    assertEquals("e", jc.get("e"));

    node4.clusterSetSlotNode(15363, node4Id);
    node3.clusterSetSlotNode(15363, node4Id);
    // assertEquals("e", jc.get("e"));
    assertEquals("e", node4.get("e"));

    // assertEquals("e", node3.get("e"));

  }

  @Test
  public void testRecalculateSlotsWhenMoved() throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    node2.clusterDelSlots(slot51);
    node3.clusterDelSlots(slot51);
    node3.clusterAddSlots(slot51);

    JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
    jc.set("51", "foo");
    assertEquals("foo", jc.get("51"));
  }

  @Test
  public void testAskResponse() throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    jc.set("51", "foo");
    assertEquals("foo", jc.get("51"));
  }

  @Test(expected = JedisClusterException.class)
  public void testThrowExceptionWithoutKey() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.ping();
  }

  @Test(expected = JedisClusterMaxRedirectionsException.class)
  public void testRedisClusterMaxRedirections() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    // This will cause an infinite redirection loop
    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    jc.set("51", "foo");
  }

  @Test
  public void testRedisHashtag() {
    assertEquals(JedisClusterCRC16.getSlot("{bar"), JedisClusterCRC16.getSlot("foo{{bar}}zap"));
    assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"),
      JedisClusterCRC16.getSlot("{user1000}.followers"));
    assertNotEquals(JedisClusterCRC16.getSlot("foo{}{bar}"), JedisClusterCRC16.getSlot("bar"));
    assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"), JedisClusterCRC16.getSlot("bar"));
  }

  @Test
  public void testClusterForgetNode() throws InterruptedException {
    // at first, join node4 to cluster
    node1.clusterMeet("127.0.0.1", nodeInfo4.getPort());

    String node7Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());

    JedisClusterTestUtil.assertNodeIsKnown(node3, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsKnown(node2, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsKnown(node1, node7Id, 1000);

    assertNodeHandshakeEnded(node3, 1000);
    assertNodeHandshakeEnded(node2, 1000);
    assertNodeHandshakeEnded(node1, 1000);

    assertEquals(4, node1.clusterNodes().split("\n").length);
    assertEquals(4, node2.clusterNodes().split("\n").length);
    assertEquals(4, node3.clusterNodes().split("\n").length);

    // do cluster forget
    node1.clusterForget(node7Id);
    node2.clusterForget(node7Id);
    node3.clusterForget(node7Id);

    JedisClusterTestUtil.assertNodeIsUnknown(node1, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsUnknown(node2, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsUnknown(node3, node7Id, 1000);

    assertEquals(3, node1.clusterNodes().split("\n").length);
    assertEquals(3, node2.clusterNodes().split("\n").length);
    assertEquals(3, node3.clusterNodes().split("\n").length);
  }

  @Test
  public void testClusterFlushSlots() {
    String slotRange = getNodeServingSlotRange(node1.clusterNodes());
    assertNotNull(slotRange);

    try {
      node1.clusterFlushSlots();
      assertNull(getNodeServingSlotRange(node1.clusterNodes()));
    } finally {
      // rollback
      String[] rangeInfo = slotRange.split("-");
      int lower = Integer.parseInt(rangeInfo[0]);
      int upper = Integer.parseInt(rangeInfo[1]);

      int[] node1Slots = new int[upper - lower + 1];
      for (int i = 0; lower <= upper;) {
        node1Slots[i++] = lower++;
      }
      node1.clusterAddSlots(node1Slots);
    }
  }

  @Test
  public void testClusterKeySlot() {
    // It assumes JedisClusterCRC16 is correctly implemented
    assertEquals(node1.clusterKeySlot("foo{bar}zap}").intValue(),
      JedisClusterCRC16.getSlot("foo{bar}zap"));
    assertEquals(node1.clusterKeySlot("{user1000}.following").intValue(),
      JedisClusterCRC16.getSlot("{user1000}.following"));
  }

  @Test
  public void testClusterCountKeysInSlot() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
    JedisCluster jc = new JedisCluster(jedisClusterNode);

    for (int index = 0; index < 5; index++) {
      jc.set("foo{bar}" + index, "hello");
    }

    int slot = JedisClusterCRC16.getSlot("foo{bar}");
    assertEquals(5, node1.clusterCountKeysInSlot(slot).intValue());
  }

  @Test
  public void testStableSlotWhenMigratingNodeOrImportingNodeIsNotSpecified()
      throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
    JedisCluster jc = new JedisCluster(jedisClusterNode);

    int slot51 = JedisClusterCRC16.getSlot("51");
    jc.set("51", "foo");
    // node2 is responsible of taking care of slot51 (7186)

    node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
    assertEquals("foo", jc.get("51"));
    node3.clusterSetSlotStable(slot51);
    assertEquals("foo", jc.get("51"));

    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    // assertEquals("foo", jc.get("51")); // it leads Max Redirections
    node2.clusterSetSlotStable(slot51);
    assertEquals("foo", jc.get("51"));
  }

  @Test(expected = JedisConnectionException.class)
  public void testIfPoolConfigAppliesToClusterPools() {
    GenericObjectPoolConfig config = new GenericObjectPoolConfig();
    config.setMaxTotal(0);
    config.setMaxWaitMillis(2000);
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode, config);
    jc.set("52", "poolTestValue");
  }

  @Test
  public void testCloseable() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));

    JedisCluster jc = null;
    try {
      jc = new JedisCluster(jedisClusterNode);
      jc.set("51", "foo");
    } finally {
      if (jc != null) {
        jc.close();
      }
    }

    Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
    while (poolIterator.hasNext()) {
      JedisPool pool = poolIterator.next();
      try {
        pool.getResource();
        fail("JedisCluster's internal pools should be already destroyed");
      } catch (JedisConnectionException e) {
        // ok to go...
      }
    }
  }

  @Test
  public void testJedisClusterRunsWithMultithreaded() throws InterruptedException,
      ExecutionException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    final JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.set("foo", "bar");

    ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 100, 0, TimeUnit.SECONDS,
        new ArrayBlockingQueue<Runnable>(10));
    List<Future<String>> futures = new ArrayList<Future<String>>();
    for (int i = 0; i < 50; i++) {
      executor.submit(new Callable<String>() {
        @Override
        public String call() throws Exception {
          // FIXME : invalidate slot cache from JedisCluster to test
          // random connection also does work
          return jc.get("foo");
        }
      });
    }

    for (Future<String> future : futures) {
      String value = future.get();
      assertEquals("bar", value);
    }

    jc.close();
  }

  private static String getNodeServingSlotRange(String infoOutput) {
    // f4f3dc4befda352a4e0beccf29f5e8828438705d 127.0.0.1:7380 master - 0
    // 1394372400827 0 connected 5461-10922
    for (String infoLine : infoOutput.split("\n")) {
      if (infoLine.contains("myself")) {
        try {
          return infoLine.split(" ")[8];
        } catch (ArrayIndexOutOfBoundsException e) {
          return null;
        }
      }
    }
    return null;
  }

  private void assertNodeHandshakeEnded(Jedis node, int timeoutMs) {
    int sleepInterval = 100;
    for (int sleepTime = 0; sleepTime <= timeoutMs; sleepTime += sleepInterval) {
      boolean isHandshaking = isAnyNodeHandshaking(node);
      if (!isHandshaking) return;

      try {
        Thread.sleep(sleepInterval);
      } catch (InterruptedException e) {
      }
    }

    throw new JedisException("Node handshaking is not ended");
  }

  private boolean isAnyNodeHandshaking(Jedis node) {
    String infoOutput = node.clusterNodes();
    for (String infoLine : infoOutput.split("\n")) {
      if (infoLine.contains("handshake")) {
        return true;
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    public static int getSlot(byte[] key) {
        int s = -1;
        int e = -1;
        boolean sFound = false;
        for (int i = 0; i < key.length; i++) {
            if (key[i] == '{' && !sFound) {
                s = i;
                sFound = true;
            }
            if (key[i] == '}' && sFound) {
                e = i;
                break;
            }
        }
        if (s > -1 && e > -1 && e != s + 1) {
            return getCRC16(key, s+1, e) & (16384 - 1);
        }
        return getCRC16(key) & (16384 - 1);
    }
=======
    // optimization with modulo operator with power of 2
    // equivalent to getCRC16(key) % 16384
    return getCRC16(key) & (16384 - 1);
  }

  /**
   * Create a CRC16 checksum from the bytes. implementation is from mp911de/lettuce, modified with
   * some more optimizations
   * @param bytes
   * @return CRC16 as integer value
   * @see https://github.com/xetorthio/jedis/pull/733#issuecomment-55840331
   */
  public static int getCRC16(byte[] bytes) {
    int crc = 0x0000;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    public static int getCRC16(byte[] bytes) {
	return getCRC16(bytes, 0, bytes.length);
    }
=======
    return crc & 0xFFFF;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
    jedisTransaction.execute();
    results = jedisTransaction.exec();
	return results;
    }

    protected void checkIsInMulti() {
	if (client.isInMulti()) {
	    throw new JedisDataException(
		    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
	}
    }

    public void connect() {
	client.connect();
    }

    public void disconnect() {
	client.disconnect();
    }

    public void resetState() {
	client.resetState();
	client.getAll();
    }

    public String watch(final byte[]... keys) {
	client.watch(keys);
	return client.getStatusCodeReply();
    }

    public String unwatch() {
	client.unwatch();
	return client.getStatusCodeReply();
    }

    @Override
	public void close() {
	client.close();
    }

    /**
     * Sort a Set or a List.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key.
     * By default sorting is numeric with elements being compared as double
     * precision floating point numbers. This is the simplest form of SORT.
     * 
     * @see #sort(byte[], byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * 
     * @param key
     * @return Assuming the Set/List at key contains a list of numbers, the
     *         return value will be the list of numbers ordered from the
     *         smallest to the biggest number.
     */
    public List<byte[]> sort(final byte[] key) {
	checkIsInMulti();
	client.sort(key);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters.
     * <p>
     * <b>examples:</b>
     * <p>
     * Given are the following sets and key/values:
     * 
     * <pre>
     * x = [1, 2, 3]
     * y = [a, b, c]
     * 
     * k1 = z
     * k2 = y
     * k3 = x
     * 
     * w1 = 9
     * w2 = 8
     * w3 = 7
     * </pre>
     * 
     * Sort Order:
     * 
     * <pre>
     * sort(x) or sort(x, sp.asc())
     * -> [1, 2, 3]
     * 
     * sort(x, sp.desc())
     * -> [3, 2, 1]
     * 
     * sort(y)
     * -> [c, a, b]
     * 
     * sort(y, sp.alpha())
     * -> [a, b, c]
     * 
     * sort(y, sp.alpha().desc())
     * -> [c, a, b]
     * </pre>
     * 
     * Limit (e.g. for Pagination):
     * 
     * <pre>
     * sort(x, sp.limit(0, 2))
     * -> [1, 2]
     * 
     * sort(y, sp.alpha().desc().limit(1, 2))
     * -> [b, a]
     * </pre>
     * 
     * Sorting by external keys:
     * 
     * <pre>
     * sort(x, sb.by(w*))
     * -> [3, 2, 1]
     * 
     * sort(x, sb.by(w*).desc())
     * -> [1, 2, 3]
     * </pre>
     * 
     * Getting external keys:
     * 
     * <pre>
     * sort(x, sp.by(w*).get(k*))
     * -> [x, y, z]
     * 
     * sort(x, sp.by(w*).get(#).get(k*))
     * -> [3, x, 2, y, 1, z]
     * </pre>
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param sortingParameters
     * @return a list of sorted elements.
     */
    public List<byte[]> sort(final byte[] key,
	    final SortingParams sortingParameters) {
	checkIsInMulti();
	client.sort(key, sortingParameters);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #brpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.blpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters and store
     * the result at dstkey.
     * 
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[])
     * @see #sort(byte[], byte[])
     * 
     * @param key
     * @param sortingParameters
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, sortingParameters, dstkey);
	return client.getIntegerReply();
    }

    /**
     * Sort a Set or a List and Store the Result at dstkey.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key
     * and store the result at dstkey. By default sorting is numeric with
     * elements being compared as double precision floating point numbers. This
     * is the simplest form of SORT.
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, dstkey);
	return client.getIntegerReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #blpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.brpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();

	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[]... args) {
	checkIsInMulti();
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[]... args) {
	checkIsInMulti();
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(final String password) {
	checkIsInMulti();
	client.auth(password);
	return client.getStatusCodeReply();
    }

    @Deprecated
    /**
     * This method is deprecated due to its error prone with multi
     * and will be removed on next major release
     * You can use pipelined() instead
     * @see https://github.com/xetorthio/jedis/pull/498
     */
    public List<Object> pipelined(final PipelineBlock jedisPipeline) {
	jedisPipeline.setClient(client);
	jedisPipeline.execute();
	return jedisPipeline.syncAndReturnAll();
    }

    public Pipeline pipelined() {
	Pipeline pipeline = new Pipeline();
	pipeline.setClient(client);
	return pipeline;
    }

    public Long zcount(final byte[] key, final double min, final double max) {
	return zcount(key, toByteArray(min), toByteArray(max));
    }

    public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zcount(key, min, max);
	return client.getIntegerReply();
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max, final int offset, final int count) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max), offset,
		count);
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max, final int offset, final int count) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max, final int offset,
	    final int count) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max),
		offset, count);
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    private Set<Tuple> getBinaryTupledSet() {
	checkIsInMulti();
	List<byte[]> membersWithScores = client.getBinaryMultiBulkReply();
	Set<Tuple> set = new LinkedHashSet<Tuple>();
	Iterator<byte[]> iterator = membersWithScores.iterator();
	while (iterator.hasNext()) {
	    set.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder
		    .encode(iterator.next()))));
	}
	return set;
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min));
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min, final int offset, final int count) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min),
		offset, count);
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min, final int offset, final int count) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min));
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min, final int offset,
	    final int count) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min), offset, count);
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Remove all elements in the sorted set at key with rank between start and
     * end. Start and end are 0-based with rank 0 being the element with the
     * lowest score. Both start and end can be negative numbers, where they
     * indicate offsets starting at the element with the highest rank. For
     * example: -1 is the element with the highest score, -2 the element with
     * the second highest score and so forth.
     * <p>
     * <b>Time complexity:</b> O(log(N))+O(M) with N being the number of
     * elements in the sorted set and M the number of elements removed by the
     * operation
     * 
     */
    public Long zremrangeByRank(final byte[] key, final long start,
	    final long end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Remove all the elements in the sorted set at key with a score between min
     * and max (including elements with score equal to min or max).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements removed by the operation
     * 
     * @param key
     * @param start
     * @param end
     * @return Integer reply, specifically the number of elements removed.
     */
    public Long zremrangeByScore(final byte[] key, final double start,
	    final double end) {
	return zremrangeByScore(key, toByteArray(start), toByteArray(end));
    }

    public Long zremrangeByScore(final byte[] key, final byte[] start,
	    final byte[] end) {
	checkIsInMulti();
	client.zremrangeByScore(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk.
     * <p>
     * Save the whole dataset on disk (this means that all the databases are
     * saved, as well as keys with an EXPIRE set (the expire is preserved). The
     * server hangs while the saving is not completed, no connection is served
     * in the meanwhile. An OK code is returned when the DB was fully stored in
     * disk.
     * <p>
     * The background variant of this command is {@link #bgsave() BGSAVE} that
     * is able to perform the saving in the background while the server
     * continues serving other clients.
     * <p>
     * 
     * @return Status code reply
     */
    public String save() {
	client.save();
	return client.getStatusCodeReply();
    }

    /**
     * Asynchronously save the DB on disk.
     * <p>
     * Save the DB in background. The OK code is immediately returned. Redis
     * forks, the parent continues to server the clients, the child saves the DB
     * on disk then exit. A client my be able to check if the operation
     * succeeded using the LASTSAVE command.
     * 
     * @return Status code reply
     */
    public String bgsave() {
	client.bgsave();
	return client.getStatusCodeReply();
    }

    /**
     * Rewrite the append only file in background when it gets too big. Please
     * for detailed information about the Redis Append Only File check the <a
     * href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append
     * Only File Howto</a>.
     * <p>
     * BGREWRITEAOF rewrites the Append Only File in background when it gets too
     * big. The Redis Append Only File is a Journal, so every operation
     * modifying the dataset is logged in the Append Only File (and replayed at
     * startup). This means that the Append Only File always grows. In order to
     * rebuild its content the BGREWRITEAOF creates a new version of the append
     * only file starting directly form the dataset in memory in order to
     * guarantee the generation of the minimal number of commands needed to
     * rebuild the database.
     * <p>
     * 
     * @return Status code reply
     */
    public String bgrewriteaof() {
	client.bgrewriteaof();
	return client.getStatusCodeReply();
    }

    /**
     * Return the UNIX time stamp of the last successfully saving of the dataset
     * on disk.
     * <p>
     * Return the UNIX TIME of the last DB save executed with success. A client
     * may check if a {@link #bgsave() BGSAVE} command succeeded reading the
     * LASTSAVE value, then issuing a BGSAVE command and checking at regular
     * intervals every N seconds if LASTSAVE changed.
     * 
     * @return Integer reply, specifically an UNIX time stamp.
     */
    public Long lastsave() {
	client.lastsave();
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk, then shutdown the server.
     * <p>
     * Stop all the clients, save the DB, then quit the server. This commands
     * makes sure that the DB is switched off without the lost of any data. This
     * is not guaranteed if the client uses simply {@link #save() SAVE} and then
     * {@link #quit() QUIT} because other clients may alter the DB data between
     * the two commands.
     * 
     * @return Status code reply on error. On success nothing is returned since
     *         the server quits and the connection is closed.
     */
    public String shutdown() {
	client.shutdown();
	String status = null;
	try {
	    status = client.getStatusCodeReply();
	} catch (JedisException ex) {
	    status = null;
	}
	return status;
    }

    /**
     * Provide information and statistics about the server.
     * <p>
     * The info command returns different information and statistics about the
     * server in an format that's simple to parse by computers and easy to read
     * by humans.
     * <p>
     * <b>Format of the returned String:</b>
     * <p>
     * All the fields are in the form field:value
     * 
     * <pre>
     * edis_version:0.07
     * connected_clients:1
     * connected_slaves:0
     * used_memory:3187
     * changes_since_last_save:0
     * last_save_time:1237655729
     * total_connections_received:1
     * total_commands_processed:1
     * uptime_in_seconds:25
     * uptime_in_days:0
     * </pre>
     * 
     * <b>Notes</b>
     * <p>
     * used_memory is returned in bytes, and is the total number of bytes
     * allocated by the program using malloc.
     * <p>
     * uptime_in_days is redundant since the uptime in seconds contains already
     * the full uptime information, this field is only mainly present for
     * humans.
     * <p>
     * changes_since_last_save does not refer to the number of key changes, but
     * to the number of operations that produced some kind of change in the
     * dataset.
     * <p>
     * 
     * @return Bulk reply
     */
    public String info() {
	client.info();
	return client.getBulkReply();
    }

    public String info(final String section) {
	client.info(section);
	return client.getBulkReply();
    }

    /**
     * Dump all the received requests in real time.
     * <p>
     * MONITOR is a debugging command that outputs the whole sequence of
     * commands received by the Redis server. is very handy in order to
     * understand what is happening into the database. This command is used
     * directly via telnet.
     * 
     * @param jedisMonitor
     */
    public void monitor(final JedisMonitor jedisMonitor) {
	client.monitor();
	client.getStatusCodeReply();
	jedisMonitor.proceed(client);
    }

    /**
     * Change the replication settings.
     * <p>
     * The SLAVEOF command can change the replication settings of a slave on the
     * fly. If a Redis server is arleady acting as slave, the command SLAVEOF NO
     * ONE will turn off the replicaiton turning the Redis server into a MASTER.
     * In the proper form SLAVEOF hostname port will make the server a slave of
     * the specific server listening at the specified hostname and port.
     * <p>
     * If a server is already a slave of some master, SLAVEOF hostname port will
     * stop the replication against the old server and start the
     * synchrnonization against the new one discarding the old dataset.
     * <p>
     * The form SLAVEOF no one will stop replication turning the server into a
     * MASTER but will not discard the replication. So if the old master stop
     * working it is possible to turn the slave into a master and set the
     * application to use the new master in read/write. Later when the other
     * Redis server will be fixed it can be configured in order to work as
     * slave.
     * <p>
     * 
     * @param host
     * @param port
     * @return Status code reply
     */
    public String slaveof(final String host, final int port) {
	client.slaveof(host, port);
	return client.getStatusCodeReply();
    }

    public String slaveofNoOne() {
	client.slaveofNoOne();
	return client.getStatusCodeReply();
    }

    /**
     * Retrieve the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * CONFIG GET returns the current configuration parameters. This sub command
     * only accepts a single argument, that is glob style pattern. All the
     * configuration parameters matching this parameter are reported as a list
     * of key-value pairs.
     * <p>
     * <b>Example:</b>
     * 
     * <pre>
     * $ redis-cli config get '*'
     * 1. "dbfilename"
     * 2. "dump.rdb"
     * 3. "requirepass"
     * 4. (nil)
     * 5. "masterauth"
     * 6. (nil)
     * 7. "maxmemory"
     * 8. "0\n"
     * 9. "appendfsync"
     * 10. "everysec"
     * 11. "save"
     * 12. "3600 1 300 100 60 10000"
     * 
     * $ redis-cli config get 'm*'
     * 1. "masterauth"
     * 2. (nil)
     * 3. "maxmemory"
     * 4. "0\n"
     * </pre>
     * 
     * @param pattern
     * @return Bulk reply.
     */
    public List<byte[]> configGet(final byte[] pattern) {
	client.configGet(pattern);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Reset the stats returned by INFO
     * 
     * @return
     */
    public String configResetStat() {
	client.configResetStat();
	return client.getStatusCodeReply();
    }

    /**
     * Alter the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * The list of configuration parameters supported by CONFIG SET can be
     * obtained issuing a {@link #configGet(String) CONFIG GET *} command.
     * <p>
     * The configuration set using CONFIG SET is immediately loaded by the Redis
     * server that will start acting as specified starting from the next
     * command.
     * <p>
     * 
     * <b>Parameters value format</b>
     * <p>
     * The value of the configuration parameter is the same as the one of the
     * same parameter in the Redis configuration file, with the following
     * exceptions:
     * <p>
     * <ul>
     * <li>The save paramter is a list of space-separated integers. Every pair
     * of integers specify the time and number of changes limit to trigger a
     * save. For instance the command CONFIG SET save "3600 10 60 10000" will
     * configure the server to issue a background saving of the RDB file every
     * 3600 seconds if there are at least 10 changes in the dataset, and every
     * 60 seconds if there are at least 10000 changes. To completely disable
     * automatic snapshots just set the parameter as an empty string.
     * <li>All the integer parameters representing memory are returned and
     * accepted only using bytes as unit.
     * </ul>
     * 
     * @param parameter
     * @param value
     * @return Status code reply
     */
    public byte[] configSet(final byte[] parameter, final byte[] value) {
	client.configSet(parameter, value);
	return client.getBinaryBulkReply();
    }

    public boolean isConnected() {
	return client.isConnected();
    }

    public Long strlen(final byte[] key) {
	client.strlen(key);
	return client.getIntegerReply();
    }

    public void sync() {
	client.sync();
    }

    public Long lpushx(final byte[] key, final byte[]... string) {
	client.lpushx(key, string);
	return client.getIntegerReply();
    }

    /**
     * Undo a {@link #expire(byte[], int) expire} at turning the expire key into
     * a normal key.
     * <p>
     * Time complexity: O(1)
     * 
     * @param key
     * @return Integer reply, specifically: 1: the key is now persist. 0: the
     *         key is not persist (only happens when key not set).
     */
    public Long persist(final byte[] key) {
	client.persist(key);
	return client.getIntegerReply();
    }

    public Long rpushx(final byte[] key, final byte[]... string) {
	client.rpushx(key, string);
	return client.getIntegerReply();
    }

    public byte[] echo(final byte[] string) {
	client.echo(string);
	return client.getBinaryBulkReply();
    }

    public Long linsert(final byte[] key, final LIST_POSITION where,
	    final byte[] pivot, final byte[] value) {
	client.linsert(key, where, pivot, value);
	return client.getIntegerReply();
    }

    public String debug(final DebugParams params) {
	client.debug(params);
	return client.getStatusCodeReply();
    }

    public Client getClient() {
	return client;
    }

    /**
     * Pop a value from a list, push it to another list and return it; or block
     * until one is available
     * 
     * @param source
     * @param destination
     * @param timeout
     * @return the element
     */
    public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
	client.brpoplpush(source, destination, timeout);
	client.setTimeoutInfinite();
	byte[] reply = client.getBinaryBulkReply();
	client.rollbackTimeout();
	return reply;
    }

    /**
     * Sets or clears the bit at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @param value
     * @return
     */
    public Boolean setbit(byte[] key, long offset, boolean value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    public Boolean setbit(byte[] key, long offset, byte[] value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    /**
     * Returns the bit value at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @return
     */
    public Boolean getbit(byte[] key, long offset) {
	client.getbit(key, offset);
	return client.getIntegerReply() == 1;
    }

    public Long setrange(byte[] key, long offset, byte[] value) {
	client.setrange(key, offset, value);
	return client.getIntegerReply();
    }

    public byte[] getrange(byte[] key, long startOffset, long endOffset) {
	client.getrange(key, startOffset, endOffset);
	return client.getBinaryBulkReply();
    }

    public Long publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return client.getIntegerReply();
    }

    public void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels) {
	client.setTimeoutInfinite();
	jedisPubSub.proceed(client, channels);
	client.rollbackTimeout();
    }

    public void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns) {
	client.setTimeoutInfinite();
	jedisPubSub.proceedWithPatterns(client, patterns);
	client.rollbackTimeout();
    }

    public Long getDB() {
	return client.getDB();
    }

    /**
     * Evaluates scripts using the Lua interpreter built into Redis starting
     * from version 2.6.0.
     * <p>
     * 
     * @return Script result
     */
    public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	client.setTimeoutInfinite();
	client.eval(script, toByteArray(keys.size()), getParamsWithBinary(keys, args));
	return client.getOne();
    }

    protected static byte[][] getParamsWithBinary(List<byte[]> keys, List<byte[]> args) {
	int keyCount = keys.size();
	int argCount = args.size();
	byte[][] params = new byte[keyCount + args.size()][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return params;
    }

    public Object eval(byte[] script, byte[] keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, keyCount, params);
	return client.getOne();
    }

    public Object eval(byte[] script, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, SafeEncoder.encode(Integer.toString(keyCount)),
		params);
	return client.getOne();
    }

    public Object eval(byte[] script) {
	client.setTimeoutInfinite();
	client.eval(script, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {

	int keyCount = keys == null ? 0 : keys.size();
	int argCount = args == null ? 0 : args.size();

	byte[][] params = new byte[keyCount + argCount][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return evalsha(sha1, keyCount, params);
    }

    public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, keyCount, params);
	return client.getOne();
    }

    public String scriptFlush() {
	client.scriptFlush();
	return client.getStatusCodeReply();
    }

    public Long scriptExists(byte[] sha1) {
	byte[][] a = new byte[1][];
	a[0] = sha1;
	return scriptExists(a).get(0);
    }
    
    public List<Long> scriptExists(byte[]... sha1) {
	client.scriptExists(sha1);
	return client.getIntegerMultiBulkReply();
    }

    public byte[] scriptLoad(byte[] script) {
	client.scriptLoad(script);
	return client.getBinaryBulkReply();
    }

    public String scriptKill() {
	client.scriptKill();
	return client.getStatusCodeReply();
    }

    public String slowlogReset() {
	client.slowlogReset();
	return client.getBulkReply();
    }

    public Long slowlogLen() {
	client.slowlogLen();
	return client.getIntegerReply();
    }

    public List<byte[]> slowlogGetBinary() {
	client.slowlogGet();
	return client.getBinaryMultiBulkReply();
    }

    public List<byte[]> slowlogGetBinary(long entries) {
	client.slowlogGet(entries);
	return client.getBinaryMultiBulkReply();
    }

    public Long objectRefcount(byte[] key) {
	client.objectRefcount(key);
	return client.getIntegerReply();
    }

    public byte[] objectEncoding(byte[] key) {
	client.objectEncoding(key);
	return client.getBinaryBulkReply();
    }

    public Long objectIdletime(byte[] key) {
	client.objectIdletime(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key) {
	client.bitcount(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key, long start, long end) {
	client.bitcount(key, start, end);
	return client.getIntegerReply();
    }

    public Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return client.getIntegerReply();
    }

    public byte[] dump(final byte[] key) {
	checkIsInMulti();
	client.dump(key);
	return client.getBinaryBulkReply();
    }

    public String restore(final byte[] key, final int ttl,
	    final byte[] serializedValue) {
	checkIsInMulti();
	client.restore(key, ttl, serializedValue);
	return client.getStatusCodeReply();
    }

    public Long pexpire(final byte[] key, final int milliseconds) {
	checkIsInMulti();
	client.pexpire(key, milliseconds);
	return client.getIntegerReply();
    }

    public Long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
	checkIsInMulti();
	client.pexpireAt(key, millisecondsTimestamp);
	return client.getIntegerReply();
    }

    public Long pttl(final byte[] key) {
	checkIsInMulti();
	client.pttl(key);
	return client.getIntegerReply();
    }

    public Double incrByFloat(final byte[] key, final double increment) {
	checkIsInMulti();
	client.incrByFloat(key, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    public String psetex(final byte[] key, final int milliseconds,
	    final byte[] value) {
	checkIsInMulti();
	client.psetex(key, milliseconds, value);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
	checkIsInMulti();
	client.set(key, value, nxxx);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx,
	    final byte[] expx, final int time) {
	checkIsInMulti();
	client.set(key, value, nxxx, expx, time);
	return client.getStatusCodeReply();
    }

    public String clientKill(final byte[] client) {
	checkIsInMulti();
	this.client.clientKill(client);
	return this.client.getStatusCodeReply();
    }

    public String clientGetname() {
	checkIsInMulti();
	client.clientGetname();
	return client.getBulkReply();
    }

    public String clientList() {
	checkIsInMulti();
	client.clientList();
	return client.getBulkReply();
    }

    public String clientSetname(final byte[] name) {
	checkIsInMulti();
	client.clientSetname(name);
	return client.getBulkReply();
    }

    public List<String> time() {
	checkIsInMulti();
	client.time();
	return client.getMultiBulkReply();
    }

    public String migrate(final byte[] host, final int port, final byte[] key,
	    final int destinationDb, final int timeout) {
	checkIsInMulti();
	client.migrate(host, port, key, destinationDb, timeout);
	return client.getStatusCodeReply();
    }

    public Double hincrByFloat(final byte[] key, final byte[] field,
	    double increment) {
	checkIsInMulti();
	client.hincrByFloat(key, field, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    /**
     * Syncrhonous replication of Redis as described here:
     * http://antirez.com/news/66
     * 
     * Since Java Object class has implemented "wait" method, we cannot use it,
     * so I had to change the name of the method. Sorry :S
     */
    public Long waitReplicas(int replicas, long timeout) {
	checkIsInMulti();
	client.waitReplicas(replicas, timeout);
	return client.getIntegerReply();
=======
    client.getOne(); // expected OK
    transaction = new Transaction(client);
    return transaction;
  }

  protected void checkIsInMulti() {
    if (client.isInMulti()) {
      throw new JedisDataException(
          "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
    }
  }

  public void connect() {
    client.connect();
  }

  public void disconnect() {
    client.disconnect();
  }

  public void resetState() {
    if (client.isConnected()) {
      if (transaction != null) {
        transaction.clear();
      }

      if (pipeline != null) {
        pipeline.clear();
      }

      if (client.isInWatch()) {
        unwatch();
      }

      client.resetState();
    }

    transaction = null;
    pipeline = null;
  }

  public String watch(final byte[]... keys) {
    client.watch(keys);
    return client.getStatusCodeReply();
  }

  public String unwatch() {
    client.unwatch();
    return client.getStatusCodeReply();
  }

  @Override
  public void close() {
    client.close();
  }

  /**
   * Sort a Set or a List.
   * <p>
   * Sort the elements contained in the List, Set, or Sorted Set value at key. By default sorting is
   * numeric with elements being compared as double precision floating point numbers. This is the
   * simplest form of SORT.
   * @see #sort(byte[], byte[])
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @return Assuming the Set/List at key contains a list of numbers, the return value will be the
   *         list of numbers ordered from the smallest to the biggest number.
   */
  public List<byte[]> sort(final byte[] key) {
    checkIsInMulti();
    client.sort(key);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * Sort a Set or a List accordingly to the specified parameters.
   * <p>
   * <b>examples:</b>
   * <p>
   * Given are the following sets and key/values:
   * 
   * <pre>
   * x = [1, 2, 3]
   * y = [a, b, c]
   * 
   * k1 = z
   * k2 = y
   * k3 = x
   * 
   * w1 = 9
   * w2 = 8
   * w3 = 7
   * </pre>
   * 
   * Sort Order:
   * 
   * <pre>
   * sort(x) or sort(x, sp.asc())
   * -> [1, 2, 3]
   * 
   * sort(x, sp.desc())
   * -> [3, 2, 1]
   * 
   * sort(y)
   * -> [c, a, b]
   * 
   * sort(y, sp.alpha())
   * -> [a, b, c]
   * 
   * sort(y, sp.alpha().desc())
   * -> [c, a, b]
   * </pre>
   * 
   * Limit (e.g. for Pagination):
   * 
   * <pre>
   * sort(x, sp.limit(0, 2))
   * -> [1, 2]
   * 
   * sort(y, sp.alpha().desc().limit(1, 2))
   * -> [b, a]
   * </pre>
   * 
   * Sorting by external keys:
   * 
   * <pre>
   * sort(x, sb.by(w*))
   * -> [3, 2, 1]
   * 
   * sort(x, sb.by(w*).desc())
   * -> [1, 2, 3]
   * </pre>
   * 
   * Getting external keys:
   * 
   * <pre>
   * sort(x, sp.by(w*).get(k*))
   * -> [x, y, z]
   * 
   * sort(x, sp.by(w*).get(#).get(k*))
   * -> [3, x, 2, y, 1, z]
   * </pre>
   * @see #sort(byte[])
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @param sortingParameters
   * @return a list of sorted elements.
   */
  public List<byte[]> sort(final byte[] key, final SortingParams sortingParameters) {
    checkIsInMulti();
    client.sort(key, sortingParameters);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this commands as blocking
   * versions of LPOP and RPOP able to block if the specified keys don't exist or contain empty
   * lists.
   * <p>
   * The following is a description of the exact semantic. We describe BLPOP but the two commands
   * are identical, the only difference is that BLPOP pops the element from the left (head) of the
   * list, and BRPOP pops from the right (tail).
   * <p>
   * <b>Non blocking behavior</b>
   * <p>
   * When BLPOP is called, if at least one of the specified keys contain a non empty list, an
   * element is popped from the head of the list and returned to the caller together with the name
   * of the key (BLPOP returns a two elements array, the first element is the key, the second the
   * popped value).
   * <p>
   * Keys are scanned from left to right, so for instance if you issue BLPOP list1 list2 list3 0
   * against a dataset where list1 does not exist but list2 and list3 contain non empty lists, BLPOP
   * guarantees to return an element from the list stored at list2 (since it is the first non empty
   * list starting from the left).
   * <p>
   * <b>Blocking behavior</b>
   * <p>
   * If none of the specified keys exist or contain non empty lists, BLPOP blocks until some other
   * client performs a LPUSH or an RPUSH operation against one of the lists.
   * <p>
   * Once new data is present on one of the lists, the client finally returns with the name of the
   * key unblocking it and the popped value.
   * <p>
   * When blocking, if a non-zero timeout is specified, the client will unblock returning a nil
   * special value if the specified amount of seconds passed without a push operation against at
   * least one of the specified keys.
   * <p>
   * The timeout argument is interpreted as an integer value. A timeout of zero means instead to
   * block forever.
   * <p>
   * <b>Multiple clients blocking for the same keys</b>
   * <p>
   * Multiple clients can block for the same key. They are put into a queue, so the first to be
   * served will be the one that started to wait earlier, in a first-blpopping first-served fashion.
   * <p>
   * <b>blocking POP inside a MULTI/EXEC transaction</b>
   * <p>
   * BLPOP and BRPOP can be used with pipelining (sending multiple commands and reading the replies
   * in batch), but it does not make sense to use BLPOP or BRPOP inside a MULTI/EXEC block (a Redis
   * transaction).
   * <p>
   * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to return a multi-bulk nil
   * reply, exactly what happens when the timeout is reached. If you like science fiction, think at
   * it like if inside MULTI/EXEC the time will flow at infinite speed :)
   * <p>
   * Time complexity: O(1)
   * @see #brpop(int, byte[]...)
   * @param timeout
   * @param keys
   * @return BLPOP returns a two-elements array via a multi bulk reply in order to return both the
   *         unblocking key and the popped value.
   *         <p>
   *         When a non-zero timeout is specified, and the BLPOP operation timed out, the return
   *         value is a nil multi bulk reply. Most client values will return false or nil
   *         accordingly to the programming language used.
   */
  public List<byte[]> blpop(final int timeout, final byte[]... keys) {
    return blpop(getArgsAddTimeout(timeout, keys));
  }

  private byte[][] getArgsAddTimeout(int timeout, byte[][] keys) {
    int size = keys.length;
    final byte[][] args = new byte[size + 1][];
    for (int at = 0; at != size; ++at) {
      args[at] = keys[at];
    }
    args[size] = Protocol.toByteArray(timeout);
    return args;
  }

  /**
   * Sort a Set or a List accordingly to the specified parameters and store the result at dstkey.
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[])
   * @see #sort(byte[], byte[])
   * @param key
   * @param sortingParameters
   * @param dstkey
   * @return The number of elements of the list at dstkey.
   */
  public Long sort(final byte[] key, final SortingParams sortingParameters, final byte[] dstkey) {
    checkIsInMulti();
    client.sort(key, sortingParameters, dstkey);
    return client.getIntegerReply();
  }

  /**
   * Sort a Set or a List and Store the Result at dstkey.
   * <p>
   * Sort the elements contained in the List, Set, or Sorted Set value at key and store the result
   * at dstkey. By default sorting is numeric with elements being compared as double precision
   * floating point numbers. This is the simplest form of SORT.
   * @see #sort(byte[])
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @param dstkey
   * @return The number of elements of the list at dstkey.
   */
  public Long sort(final byte[] key, final byte[] dstkey) {
    checkIsInMulti();
    client.sort(key, dstkey);
    return client.getIntegerReply();
  }

  /**
   * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this commands as blocking
   * versions of LPOP and RPOP able to block if the specified keys don't exist or contain empty
   * lists.
   * <p>
   * The following is a description of the exact semantic. We describe BLPOP but the two commands
   * are identical, the only difference is that BLPOP pops the element from the left (head) of the
   * list, and BRPOP pops from the right (tail).
   * <p>
   * <b>Non blocking behavior</b>
   * <p>
   * When BLPOP is called, if at least one of the specified keys contain a non empty list, an
   * element is popped from the head of the list and returned to the caller together with the name
   * of the key (BLPOP returns a two elements array, the first element is the key, the second the
   * popped value).
   * <p>
   * Keys are scanned from left to right, so for instance if you issue BLPOP list1 list2 list3 0
   * against a dataset where list1 does not exist but list2 and list3 contain non empty lists, BLPOP
   * guarantees to return an element from the list stored at list2 (since it is the first non empty
   * list starting from the left).
   * <p>
   * <b>Blocking behavior</b>
   * <p>
   * If none of the specified keys exist or contain non empty lists, BLPOP blocks until some other
   * client performs a LPUSH or an RPUSH operation against one of the lists.
   * <p>
   * Once new data is present on one of the lists, the client finally returns with the name of the
   * key unblocking it and the popped value.
   * <p>
   * When blocking, if a non-zero timeout is specified, the client will unblock returning a nil
   * special value if the specified amount of seconds passed without a push operation against at
   * least one of the specified keys.
   * <p>
   * The timeout argument is interpreted as an integer value. A timeout of zero means instead to
   * block forever.
   * <p>
   * <b>Multiple clients blocking for the same keys</b>
   * <p>
   * Multiple clients can block for the same key. They are put into a queue, so the first to be
   * served will be the one that started to wait earlier, in a first-blpopping first-served fashion.
   * <p>
   * <b>blocking POP inside a MULTI/EXEC transaction</b>
   * <p>
   * BLPOP and BRPOP can be used with pipelining (sending multiple commands and reading the replies
   * in batch), but it does not make sense to use BLPOP or BRPOP inside a MULTI/EXEC block (a Redis
   * transaction).
   * <p>
   * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to return a multi-bulk nil
   * reply, exactly what happens when the timeout is reached. If you like science fiction, think at
   * it like if inside MULTI/EXEC the time will flow at infinite speed :)
   * <p>
   * Time complexity: O(1)
   * @see #blpop(int, byte[]...)
   * @param timeout
   * @param keys
   * @return BLPOP returns a two-elements array via a multi bulk reply in order to return both the
   *         unblocking key and the popped value.
   *         <p>
   *         When a non-zero timeout is specified, and the BLPOP operation timed out, the return
   *         value is a nil multi bulk reply. Most client values will return false or nil
   *         accordingly to the programming language used.
   */
  public List<byte[]> brpop(final int timeout, final byte[]... keys) {
    return brpop(getArgsAddTimeout(timeout, keys));
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  public List<byte[]> blpop(byte[] arg) {
    return blpop(new byte[][] { arg });
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  public List<byte[]> brpop(byte[] arg) {
    return brpop(new byte[][] { arg });
  }

  public List<byte[]> blpop(byte[]... args) {
    checkIsInMulti();
    client.blpop(args);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryMultiBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  public List<byte[]> brpop(byte[]... args) {
    checkIsInMulti();
    client.brpop(args);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryMultiBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  /**
   * Request for authentication in a password protected Redis server. A Redis server can be
   * instructed to require a password before to allow clients to issue commands. This is done using
   * the requirepass directive in the Redis configuration file. If the password given by the client
   * is correct the server replies with an OK status code reply and starts accepting commands from
   * the client. Otherwise an error is returned and the clients needs to try a new password. Note
   * that for the high performance nature of Redis it is possible to try a lot of passwords in
   * parallel in very short time, so make sure to generate a strong and very long password so that
   * this attack is infeasible.
   * @param password
   * @return Status code reply
   */
  public String auth(final String password) {
    checkIsInMulti();
    client.auth(password);
    return client.getStatusCodeReply();
  }

  public Pipeline pipelined() {
    pipeline = new Pipeline();
    pipeline.setClient(client);
    return pipeline;
  }

  public Long zcount(final byte[] key, final double min, final double max) {
    return zcount(key, toByteArray(min), toByteArray(max));
  }

  public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zcount(key, min, max);
    return client.getIntegerReply();
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max));
  }

  public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByScore(key, min, max);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max,
      final int offset, final int count) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByScore(key, min, max, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
  }

  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByScoreWithScores(key, min, max);
    return getBinaryTupledSet();
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max,
      final int offset, final int count) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByScoreWithScores(key, min, max, offset, count);
    return getBinaryTupledSet();
  }

  private Set<Tuple> getBinaryTupledSet() {
    checkIsInMulti();
    List<byte[]> membersWithScores = client.getBinaryMultiBulkReply();
    Set<Tuple> set = new LinkedHashSet<Tuple>();
    Iterator<byte[]> iterator = membersWithScores.iterator();
    while (iterator.hasNext()) {
      set.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
    }
    return set;
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min) {
    return zrevrangeByScore(key, toByteArray(max), toByteArray(min));
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
    checkIsInMulti();
    client.zrevrangeByScore(key, max, min);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min,
      final int offset, final int count) {
    return zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrevrangeByScore(key, max, min, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
    return zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max,
      final double min, final int offset, final int count) {
    return zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset, count);
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
    checkIsInMulti();
    client.zrevrangeByScoreWithScores(key, max, min);
    return getBinaryTupledSet();
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
      final byte[] min, final int offset, final int count) {
    checkIsInMulti();
    client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getBinaryTupledSet();
  }

  /**
   * Remove all elements in the sorted set at key with rank between start and end. Start and end are
   * 0-based with rank 0 being the element with the lowest score. Both start and end can be negative
   * numbers, where they indicate offsets starting at the element with the highest rank. For
   * example: -1 is the element with the highest score, -2 the element with the second highest score
   * and so forth.
   * <p>
   * <b>Time complexity:</b> O(log(N))+O(M) with N being the number of elements in the sorted set
   * and M the number of elements removed by the operation
   */
  public Long zremrangeByRank(final byte[] key, final long start, final long end) {
    checkIsInMulti();
    client.zremrangeByRank(key, start, end);
    return client.getIntegerReply();
  }

  /**
   * Remove all the elements in the sorted set at key with a score between min and max (including
   * elements with score equal to min or max).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements removed by the operation
   * @param key
   * @param start
   * @param end
   * @return Integer reply, specifically the number of elements removed.
   */
  public Long zremrangeByScore(final byte[] key, final double start, final double end) {
    return zremrangeByScore(key, toByteArray(start), toByteArray(end));
  }

  public Long zremrangeByScore(final byte[] key, final byte[] start, final byte[] end) {
    checkIsInMulti();
    client.zremrangeByScore(key, start, end);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...)} ZINTERSTORE} command requires
   * an element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...)} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
    checkIsInMulti();
    client.zunionstore(dstkey, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @param params
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zunionstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
    checkIsInMulti();
    client.zunionstore(dstkey, params, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
    checkIsInMulti();
    client.zinterstore(dstkey, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @param params
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zinterstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
    checkIsInMulti();
    client.zinterstore(dstkey, params, sets);
    return client.getIntegerReply();
  }

  @Override
  public Long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zlexcount(key, min, max);
    return client.getIntegerReply();
  }

  @Override
  public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByLex(key, min, max);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByLex(key, min, max, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
    checkIsInMulti();
    client.zrevrangeByLex(key, max, min);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
    checkIsInMulti();
    client.zrevrangeByLex(key, max, min, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zremrangeByLex(key, min, max);
    return client.getIntegerReply();
  }

  /**
   * Synchronously save the DB on disk.
   * <p>
   * Save the whole dataset on disk (this means that all the databases are saved, as well as keys
   * with an EXPIRE set (the expire is preserved). The server hangs while the saving is not
   * completed, no connection is served in the meanwhile. An OK code is returned when the DB was
   * fully stored in disk.
   * <p>
   * The background variant of this command is {@link #bgsave() BGSAVE} that is able to perform the
   * saving in the background while the server continues serving other clients.
   * <p>
   * @return Status code reply
   */
  public String save() {
    client.save();
    return client.getStatusCodeReply();
  }

  /**
   * Asynchronously save the DB on disk.
   * <p>
   * Save the DB in background. The OK code is immediately returned. Redis forks, the parent
   * continues to server the clients, the child saves the DB on disk then exit. A client my be able
   * to check if the operation succeeded using the LASTSAVE command.
   * @return Status code reply
   */
  public String bgsave() {
    client.bgsave();
    return client.getStatusCodeReply();
  }

  /**
   * Rewrite the append only file in background when it gets too big. Please for detailed
   * information about the Redis Append Only File check the <a
   * href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append Only File Howto</a>.
   * <p>
   * BGREWRITEAOF rewrites the Append Only File in background when it gets too big. The Redis Append
   * Only File is a Journal, so every operation modifying the dataset is logged in the Append Only
   * File (and replayed at startup). This means that the Append Only File always grows. In order to
   * rebuild its content the BGREWRITEAOF creates a new version of the append only file starting
   * directly form the dataset in memory in order to guarantee the generation of the minimal number
   * of commands needed to rebuild the database.
   * <p>
   * @return Status code reply
   */
  public String bgrewriteaof() {
    client.bgrewriteaof();
    return client.getStatusCodeReply();
  }

  /**
   * Return the UNIX time stamp of the last successfully saving of the dataset on disk.
   * <p>
   * Return the UNIX TIME of the last DB save executed with success. A client may check if a
   * {@link #bgsave() BGSAVE} command succeeded reading the LASTSAVE value, then issuing a BGSAVE
   * command and checking at regular intervals every N seconds if LASTSAVE changed.
   * @return Integer reply, specifically an UNIX time stamp.
   */
  public Long lastsave() {
    client.lastsave();
    return client.getIntegerReply();
  }

  /**
   * Synchronously save the DB on disk, then shutdown the server.
   * <p>
   * Stop all the clients, save the DB, then quit the server. This commands makes sure that the DB
   * is switched off without the lost of any data. This is not guaranteed if the client uses simply
   * {@link #save() SAVE} and then {@link #quit() QUIT} because other clients may alter the DB data
   * between the two commands.
   * @return Status code reply on error. On success nothing is returned since the server quits and
   *         the connection is closed.
   */
  public String shutdown() {
    client.shutdown();
    String status;
    try {
      status = client.getStatusCodeReply();
    } catch (JedisException ex) {
      status = null;
    }
    return status;
  }

  /**
   * Provide information and statistics about the server.
   * <p>
   * The info command returns different information and statistics about the server in an format
   * that's simple to parse by computers and easy to read by humans.
   * <p>
   * <b>Format of the returned String:</b>
   * <p>
   * All the fields are in the form field:value
   * 
   * <pre>
   * edis_version:0.07
   * connected_clients:1
   * connected_slaves:0
   * used_memory:3187
   * changes_since_last_save:0
   * last_save_time:1237655729
   * total_connections_received:1
   * total_commands_processed:1
   * uptime_in_seconds:25
   * uptime_in_days:0
   * </pre>
   * 
   * <b>Notes</b>
   * <p>
   * used_memory is returned in bytes, and is the total number of bytes allocated by the program
   * using malloc.
   * <p>
   * uptime_in_days is redundant since the uptime in seconds contains already the full uptime
   * information, this field is only mainly present for humans.
   * <p>
   * changes_since_last_save does not refer to the number of key changes, but to the number of
   * operations that produced some kind of change in the dataset.
   * <p>
   * @return Bulk reply
   */
  public String info() {
    client.info();
    return client.getBulkReply();
  }

  public String info(final String section) {
    client.info(section);
    return client.getBulkReply();
  }

  /**
   * Dump all the received requests in real time.
   * <p>
   * MONITOR is a debugging command that outputs the whole sequence of commands received by the
   * Redis server. is very handy in order to understand what is happening into the database. This
   * command is used directly via telnet.
   * @param jedisMonitor
   */
  public void monitor(final JedisMonitor jedisMonitor) {
    client.monitor();
    client.getStatusCodeReply();
    jedisMonitor.proceed(client);
  }

  /**
   * Change the replication settings.
   * <p>
   * The SLAVEOF command can change the replication settings of a slave on the fly. If a Redis
   * server is arleady acting as slave, the command SLAVEOF NO ONE will turn off the replicaiton
   * turning the Redis server into a MASTER. In the proper form SLAVEOF hostname port will make the
   * server a slave of the specific server listening at the specified hostname and port.
   * <p>
   * If a server is already a slave of some master, SLAVEOF hostname port will stop the replication
   * against the old server and start the synchrnonization against the new one discarding the old
   * dataset.
   * <p>
   * The form SLAVEOF no one will stop replication turning the server into a MASTER but will not
   * discard the replication. So if the old master stop working it is possible to turn the slave
   * into a master and set the application to use the new master in read/write. Later when the other
   * Redis server will be fixed it can be configured in order to work as slave.
   * <p>
   * @param host
   * @param port
   * @return Status code reply
   */
  public String slaveof(final String host, final int port) {
    client.slaveof(host, port);
    return client.getStatusCodeReply();
  }

  public String slaveofNoOne() {
    client.slaveofNoOne();
    return client.getStatusCodeReply();
  }

  /**
   * Retrieve the configuration of a running Redis server. Not all the configuration parameters are
   * supported.
   * <p>
   * CONFIG GET returns the current configuration parameters. This sub command only accepts a single
   * argument, that is glob style pattern. All the configuration parameters matching this parameter
   * are reported as a list of key-value pairs.
   * <p>
   * <b>Example:</b>
   * 
   * <pre>
   * $ redis-cli config get '*'
   * 1. "dbfilename"
   * 2. "dump.rdb"
   * 3. "requirepass"
   * 4. (nil)
   * 5. "masterauth"
   * 6. (nil)
   * 7. "maxmemory"
   * 8. "0\n"
   * 9. "appendfsync"
   * 10. "everysec"
   * 11. "save"
   * 12. "3600 1 300 100 60 10000"
   * 
   * $ redis-cli config get 'm*'
   * 1. "masterauth"
   * 2. (nil)
   * 3. "maxmemory"
   * 4. "0\n"
   * </pre>
   * @param pattern
   * @return Bulk reply.
   */
  public List<byte[]> configGet(final byte[] pattern) {
    client.configGet(pattern);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * Reset the stats returned by INFO
   * @return
   */
  public String configResetStat() {
    client.configResetStat();
    return client.getStatusCodeReply();
  }

  /**
   * Alter the configuration of a running Redis server. Not all the configuration parameters are
   * supported.
   * <p>
   * The list of configuration parameters supported by CONFIG SET can be obtained issuing a
   * {@link #configGet(byte[]) CONFIG GET *} command.
   * <p>
   * The configuration set using CONFIG SET is immediately loaded by the Redis server that will
   * start acting as specified starting from the next command.
   * <p>
   * <b>Parameters value format</b>
   * <p>
   * The value of the configuration parameter is the same as the one of the same parameter in the
   * Redis configuration file, with the following exceptions:
   * <p>
   * <ul>
   * <li>The save paramter is a list of space-separated integers. Every pair of integers specify the
   * time and number of changes limit to trigger a save. For instance the command CONFIG SET save
   * "3600 10 60 10000" will configure the server to issue a background saving of the RDB file every
   * 3600 seconds if there are at least 10 changes in the dataset, and every 60 seconds if there are
   * at least 10000 changes. To completely disable automatic snapshots just set the parameter as an
   * empty string.
   * <li>All the integer parameters representing memory are returned and accepted only using bytes
   * as unit.
   * </ul>
   * @param parameter
   * @param value
   * @return Status code reply
   */
  public byte[] configSet(final byte[] parameter, final byte[] value) {
    client.configSet(parameter, value);
    return client.getBinaryBulkReply();
  }

  public boolean isConnected() {
    return client.isConnected();
  }

  public Long strlen(final byte[] key) {
    client.strlen(key);
    return client.getIntegerReply();
  }

  public void sync() {
    client.sync();
  }

  public Long lpushx(final byte[] key, final byte[]... string) {
    client.lpushx(key, string);
    return client.getIntegerReply();
  }

  /**
   * Undo a {@link #expire(byte[], int) expire} at turning the expire key into a normal key.
   * <p>
   * Time complexity: O(1)
   * @param key
   * @return Integer reply, specifically: 1: the key is now persist. 0: the key is not persist (only
   *         happens when key not set).
   */
  public Long persist(final byte[] key) {
    client.persist(key);
    return client.getIntegerReply();
  }

  public Long rpushx(final byte[] key, final byte[]... string) {
    client.rpushx(key, string);
    return client.getIntegerReply();
  }

  public byte[] echo(final byte[] string) {
    client.echo(string);
    return client.getBinaryBulkReply();
  }

  public Long linsert(final byte[] key, final LIST_POSITION where, final byte[] pivot,
      final byte[] value) {
    client.linsert(key, where, pivot, value);
    return client.getIntegerReply();
  }

  public String debug(final DebugParams params) {
    client.debug(params);
    return client.getStatusCodeReply();
  }

  public Client getClient() {
    return client;
  }

  /**
   * Pop a value from a list, push it to another list and return it; or block until one is available
   * @param source
   * @param destination
   * @param timeout
   * @return the element
   */
  public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  /**
   * Sets or clears the bit at offset in the string value stored at key
   * @param key
   * @param offset
   * @param value
   * @return
   */
  public Boolean setbit(byte[] key, long offset, boolean value) {
    client.setbit(key, offset, value);
    return client.getIntegerReply() == 1;
  }

  public Boolean setbit(byte[] key, long offset, byte[] value) {
    client.setbit(key, offset, value);
    return client.getIntegerReply() == 1;
  }

  /**
   * Returns the bit value at offset in the string value stored at key
   * @param key
   * @param offset
   * @return
   */
  public Boolean getbit(byte[] key, long offset) {
    client.getbit(key, offset);
    return client.getIntegerReply() == 1;
  }

  public Long bitpos(final byte[] key, final boolean value) {
    return bitpos(key, value, new BitPosParams());
  }

  public Long bitpos(final byte[] key, final boolean value, final BitPosParams params) {
    client.bitpos(key, value, params);
    return client.getIntegerReply();
  }

  public Long setrange(byte[] key, long offset, byte[] value) {
    client.setrange(key, offset, value);
    return client.getIntegerReply();
  }

  public byte[] getrange(byte[] key, long startOffset, long endOffset) {
    client.getrange(key, startOffset, endOffset);
    return client.getBinaryBulkReply();
  }

  public Long publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return client.getIntegerReply();
  }

  public void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels) {
    client.setTimeoutInfinite();
    try {
      jedisPubSub.proceed(client, channels);
    } finally {
      client.rollbackTimeout();
    }
  }

  public void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns) {
    client.setTimeoutInfinite();
    try {
      jedisPubSub.proceedWithPatterns(client, patterns);
    } finally {
      client.rollbackTimeout();
    }
  }

  public Long getDB() {
    return client.getDB();
  }

  /**
   * Evaluates scripts using the Lua interpreter built into Redis starting from version 2.6.0.
   * <p>
   * @return Script result
   */
  public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
    return eval(script, toByteArray(keys.size()), getParams(keys, args));
  }

  private byte[][] getParams(List<byte[]> keys, List<byte[]> args) {
    final int keyCount = keys.size();
    final int argCount = args.size();
    byte[][] params = new byte[keyCount + argCount][];

    for (int i = 0; i < keyCount; i++)
      params[i] = keys.get(i);

    for (int i = 0; i < argCount; i++)
      params[keyCount + i] = args.get(i);

    return params;
  }

  public Object eval(byte[] script, byte[] keyCount, byte[]... params) {
    client.setTimeoutInfinite();
    try {
      client.eval(script, keyCount, params);
      return client.getOne();
    } finally {
      client.rollbackTimeout();
    }
  }

  public Object eval(byte[] script, int keyCount, byte[]... params) {
    return eval(script, toByteArray(keyCount), params);
  }

  public Object eval(byte[] script) {
    return eval(script, 0);
  }

  public Object evalsha(byte[] sha1) {
    return evalsha(sha1, 1);
  }

  public Object evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
    return evalsha(sha1, keys.size(), getParams(keys, args));
  }

  public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
    client.setTimeoutInfinite();
    try {
      client.evalsha(sha1, keyCount, params);
      return client.getOne();
    } finally {
      client.rollbackTimeout();
    }
  }

  public String scriptFlush() {
    client.scriptFlush();
    return client.getStatusCodeReply();
  }

  public List<Long> scriptExists(byte[]... sha1) {
    client.scriptExists(sha1);
    return client.getIntegerMultiBulkReply();
  }

  public byte[] scriptLoad(byte[] script) {
    client.scriptLoad(script);
    return client.getBinaryBulkReply();
  }

  public String scriptKill() {
    client.scriptKill();
    return client.getStatusCodeReply();
  }

  public String slowlogReset() {
    client.slowlogReset();
    return client.getBulkReply();
  }

  public Long slowlogLen() {
    client.slowlogLen();
    return client.getIntegerReply();
  }

  public List<byte[]> slowlogGetBinary() {
    client.slowlogGet();
    return client.getBinaryMultiBulkReply();
  }

  public List<byte[]> slowlogGetBinary(long entries) {
    client.slowlogGet(entries);
    return client.getBinaryMultiBulkReply();
  }

  public Long objectRefcount(byte[] key) {
    client.objectRefcount(key);
    return client.getIntegerReply();
  }

  public byte[] objectEncoding(byte[] key) {
    client.objectEncoding(key);
    return client.getBinaryBulkReply();
  }

  public Long objectIdletime(byte[] key) {
    client.objectIdletime(key);
    return client.getIntegerReply();
  }

  public Long bitcount(final byte[] key) {
    client.bitcount(key);
    return client.getIntegerReply();
  }

  public Long bitcount(final byte[] key, long start, long end) {
    client.bitcount(key, start, end);
    return client.getIntegerReply();
  }

  public Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return client.getIntegerReply();
  }

  public byte[] dump(final byte[] key) {
    checkIsInMulti();
    client.dump(key);
    return client.getBinaryBulkReply();
  }

  public String restore(final byte[] key, final int ttl, final byte[] serializedValue) {
    checkIsInMulti();
    client.restore(key, ttl, serializedValue);
    return client.getStatusCodeReply();
  }

  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  public Long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
    checkIsInMulti();
    client.pexpireAt(key, millisecondsTimestamp);
    return client.getIntegerReply();
  }

  public Long pttl(final byte[] key) {
    checkIsInMulti();
    client.pttl(key);
    return client.getIntegerReply();
  }

  public String psetex(final byte[] key, final int milliseconds, final byte[] value) {
    checkIsInMulti();
    client.psetex(key, milliseconds, value);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
    checkIsInMulti();
    client.set(key, value, nxxx);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final int time) {
    checkIsInMulti();
    client.set(key, value, nxxx, expx, time);
    return client.getStatusCodeReply();
  }

  public String clientKill(final byte[] client) {
    checkIsInMulti();
    this.client.clientKill(client);
    return this.client.getStatusCodeReply();
  }

  public String clientGetname() {
    checkIsInMulti();
    client.clientGetname();
    return client.getBulkReply();
  }

  public String clientList() {
    checkIsInMulti();
    client.clientList();
    return client.getBulkReply();
  }

  public String clientSetname(final byte[] name) {
    checkIsInMulti();
    client.clientSetname(name);
    return client.getBulkReply();
  }

  public List<String> time() {
    checkIsInMulti();
    client.time();
    return client.getMultiBulkReply();
  }

  public String migrate(final byte[] host, final int port, final byte[] key,
      final int destinationDb, final int timeout) {
    checkIsInMulti();
    client.migrate(host, port, key, destinationDb, timeout);
    return client.getStatusCodeReply();
  }

  /**
   * Syncrhonous replication of Redis as described here: http://antirez.com/news/66 Since Java
   * Object class has implemented "wait" method, we cannot use it, so I had to change the name of
   * the method. Sorry :S
   */
  public Long waitReplicas(int replicas, long timeout) {
    checkIsInMulti();
    client.waitReplicas(replicas, timeout);
    return client.getIntegerReply();
  }

  @Override
  public Long pfadd(final byte[] key, final byte[]... elements) {
    checkIsInMulti();
    client.pfadd(key, elements);
    return client.getIntegerReply();
  }

  @Override
  public long pfcount(final byte[] key) {
    checkIsInMulti();
    client.pfcount(key);
    return client.getIntegerReply();
  }

  @Override
  public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
    checkIsInMulti();
    client.pfmerge(destkey, sourcekeys);
    return client.getStatusCodeReply();
  }

  @Override
  public Long pfcount(byte[]... keys) {
    checkIsInMulti();
    client.pfcount(keys);
    return client.getIntegerReply();
  }

  public ScanResult<byte[]> scan(final byte[] cursor) {
    return scan(cursor, new ScanParams());
  }

  public ScanResult<byte[]> scan(final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.scan(cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    return new ScanResult<byte[]>(newcursor, rawResults);
  }

  public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key, final byte[] cursor) {
    return hscan(key, cursor, new ScanParams());
  }

  public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key, final byte[] cursor,
      final ScanParams params) {
    checkIsInMulti();
    client.hscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<Map.Entry<byte[], byte[]>> results = new ArrayList<Map.Entry<byte[], byte[]>>();
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    Iterator<byte[]> iterator = rawResults.iterator();
    while (iterator.hasNext()) {
      results.add(new AbstractMap.SimpleEntry<byte[], byte[]>(iterator.next(), iterator.next()));
    }
    return new ScanResult<Map.Entry<byte[], byte[]>>(newcursor, results);
  }

  public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor) {
    return sscan(key, cursor, new ScanParams());
  }

  public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.sscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    return new ScanResult<byte[]>(newcursor, rawResults);
  }

  public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor) {
    return zscan(key, cursor, new ScanParams());
  }

  public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.zscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<Tuple> results = new ArrayList<Tuple>();
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    Iterator<byte[]> iterator = rawResults.iterator();
    while (iterator.hasNext()) {
      results.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/main/java/org/junit/experimental/theories/DataPoint.java;<<<<<<< MINE
    String[] value() default {};
=======
    String[] value() default {};
    Class<? extends Throwable>[] ignoredExceptions() default {};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/internal/AllMembersSupplierTest.java;<<<<<<< MINE
    public void dataPointsArrayShouldBeRecognizedOnValueTypeNotFieldType() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointsArrayWithMatchingButInaccurateTypes.class.getMethod("theory", Integer.class));
        
        assertEquals(2, assignments.size());
    }
    
    public static class HasDataPointMethodWithOverlyGeneralTypes {
        @DataPoint
        public static Integer object() {
            return 1;
        }

        @Theory
        public void theory(Object param) {
        }
    }

    @Test
    public void dataPointMethodShouldBeRecognizedForOverlyGeneralParameters() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointMethodWithOverlyGeneralTypes.class.getMethod("theory", Object.class));
        
        assertEquals(1, assignments.size());
    }
    
    public static class HasDataPointsWithObjectParameter {
        @DataPoints
        public static Object[] objectField = {1, 2};

        @Theory
        public void theory(Object obj) {
        }
    }

    @Test
    public void dataPointsAnnotationMeansTreatAsArrayOnly() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointsWithObjectParameter.class.getMethod("theory", Object.class));
        
        assertEquals(2, assignments.size());
        for (PotentialAssignment assignment : assignments) {
            assertNotEquals(HasDataPointsWithObjectParameter.objectField, assignment.getValue());
        }
=======
    public void dataPointsAnnotationMeansTreatAsArrayOnly() throws Throwable {
        List<PotentialAssignment> valueSources = allMemberValuesFor(
                HasDataPoints.class, Object.class);
        assertThat(valueSources.size(), is(2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_364c6d9_7e24eac/rev_364c6d9-7e24eac/src/test/java/redis/clients/jedis/tests/commands/ObjectCommandsTest.java;<<<<<<< MINE
    assertEquals("ziplist", encoding);
=======
    assertEquals("quicklist", encoding);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_364c6d9_7e24eac/rev_364c6d9-7e24eac/src/test/java/redis/clients/jedis/tests/commands/ObjectCommandsTest.java;<<<<<<< MINE
    assertEquals("ziplist", encoding);
=======
    assertEquals("quicklist", encoding);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
  protected void returnBrokenResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnBrokenResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
   protected void returnResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
  protected void returnBrokenResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  public void returnBrokenResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
  protected void returnResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  public void returnResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public String set(final String key, final String value, final SetParams params) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
=======
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }.run(null);
=======
    }.run(key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }.run(null);
=======
    }.run(key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }.run(null);
=======
    }.run(key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
   * Test for "Issue - BinaryShardedJedis.disconnect() may occur memory leak".
   * You can find more detailed information at https://github.com/xetorthio/jedis/issues/808
   *
=======
   * Test for "Issue - BinaryShardedJedis.disconnect() may occur memory leak". You can find more
   * detailed information at https://github.com/xetorthio/jedis/issues/808
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
    
    //We set a name to the instance so it's easy to find it
=======

    // We set a name to the instance so it's easy to find it
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
    assertEquals(true, deadClient.isConnected());
    assertEquals(false, deadClient.getClient().getSocket().isClosed());
    assertEquals(false, deadClient.getClient().isBroken()); // normal - not found

    shardedJedis.disconnect();

    assertEquals(false, deadClient.isConnected());
    assertEquals(true, deadClient.getClient().getSocket().isClosed());
    assertEquals(true, deadClient.getClient().isBroken());

    Jedis jedis2 = it.next();
    assertEquals(false, jedis2.isConnected());
    assertEquals(true, jedis2.getClient().getSocket().isClosed());
    assertEquals(false, jedis2.getClient().isBroken());

=======
    ClientKillerUtil.killClient(deadClient, "DEAD");

    assertEquals(true, deadClient.isConnected());
    assertEquals(false, deadClient.getClient().getSocket().isClosed());
    assertEquals(false, deadClient.getClient().isBroken()); // normal - not found

    shardedJedis.disconnect();

    assertEquals(false, deadClient.isConnected());
    assertEquals(true, deadClient.getClient().getSocket().isClosed());
    assertEquals(true, deadClient.getClient().isBroken());

    Jedis jedis2 = it.next();
    assertEquals(false, jedis2.isConnected());
    assertEquals(true, jedis2.getClient().getSocket().isClosed());
    assertEquals(false, jedis2.getClient().isBroken());

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
        return new JedisClusterCommand<String>(connectionHandler,
                timeout, maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.scriptLoad(script);
            }
        }.run(key);
    }

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long del(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> blpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.run(keys.length, keys);

    }
    
    @Override
    public List<String> brpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> mget(final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.run(keys.length - 1, keys);
    }

    @Override
    public String mset(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long msetnx(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public String rename(final String oldkey, final String newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final String oldkey, final String newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public String rpoplpush(final String srckey, final String dstkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Set<String> sdiff(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Set<String> sinter(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sinterstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long smove(final String srckey, final String dstkey,
	    final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Long sort(final String key, final SortingParams sortingParameters,
	    final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Long sort(final String key, final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Set<String> sunion(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sunionstore(final String dstkey, final String... keys) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final String... sets) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String brpoplpush(final String source, final String destination,
	    final int timeout) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.run(2, source, destination);
    }

    @Override
    public Long publish(final String channel, final String message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final JedisPubSub jedisPubSub,
	    final String... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final JedisPubSub jedisPubSub,
	    final String... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final String destKey,
	    final String... srcKeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String pfmerge(final String destkey, final String... sourcekeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public long pfcount(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.run(keys.length, keys);
    }

=======
  }

  @Override
  public Set<String> zrevrangeByScore(final String key, final String max, final String min,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByScore(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrangeByScoreWithScores(final String key, final String min, final String max) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrangeByScoreWithScores(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final String max, final String min) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrangeByScoreWithScores(key, min, max, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final double max,
      final double min, final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final String max,
      final String min, final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByRank(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByRank(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByScore(final String key, final double start, final double end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByScore(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByScore(final String key, final String start, final String end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByScore(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zlexcount(final String key, final String min, final String max) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zlexcount(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrangeByLex(final String key, final String min, final String max) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrangeByLex(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrangeByLex(final String key, final String min, final String max,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrangeByLex(key, min, max, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrevrangeByLex(final String key, final String max, final String min) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByLex(key, max, min);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByLex(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByLex(final String key, final String min, final String max) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByLex(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Long linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.linsert(key, where, pivot, value);
      }
    }.run(key);
  }

  @Override
  public Long lpushx(final String key, final String... string) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.lpushx(key, string);
      }
    }.run(key);
  }

  @Override
  public Long rpushx(final String key, final String... string) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.rpushx(key, string);
      }
    }.run(key);
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Override
  @Deprecated
  public List<String> blpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.blpop(arg);
      }
    }.run(arg);
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Override
  @Deprecated
  public List<String> brpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.brpop(arg);
      }
    }.run(arg);
  }

  @Override
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.del(key);
      }
    }.run(key);
  }

  @Override
  public String echo(final String string) {
    // note that it'll be run from arbitary node
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.echo(string);
      }
    }.run(string);
  }

  @Override
  public Long move(final String key, final int dbIndex) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.move(key, dbIndex);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key, start, end);
      }
    }.run(key);
  }

  @Override
  public ScanResult<Entry<String, String>> hscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<Entry<String, String>>>(connectionHandler,
        maxRedirections) {
      @Override
      public ScanResult<Entry<String, String>> execute(Jedis connection) {
        return connection.hscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public ScanResult<String> sscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<String>>(connectionHandler, maxRedirections) {
      @Override
      public ScanResult<String> execute(Jedis connection) {
        return connection.sscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public ScanResult<Tuple> zscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public ScanResult<Tuple> execute(Jedis connection) {
        return connection.zscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public Long pfadd(final String key, final String... elements) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.pfadd(key, elements);
      }
    }.run(key);
  }

  @Override
  public long pfcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.pfcount(key);
      }
    }.run(key);
  }

  @Override
  public List<String> blpop(final int timeout, final String key) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.blpop(timeout, key);
      }
    }.run(key);
  }

  @Override
  public List<String> brpop(final int timeout, final String key) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.brpop(timeout, key);
      }
    }.run(key);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
        
        return runWithRetries(keys[0], this.redirections, false, false);
    }
    
    public T runWithAnyNode() {
	Jedis connection = null;
	try {
	    connection = connectionHandler.getConnection();
	    return execute(connection);
	} catch (JedisConnectionException e) {
	    releaseConnection(connection, true);
	    throw e;
	} finally {
	    releaseConnection(connection, false);
	}
    }
=======
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
	MultiKeyBinaryJedisClusterCommands, JedisClusterBinaryScriptingCommands, 
	Closeable {
    
    public static final short HASHSLOTS = 16384;
    protected static final int DEFAULT_TIMEOUT = 1;
    protected static final int DEFAULT_MAX_REDIRECTIONS = 5;

    protected int timeout;
    protected int maxRedirections;

    protected JedisClusterConnectionHandler connectionHandler;
    
    public BinaryJedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, new GenericObjectPoolConfig());
    }

    public BinaryJedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public BinaryJedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
	    int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	this.connectionHandler = new JedisSlotBasedConnectionHandler(
		jedisClusterNode, poolConfig);
	this.timeout = timeout;
	this.maxRedirections = maxRedirections;
    }

    @Override
    public String set(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
        maxRedirections) {
            @Override
            public String execute(Jedis connection) {
            return connection.set(key, value);
            }
        }.runBinary(key);
    }
 
    @Override
    public byte[] get(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.get(key);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean exists(final byte[] key) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.exists(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long persist(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.persist(key);
            }
        }.runBinary(key);
    }

    @Override
    public String type(final byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.type(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long expire(final byte[] key, final int seconds) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expire(key, seconds);
            }
        }.runBinary(key);
    }

    @Override
    public Long expireAt(final byte[] key, final long unixTime) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expireAt(key, unixTime);
            }
        }.runBinary(key);
    }

    @Override
    public Long ttl(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.ttl(key);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean setbit(final byte[] key, final long offset, final boolean value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean setbit(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean getbit(final byte[] key, final long offset) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.getbit(key, offset);
            }
        }.runBinary(key);
    }

    @Override
    public Long setrange(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setrange(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getrange(final byte[] key, final long startOffset, final long endOffset) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getrange(key, startOffset, endOffset);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getSet(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getSet(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long setnx(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setnx(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public String setex(final byte[] key, final int seconds, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.setex(key, seconds, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long decrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Long decr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long incrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Double incrByFloat(final byte[] key, final double value) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) { return connection.incrByFloat(key, value); }
        }.runBinary(key);
    }

    @Override
    public Long incr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long append(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.append(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] substr(final byte[] key, final int start, final int end) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.substr(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long hset(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hset(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] hget(final byte[] key, final byte[] field) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.hget(key, field);
            }
        }.runBinary(key);
    }

    @Override
    public Long hsetnx(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hsetnx(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public String hmset(final byte[] key, final Map<byte[], byte[]> hash) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.hmset(key, hash);
            }
        }.runBinary(key);
    }

    @Override
    public List<byte[]> hmget(final byte[] key, final byte[]... fields) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.hmget(key, fields);
            }
        }.runBinary(key);
    }
=======
    JedisClusterBinaryScriptingCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}
=======
    JedisClusterScriptingCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
	    int maxRedirections) {
        this(nodes, timeout, maxRedirections,
                new GenericObjectPoolConfig());
    }

    public JedisCluster(Set<HostAndPort> nodes,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, DEFAULT_TIMEOUT, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	super(jedisClusterNode, timeout, maxRedirections, poolConfig);
    }
    
    @Override
    public String set(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.set(key, value);
	    }
	}.run(key);
    }

    @Override
    public String set(final String key, final String value, final String nxxx,
                      final String expx, final long time) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.set(key, value, nxxx, expx, time);
            }
        }.run(key);
    }

    @Override
    public String get(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.get(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean exists(final String key) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.exists(key);
	    }
	}.run(key);
    }

    @Override
    public Long persist(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.persist(key);
	    }
	}.run(key);
    }

    @Override
    public String type(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.type(key);
	    }
	}.run(key);
    }

    @Override
    public Long expire(final String key, final int seconds) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.expire(key, seconds);
	    }
	}.run(key);
    }

    @Override
    public Long expireAt(final String key, final long unixTime) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.expireAt(key, unixTime);
	    }
	}.run(key);
    }

    @Override
    public Long ttl(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.ttl(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final boolean value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final String value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean getbit(final String key, final long offset) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.getbit(key, offset);
	    }
	}.run(key);
    }

    @Override
    public Long setrange(final String key, final long offset, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setrange(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public String getrange(final String key, final long startOffset,
	    final long endOffset) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getrange(key,
			startOffset, endOffset);
	    }
	}.run(key);
    }

    @Override
    public String getSet(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getSet(key, value);
	    }
	}.run(key);
    }

    @Override
    public Long setnx(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setnx(key, value);
	    }
	}.run(key);
    }

    @Override
    public String setex(final String key, final int seconds, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.setex(key, seconds,
			value);
	    }
	}.run(key);
    }

    @Override
    public Long decrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long decr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decr(key);
	    }
	}.run(key);
    }

    @Override
    public Long incrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long incr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incr(key);
	    }
	}.run(key);
    }

    @Override
    public Long append(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.append(key, value);
	    }
	}.run(key);
    }

    @Override
    public String substr(final String key, final int start, final int end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.substr(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long hset(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.hset(key, field, value);
	    }
	}.run(key);
    }

    @Override
    public String hget(final String key, final String field) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hget(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hsetnx(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hsetnx(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public String hmset(final String key, final Map<String, String> hash) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hmset(key, hash);
	    }
	}.run(key);
    }

    @Override
    public List<String> hmget(final String key, final String... fields) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hmget(key, fields);
	    }
	}.run(key);
    }

    @Override
    public Long hincrBy(final String key, final String field, final long value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hincrBy(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean hexists(final String key, final String field) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.hexists(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hdel(final String key, final String... field) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hdel(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hlen(key);
	    }
	}.run(key);
    }

    @Override
    public Set<String> hkeys(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.hkeys(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> hvals(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hvals(key);
	    }
	}.run(key);
    }

    @Override
    public Map<String, String> hgetAll(final String key) {
	return new JedisClusterCommand<Map<String, String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public Map<String, String> execute(Jedis connection) {
		return connection.hgetAll(key);
	    }
	}.run(key);
    }

    @Override
    public Long rpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long lpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long llen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.llen(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> lrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection
			.lrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String ltrim(final String key, final long start, final long end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ltrim(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String lindex(final String key, final long index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lindex(key, index);
	    }
	}.run(key);
    }

    @Override
    public String lset(final String key, final long index, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.lset(key, index, value);
	    }
	}.run(key);
    }

    @Override
    public Long lrem(final String key, final long count, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.lrem(key, count, value);
	    }
	}.run(key);
    }

    @Override
    public String lpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lpop(key);
	    }
	}.run(key);
    }

    @Override
    public String rpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpop(key);
	    }
	}.run(key);
    }

    @Override
    public Long sadd(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sadd(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> smembers(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.smembers(key);
	    }
	}.run(key);
    }

    @Override
    public Long srem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.srem(key, member);
	    }
	}.run(key);
    }

    @Override
    public String spop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.spop(key);
	    }
	}.run(key);
    }

    @Override
    public Long scard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.scard(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean sismember(final String key, final String member) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.sismember(key, member);
	    }
	}.run(key);
    }

    @Override
    public String srandmember(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.srandmember(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> srandmember(final String key, final int count) {
        return new JedisClusterCommand<List<String>>(connectionHandler, timeout,
            maxRedirections) {
            @Override
            public List<String> execute(Jedis connection) {
            return connection.srandmember(key, count);
            }
        }.run(key);
    }

    @Override
    public Long strlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.strlen(key);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final double score, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zadd(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final Map<String, Double> scoreMembers) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.zadd(key, scoreMembers);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrange(final String key, final long start, final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection
			.zrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zrem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrem(key, member);
	    }
	}.run(key);
    }

    @Override
    public Double zincrby(final String key, final double score,
	    final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zincrby(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Long zrevrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrevrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrange(key, start,
			end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrangeWithScores(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrevrangeWithScores(
			key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zcard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcard(key);
	    }
	}.run(key);
    }

    @Override
    public Double zscore(final String key, final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zscore(key, member);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key,
	    final SortingParams sortingParameters) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key,
			sortingParameters);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final double min, final double max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByRank(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByRank(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final double start,
	    final double end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final String start,
	    final String end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }
    
    @Override
    public Long zlexcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long linsert(final String key, final LIST_POSITION where,
	    final String pivot, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.linsert(key, where,
			pivot, value);
	    }
	}.run(key);
    }

    @Override
    public Long lpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long rpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpushx(key, string);
	    }
	}.run(key);
    }
    
    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, key);
	    }
	}.run(key);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, key);
	    }
	}.run(key);
    }


    @Override
    public List<String> blpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(arg);
	    }
	}.run(arg);
    }

    @Override
    public List<String> brpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(arg);
	    }
	}.run(arg);
    }

    @Override
    public Long del(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(key);
	    }
	}.run(key);
    }

    @Override
    public String echo(final String string) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.echo(string);
	    }
	}.run(null);
    }

    @Override
    public Long move(final String key, final int dbIndex) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.move(key, dbIndex);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key, final long start, final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key, start,
			end);
	    }
	}.run(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final String cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(key);
    }
    
    @Override
    public ScanResult<String> sscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(key);
    }
    
    @Override
    public ScanResult<Tuple> zscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(key);
    }

    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
=======
  public static enum Reset {
    SOFT, HARD
  }

  public JedisCluster(Set<HostAndPort> nodes) {
    this(nodes, DEFAULT_TIMEOUT);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout) {
    this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, int maxRedirections) {
    this(nodes, timeout, maxRedirections, new GenericObjectPoolConfig());
  }

  public JedisCluster(Set<HostAndPort> nodes, final GenericObjectPoolConfig poolConfig) {
    this(nodes, DEFAULT_TIMEOUT, DEFAULT_MAX_REDIRECTIONS, poolConfig);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, final GenericObjectPoolConfig poolConfig) {
    this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, poolConfig);
  }

  public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout, int maxRedirections,
      final GenericObjectPoolConfig poolConfig) {
    super(jedisClusterNode, timeout, maxRedirections, poolConfig);
  }

  public Map<String, JedisPool> getClusterNodes() {
    return connectionHandler.getNodes();
  }

  @Override
  public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler, maxRedirections) {
      @Override
      public Object execute(Jedis connection) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8558487_ca59f9b/rev_8558487-ca59f9b/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, timeout, maxRedirections) {
=======
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.del(key);
      }
    }.run(key);
  }

  @Override
  public String echo(final String string) {
    // note that it'll be run from arbitary node
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.echo(string);
      }
    }.run(string);
  }

  @Override
  public Long bitcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
    	@Ignore
    	@Test
    	public String methodToBeMatched() {
    		return "jupiter";
    	}

    	@Ignore
    	@Test
    	public int methodOfWrongType() {
    		return 0;
=======
        @Ignore
        @Test
        public int methodC() {
            return 0;
        }

        @Ignore
        @Test
        public String methodA() {
            return "jupiter";
        }
    	
        @Ignore
        @Test
        public int methodB() {
            return 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f03bc79_eb8b5ee/rev_f03bc79-eb8b5ee/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
        JUnitCoreTest.class,
        FailOnTimeoutTest.class
=======
        FrameworkFieldTest.class,
        FrameworkMethodTest.class,
        JUnitCoreTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_60c1bdf_8851c49/rev_60c1bdf-8851c49/src/main/java/redis/clients/util/Pool.java;<<<<<<< MINE
  protected void returnResourceObject(final T resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnResourceObject(final T resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
   * @param nxxx NX|XX, NX -- Only set the key if it does not already exist. XX -- Only set the key
   *          if it already exist.
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of <code>expx</code>
=======
   * @param params
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final long time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
=======
  public String set(final byte[] key, final byte[] value, final SetParams params) {
    checkIsInMulti();
    client.set(key, value, params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of <code>expx</code>
=======
   *          EX|PX, expire time units: EX = seconds; PX = milliseconds
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
  @Override
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
=======
  public String set(final String key, final String value, final SetParams params) {
    checkIsInMulti();
    client.set(key, value, params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    set(SafeEncoder.encode(key), SafeEncoder.encode(value), SafeEncoder.encode(nxxx),
      SafeEncoder.encode(expx), time);
=======
  public void set(final String key, final String value, final SetParams params) {
    set(SafeEncoder.encode(key), SafeEncoder.encode(value), params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE
  @Override
  public String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time) {
=======
  public String set(byte[] key, byte[] value, SetParams params) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
  @Override
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
=======
  public void exists(final String... keys) {
    final byte[][] bkeys = SafeEncoder.encodeMany(keys);
    exists(bkeys);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_fe17537_45f2265/rev_fe17537-45f2265/src/main/java/org/junit/rules/Timeout.java;<<<<<<< MINE
 *  public Timeout globalTimeout= new Timeout(20);
=======
 *  public Timeout globalTimeout = Timeout.millis(20);
>>>>>>> YOURS
