file;linedbasedConf
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/main/java/org/junit/runner/Result.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/main/java/org/junit/runner/Result.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/main/java/org/junit/runner/Result.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/test/java/org/junit/tests/running/methods/TestMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
    public static final byte DOLLAR_BYTE = DOLLAR.getBytes(CHARSET)[0];
    public static final byte ASTERISK_BYTE = ASTERISK.getBytes(CHARSET)[0];
    public static final byte PLUS_BYTE = PLUS.getBytes(CHARSET)[0];
    public static final byte MINUS_BYTE = MINUS.getBytes(CHARSET)[0];
    public static final byte COLON_BYTE = COLON.getBytes(CHARSET)[0];

    public void sendCommand(DataOutputStream os, String name, String... args) {
	    StringBuilder sb = new StringBuilder();
	    sb.append(ASTERISK);
	    sb.append((new Integer(args.length + 1)).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(DOLLAR);
	    sb.append((new Integer(name.length())).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(name);
	    sb.append(COMMAND_DELIMITER);

	    for (String arg : args) {
		int size = arg.getBytes(CHARSET).length;

		sb.append(DOLLAR);
		sb.append((new Integer(size)).toString());
		sb.append(COMMAND_DELIMITER);
		sb.append(arg);
		sb.append(COMMAND_DELIMITER);
	    }

		try {
		    os.write(sb.toString().getBytes(CHARSET));
	    /*
	    os.write(ASTERISK_BYTE);
	    os.write((new Integer(args.length + 1)).toString()
		    .getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(DOLLAR_BYTE);
	    os.write((new Integer(name.length())).toString().getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(name.getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);

	    for (String arg : args) {
		byte[] barg = arg.getBytes(CHARSET);

		os.write(DOLLAR_BYTE);
		os.write((new Integer(barg.length)).toString()
			.getBytes(CHARSET));
		os.write(COMMAND_DELIMITER_BYTES);
		os.write(barg);
		os.write(COMMAND_DELIMITER_BYTES);
	    }
	    */
	} catch (IOException e) {
	    throw new JedisException(e);
	}
    }

    public void processError(DataInputStream is) {
	String message = readLine(is);
	throw new JedisException(message);
    }

    private String readLine(DataInputStream is) {
	byte b;
	byte c;
	StringBuilder sb = new StringBuilder();

	try {
	    while ((b = is.readByte()) != -1) {
		if (b == '\r') {
		    c = is.readByte();
		    if (c == '\n') {
			break;
		    }
		    sb.append((char) b);
		    sb.append((char) c);
		} else {
		    sb.append((char) b);
		}
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return sb.toString();
    }

    private Object process(DataInputStream is) {
	try {
	    byte b = is.readByte();
	    if (b == MINUS_BYTE) {
		processError(is);
	    } else if (b == ASTERISK_BYTE) {
		return processMultiBulkReply(is);
	    } else if (b == COLON_BYTE) {
		return processInteger(is);
	    } else if (b == DOLLAR_BYTE) {
		return processBulkReply(is);
	    } else if (b == PLUS_BYTE) {
		return processStatusCodeReply(is);
	    } else {
		throw new JedisException("Unknown reply: " + (char) b);
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return null;
    }

    private Object processStatusCodeReply(DataInputStream is) {
	String ret = null;
	ret = readLine(is);
	return ret;
    }

    private Object processBulkReply(DataInputStream is) {
	int len = Integer.parseInt(readLine(is));
	if (len == -1) {
	    return null;
	}
	byte[] read = new byte[len];
	int offset = 0;
	try {
		while(offset < len) {
		    offset += is.read(read, offset, (len - offset));
		}
	    // read 2 more bytes for the command delimiter
	    is.read();
	    is.read();
	} catch (IOException e) {
	    throw new JedisException(e);
	}

	return new String(read, CHARSET);
    }

    private Object processInteger(DataInputStream is) {
	int ret = 0;
	String num = readLine(is);
	ret = Integer.parseInt(num);
	return ret;
    }

    private Object processMultiBulkReply(DataInputStream is) {
	int num = Integer.parseInt(readLine(is));
	if (num == -1) {
	    return null;
	}
	List<Object> ret = new ArrayList<Object>();
	for (int i = 0; i < num; i++) {
	    ret.add(process(is));
	}
	return ret;
||||||| BASE
    public static final byte DOLLAR_BYTE = DOLLAR.getBytes(CHARSET)[0];
    public static final byte ASTERISK_BYTE = ASTERISK.getBytes(CHARSET)[0];
    public static final byte PLUS_BYTE = PLUS.getBytes(CHARSET)[0];
    public static final byte MINUS_BYTE = MINUS.getBytes(CHARSET)[0];
    public static final byte COLON_BYTE = COLON.getBytes(CHARSET)[0];

    public void sendCommand(DataOutputStream os, String name, String... args) {
	    StringBuilder sb = new StringBuilder();
	    sb.append(ASTERISK);
	    sb.append((new Integer(args.length + 1)).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(DOLLAR);
	    sb.append((new Integer(name.length())).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(name);
	    sb.append(COMMAND_DELIMITER);

	    for (String arg : args) {
		int size = arg.getBytes(CHARSET).length;

		sb.append(DOLLAR);
		sb.append((new Integer(size)).toString());
		sb.append(COMMAND_DELIMITER);
		sb.append(arg);
		sb.append(COMMAND_DELIMITER);
	    }

		try {
		    os.write(sb.toString().getBytes(CHARSET));
	    /*
	    os.write(ASTERISK_BYTE);
	    os.write((new Integer(args.length + 1)).toString()
		    .getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(DOLLAR_BYTE);
	    os.write((new Integer(name.length())).toString().getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(name.getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);

	    for (String arg : args) {
		byte[] barg = arg.getBytes(CHARSET);

		os.write(DOLLAR_BYTE);
		os.write((new Integer(barg.length)).toString()
			.getBytes(CHARSET));
		os.write(COMMAND_DELIMITER_BYTES);
		os.write(barg);
		os.write(COMMAND_DELIMITER_BYTES);
	    }
	    */
	} catch (IOException e) {
	    throw new JedisException(e);
	}
    }

    public void processError(DataInputStream is) {
	String message = readLine(is);
	throw new JedisException(message);
    }

    private String readLine(DataInputStream is) {
	byte b;
	byte c;
	StringBuilder sb = new StringBuilder();

	try {
	    while ((b = is.readByte()) != -1) {
		if (b == '\r') {
		    c = is.readByte();
		    if (c == '\n') {
			break;
		    }
		    sb.append((char) b);
		    sb.append((char) c);
		} else {
		    sb.append((char) b);
		}
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return sb.toString();
    }

    private Object process(DataInputStream is) {
	try {
	    byte b = is.readByte();
	    if (b == MINUS_BYTE) {
		processError(is);
	    } else if (b == ASTERISK_BYTE) {
		return processMultiBulkReply(is);
	    } else if (b == COLON_BYTE) {
		return processInteger(is);
	    } else if (b == DOLLAR_BYTE) {
		return processBulkReply(is);
	    } else if (b == PLUS_BYTE) {
		return processStatusCodeReply(is);
	    } else {
		throw new JedisException("Unknown reply: " + (char) b);
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return null;
    }

    private Object processStatusCodeReply(DataInputStream is) {
	String ret = null;
	ret = readLine(is);
	return ret;
    }

    private Object processBulkReply(DataInputStream is) {
	int len = Integer.parseInt(readLine(is));
	if (len == -1) {
	    return null;
	}
	byte[] read = new byte[len];
	try {
	    is.read(read);
	    // read 2 more bytes for the command delimiter
	    is.read();
	    is.read();
	} catch (IOException e) {
	    throw new JedisException(e);
	}

	return new String(read, CHARSET);
    }

    private Object processInteger(DataInputStream is) {
	int ret = 0;
	String num = readLine(is);
	ret = Integer.parseInt(num);
	return ret;
    }

    private Object processMultiBulkReply(DataInputStream is) {
	int num = Integer.parseInt(readLine(is));
	if (num == -1) {
	    return null;
	}
	List<Object> ret = new ArrayList<Object>();
	for (int i = 0; i < num; i++) {
	    ret.add(process(is));
	}
	return ret;
=======
    public static final byte DOLLAR_BYTE = '$';
    public static final byte ASTERISK_BYTE = '*';
    public static final byte PLUS_BYTE = '+';
    public static final byte MINUS_BYTE = '-';
    public static final byte COLON_BYTE = ':';

    public void sendCommand(RedisOutputStream os, String name, String... args) {
        try {
            os.write(ASTERISK_BYTE);
            os.writeIntCrLf(args.length + 1);
            os.write(DOLLAR_BYTE);
            os.writeIntCrLf(name.length());
            os.writeAsciiCrLf(name);

            for (String str : args) {
                os.write(DOLLAR_BYTE);
                final int size = RedisOutputStream.utf8Length(str);
                os.writeIntCrLf(size);
                if (size == str.length())
                    os.writeAsciiCrLf(str);
                else {
                    os.writeUtf8CrLf(str);
                }
            }
            os.flush();
        } catch (IOException e) {
            throw new JedisException(e);
        }
    }

    private void processError(RedisInputStream is) {
        String message = is.readLine();
        throw new JedisException(message);
    }

    private Object process(RedisInputStream is) {
        try {
            byte b = is.readByte();
            if (b == MINUS_BYTE) {
                processError(is);
            } else if (b == ASTERISK_BYTE) {
                return processMultiBulkReply(is);
            } else if (b == COLON_BYTE) {
                return processInteger(is);
            } else if (b == DOLLAR_BYTE) {
                return processBulkReply(is);
            } else if (b == PLUS_BYTE) {
                return processStatusCodeReply(is);
            } else {
                throw new JedisException("Unknown reply: " + (char) b);
            }
        } catch (IOException e) {
            throw new JedisException(e);
        }
        return null;
    }

    private String processStatusCodeReply(RedisInputStream is) {
        return is.readLine();
    }

    private String processBulkReply(RedisInputStream is) {
        int len = Integer.parseInt(is.readLine());
        if (len == -1) {
            return null;
        }
        byte[] read = new byte[len];
        int offset = 0;
        try {
            while (offset < len) {
                offset += is.read(read, offset, (len - offset));
            }
            // read 2 more bytes for the command delimiter
            is.readByte();
            is.readByte();
        } catch (IOException e) {
            throw new JedisException(e);
        }

        return new String(read, CHARSET);
    }

    private Integer processInteger(RedisInputStream is) {
        String num = is.readLine();
        return Integer.valueOf(num);
    }

    private List<Object> processMultiBulkReply(RedisInputStream is) {
        int num = Integer.parseInt(is.readLine());
        if (num == -1) {
            return null;
        }
        List<Object> ret = new ArrayList<Object>(num);
        for (int i = 0; i < num; i++) {
            ret.add(process(is));
        }
        return ret;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/test/java/redis/clients/jedis/tests/FragmentedByteArrayInputStream.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/test/java/redis/clients/jedis/tests/ProtocolTest.java;<<<<<<< MINE
    public void fragmentedBulkReply() {
    	FragmentedByteArrayInputStream fis = new FragmentedByteArrayInputStream("$30\r\n012345678901234567890123456789\r\n".getBytes());
    	Protocol protocol = new Protocol();
    	String response = (String) protocol.read(new DataInputStream(fis));
    	assertEquals("012345678901234567890123456789", response);
    	assertEquals(3, fis.getReadMethodCallCount());
    }

    
    @Test
||||||| BASE
=======
    public void fragmentedBulkReply() {
    	FragmentedByteArrayInputStream fis = new FragmentedByteArrayInputStream("$30\r\n012345678901234567890123456789\r\n".getBytes());
    	Protocol protocol = new Protocol();
    	String response = (String) protocol.read(new RedisInputStream(fis));
    	assertEquals("012345678901234567890123456789", response);
//    	assertEquals(3, fis.getReadMethodCallCount());
    }

    
    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/Request.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/junit3compatibility/OldTestClassAdaptingListenerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/junit3compatibility/OldTestClassAdaptingListenerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jeromq/revisions/rev_422e861_d89fa27/rev_422e861-d89fa27/src/test/java/org/jeromq/TestZLoop.java;<<<<<<< MINE
        loop.pollerEnd(poll_input);
        ctx.destroy();
        //  @end
        printf ("OK\n");
    }
    
    @Test(timeout = 1000)
    public void testZLoopEndReactorFromTimer() {
        printf (" * zloop end reactor from timer: ");
        int rc = 0;
        //  @selftest
        ZContext ctx = new ZContext ();
        assert (ctx != null);
        
        Socket output = ctx.createSocket(ZMQ.PAIR);
        assert (output != null);
        output.bind("inproc://zloop.test");
        Socket input = ctx.createSocket(ZMQ.PAIR);
        assert (input != null);
        input.connect( "inproc://zloop.test");

        ZLoop loop = ZLoop.instance();
        assert (loop != null);
        loop.verbose (true);
        
        ZLoop.IZLoopHandler s_timer_event = new ZLoop.IZLoopHandler() {

            @Override
            public int handle(ZLoop loop, PollItem item, Object arg) {
                ((Socket)arg).send("PING", 0);
                return 0;
            }
        };
        
        ZLoop.IZLoopHandler s_socket_event = new ZLoop.IZLoopHandler() {

            @Override
            public int handle(ZLoop loop, PollItem item, Object arg) {
                //  After 10 msecs, fire an event that ends the reactor
            	ZLoop.IZLoopHandler s_shutdown_event = new ZLoop.IZLoopHandler() {
                    @Override
                    public int handle(ZLoop loop, PollItem item, Object arg) {
                    	//  Just end the reactor
                        return -1;
                    }
                };
                loop.timer(10, 1, s_shutdown_event, s_shutdown_event);
                return 0;
            }
        };

        //  Fire event that sends a ping message to output
        loop.timer (0, 1, s_timer_event, output);
        
        //  When we get the ping message, end the reactor
        PollItem poll_input = new PollItem( input, ZMQ.POLLIN );
        rc = loop.poller (poll_input, s_socket_event, null);
        assert (rc == 0);
        loop.start ();

        loop.pollerEnd(poll_input);
||||||| BASE
=======
        loop.pollerEnd(poll_input);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jeromq/revisions/rev_422e861_d89fa27/rev_422e861-d89fa27/src/test/java/org/jeromq/TestZLoop.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_e4ee2c0_f454880/rev_e4ee2c0-f454880/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	private static String host = "localhost";
	private static int port = Protocol.DEFAULT_PORT;
	
	static {
		final String envHost = System.getProperty("redis-host");
		final String envPort = System.getProperty("redis-port");
		if (null != envHost && 0 < envHost.length()) {
			host = envHost;
		}
		if (null != envPort && 0 < envPort.length()) {
			try {
				port = Integer.parseInt(envPort);
			} catch (final NumberFormatException e) {}
		}
		
		System.out.println("Redis host to be used : " + host + ":" + port);
	}
	
	@Test
	public void checkConnections() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port, 2000);
		pool.setResourcesNumber(10);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "bar");
		assertEquals("bar", jedis.get("foo"));
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test
	public void checkConnectionWithDefaultPort() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(10);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "bar");
		assertEquals("bar", jedis.get("foo"));
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test
	public void checkJedisIsReusedWhenReturned() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "0");
		pool.returnResource(jedis);

		jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.incr("foo");
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test
	public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
			IOException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.quit();
		pool.returnBrokenResource(jedis);

		jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.incr("foo");
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test(expected = TimeoutException.class)
	public void checkPoolOverflow() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "0");

		Jedis newJedis = pool.getResource(200);
		newJedis.auth("foobared");
		newJedis.incr("foo");
	}
||||||| BASE
    @Test
    public void checkConnections() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT, 2000);
	pool.setResourcesNumber(10);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkConnectionWithDefaultPort() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(10);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkJedisIsReusedWhenReturned() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "0");
	pool.returnResource(jedis);

	jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
	    IOException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.quit();
	pool.returnBrokenResource(jedis);

	jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test(expected = TimeoutException.class)
    public void checkPoolOverflow() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.auth("foobared");
	jedis.set("foo", "0");

	Jedis newJedis = pool.getResource(200);
	newJedis.auth("foobared");
	newJedis.incr("foo");
    }
=======
    @Test
    public void checkConnections() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(10);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkConnectionWithDefaultPort() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(10);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkJedisIsReusedWhenReturned() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "0");
	pool.returnResource(jedis);

	jedis = pool.getResource(200);
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
	    IOException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.quit();
	pool.returnBrokenResource(jedis);

	jedis = pool.getResource(200);
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test(expected = TimeoutException.class)
    public void checkPoolOverflow() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "0");

	Jedis newJedis = pool.getResource(200);
	newJedis.incr("foo");
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/junit/runner/Version.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ef92925_469dcc7/rev_ef92925-469dcc7/src/main/java/junit/runner/Version.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/JedisPool.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/JedisShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/JedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/JedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis implements JedisCommands {
    private Client client = null;
    private String password = null;

    public Jedis(String host) {
        client = new Client(host);
||||||| BASE
public class Jedis implements JedisCommands {
    private Client client = null;

    public Jedis(String host) {
        client = new Client(host);
=======
public class Jedis extends BinaryJedis implements JedisCommands {
    public Jedis(final String host) {
        super(host);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Jedis(JedisShardInfo shardInfo) {
        client = new Client(shardInfo.getHost(), shardInfo.getPort());
        client.setTimeout(shardInfo.getTimeout());
        this.password = shardInfo.getPassword();
    }

    public String ping() {
        runChecks();
        client.ping();
        return client.getStatusCodeReply();
||||||| BASE
    public Jedis(JedisShardInfo shardInfo) {
        client = new Client(shardInfo.getHost(), shardInfo.getPort());
        client.setTimeout(shardInfo.getTimeout());
        if (shardInfo.getPassword() != null) {
            this.auth(shardInfo.getPassword());
        }
    }

    public String ping() {
        checkIsInMulti();
        client.ping();
        return client.getStatusCodeReply();
=======
    public Jedis(final JedisShardInfo shardInfo) {
    	super(shardInfo);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Ask the server to silently close the connection.
     */
    public void quit() {
        runChecks();
        client.quit();
    }

    /**
||||||| BASE
     * Ask the server to silently close the connection.
     */
    public void quit() {
        checkIsInMulti();
        client.quit();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Delete all the keys of the currently selected DB. This command never
     * fails.
     * 
     * @return Status code reply
     */
    public String flushDB() {
        runChecks();
        client.flushDB();
        return client.getStatusCodeReply();
    }

    /**
||||||| BASE
     * Delete all the keys of the currently selected DB. This command never
     * fails.
     * 
     * @return Status code reply
     */
    public String flushDB() {
        checkIsInMulti();
        client.flushDB();
        return client.getStatusCodeReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Return the number of keys in the currently selected database.
     * 
     * @return Integer reply
     */
    public Integer dbSize() {
        runChecks();
        client.dbSize();
        return client.getIntegerReply();
    }

    /**
||||||| BASE
     * Return the number of keys in the currently selected database.
     * 
     * @return Integer reply
     */
    public Integer dbSize() {
        checkIsInMulti();
        client.dbSize();
        return client.getIntegerReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Select the DB with having the specified zero-based numeric index. For
     * default every new client connection is automatically selected to DB 0.
     * 
     * @param index
     * @return Status code reply
     */
    public String select(int index) {
        runChecks();
        client.select(index);
        return client.getStatusCodeReply();
    }

    /**
||||||| BASE
     * Select the DB with having the specified zero-based numeric index. For
     * default every new client connection is automatically selected to DB 0.
     * 
     * @param index
     * @return Status code reply
     */
    public String select(int index) {
        checkIsInMulti();
        client.select(index);
        return client.getStatusCodeReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Delete all the keys of all the existing databases, not just the currently
     * selected one. This command never fails.
     * 
     * @return Status code reply
     */
    public String flushAll() {
        runChecks();
        client.flushAll();
        return client.getStatusCodeReply();
    }

    /**
||||||| BASE
     * Delete all the keys of all the existing databases, not just the currently
     * selected one. This command never fails.
     * 
     * @return Status code reply
     */
    public String flushAll() {
        checkIsInMulti();
        client.flushAll();
        return client.getStatusCodeReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Transaction multi() {
        client.multi();
        client.getStatusCodeReply();
        return new Transaction(client);
    }

    public List<Object> multi(TransactionBlock jedisTransaction) {
        List<Object> results = null;
        try {
            jedisTransaction.setClient(client);
            multi();
            jedisTransaction.execute();
            results = jedisTransaction.exec();
        } catch (Exception ex) {
            client.discard();
        }
        return results;
    }

    private void runChecks() {
        if (client.isInMulti()) {
            throw new JedisException(
                    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
        }
        try {
            this.connect();
        } catch (UnknownHostException e) {
            throw new JedisException(e);
        } catch (IOException e) {
            throw new JedisException(e);
        }
    }

    public void connect() throws UnknownHostException, IOException {
        if (!client.isConnected()) {
            client.connect();
            if (this.password != null) {
                this.auth(this.password);
            }
        }
    }

    public void disconnect() throws IOException {
        client.disconnect();
    }

    public String watch(String key) {
||||||| BASE
    public Transaction multi() {
        client.multi();
        client.getStatusCodeReply();
        return new Transaction(client);
    }

    public List<Object> multi(TransactionBlock jedisTransaction) {
        List<Object> results = null;
        try {
            jedisTransaction.setClient(client);
            multi();
            jedisTransaction.execute();
            results = jedisTransaction.exec();
        } catch (Exception ex) {
            client.discard();
        }
        return results;
    }

    private void checkIsInMulti() {
        if (client.isInMulti()) {
            throw new JedisException(
                    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
        }
    }

    public void connect() throws UnknownHostException, IOException {
        client.connect();
    }

    public void disconnect() throws IOException {
        client.disconnect();
    }

    public String watch(String key) {
=======
    public String watch(final String key) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(String password) {
        runChecks();
        client.auth(password);
        return client.getStatusCodeReply();
    }

    public List<Object> pipelined(JedisPipeline jedisPipeline) {
        jedisPipeline.setClient(client);
        jedisPipeline.execute();
        return client.getAll();
    }

    public void subscribe(JedisPubSub jedisPubSub, String... channels) {
        client.setTimeoutInfinite();
        jedisPubSub.proceed(client, channels);
        client.rollbackTimeout();
    }

    public Integer publish(String channel, String message) {
        client.publish(channel, message);
        return client.getIntegerReply();
    }

    public void psubscribe(JedisPubSub jedisPubSub, String... patterns) {
        client.setTimeoutInfinite();
        jedisPubSub.proceedWithPatterns(client, patterns);
        client.rollbackTimeout();
    }

    public Integer zcount(String key, double min, double max) {
        runChecks();
||||||| BASE
    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(String password) {
        checkIsInMulti();
        client.auth(password);
        return client.getStatusCodeReply();
    }

    public List<Object> pipelined(JedisPipeline jedisPipeline) {
        jedisPipeline.setClient(client);
        jedisPipeline.execute();
        return client.getAll();
    }

    public void subscribe(JedisPubSub jedisPubSub, String... channels) {
        client.setTimeoutInfinite();
        jedisPubSub.proceed(client, channels);
        client.rollbackTimeout();
    }

    public Integer publish(String channel, String message) {
        client.publish(channel, message);
        return client.getIntegerReply();
    }

    public void psubscribe(JedisPubSub jedisPubSub, String... patterns) {
        client.setTimeoutInfinite();
        jedisPubSub.proceedWithPatterns(client, patterns);
        client.rollbackTimeout();
    }

    public Integer zcount(String key, double min, double max) {
        checkIsInMulti();
=======
    public Integer zcount(final String key, final double min, final double max) {
        checkIsInMulti();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
    protected Connection sendCommand(String name, String... args) {
        protocol.sendCommand(outputStream, name, args);
||||||| BASE
    protected Connection sendCommand(String name, String... args) {
        try {
            connect();
        } catch (UnknownHostException e) {
            throw new JedisException("Could not connect to redis-server", e);
        } catch (IOException e) {
            throw new JedisException("Could not connect to redis-server", e);
        }
        protocol.sendCommand(outputStream, name, args);
=======
    protected Connection sendCommand(final Command cmd, final String... args) {
    	final byte[][] bargs = new byte[args.length][];
    	for(int i=0; i < args.length; i++) {
    		bargs[i] = args[i].getBytes(Protocol.UTF8);
    	}
    	return sendCommand(cmd, bargs);
    }

    protected Connection sendCommand(final Command cmd, final byte[]... args) {
        try {
            connect();
        } catch (UnknownHostException e) {
            throw new JedisException("Could not connect to redis-server", e);
        } catch (IOException e) {
            throw new JedisException("Could not connect to redis-server", e);
        }
        protocol.sendCommand(outputStream, cmd, args);
        pipelinedCommands++;
        return this;
    }

    protected Connection sendCommand(final Command cmd) {
        try {
            connect();
        } catch (UnknownHostException e) {
            throw new JedisException("Could not connect to redis-server", e);
        } catch (IOException e) {
            throw new JedisException("Could not connect to redis-server", e);
        }
        protocol.sendCommand(outputStream, cmd, new byte[0][]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/junit/runner/Version.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/AfterClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/Interceptor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/StatementInterceptor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/experimental/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/running/classes/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/running/classes/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_11f0abd_8b507d7/rev_11f0abd-8b507d7/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE

||||||| BASE
	
//	public static MaxHistory forFolder(String folder) {
//		File serializedFile= new File(folder + ".ser");
//		try {
//			if (serializedFile.exists())
//				return readHistory(folder);
//		} catch (CouldNotReadCoreException e) {
//			e.printStackTrace();
//			serializedFile.delete();
//		}
//		return new MaxHistory(folder);
//	}

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Transaction.java;<<<<<<< MINE
    public String setbit(String key, long offset, boolean value) {
||||||| BASE
    public String setbit(String key, long offset, String value) {
=======
    public void setbit(String key, long offset, String value) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Transaction.java;<<<<<<< MINE
        return client.getStatusCodeReply() == "1";
    }

    public long setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
        return client.getIntegerReply();
    }

    public String getrange(String key, long startOffset, long endOffset) {
        client.getrange(key, startOffset, endOffset);
        return client.getBulkReply();
||||||| BASE
        return client.getStatusCodeReply();
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        while (pipelinedCommands > 0) {
||||||| BASE
        while (pipelinedCommands > 0) {
=======
        while (pipelinedCommands > except) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/junit/runner/Version.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/ExactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}

	private static <T> Runner parallelize(ParentRunner<T> runner)
			throws InitializationError {
		return new ParallelParentRunner<T>(runner);
	}

	private static class ParallelParentRunner<T> extends ParentRunner<T> {
		private final ParentRunner<T> fDelegate;

		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

		private final ExecutorService fService= Executors.newCachedThreadPool();

		public ParallelParentRunner(ParentRunner<T> delegate)
				throws InitializationError {
			super(delegate.getTestClass().getJavaClass());
			fDelegate= delegate;
||||||| BASE
	
//TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
=======
	
	// TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE

||||||| BASE
		private ExecutorService fService= Executors.newCachedThreadPool();
		private List<Future<Object>> fResults= new ArrayList<Future<Object>>();
	
=======
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public Description describeChild(T child) {
			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
			return fDelegate.internalDescribeChild(child);
||||||| BASE
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fResults.add(fService.submit(callable));
=======
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fCollator.process(callable);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public List<T> getChildren() {
			return fDelegate.internalGetChildren();
||||||| BASE
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fResults)
				try {
					each.get(2000, TimeUnit.MILLISECONDS);
				} catch (Exception e) {
					e.printStackTrace();
				} 
=======
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fCollator.results)
				try {
					each.get();
				} catch (Exception e) {
					e.printStackTrace();
				} 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
||||||| BASE
	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		private ExecutorService fService= Executors.newCachedThreadPool();
		private List<Future<Object>> fResults= new ArrayList<Future<Object>>();
	
=======
	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
			}));
||||||| BASE
			};
			fResults.add(fService.submit(callable));
=======
			};
			fCollator.process(callable);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runner/Computer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runner/Request.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runner/Request.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Timeout.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE

	public void starting(FrameworkMethod method) throws Exception {
	}

	public void finished(FrameworkMethod method) {
	}
||||||| BASE
=======

	public void starting(FrameworkMethod method) {
	}

	public void finished(FrameworkMethod method) {
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/test/java/org/junit/tests/experimental/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/test/java/org/junit/tests/experimental/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private RunnerInterceptor fRunnerInterceptor= new RunnerInterceptor() {	
		public void runChild(Runnable childStatement) {
			childStatement.run();
		}
	
		public void finished() {
			// do nothing
		}
	};

||||||| BASE
=======
	private Decorator fDecorator= new Decorator() {
		public void runAll(SafeStatement statement) {
			statement.execute();
		}

		public void runChild(SafeStatement statement) {
			statement.execute();
		}
	};

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		
||||||| BASE
	
	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows delegation without breaking subclasses
	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public List<T> internalGetChildren() {
		return getChildren();
	}

	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public Description internalDescribeChild(T child) {
		return describeChild(child);
	}

	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public void internalRunChild(T child, RunNotifier notifier) {
		runChild(child, notifier);
	}
	
=======

	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows
	// delegation without breaking subclasses
	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public List<T> internalGetChildren() {
		return getChildren();
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public Description internalDescribeChild(T child) {
		return describeChild(child);
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public void internalRunChild(T child, RunNotifier notifier) {
		runChild(child, notifier);
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

	public void setRunnerInterceptor(RunnerInterceptor runnerInterceptor) {
		this.fRunnerInterceptor = runnerInterceptor;
	}
||||||| BASE
=======

	// TODO (May 11, 2009 2:53:54 PM): complex
	public void installDecorator(Decorator decorator) {
		this.fDecorator= decorator;
	}

	// TODO (May 11, 2009 4:19:18 PM): move?
	public boolean isSuite() {
		return false;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;
||||||| BASE
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;
import org.junit.runners.model.RunnerInterceptor;
||||||| BASE
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;
=======
import org.junit.tests.SafeStatement;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	private static <T> Runner parallelize(ParentRunner<T> runner) {
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runChild(final Runnable childStatement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						childStatement.run();
						return null;
					}
				}));
			}

			public void finished() {
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
		});
		return runner;
	}

||||||| BASE
	private static <T> Runner parallelize(ParentRunner<T> runner)
			throws InitializationError {
		return new ParallelParentRunner<T>(runner);
	}

	private static class ParallelParentRunner<T> extends ParentRunner<T> {
		private final ParentRunner<T> fDelegate;

		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

		private final ExecutorService fService= Executors.newCachedThreadPool();

		public ParallelParentRunner(ParentRunner<T> delegate)
				throws InitializationError {
			super(delegate.getTestClass().getJavaClass());
			fDelegate= delegate;
		}

		@Override
		public Description describeChild(T child) {
			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
			return fDelegate.internalDescribeChild(child);
		}

		@Override
		public List<T> getChildren() {
			return fDelegate.internalGetChildren();
		}

		@Override
		public void runChild(final T child, final RunNotifier notifier) {
			fResults.add(fService.submit(new Callable<Object>() {
				public Object call() throws Exception {
					fDelegate.internalRunChild(child, notifier);
					return null;
				}
			}));
		}

		@Override
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fResults)
				try {
					each.get();
				} catch (Exception e) {
					e.printStackTrace();
				}
		}
	}

=======
	private static void parallelize(Runner runner) {
		((ParentRunner<?>) runner).installDecorator(new ParentRunner.Decorator() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runAll(SafeStatement statement) {
				statement.execute();
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}

			}

			public void runChild(final SafeStatement statement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						statement.execute();
						return null;
					}
				}));
			}
		});
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
||||||| BASE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
=======
	private boolean shouldParallelize(Runner runner) {
		if (runner instanceof ParentRunner) {
			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
			if (fClasses && parentRunner.isSuite())
				return true;
			if (fMethods && !parentRunner.isSuite())
				return true;
		}
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
package org.junit.tests;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerInterceptor;

public class ParentRunnerTest {
	public static String log= "";

	public static class FruitTest {
		@Test
		public void apple() {
			log+= "apple ";
		}

		@Test
		public void banana() {
			log+= "banana ";
		}
	}

	@Test
	public void useChildHarvester() throws InitializationError {
		log= "";
		ParentRunner<?> runner= new BlockJUnit4ClassRunner(FruitTest.class);
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			public void runChild(Runnable childStatement) {
				log+= "before ";
				childStatement.run();
				log+= "after ";
			}

			public void finished() {
				log+= "afterAll ";
			}
		});

		runner.run(new RunNotifier());
		assertEquals("before apple after before banana after afterAll ", log);
	}
}||||||| BASE
=======
package org.junit.tests;

import static org.junit.Assert.assertEquals;

import java.util.Comparator;

import org.junit.Test;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Sorter;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.FrameworkMethod;

// TODO (May 11, 2009 2:42:38 PM): move package

public class ParentRunnerTest {
	private static StringBuffer log= new StringBuffer();

	public static class FruitTests {
		@Test
		public void apple() {
			log.append("apple ");
		}

		@Test
		public void banana() {
			log.append("banana ");
		}

		@Test
		public void pear() {
			log.append("pear ");
		}
	}

	@Test
	public void installDecorator() throws Throwable {
		log.setLength(0);
		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
				true).runnerForClass(FruitTests.class);
		// TODO (May 11, 2009 2:58:11 PM): DUP?
		runner.sort(new Sorter(new Comparator<Description>() {
			public int compare(Description o1, Description o2) {
				return o1.toString().compareTo(o2.toString());
			}
		}));
		runner.installDecorator(new ParentRunner.Decorator() {
			public void runChild(SafeStatement statement) {
				log.append("before ");
				statement.execute();
				log.append("after ");
			}

			public void runAll(SafeStatement statement) {
				log.append("beforeAll ");
				statement.execute();
				log.append("afterAll ");
			}
		});

		runner.run(new RunNotifier());
		assertEquals(
				"beforeAll before apple after before banana after before pear after afterAll ",
				log.toString());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private RunnerInterceptor fRunnerInterceptor= new RunnerInterceptor() {	
		public void runChild(Runnable childStatement) {
			childStatement.run();
		}
	
		public void finished() {
			// do nothing
		}
	};

||||||| BASE
=======
	private Decorator fDecorator= new Decorator() {
		public void runAll(SafeStatement statement) {
			statement.execute();
		}

		public void runChild(SafeStatement statement) {
			statement.execute();
		}
	};

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		
||||||| BASE
	
	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows delegation without breaking subclasses
	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public List<T> internalGetChildren() {
		return getChildren();
	}

	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public Description internalDescribeChild(T child) {
		return describeChild(child);
	}

	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public void internalRunChild(T child, RunNotifier notifier) {
		runChild(child, notifier);
	}
	
=======

	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows
	// delegation without breaking subclasses
	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public List<T> internalGetChildren() {
		return getChildren();
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public Description internalDescribeChild(T child) {
		return describeChild(child);
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public void internalRunChild(T child, RunNotifier notifier) {
		runChild(child, notifier);
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

	public void setRunnerInterceptor(RunnerInterceptor runnerInterceptor) {
		this.fRunnerInterceptor = runnerInterceptor;
	}
||||||| BASE
=======

	// TODO (May 11, 2009 2:53:54 PM): complex
	public void installDecorator(Decorator decorator) {
		this.fDecorator= decorator;
	}

	// TODO (May 11, 2009 4:19:18 PM): move?
	public boolean isSuite() {
		return false;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;
||||||| BASE
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;
import org.junit.runners.model.RunnerInterceptor;
||||||| BASE
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;
=======
import org.junit.tests.SafeStatement;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	private static <T> Runner parallelize(ParentRunner<T> runner) {
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runChild(final Runnable childStatement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						childStatement.run();
						return null;
					}
				}));
			}

			public void finished() {
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
		});
		return runner;
	}

||||||| BASE
	private static <T> Runner parallelize(ParentRunner<T> runner)
			throws InitializationError {
		return new ParallelParentRunner<T>(runner);
	}

	private static class ParallelParentRunner<T> extends ParentRunner<T> {
		private final ParentRunner<T> fDelegate;

		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

		private final ExecutorService fService= Executors.newCachedThreadPool();

		public ParallelParentRunner(ParentRunner<T> delegate)
				throws InitializationError {
			super(delegate.getTestClass().getJavaClass());
			fDelegate= delegate;
		}

		@Override
		public Description describeChild(T child) {
			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
			return fDelegate.internalDescribeChild(child);
		}

		@Override
		public List<T> getChildren() {
			return fDelegate.internalGetChildren();
		}

		@Override
		public void runChild(final T child, final RunNotifier notifier) {
			fResults.add(fService.submit(new Callable<Object>() {
				public Object call() throws Exception {
					fDelegate.internalRunChild(child, notifier);
					return null;
				}
			}));
		}

		@Override
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fResults)
				try {
					each.get();
				} catch (Exception e) {
					e.printStackTrace();
				}
		}
	}

=======
	private static void parallelize(Runner runner) {
		((ParentRunner<?>) runner).installDecorator(new ParentRunner.Decorator() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runAll(SafeStatement statement) {
				statement.execute();
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}

			}

			public void runChild(final SafeStatement statement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						statement.execute();
						return null;
					}
				}));
			}
		});
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
||||||| BASE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
=======
	private boolean shouldParallelize(Runner runner) {
		if (runner instanceof ParentRunner) {
			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
			if (fClasses && parentRunner.isSuite())
				return true;
			if (fMethods && !parentRunner.isSuite())
				return true;
		}
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
package org.junit.tests;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerInterceptor;

public class ParentRunnerTest {
	public static String log= "";

	public static class FruitTest {
		@Test
		public void apple() {
			log+= "apple ";
		}

		@Test
		public void banana() {
			log+= "banana ";
		}
	}

	@Test
	public void useChildHarvester() throws InitializationError {
		log= "";
		ParentRunner<?> runner= new BlockJUnit4ClassRunner(FruitTest.class);
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			public void runChild(Runnable childStatement) {
				log+= "before ";
				childStatement.run();
				log+= "after ";
			}

			public void finished() {
				log+= "afterAll ";
			}
		});

		runner.run(new RunNotifier());
		assertEquals("before apple after before banana after afterAll ", log);
	}
}||||||| BASE
=======
package org.junit.tests;

import static org.junit.Assert.assertEquals;

import java.util.Comparator;

import org.junit.Test;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Sorter;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.FrameworkMethod;

// TODO (May 11, 2009 2:42:38 PM): move package

public class ParentRunnerTest {
	private static StringBuffer log= new StringBuffer();

	public static class FruitTests {
		@Test
		public void apple() {
			log.append("apple ");
		}

		@Test
		public void banana() {
			log.append("banana ");
		}

		@Test
		public void pear() {
			log.append("pear ");
		}
	}

	@Test
	public void installDecorator() throws Throwable {
		log.setLength(0);
		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
				true).runnerForClass(FruitTests.class);
		// TODO (May 11, 2009 2:58:11 PM): DUP?
		runner.sort(new Sorter(new Comparator<Description>() {
			public int compare(Description o1, Description o2) {
				return o1.toString().compareTo(o2.toString());
			}
		}));
		runner.installDecorator(new ParentRunner.Decorator() {
			public void runChild(SafeStatement statement) {
				log.append("before ");
				statement.execute();
				log.append("after ");
			}

			public void runAll(SafeStatement statement) {
				log.append("beforeAll ");
				statement.execute();
				log.append("afterAll ");
			}
		});

		runner.run(new RunNotifier());
		assertEquals(
				"beforeAll before apple after before banana after before pear after afterAll ",
				log.toString());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8aa25eb_58aa95c/rev_8aa25eb-58aa95c/src/main/java/redis/clients/jedis/Pipeline.java;<<<<<<< MINE
    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
||||||| BASE
    public void zrangeWithScores(String key, int start, int end) {
=======
    //--
    public void zrevrangeByScore(String key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(byte[] key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, String max, String min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScore(byte[] key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(byte[] key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(byte[] key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrangeWithScores(String key, int start, int end) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8aa25eb_58aa95c/rev_8aa25eb-58aa95c/src/main/java/redis/clients/jedis/PipelineBlock.java;<<<<<<< MINE
||||||| BASE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

import java.util.Map;

public abstract class PipelineBlock implements Commands {
    private Client client;

    public void setClient(Client client) {
        this.client = client;
    }

    public void append(String key, String value) {
        client.append(key, value);
    }

    public void blpop(String[] args) {
        client.blpop(args);
    }

    public void brpop(String[] args) {
        client.brpop(args);
    }

    public void decr(String key) {
        client.decr(key);
    }

    public void decrBy(String key, long integer) {
        client.decrBy(key, integer);
    }

    public void del(String... keys) {
        client.del(keys);
    }

    public void echo(String string) {
        client.echo(string);
    }

    public void exists(String key) {
        client.exists(key);
    }

    public void expire(String key, int seconds) {
        client.expire(key, seconds);
    }

    public void expireAt(String key, long unixTime) {
        client.expireAt(key, unixTime);
    }

    public void get(String key) {
        client.get(key);
    }

    public void getbit(String key, long offset) {
        client.getbit(key, offset);
    }

    public void getrange(String key, long startOffset, long endOffset) {
        client.getrange(key, startOffset, endOffset);
    }

    public void getSet(String key, String value) {
        client.getSet(key, value);
    }

    public void hdel(String key, String field) {
        client.hdel(key, field);
    }

    public void hexists(String key, String field) {
        client.hexists(key, field);
    }

    public void hget(String key, String field) {
        client.hget(key, field);
    }

    public void hgetAll(String key) {
        client.hgetAll(key);
    }

    public void hincrBy(String key, String field, long value) {
        client.hincrBy(key, field, value);
    }

    public void hkeys(String key) {
        client.hkeys(key);
    }

    public void hlen(String key) {
        client.hlen(key);
    }

    public void hmget(String key, String... fields) {
        client.hmget(key, fields);
    }

    public void hmset(String key, Map<String, String> hash) {
        client.hmset(key, hash);
    }

    public void hset(String key, String field, String value) {
        client.hset(key, field, value);
    }

    public void hsetnx(String key, String field, String value) {
        client.hsetnx(key, field, value);
    }

    public void hvals(String key) {
        client.hvals(key);
    }

    public void incr(String key) {
        client.incr(key);
    }

    public void incrBy(String key, long integer) {
        client.incrBy(key, integer);
    }

    public void keys(String pattern) {
        client.keys(pattern);
    }

    public void lindex(String key, int index) {
        client.lindex(key, index);
    }

    public void linsert(String key, LIST_POSITION where, String pivot,
            String value) {
        client.linsert(key, where, pivot, value);
    }

    public void llen(String key) {
        client.llen(key);
    }

    public void lpop(String key) {
        client.lpop(key);
    }

    public void lpush(String key, String string) {
        client.lpush(key, string);
    }

    public void lpushx(String key, String string) {
        client.lpushx(key, string);
    }

    public void lrange(String key, int start, int end) {
        client.lrange(key, start, end);
    }

    public void lrem(String key, int count, String value) {
        client.lrem(key, count, value);
    }

    public void lset(String key, int index, String value) {
        client.lset(key, index, value);
    }

    public void ltrim(String key, int start, int end) {
        client.ltrim(key, start, end);
    }

    public void mget(String... keys) {
        client.mget(keys);
    }

    public void move(String key, int dbIndex) {
        client.move(key, dbIndex);
    }

    public void mset(String... keysvalues) {
        client.mset(keysvalues);
    }

    public void msetnx(String... keysvalues) {
        client.msetnx(keysvalues);
    }

    public void persist(String key) {
        client.persist(key);
    }

    public void rename(String oldkey, String newkey) {
        client.rename(oldkey, newkey);
    }

    public void renamenx(String oldkey, String newkey) {
        client.renamenx(oldkey, newkey);
    }

    public void rpop(String key) {
        client.rpop(key);
    }

    public void rpoplpush(String srckey, String dstkey) {
        client.rpoplpush(srckey, dstkey);
    }

    public void rpush(String key, String string) {
        client.rpush(key, string);
    }

    public void rpushx(String key, String string) {
        client.rpushx(key, string);
    }

    public void sadd(String key, String member) {
        client.sadd(key, member);
    }

    public void scard(String key) {
        client.scard(key);
    }

    public void sdiff(String... keys) {
        client.sdiff(keys);
    }

    public void sdiffstore(String dstkey, String... keys) {
        client.sdiffstore(dstkey, keys);
    }

    public void set(String key, String value) {
        client.set(key, value);
    }

    public void setbit(String key, long offset, boolean value) {
        client.setbit(key, offset, value);
    }

    public void setex(String key, int seconds, String value) {
        client.setex(key, seconds, value);
    }

    public void setnx(String key, String value) {
        client.setnx(key, value);
    }

    public void setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
    }

    public void sinter(String... keys) {
        client.sinter(keys);
    }

    public void sinterstore(String dstkey, String... keys) {
        client.sinterstore(dstkey, keys);
    }

    public void sismember(String key, String member) {
        client.sismember(key, member);
    }

    public void smembers(String key) {
        client.smembers(key);
    }

    public void smove(String srckey, String dstkey, String member) {
        client.smove(srckey, dstkey, member);
    }

    public void sort(String key) {
        client.sort(key);
    }

    public void sort(String key, SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
    }

    public void sort(String key, SortingParams sortingParameters, String dstkey) {
        client.sort(key, sortingParameters, dstkey);
    }

    public void sort(String key, String dstkey) {
        client.sort(key, dstkey);
    }

    public void spop(String key) {
        client.spop(key);
    }

    public void srandmember(String key) {
        client.srandmember(key);
    }

    public void srem(String key, String member) {
        client.srem(key, member);
    }

    public void strlen(String key) {
        client.strlen(key);
    }

    public void substr(String key, int start, int end) {
        client.substr(key, start, end);
    }

    public void sunion(String... keys) {
        client.sunion(keys);
    }

    public void sunionstore(String dstkey, String... keys) {
        client.sunionstore(dstkey, keys);
    }

    public void ttl(String key) {
        client.ttl(key);
    }

    public void type(String key) {
        client.type(key);
    }

    public void watch(String... keys) {
        client.watch(keys);
    }

    public void zadd(String key, double score, String member) {
        client.zadd(key, score, member);
    }

    public void zcard(String key) {
        client.zcard(key);
    }

    public void zcount(String key, double min, double max) {
        client.zcount(key, min, max);
    }

    public void zincrby(String key, double score, String member) {
        client.zincrby(key, score, member);
    }

    public void zinterstore(String dstkey, String... sets) {
        client.zinterstore(dstkey, sets);
    }

    public void zinterstore(String dstkey, ZParams params, String... sets) {
        client.zinterstore(dstkey, params, sets);
    }

    public void zrange(String key, int start, int end) {
        client.zrange(key, start, end);
    }

    public void zrangeByScore(String key, double min, double max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, String min, String max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, double min, double max, int offset,
            int count) {
        client.zrangeByScore(key, min, max, offset, count);
    }

    public void zrangeByScoreWithScores(String key, double min, double max) {
        client.zrangeByScoreWithScores(key, min, max);
    }

    public void zrangeByScoreWithScores(String key, double min, double max,
            int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
    }

    public void zrangeWithScores(String key, int start, int end) {
        client.zrangeWithScores(key, start, end);
    }

    public void zrank(String key, String member) {
        client.zrank(key, member);
    }

    public void zrem(String key, String member) {
        client.zrem(key, member);
    }

    public void zremrangeByRank(String key, int start, int end) {
        client.zremrangeByRank(key, start, end);
    }

    public void zremrangeByScore(String key, double start, double end) {
        client.zremrangeByScore(key, start, end);
    }

    public void zrevrange(String key, int start, int end) {
        client.zrevrange(key, start, end);
    }

    public void zrevrangeWithScores(String key, int start, int end) {
        client.zrevrangeWithScores(key, start, end);
    }

    public void zrevrank(String key, String member) {
        client.zrevrank(key, member);
    }

    public void zscore(String key, String member) {
        client.zscore(key, member);
    }

    public void zunionstore(String dstkey, String... sets) {
        client.zunionstore(dstkey, sets);
    }

    public void zunionstore(String dstkey, ZParams params, String... sets) {
        client.zunionstore(dstkey, params, sets);
    }

    public void bgrewriteaof() {
        client.bgrewriteaof();
    }

    public void bgsave() {
        client.bgsave();
    }

    public void configGet(String pattern) {
        client.configGet(pattern);
    }

    public void configSet(String parameter, String value) {
        client.configSet(parameter, value);
    }

    public void brpoplpush(String source, String destination, int timeout) {
        client.brpoplpush(source, destination, timeout);
    }

    public void configResetStat() {
        client.configResetStat();
    }

    public void save() {
        client.save();
    }

    public void lastsave() {
        client.lastsave();
    }

    public void discard() {
        client.discard();
    }

    public void exec() {
        client.exec();
    }

    public void multi() {
        client.multi();
    }
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

import java.util.Map;

public abstract class PipelineBlock implements Commands {
    private Client client;

    public void setClient(Client client) {
        this.client = client;
    }

    public void append(String key, String value) {
        client.append(key, value);
    }

    public void blpop(String[] args) {
        client.blpop(args);
    }

    public void brpop(String[] args) {
        client.brpop(args);
    }

    public void decr(String key) {
        client.decr(key);
    }

    public void decrBy(String key, long integer) {
        client.decrBy(key, integer);
    }

    public void del(String... keys) {
        client.del(keys);
    }

    public void echo(String string) {
        client.echo(string);
    }

    public void exists(String key) {
        client.exists(key);
    }

    public void expire(String key, int seconds) {
        client.expire(key, seconds);
    }

    public void expireAt(String key, long unixTime) {
        client.expireAt(key, unixTime);
    }

    public void get(String key) {
        client.get(key);
    }

    public void getbit(String key, long offset) {
        client.getbit(key, offset);
    }

    public void getrange(String key, long startOffset, long endOffset) {
        client.getrange(key, startOffset, endOffset);
    }

    public void getSet(String key, String value) {
        client.getSet(key, value);
    }

    public void hdel(String key, String field) {
        client.hdel(key, field);
    }

    public void hexists(String key, String field) {
        client.hexists(key, field);
    }

    public void hget(String key, String field) {
        client.hget(key, field);
    }

    public void hgetAll(String key) {
        client.hgetAll(key);
    }

    public void hincrBy(String key, String field, long value) {
        client.hincrBy(key, field, value);
    }

    public void hkeys(String key) {
        client.hkeys(key);
    }

    public void hlen(String key) {
        client.hlen(key);
    }

    public void hmget(String key, String... fields) {
        client.hmget(key, fields);
    }

    public void hmset(String key, Map<String, String> hash) {
        client.hmset(key, hash);
    }

    public void hset(String key, String field, String value) {
        client.hset(key, field, value);
    }

    public void hsetnx(String key, String field, String value) {
        client.hsetnx(key, field, value);
    }

    public void hvals(String key) {
        client.hvals(key);
    }

    public void incr(String key) {
        client.incr(key);
    }

    public void incrBy(String key, long integer) {
        client.incrBy(key, integer);
    }

    public void keys(String pattern) {
        client.keys(pattern);
    }

    public void lindex(String key, int index) {
        client.lindex(key, index);
    }

    public void linsert(String key, LIST_POSITION where, String pivot,
            String value) {
        client.linsert(key, where, pivot, value);
    }

    public void llen(String key) {
        client.llen(key);
    }

    public void lpop(String key) {
        client.lpop(key);
    }

    public void lpush(String key, String string) {
        client.lpush(key, string);
    }

    public void lpushx(String key, String string) {
        client.lpushx(key, string);
    }

    public void lrange(String key, int start, int end) {
        client.lrange(key, start, end);
    }

    public void lrem(String key, int count, String value) {
        client.lrem(key, count, value);
    }

    public void lset(String key, int index, String value) {
        client.lset(key, index, value);
    }

    public void ltrim(String key, int start, int end) {
        client.ltrim(key, start, end);
    }

    public void mget(String... keys) {
        client.mget(keys);
    }

    public void move(String key, int dbIndex) {
        client.move(key, dbIndex);
    }

    public void mset(String... keysvalues) {
        client.mset(keysvalues);
    }

    public void msetnx(String... keysvalues) {
        client.msetnx(keysvalues);
    }

    public void persist(String key) {
        client.persist(key);
    }

    public void rename(String oldkey, String newkey) {
        client.rename(oldkey, newkey);
    }

    public void renamenx(String oldkey, String newkey) {
        client.renamenx(oldkey, newkey);
    }

    public void rpop(String key) {
        client.rpop(key);
    }

    public void rpoplpush(String srckey, String dstkey) {
        client.rpoplpush(srckey, dstkey);
    }

    public void rpush(String key, String string) {
        client.rpush(key, string);
    }

    public void rpushx(String key, String string) {
        client.rpushx(key, string);
    }

    public void sadd(String key, String member) {
        client.sadd(key, member);
    }

    public void scard(String key) {
        client.scard(key);
    }

    public void sdiff(String... keys) {
        client.sdiff(keys);
    }

    public void sdiffstore(String dstkey, String... keys) {
        client.sdiffstore(dstkey, keys);
    }

    public void set(String key, String value) {
        client.set(key, value);
    }

    public void setbit(String key, long offset, boolean value) {
        client.setbit(key, offset, value);
    }

    public void setex(String key, int seconds, String value) {
        client.setex(key, seconds, value);
    }

    public void setnx(String key, String value) {
        client.setnx(key, value);
    }

    public void setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
    }

    public void sinter(String... keys) {
        client.sinter(keys);
    }

    public void sinterstore(String dstkey, String... keys) {
        client.sinterstore(dstkey, keys);
    }

    public void sismember(String key, String member) {
        client.sismember(key, member);
    }

    public void smembers(String key) {
        client.smembers(key);
    }

    public void smove(String srckey, String dstkey, String member) {
        client.smove(srckey, dstkey, member);
    }

    public void sort(String key) {
        client.sort(key);
    }

    public void sort(String key, SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
    }

    public void sort(String key, SortingParams sortingParameters, String dstkey) {
        client.sort(key, sortingParameters, dstkey);
    }

    public void sort(String key, String dstkey) {
        client.sort(key, dstkey);
    }

    public void spop(String key) {
        client.spop(key);
    }

    public void srandmember(String key) {
        client.srandmember(key);
    }

    public void srem(String key, String member) {
        client.srem(key, member);
    }

    public void strlen(String key) {
        client.strlen(key);
    }

    public void substr(String key, int start, int end) {
        client.substr(key, start, end);
    }

    public void sunion(String... keys) {
        client.sunion(keys);
    }

    public void sunionstore(String dstkey, String... keys) {
        client.sunionstore(dstkey, keys);
    }

    public void ttl(String key) {
        client.ttl(key);
    }

    public void type(String key) {
        client.type(key);
    }

    public void watch(String... keys) {
        client.watch(keys);
    }

    public void zadd(String key, double score, String member) {
        client.zadd(key, score, member);
    }

    public void zcard(String key) {
        client.zcard(key);
    }

    public void zcount(String key, double min, double max) {
        client.zcount(key, min, max);
    }

    public void zincrby(String key, double score, String member) {
        client.zincrby(key, score, member);
    }

    public void zinterstore(String dstkey, String... sets) {
        client.zinterstore(dstkey, sets);
    }

    public void zinterstore(String dstkey, ZParams params, String... sets) {
        client.zinterstore(dstkey, params, sets);
    }

    public void zrange(String key, int start, int end) {
        client.zrange(key, start, end);
    }

    public void zrangeByScore(String key, double min, double max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, String min, String max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, double min, double max, int offset,
            int count) {
        client.zrangeByScore(key, min, max, offset, count);
    }

    public void zrangeByScoreWithScores(String key, double min, double max) {
        client.zrangeByScoreWithScores(key, min, max);
    }

    public void zrangeByScoreWithScores(String key, double min, double max,
            int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
    }

    public void zrevrangeByScore(String key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, String max, String min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrangeWithScores(String key, int start, int end) {
        client.zrangeWithScores(key, start, end);
    }

    public void zrank(String key, String member) {
        client.zrank(key, member);
    }

    public void zrem(String key, String member) {
        client.zrem(key, member);
    }

    public void zremrangeByRank(String key, int start, int end) {
        client.zremrangeByRank(key, start, end);
    }

    public void zremrangeByScore(String key, double start, double end) {
        client.zremrangeByScore(key, start, end);
    }

    public void zrevrange(String key, int start, int end) {
        client.zrevrange(key, start, end);
    }

    public void zrevrangeWithScores(String key, int start, int end) {
        client.zrevrangeWithScores(key, start, end);
    }

    public void zrevrank(String key, String member) {
        client.zrevrank(key, member);
    }

    public void zscore(String key, String member) {
        client.zscore(key, member);
    }

    public void zunionstore(String dstkey, String... sets) {
        client.zunionstore(dstkey, sets);
    }

    public void zunionstore(String dstkey, ZParams params, String... sets) {
        client.zunionstore(dstkey, params, sets);
    }

    public void bgrewriteaof() {
        client.bgrewriteaof();
    }

    public void bgsave() {
        client.bgsave();
    }

    public void configGet(String pattern) {
        client.configGet(pattern);
    }

    public void configSet(String parameter, String value) {
        client.configSet(parameter, value);
    }

    public void brpoplpush(String source, String destination, int timeout) {
        client.brpoplpush(source, destination, timeout);
    }

    public void configResetStat() {
        client.configResetStat();
    }

    public void save() {
        client.save();
    }

    public void lastsave() {
        client.lastsave();
    }

    public void discard() {
        client.discard();
    }

    public void exec() {
        client.exec();
    }

    public void multi() {
        client.multi();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/experimental/interceptor/TestName.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMember.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkField.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestName.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/junit/runner/Version.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/SubstringMatcher.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/IsCollectionContaining.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/IsCollectionContaining.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/CombinableMatcher.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/CombinableMatcher.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/TypeSafeMatcher.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/experimental/results/ResultMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/Assume.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/Assume.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/Assume.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionViolatedExceptionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionViolatedExceptionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/PrintableResultTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/PrintableResultTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/PrintableResultTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/ResultMatchersTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/ResultMatchersTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/ResultMatchersTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WhenNoParametersMatch.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WhenNoParametersMatch.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithOnlyTestAnnotations.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithOnlyTestAnnotations.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterSignatureTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterSignatureTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterizedAssertionErrorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterizedAssertionErrorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/junit3compatibility/AllTestsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/junit3compatibility/AllTestsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.equalTo;

import java.util.ArrayList;
import java.util.List;

||||||| BASE
=======
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.is;

import java.util.ArrayList;
import java.util.List;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	}
	
	/**
	 * This is sugar for the situation where you want to specify
	 * a finite list of concrete objects that can match.
	 * For example:
	 * <pre>
	 *   assertThat(string, isOneOf("a", "b", "c"));
	 *   // is equivalent to
	 *   assertThat(string, anyOf(is("a"), is("b"), is("c")))
	 * </pre>
	 */
	public static <T> Matcher<T> isOneOf(T... objects) {
		List<Matcher<? super T>> matchers = new ArrayList<Matcher<? super T>>();
		for (T each : objects) {
			matchers.add(equalTo(each));
		}
		return anyOf(matchers);
	}
	
	/**
	 * Loosens type parameter, in order to use a Matcher 
	 * in a place where Java doesn't want to type-check:
	 *
	 * Goofy example:
	 * <pre>
	 *   assertThat(3, matches(containsString("a")));
	 * </pre>
	 * 
	 * Real example:
	 * <pre>
	 *   assertThat(3, either(matches(is(String.class))).or(
	 *		                  matches(is(Integer.class))));
	 * </pre>
	 */
	@SuppressWarnings("unchecked")
	public static <T> Matcher<T> matches(Matcher<?> matcher) {
		return (Matcher<T>)matcher;
	}
||||||| BASE
	}	
=======
	}
	
	/**
	 * This is sugar for the situation where 
	 * For example:
	 * <pre>
	 *   assertThat(string, eitherIs("a").or(is("b")));
	 * </pre>
	 */
	public static <T> Matcher<T> isOneOf(T... objects) {
		List<Matcher<? super T>> matchers = new ArrayList<Matcher<? super T>>();
		for (T each : objects) {
			matchers.add(is(each));
		}
		return anyOf(matchers);
	}
	
	/**
	 * Loosens type parameter, in order to use a Matcher 
	 * in a place where Java doesn't want to typecheck:
	 *
	 * Goofy example:
	 * <pre>
	 *   assertThat(3, matches(containsString("a")));
	 * </pre>
	 * 
	 * Real example:
	 * <pre>
	 *   assertThat(3, either(matches(is(String.class))).or(
	 *		                  matches(is(Integer.class))));
     *
	 * </pre>
	 */
	@SuppressWarnings("unchecked")
	public static <T> Matcher<T> matches(Matcher<?> matcher) {
		return (Matcher<T>)matcher;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/junit/runner/Version.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/matchers/IsCollectionContaining.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/model/MultipleFailureException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ExactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMethod.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;

/**
 * Represents a field on a test class (currently used only for Rules in
 * {@link BlockJUnit4ClassRunner}, but custom runners can make other uses)
 */
public class FrameworkField extends FrameworkMember<FrameworkField> {
||||||| BASE
public class FrameworkField implements FrameworkMember<FrameworkField> {
=======
import org.junit.runners.BlockJUnit4ClassRunner;

/**
 * Represents a field on a test class (currently used only for Interceptors in
 * {@link BlockJUnit4ClassRunner}, but custom runners can make other uses)
 */
public class FrameworkField extends FrameworkMember<FrameworkField> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
||||||| BASE
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.StatementInterceptor;
=======
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private void validateRuleField(Field field, List<Throwable> errors) {
		if (!MethodRule.class.isAssignableFrom(field.getType()))
||||||| BASE
	private void validateInterceptorField(Field field, List<Throwable> errors) {
		if (!StatementInterceptor.class.isAssignableFrom(field.getType()))
=======
	private void validateInterceptorField(Field field, List<Throwable> errors) {
		if (!MethodRule.class.isAssignableFrom(field.getType()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
||||||| BASE
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
||||||| BASE
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
||||||| BASE
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
||||||| BASE
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Request.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/FailureList.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/CouldNotReadCoreException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/CouldNotReadCoreException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	/**
	 * Loads a {@link MaxHistory} from {@code file}, or generates a new one that
	 * will be saved to {@code file}.
	 */
	public static MaxHistory forFolder(File file) {
		if (file.exists())
			try {
				return readHistory(file);
			} catch (CouldNotReadCoreException e) {
				e.printStackTrace();
				file.delete();
			}
		return new MaxHistory(file);
	}
||||||| BASE
=======
	/**
	 * Loads a {@link MaxHistory} from {@code file}, or generates a new one that
	 * will be saved to {@code file}.
	 */
	public static MaxHistory forFolder(File file) {
		// TODO: temp!
		if (file.getPath() == null)
			throw new NullPointerException();
		if (file.exists())
			try {
				return readHistory(file);
			} catch (CouldNotReadCoreException e) {
				e.printStackTrace();
				file.delete();
			}
		return new MaxHistory(file);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TestName.java;<<<<<<< MINE
||||||| BASE
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;

public class TestName extends TestWatchman {
	private String fName;

	@Override
	public void starting(FrameworkMethod method) {
		fName = method.getName();
	}
	
	public String getMethodName() {
		return fName;
	}
}=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;

/**
 * The TestName Rule makes the current test name available inside test methods:
 * 
 * <pre>
 * public class TestNameTest {
 * 	&#064;Rule
 * 	public TestName name= new TestName();
 * 
 * 	&#064;Test
 * 	public void testA() {
 * 		assertEquals(&quot;testA&quot;, name.getMethodName());
 * 	}
 * 
 * 	&#064;Test
 * 	public void testB() {
 * 		assertEquals(&quot;testB&quot;, name.getMethodName());
 * 	}
 * }
 * </pre>
 */
public class TestName extends TestWatchman {
	private String fName;

	@Override
	public void starting(FrameworkMethod method) {
		fName= method.getName();
	}

	public String getMethodName() {
		return fName;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/ExternalResource.java;<<<<<<< MINE
||||||| BASE
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class ExternalResource implements StatementInterceptor {
	public final Statement intercept(final Statement base, FrameworkMethod method) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				// TODO (Jun 3, 2009 11:49:23 PM): should we replicate
				// @Before/@After semantics?
				// 1. after() run even if before() fails.
				// 2. exception in after() _adds_ to failure in base.
				before();
				try {
					base.evaluate();
				} finally {
					after();
				}
			}
		};
	}

	protected void before() throws Throwable {
		// do nothing
	}

	protected void after() {
		// do nothing
	}
}=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * A base class for Rules (like TemporaryFolder) that set up an external
 * resource before a test (a file, socket, server, database connection, etc.),
 * and guarantee to tear it down afterward:
 * 
 * <pre>
 * public static class UsesExternalResource {
 * 	Server myServer= new Server();
 * 
 * 	&#064;Rule
 * 	public ExternalResource resource= new ExternalResource() {
 * 		&#064;Override
 * 		protected void before() throws Throwable {
 * 			myServer.connect();
 * 		};
 * 
 * 		&#064;Override
 * 		protected void after() {
 * 			myServer.disconnect();
 * 		};
 * 	};
 * 
 * 	&#064;Test
 * 	public void testFoo() {
 * 		new Client().run(myServer);
 * 	}
 * }
 * </pre>
 */
public abstract class ExternalResource implements MethodRule {
	public final Statement apply(final Statement base,
			FrameworkMethod method, Object target) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				before();
				try {
					base.evaluate();
				} finally {
					after();
				}
			}
		};
	}

	/**
	 * Override to set up your specific external resource.
	 * @throws if setup fails (which will disable {@code after}
	 */
	protected void before() throws Throwable {
		// do nothing
	}

	/**
	 * Override to tear down your specific external resource.
	 * @throws if setup fails (which will disable {@code after}
	 */
	protected void after() {
		// do nothing
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
||||||| BASE
package org.junit.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.matches;
import org.hamcrest.FeatureMatcher;
import org.hamcrest.Matcher;
import org.hamcrest.StringDescription;
import org.junit.Assert;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class ExpectedException implements StatementInterceptor {
	private Matcher<?> fMatcher= null;

	public Statement intercept(Statement base, FrameworkMethod method) {
		return new ExpectedExceptionStatement(base);
	}

	public void expect(Matcher<?> matcher) {
		if (fMatcher == null)
			fMatcher = matcher;
		else
			fMatcher = both(fMatcher).and(matches(matcher));
	}

	public void expect(Class<? extends Throwable> type) {
		expect(instanceOf(type));
	}

	public void expectMessage(String substring) {
		expectMessage(containsString(substring));
	}

	public void expectMessage(Matcher<String> matcher) {
		expect(hasMessage(matcher));
	}

	private class ExpectedExceptionStatement extends Statement {
		private final Statement fNext;

		public ExpectedExceptionStatement(Statement base) {
			fNext= base;
		}

		@Override
		public void evaluate() throws Throwable {
			try {
				fNext.evaluate();
			} catch (Throwable e) {
				if (fMatcher == null)
					throw e;
				Assert.assertThat(e, matches(fMatcher));
				return;
			}
			if (fMatcher != null)
				throw new AssertionError("Expected test to throw "
						+ StringDescription.toString(fMatcher));
		}
	}

	private Matcher<Throwable> hasMessage(Matcher<String> matcher) {
		return new FeatureMatcher<Throwable, String>(matcher,
				"exception with message", "getMessage()") {
			@Override
			protected String featureValueOf(Throwable actual) {
				return actual.getMessage();
			}
		};
	}
}=======
package org.junit.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.matches;
import org.hamcrest.FeatureMatcher;
import org.hamcrest.Matcher;
import org.hamcrest.StringDescription;
import org.junit.Assert;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * The ExpectedException Rule allows in-test specification of expected exception
 * types and messages:
 * 
 * <pre>
 * // These tests all pass.
 * public static class HasExpectedException {
 * 	&#064;Rule
 * 	public ExpectedException thrown= new ExpectedException();
 * 
 * 	&#064;Test
 * 	public void throwsNothing() {
 *    // no exception expected, none thrown: passes.
 * 	}
 * 
 * 	&#064;Test
 * 	public void throwsNullPointerException() {
 * 		thrown.expect(NullPointerException.class);
 * 		throw new NullPointerException();
 * 	}
 * 
 * 	&#064;Test
 * 	public void throwsNullPointerExceptionWithMessage() {
 * 		thrown.expect(NullPointerException.class);
 * 		thrown.expectMessage(&quot;happened?&quot;);
 * 		thrown.expectMessage(startsWith(&quot;What&quot;));
 * 		throw new NullPointerException(&quot;What happened?&quot;);
 * 	}
 * }
 * </pre>
 */
public class ExpectedException implements MethodRule {
	public static ExpectedException none() {
		return new ExpectedException();
	}

	private Matcher<?> fMatcher= null;

	private ExpectedException() {
		
	}
	
	public Statement apply(Statement base, FrameworkMethod method, Object target) {
		return new ExpectedExceptionStatement(base);
	}

	/**
	 * Adds {@code matcher} to the list of requirements for any thrown exception.
	 */
	public void expect(Matcher<?> matcher) {
		if (fMatcher == null)
			fMatcher= matcher;
		else
			fMatcher= both(fMatcher).and(matches(matcher));
	}

	/**
	 * Adds to the list of requirements for any thrown exception that it
	 * should be an instance of {@code type}
	 */
	public void expect(Class<? extends Throwable> type) {
		expect(instanceOf(type));
	}

	/**
	 * Adds to the list of requirements for any thrown exception that it
	 * should <em>contain</em> string {@code substring}
	 */
	public void expectMessage(String substring) {
		expectMessage(containsString(substring));
	}

	/**
	 * Adds {@code matcher} to the list of requirements for the message 
	 * returned from any thrown exception.
	 */
	public void expectMessage(Matcher<String> matcher) {
		expect(hasMessage(matcher));
	}

	private class ExpectedExceptionStatement extends Statement {
		private final Statement fNext;

		public ExpectedExceptionStatement(Statement base) {
			fNext= base;
		}

		@Override
		public void evaluate() throws Throwable {
			try {
				fNext.evaluate();
			} catch (Throwable e) {
				if (fMatcher == null)
					throw e;
				Assert.assertThat(e, matches(fMatcher));
				return;
			}
			if (fMatcher != null)
				throw new AssertionError("Expected test to throw "
						+ StringDescription.toString(fMatcher));
		}
	}

	private Matcher<Throwable> hasMessage(Matcher<String> matcher) {
		return new FeatureMatcher<Throwable, String>(matcher,
				"exception with message", "getMessage()") {
			@Override
			protected String featureValueOf(Throwable actual) {
				return actual.getMessage();
			}
		};
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/Timeout.java;<<<<<<< MINE
||||||| BASE
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.internal.runners.statements.FailOnTimeout;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class Timeout implements StatementInterceptor {
	private final int fMillis;

	public Timeout(int millis) {
		fMillis= millis;
	}

	public Statement intercept(Statement base, FrameworkMethod method) {
		return new FailOnTimeout(base, fMillis);
	}
}=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.internal.runners.statements.FailOnTimeout;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * The Timeout Rule applies the same timeout to all test methods in a class:
 * 
 * <pre>
 * public static class HasGlobalTimeout {
 * 	public static String log;
 * 
 * 	&#064;Rule
 * 	public MethodRule globalTimeout= new Timeout(20);
 * 
 * 	&#064;Test
 * 	public void testInfiniteLoop1() {
 * 		log+= &quot;ran1&quot;;
 * 		for (;;) {
 * 		}
 * 	}
 * 
 * 	&#064;Test
 * 	public void testInfiniteLoop2() {
 * 		log+= &quot;ran2&quot;;
 * 		for (;;) {
 * 		}
 * 	}
 * }
 * </pre>
 */
public class Timeout implements MethodRule {
	private final int fMillis;

	public Timeout(int millis) {
		fMillis= millis;
	}

	public Statement apply(Statement base, FrameworkMethod method, Object target) {
		return new FailOnTimeout(base, fMillis);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
||||||| BASE
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class TestWatchman implements StatementInterceptor {
	public Statement intercept(final Statement base,
			final FrameworkMethod method) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				starting(method);
				try {
					base.evaluate();
					succeeded(method);
				} catch (Throwable t) {
					failed(t, method);
					throw t;
				} finally {
					finished(method);
				}
			}
		};
	}
	
	// TODO (May 25, 2009 9:44:36 PM): Fix max and Theories

	public void succeeded(FrameworkMethod method) {
	}

	// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
	// FrameworkMethod too powerful?
	public void failed(Throwable e, FrameworkMethod method) {
	}

	public void starting(FrameworkMethod method) {
	}

	public void finished(FrameworkMethod method) {
	}
}=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * TestWatchman is a base class for Rules that take note of the testing
 * action, without modifying it. For example, this class will keep a log of each
 * passing and failing test:
 * 
 * <pre>
 * public static class WatchmanTest {
 * 	private static String watchedLog;
 * 
 * 	&#064;Rule
 * 	public MethodRule watchman= new TestWatchman() {
 * 		&#064;Override
 * 		public void failed(Throwable e, FrameworkMethod method) {
 * 			watchedLog+= method.getName() + &quot; &quot; + e.getClass().getSimpleName()
 * 					+ &quot;\n&quot;;
 * 		}
 * 
 * 		&#064;Override
 * 		public void succeeded(FrameworkMethod method) {
 * 			watchedLog+= method.getName() + &quot; &quot; + &quot;success!\n&quot;;
 * 		}
 * 	};
 * 
 * 	&#064;Test
 * 	public void fails() {
 * 		fail();
 * 	}
 * 
 * 	&#064;Test
 * 	public void succeeds() {
 * 	}
 * }
 * </pre>
 */
public class TestWatchman implements MethodRule {
	public Statement apply(final Statement base, final FrameworkMethod method,
			Object target) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				starting(method);
				try {
					base.evaluate();
					succeeded(method);
				} catch (Throwable t) {
					failed(t, method);
					throw t;
				} finally {
					finished(method);
				}
			}
		};
	}

	/**
	 * Invoked when a test method succeeds
	 * 
	 * @param method
	 */
	public void succeeded(FrameworkMethod method) {
	}

	/**
	 * Invoked when a test method fails
	 * 
	 * @param e 
	 * @param method
	 */
	public void failed(Throwable e, FrameworkMethod method) {
	}

	/**
	 * Invoked when a test method is about to start
	 * 
	 * @param method  
	 */
	public void starting(FrameworkMethod method) {
	}


	/**
	 * Invoked when a test method finishes (whether passing or failing)
	 * 
	 * @param method  
	 */
	public void finished(FrameworkMethod method) {
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TemporaryFolder.java;<<<<<<< MINE
||||||| BASE
/**
 * 
 */
package org.junit.experimental.interceptor;

import java.io.File;
import java.io.IOException;

public class TemporaryFolder extends ExternalResource {
	private File folder;

	@Override
	protected void before() throws Throwable {
		create();
	}
	
	@Override
	protected void after() {
		delete();
	}
	
	// testing purposes only
	public void create() throws IOException {
		folder= File.createTempFile("junit", "");
		folder.delete();
		folder.mkdir();
	}

	public File newFile(String fileName) throws IOException {
		File file= new File(folder, fileName);
		file.createNewFile();
		return file;
	}

	public File newFolder(String folderName) {
		File file= new File(folder, folderName);
		file.mkdir();
		return file;
	}

	public File getRoot() {
		return folder;
	}

	public void delete() {
		recursiveDelete(folder);
	}

	private void recursiveDelete(File file) {
		File[] files= file.listFiles();
		if (files != null)
			for (File each : files)
				recursiveDelete(each);
		file.delete();
	}
}=======
package org.junit.experimental.interceptor;

import java.io.File;
import java.io.IOException;

/**
 * The TemporaryFolder Rule allows creation of files and folders that are
 * guaranteed to be deleted when the test method finishes (whether it passes or
 * fails):
 * 
 * <pre>
 * public static class HasTempFolder {
 * 	&#064;Rule
 * 	public TemporaryFolder folder= new TemporaryFolder();
 * 
 * 	&#064;Test
 * 	public void testUsingTempFolder() throws IOException {
 * 		File createdFile= folder.newFile(&quot;myfile.txt&quot;);
 * 		File createdFolder= folder.newFolder(&quot;subfolder&quot;);
 * 		// ...
 * 	}
 * }
 * </pre>
 */
public class TemporaryFolder extends ExternalResource {
	private File folder;

	@Override
	protected void before() throws Throwable {
		create();
	}

	@Override
	protected void after() {
		delete();
	}

	// testing purposes only
	public void create() throws IOException {
		folder= File.createTempFile("junit", "");
		folder.delete();
		folder.mkdir();
	}

	public File newFile(String fileName) throws IOException {
		File file= new File(folder, fileName);
		file.createNewFile();
		return file;
	}

	public File newFolder(String folderName) {
		File file= new File(folder, folderName);
		file.mkdir();
		return file;
	}

	public File getRoot() {
		return folder;
	}

	public void delete() {
		recursiveDelete(folder);
	}

	private void recursiveDelete(File file) {
		File[] files= file.listFiles();
		if (files != null)
			for (File each : files)
				recursiveDelete(each);
		file.delete();
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
||||||| BASE
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.TestName;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	public static class ExampleTest {
		@Interceptor
		public StatementInterceptor example= new StatementInterceptor() {
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAndEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	public static class MultipleInterceptorTest {
		private static class Incrementor implements StatementInterceptor {
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Interceptor
		public StatementInterceptor interceptor1= new Incrementor();

		@Interceptor
		public StatementInterceptor interceptor2= new Incrementor();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	public static class OnFailureTest {
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	public static class WatchmanTest {
		private static String watchedLog;

		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}

	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
	
	public static class WrongTypedField {
		@Interceptor public int x = 5;
		@Test public void foo() {}
	}
	
	@Test public void validateWrongTypedField() {
		assertThat(testResult(WrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}
	
	public static class SonOfWrongTypedField extends WrongTypedField {
		
	}

	@Test public void validateWrongTypedFieldInSuperclass() {
		assertThat(testResult(SonOfWrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}

	public static class PrivateInterceptor {
		@SuppressWarnings("unused")
		@Interceptor private StatementInterceptor interceptor = new TestName();
		@Test public void foo() {}
	}
	
	@Test public void validatePrivateInterceptor() {
		assertThat(testResult(PrivateInterceptor.class), 
				hasSingleFailureContaining("must be public"));
	}
}=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
import org.junit.experimental.interceptor.TestName;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	public static class ExampleTest {
		@Rule
		public MethodRule example= new MethodRule() {
			public Statement apply(final Statement base,
					FrameworkMethod method, Object target) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAndEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	public static class MultipleInterceptorTest {
		private static class Increment implements MethodRule {
			public Statement apply(final Statement base,
					FrameworkMethod method, Object target) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Rule
		public MethodRule incrementor1= new Increment();

		@Rule
		public MethodRule incrementor2= new Increment();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	public static class OnFailureTest {
		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	public static class WatchmanTest {
		private static String watchedLog;

		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}

	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
	
	public static class WrongTypedField {
		@Rule public int x = 5;
		@Test public void foo() {}
	}
	
	@Test public void validateWrongTypedField() {
		assertThat(testResult(WrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}
	
	public static class SonOfWrongTypedField extends WrongTypedField {
		
	}

	@Test public void validateWrongTypedFieldInSuperclass() {
		assertThat(testResult(SonOfWrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}

	public static class PrivateInterceptor {
		@SuppressWarnings("unused")
		@Rule private MethodRule interceptor = new TestName();
		@Test public void foo() {}
	}
	
	@Test public void validatePrivateInterceptor() {
		assertThat(testResult(PrivateInterceptor.class), 
				hasSingleFailureContaining("must be public"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/TempFolderInterceptorTest.java;<<<<<<< MINE
||||||| BASE
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;

import java.io.File;
import java.io.IOException;

import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.TemporaryFolder;

public class TempFolderInterceptorTest {
	private static File createdFile;

	public static class HasTempFolder {
		@Interceptor
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFile("myfile.txt");
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void tempFolderIsDeleted() {
		assertThat(testResult(HasTempFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	public static class CreatesSubFolder {
		@Interceptor
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFolder("subfolder");
			new File(createdFile, "a.txt").createNewFile();
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void subFolderIsDeleted() {
		assertThat(testResult(CreatesSubFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	@Test
	public void recursiveDeleteFolderWithOneElement() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		File file= folder.newFile("a");
		folder.delete();
		assertFalse(file.exists());
		assertFalse(folder.getRoot().exists());
	}

	@Test
	public void recursiveDeleteFolderWithZeroElements() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		folder.delete();
		assertFalse(folder.getRoot().exists());
	}
}=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;

import java.io.File;
import java.io.IOException;

import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.TemporaryFolder;

public class TempFolderInterceptorTest {
	private static File createdFile;

	public static class HasTempFolder {
		@Rule
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFile("myfile.txt");
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void tempFolderIsDeleted() {
		assertThat(testResult(HasTempFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	public static class CreatesSubFolder {
		@Rule
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFolder("subfolder");
			new File(createdFile, "a.txt").createNewFile();
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void subFolderIsDeleted() {
		assertThat(testResult(CreatesSubFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	@Test
	public void recursiveDeleteFolderWithOneElement() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		File file= folder.newFile("a");
		folder.delete();
		assertFalse(file.exists());
		assertFalse(folder.getRoot().exists());
	}

	@Test
	public void recursiveDeleteFolderWithZeroElements() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		folder.delete();
		assertFalse(folder.getRoot().exists());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
||||||| BASE
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExpectedException;
import org.junit.experimental.interceptor.Interceptor;

public class ExpectedExceptionInterceptorTest {
	public static class HasExpectedException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class),
				hasSingleFailureContaining("\"expectedMessage\"\n     but: getMessage() was \"actualMessage\""));
	}

	public static class WronglyExpectsException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("but: getMessage() was null"));
	}

	public static class ExpectsMessageMatcher {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExpectedException;
import org.junit.experimental.interceptor.Rule;

public class ExpectedExceptionInterceptorTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class),
				hasSingleFailureContaining("\"expectedMessage\"\n     but: getMessage() was \"actualMessage\""));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("but: getMessage() was null"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/ExternalResourceInterceptorTest.java;<<<<<<< MINE
||||||| BASE
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExternalResource;
import org.junit.experimental.interceptor.Interceptor;

public class ExternalResourceInterceptorTest {
	private static String callSequence;
	
	public static class UsesExternalResource {
		@Interceptor public ExternalResource resource = new ExternalResource() {
			@Override
			protected void before() throws Throwable {
				callSequence += "before ";
			};
			
			@Override
			protected void after() {
				callSequence += "after ";
			};
		};
		
		@Test public void testFoo() {
			callSequence += "test ";
		}
	}

	@Test public void externalResourceGeneratesCorrectSequence() {
		callSequence= "";
		assertThat(testResult(UsesExternalResource.class), isSuccessful());
		assertEquals("before test after ", callSequence);
	}
}=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExternalResource;
import org.junit.experimental.interceptor.Rule;

public class ExternalResourceInterceptorTest {
	private static String callSequence;
	
	public static class UsesExternalResource {
		@Rule public ExternalResource resource = new ExternalResource() {
			@Override
			protected void before() throws Throwable {
				callSequence += "before ";
			};
			
			@Override
			protected void after() {
				callSequence += "after ";
			};
		};
		
		@Test public void testFoo() {
			callSequence += "test ";
		}
	}

	@Test public void externalResourceGeneratesCorrectSequence() {
		callSequence= "";
		assertThat(testResult(UsesExternalResource.class), isSuccessful());
		assertEquals("before test after ", callSequence);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
||||||| BASE
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;

public class TimeoutInterceptorTest {
	public static class HasGlobalTimeout {
		public static String log;
		
		@Interceptor public StatementInterceptor globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	// TODO (May 6, 2009 11:30:19 AM): Make a separate build that makes gump happy
	@Ignore("For gump, for now")
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;

public class TimeoutInterceptorTest {
	public static class HasGlobalTimeout {
		public static String log;
		
		@Rule public MethodRule globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	@Ignore("For gump, for now")
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
||||||| BASE
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.TestName;

public class NameInterceptorTest {
	@Interceptor public TestName name = new TestName();
	
	@Test public void testA() {
		assertEquals("testA", name.getMethodName());
	}
	
	@Test public void testB() {
		assertEquals("testB", name.getMethodName());
	}
}=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.TestName;

public class NameInterceptorTest {
	@Rule public TestName name = new TestName();
	
	@Test public void testA() {
		assertEquals("testA", name.getMethodName());
	}
	
	@Test public void testB() {
		assertEquals("testB", name.getMethodName());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
||||||| BASE
import org.junit.tests.experimental.interceptor.ExpectedExceptionInterceptorTest;
import org.junit.tests.experimental.interceptor.ExternalResourceInterceptorTest;
import org.junit.tests.experimental.interceptor.InterceptorTest;
import org.junit.tests.experimental.interceptor.NameInterceptorTest;
import org.junit.tests.experimental.interceptor.TempFolderInterceptorTest;
import org.junit.tests.experimental.interceptor.TimeoutInterceptorTest;
=======
import org.junit.tests.experimental.interceptor.ExpectedExceptionInterceptorTest;
import org.junit.tests.experimental.interceptor.ExternalResourceInterceptorTest;
import org.junit.tests.experimental.interceptor.InterceptorTest;
import org.junit.tests.experimental.interceptor.NameInterceptorTest;
import org.junit.tests.experimental.interceptor.TempFolderInterceptorTest;
import org.junit.tests.experimental.interceptor.TimeoutInterceptorTest;
import org.junit.tests.experimental.interceptor.VerifierInterceptorTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	RulesTest.class,
	TimeoutRuleTest.class,
||||||| BASE
	MaxComputerTest.class,
	InterceptorTest.class,
	TimeoutInterceptorTest.class,
=======
	InterceptorTest.class,
	TimeoutInterceptorTest.class,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	NameRulesTest.class,
	ExpectedExceptionRuleTest.class,
	TempFolderRuleTest.class,
	ExternalResourceRuleTest.class,
	VerifierRuleTest.class
||||||| BASE
	NameInterceptorTest.class,
	ExpectedExceptionInterceptorTest.class,
	TempFolderInterceptorTest.class,
	ExternalResourceInterceptorTest.class
=======
	NameInterceptorTest.class,
	ExpectedExceptionInterceptorTest.class,
	TempFolderInterceptorTest.class,
	ExternalResourceInterceptorTest.class,
	VerifierInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
import org.junit.rules.MethodRule;
||||||| BASE
=======
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/junit/framework/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/junit/framework/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/runners/model/InitializationError.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/runners/model/InitializationError.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/CategoryType.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/CategoryClass.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/Category.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	
	// TODO: rename var
	public Test asTest(Plan plan) {
		if (plan.isSuite())
			return createTest(plan);
		else
			return asSingleTest(plan.getDescription());
	}

	private Test asSingleTest(Description description) {
		if (!containsKey(description))
			put(description, createSingleTest(description));
		return get(description);
||||||| BASE
	
	public Test asTest(Description description) {
		if (description.isSuite())
			return createTest(description);
		else {
			if (!containsKey(description))
				put(description, createTest(description));
			return get(description);
		}
=======

	public List<Test> asTestList(Plan plan) {
		Description description= plan.getDescription();
		if (description.isTest())
			return Arrays.asList(asTestCase(description));
		else {
			List<Test> returnThis= new ArrayList<Test>();
			for (Plan child : plan.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	Test createTest(Plan plan) {
		Description description= plan.getDescription();
		if (plan.isTest())
			return createSingleTest(description);
		else {
			TestSuite suite = new TestSuite(description.getDisplayName());
			for (Plan child : plan.getChildren())
				suite.addTest(asTest(child));
			return suite;
		}
||||||| BASE
	Test createTest(Description description) {
		if (description.isTest())
			return new JUnit4TestCaseFacade(description);
		else {
			TestSuite suite = new TestSuite(description.getDisplayName());
			for (Description child : description.getChildren())
				suite.addTest(asTest(child));
			return suite;
		}
=======
	public Test asTest(Plan plan) {
		Description description= plan.getDescription();
		if (description.isSuite())
			return asTestSuite(plan);
		else
			return asTestCase(description);
	}

	private Test asTestSuite(Plan plan) {
		return createTestSuite(plan);
	}

	private Test createTestSuite(Plan plan) {
		TestSuite suite= new TestSuite(plan.getDescription().getDisplayName());
		for (Plan child : plan.getChildren())
			suite.addTest(asTest(child));
		return suite;
	}
	
	private Test asTestCase(Description description) {
		if (!containsKey(description))
			put(description, createTestCase(description));
		return get(description);
	}

	private Test createTestCase(Description description) {
		return new JUnit4TestCaseFacade(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE

	public List<Test> asTestList(Plan plan) {
		if (plan.isTest())
			return Arrays.asList(asTest(plan));
		else {
			List<Test> returnThis = new ArrayList<Test>();
			for (Plan child : plan.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
		}
	}

||||||| BASE

	public List<Test> asTestList(Description description) {
		if (description.isTest())
			return Arrays.asList(asTest(description));
		else {
			List<Test> returnThis = new ArrayList<Test>();
			for (Description child : description.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
		}
	}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: unpublic!
	public RunnerScheduler fScheduler= new RunnerScheduler() {
||||||| BASE
	private Sorter fSorter= Sorter.NULL;

	private RunnerScheduler fScheduler= new RunnerScheduler() {	
=======
	private RunnerScheduler fScheduler= new RunnerScheduler() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: public?
	public void runChildren(final RunNotifier notifier) {
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
||||||| BASE
	private void runChildren(final RunNotifier notifier) {
		for (final T each : getFilteredChildren())
			fScheduler.schedule(new Runnable() {			
=======
	private void runChildren(final RunNotifier notifier) {
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: public?
	public List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
||||||| BASE
	private List<T> getFilteredChildren() {
		ArrayList<T> filtered= new ArrayList<T>();
		for (T each : getChildren())
			if (shouldRun(each))
				try {
					filterChild(each);
					sortChild(each);
					filtered.add(each);
				} catch (NoTestsRemainException e) {
					// don't add it
				}
		Collections.sort(filtered, comparator());
		return filtered;
	}

	private void sortChild(T child) {
		fSorter.apply(child);
	}

	private void filterChild(T child) throws NoTestsRemainException {
		if (fFilter != null)
			fFilter.apply(child);
	}

	private boolean shouldRun(T each) {
		return fFilter == null || fFilter.shouldRun(describeChild(each));
=======
	private List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runner/Plan.java;<<<<<<< MINE
package org.junit.runner;

import java.util.ArrayList;
import java.util.List;

public abstract class Plan {
	public abstract Description getDescription();
	public abstract List<Plan> getChildren();

	public static Plan fromDescription(final Description description) {
		return new Plan() {
			@Override
			public Description getDescription() {
				return description;
			}
			
			@Override
			public List<Plan> getChildren() {
				List<Description> childrenDescs= description.getChildrenInternal();
				ArrayList<Plan> children= new ArrayList<Plan>();
				for (Description each : childrenDescs)
					children.add(Plan.fromDescription(each));
				return children;
			}
		};
	}
	
	public boolean isSuite() {
		return getChildren().size() > 0;
	}
	
	public boolean isTest() {
		return !isSuite();
	}
}||||||| BASE
=======
package org.junit.runner;

import java.util.ArrayList;
import java.util.List;

public class Plan {
	private final Description fDescription;

	private Plan(Description description) {
		fDescription= description;
	}

	public Description getDescription() {
		return fDescription;
	}

	public List<Plan> getChildren() {
		ArrayList<Plan> results= new ArrayList<Plan>();
		ArrayList<Description> children= fDescription.getChildren();
		for (Description each : children)
			results.add(Plan.fromDescription(each));
		return results;
	}

	static Plan fromDescription(Description description) {
		return new Plan(description);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runner/Runner.java;<<<<<<< MINE

	public Plan getPlan() {
		return Plan.fromDescription(getDescription());
	}
||||||| BASE
=======
	
	public Plan getPlan() {
		return Plan.fromDescription(getDescription());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private void findLeaves(Plan parent, Plan plan, List<Description> results) {
		if (plan.getChildren().isEmpty())
			if (plan.getDescription().toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent.getDescription()));
||||||| BASE
	private void findLeaves(Description parent, Description description, List<Description> results) {
		if (description.getChildren().isEmpty())
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
=======
	private void findLeaves(Description parent, Plan plan, List<Description> results) {
		Description description = plan.getDescription();
		if (plan.getChildren().isEmpty())
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			for (Plan each : plan.getChildren())
				findLeaves(plan, each, results);
||||||| BASE
			for (Description each : description.getChildren())
				findLeaves(description, each, results);
=======
			for (Plan each : plan.getChildren())
				findLeaves(description, each, results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
	
	@Test public void failIfEverythingIsIgnoredOut() {
||||||| BASE
	
	@Test public void descriptionAndRunNotificationsAreConsistent() {
=======

	// when executing as JUnit 3, ignored tests are stripped out before execution
	@Test
	public void descriptionAndRunNotificationsAreConsistent() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		assertEquals(1, result.getFailureCount());
||||||| BASE
		
		Description description= Request.aClass(CompatibilityTest.class).getRunner().getDescription();
		assertEquals(0, description.getChildren().size());
=======

		Runner runner= Request.aClass(CompatibilityTest.class).getRunner();
		Description description= runner.getDescription();
		assertEquals(1, description.getChildren().size());
		assertEquals("initializationError", description.getChildren().get(0)
				.getMethodName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/ThreeTestCases.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/runner/Version.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/rules/ExternalResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/rules/ExternalResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/JUnitCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunNotifier.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunNotifier.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunNotifier.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Runner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Runner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/PotentialAssignment.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/ThreeTestCases.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/listening/TestListenerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/listening/TestListenerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/listening/TestListenerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_63f40a8_ab51452/rev_63f40a8-ab51452/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	
	/**
	 * @return the MethodRules that can transform the block
	 * that runs each method in the tested class.
	 */
	protected List<MethodRule> rules(Object test) {
		List<MethodRule> results= new ArrayList<MethodRule>();
		for (FrameworkField each : ruleFields()) {
			if (MethodRule.class.isAssignableFrom(each.getType())) {
				results.add(createRule(test, each));
			}
		}
		return results;
	}

	private MethodRule createRule(Object test,
			FrameworkField each) {
		try {
			return (MethodRule) each.get(test);
		} catch (IllegalAccessException e) {
			throw new RuntimeException(
					"How did getFields return a field we couldn't access?");
		}
	}
||||||| BASE
	
	/**
	 * @return the MethodRules that can transform the block
	 * that runs each method in the tested class.
	 */
	protected List<MethodRule> rules(Object test) {
		List<MethodRule> results= new ArrayList<MethodRule>();
		for (FrameworkField each : ruleFields())
			results.add(createRule(test, each));
		return results;
	}

	private List<FrameworkField> ruleFields() {
		return getTestClass().getAnnotatedFields(Rule.class);
	}

	private MethodRule createRule(Object test,
			FrameworkField each) {
		try {
			return (MethodRule) each.get(test);
		} catch (IllegalAccessException e) {
			throw new RuntimeException(
					"How did getFields return a field we couldn't access?");
		}
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/rules/ClassRule.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/model/FrameworkField.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/test/java/org/junit/tests/experimental/rules/ClassRulesTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/test/java/org/junit/tests/AllTests.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_5f25ca3_bed58a5/rev_5f25ca3-bed58a5/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
 * ways.  {@link org.junit.Rule} annotates method-level 
 * {@link TestRule}s, and {@link org.junit.ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
||||||| BASE
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
=======
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See the Javadoc for those annotations
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f27f809_d97f30a/rev_f27f809-d97f30a/src/test/java/redis/clients/jedis/tests/SharedJedisPipelineTest.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis.tests;

import org.junit.Before;
import org.junit.Test;
import redis.clients.jedis.*;
import redis.clients.jedis.exceptions.JedisDataException;

import java.io.UnsupportedEncodingException;
import java.util.*;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.flushAll();
        jedis.disconnect();

        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(new JedisShardInfo(redis1.host, redis1.port));
        shards.add(new JedisShardInfo(redis2.host, redis2.port));
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(new Double(2), zincrby.get());
        assertEquals(new Long(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}=======
package redis.clients.jedis.tests;

import org.junit.Before;
import org.junit.Test;
import redis.clients.jedis.*;
import redis.clients.jedis.exceptions.JedisDataException;

import java.io.UnsupportedEncodingException;
import java.util.*;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();

        JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.host, redis1.port);
        JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.host, redis2.port);
        shardInfo1.setPassword("foobared");
        shardInfo2.setPassword("foobared");
        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(shardInfo1);
        shards.add(shardInfo2);
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));
    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(new Double(2), zincrby.get());
        assertEquals(new Long(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_0781e97_7f6173a/rev_0781e97-7f6173a/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
 * ways.  {@link org.junit.Rule} annotates method-level 
 * {@link TestRule}s, and {@link org.junit.ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
||||||| BASE
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See the Javadoc for those annotations
=======
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_cb1b19b_04f6038/rev_cb1b19b-04f6038/src/test/java/redis/clients/jedis/tests/SharedJedisPipelineTest.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis.tests;

import org.junit.Before;
import org.junit.Test;
import redis.clients.jedis.*;
import redis.clients.jedis.exceptions.JedisDataException;

import java.io.UnsupportedEncodingException;
import java.util.*;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.flushAll();
        jedis.disconnect();

        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(new JedisShardInfo(redis1.host, redis1.port));
        shards.add(new JedisShardInfo(redis2.host, redis2.port));
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(new Double(2), zincrby.get());
        assertEquals(new Long(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}=======
package redis.clients.jedis.tests;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import org.junit.Before;
import org.junit.Test;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.Response;
import redis.clients.jedis.ShardedJedis;
import redis.clients.jedis.ShardedJedisPipeline;
import redis.clients.jedis.Tuple;
import redis.clients.jedis.exceptions.JedisDataException;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.flushAll();
        jedis.disconnect();

        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(new JedisShardInfo(redis1.host, redis1.port));
        shards.add(new JedisShardInfo(redis2.host, redis2.port));
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(Double.valueOf(2), zincrby.get());
        assertEquals(Long.valueOf(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e857122_9d8bb06/rev_e857122-9d8bb06/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
	protected abstract Statement apply(Statement base, Description description);
||||||| BASE
	protected abstract Statement apply(Statement base, Description description);

	/**
	 * Modifies the method-running {@link Statement} to implement the additional
	 * test-running rules.
	 *
	 * @param rules The {@link TestRule rules} to apply
	 * @param base The {@link Statement} to be modified
	 * @param description A {@link Description} of the test implemented in {@code base}
	 * @return a new statement, which may be the same as {@code base},
	 * a wrapper around {@code base}, or a completely new Statement.
	 */
	public static Statement applyAll(Iterable<TestRule> rules, Statement base,
			Description description) {
		Statement result = base;
		for (TestRule each : rules)
			result= each.apply(result, description);
		return result;
	}
=======
	Statement apply(Statement base, Description description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e857122_9d8bb06/rev_e857122-9d8bb06/src/main/java/org/junit/rules/TestWatcher.java;<<<<<<< MINE
public abstract class TestWatcher extends TestRule {
	@Override
	protected Statement apply(final Statement base, final Description description) {
||||||| BASE
public class TestWatcher extends TestRule {
	@Override
	protected Statement apply(final Statement base, final Description description) {
=======
public class TestWatcher implements TestRule {
	public Statement apply(final Statement base, final Description description) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e857122_9d8bb06/rev_e857122-9d8bb06/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
import org.junit.rules.RunRules;
||||||| BASE
=======
import org.junit.rules.MethodRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_fb723db_72ca494/rev_fb723db-72ca494/src/main/java/redis/clients/jedis/Response.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_fb723db_72ca494/rev_fb723db-72ca494/src/main/java/redis/clients/jedis/Response.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_fb723db_72ca494/rev_fb723db-72ca494/src/test/java/redis/clients/jedis/tests/PipeliningTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_708ed37_9d8bb06/rev_708ed37-9d8bb06/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
import org.junit.internal.AssumptionViolatedException;
import org.junit.internal.runners.model.EachTestNotifier;
||||||| BASE
import org.junit.internal.AssumptionViolatedException;
import org.junit.internal.runners.model.EachTestNotifier;
import org.junit.internal.runners.model.MultipleFailureException;
=======
import org.junit.internal.runners.model.MultipleFailureException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
    
    /**
     * Evaluates scripts using the Lua interpreter built into Redis starting from version 2.6.0.
     * <p>
     * 
     * @return Script result
     */
	public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	    client.setTimeoutInfinite();
        client.eval(script, toByteArray(keys.size()), getParams(keys, args));
        return client.getOne();
	}
	private byte[][] getParams(List<byte[]> keys, List<byte[]> args){
    	int keyCount = keys.size();
    	byte[][] params = new byte[keyCount + args.size()][];
    	
    	for(int i=0;i<keyCount;i++)
    		params[i] = keys.get(i);
    	
    	for(int i=0;i<keys.size();i++)
    		params[keyCount + i] = args.get(i);
    	
    	return params;
    }
	public Object eval(byte[] script, byte[] keyCount, byte[][] params) {
	    client.setTimeoutInfinite();
        client.eval(script, keyCount, params);
        return client.getOne();
	}
	
	public byte[] scriptFlush(){
    	client.scriptFlush();
    	return client.getBinaryBulkReply();
    }
	
    public List<Long> scriptExists(byte[]... sha1){
		client.scriptExists(sha1);
		return client.getIntegerMultiBulkReply();
    }
    
    public byte[] scriptLoad(byte[] script){
    	client.scriptLoad(script);
    	return client.getBinaryBulkReply();
    }
    
    public byte[] scriptKill(){
    	client.scriptKill();
    	return client.getBinaryBulkReply();
    }
||||||| BASE
=======
    
	public byte[] slowlogReset() {
		client.slowlogReset();
		return client.getBinaryBulkReply();
	}
	
	public long slowlogLen() {
		client.slowlogLen();
		return client.getIntegerReply();
	}
	
	public List<byte[]> slowlogGetBinary() {
		client.slowlogGet();
		return client.getBinaryMultiBulkReply();
	}
	
	public List<byte[]> slowlogGetBinary(long entries) {
		client.slowlogGet(entries);
		return client.getBinaryMultiBulkReply();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    
    private void sendEvalCommand(Command command, byte[] script, byte[] keyCount, byte[][] params){
    	
    	final byte[][] allArgs = new byte[params.length + 2][];
    	
    	allArgs[0] = script;
    	allArgs[1] = keyCount;
    	
    	for(int i=0;i<params.length; i++)
    		allArgs[i+2] = params[i];
    	
    	sendCommand(command, allArgs );
    }
    
    public void eval(byte[] script, byte[] keyCount, byte[][] params){
    	sendEvalCommand(EVAL, script, keyCount, params );
    }
    
    public void evalsha(byte[] sha1, byte[] keyCount, byte[][] params){
    	sendEvalCommand(EVALSHA, sha1, keyCount, params);
    }
    
    public void scriptFlush(){
    	sendCommand(SCRIPT, Keyword.FLUSH.raw);
    }
    
    public void scriptExists(byte[]... sha1){
    	byte[][] args = new byte[sha1.length + 1][];
    	args[0] = Keyword.EXISTS.raw;
    	for(int i=0;i<sha1.length; i++)
    		args[i+1] = sha1[i];
    	
    	sendCommand(SCRIPT, args);
    }
    
    public void scriptLoad(byte[] script){
    	sendCommand(SCRIPT, Keyword.LOAD.raw, script);
    }
    
    public void scriptKill(){
    	sendCommand(SCRIPT, Keyword.KILL.raw);
    }
||||||| BASE
=======

	public void slowlogGet() {
		sendCommand(SLOWLOG, Keyword.GET.raw);
	}
	
	public void slowlogGet(long entries) {
		sendCommand(SLOWLOG, Keyword.GET.raw, toByteArray(entries));
	}
	
	public void slowlogReset() {
		sendCommand(SLOWLOG, RESET.raw);
	}
	
	public void slowlogLen() {
		sendCommand(SLOWLOG, LEN.raw);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import redis.clients.util.SafeEncoder;
||||||| BASE
=======
import redis.clients.util.Slowlog;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    }

    public Object eval(String script, int keyCount, String... params) {
    	client.setTimeoutInfinite();
        client.eval(script, keyCount, params);
        
        return getEvalResult();
    }
	
    private String[] getParams(List<String> keys, List<String> args){
    	int keyCount = keys.size();
		int argCount = args.size();
    	
    	String[] params = new String[keyCount + args.size()];
    	
    	for(int i=0;i<keyCount;i++)
    		params[i] = keys.get(i);
    	
    	for(int i=0;i<argCount;i++)
    		params[keyCount + i] = args.get(i);
    	
    	return params;
    }
    
    public Object eval(String script, List<String> keys, List<String> args) {
    	return eval(script, keys.size(), getParams(keys, args));
	}

	public Object eval(String script) {
		return eval(script,0);		
	}

	public Object evalsha(String script) {
		return evalsha(script,0);		
	}
    
    private Object getEvalResult(){
    	Object result = client.getOne();
        
        if(result instanceof byte[])
        	return SafeEncoder.encode((byte[])result);
        
        if(result instanceof List<?>) {
        	List<?> list = (List<?>)result;
        	List<String> listResult = new ArrayList<String>(list.size());
        	for(Object bin: list)
        		listResult.add(SafeEncoder.encode((byte[])bin));
        	
        	return listResult;
        }
        
        return result;
    }
    
    public Object evalsha(String sha1, List<String> keys, List<String> args) {
    	return evalsha(sha1, keys.size(), getParams(keys, args));
    }
    
	public Object evalsha(String sha1, int keyCount, String... params) {
		checkIsInMulti();
        client.evalsha(sha1, keyCount, params);
        
        return getEvalResult();
    }
	
	public Boolean scriptExists(String sha1){
		String[] a = new String[1];
		a[0] = sha1;
		return scriptExists(a).get(0);
    }

	public List<Boolean> scriptExists(String... sha1){
		client.scriptExists(sha1);
		List<Long> result = client.getIntegerMultiBulkReply();
		List<Boolean> exists = new ArrayList<Boolean>();
		
		for(Long value : result)
			exists.add(value == 1);
		
		return exists;
    }
	
    public String scriptLoad(String script){
    	client.scriptLoad(script);
    	return client.getBulkReply();
    }
||||||| BASE
    }    
=======
    }
    
    public List<Slowlog> slowlogGet() {
		client.slowlogGet();
		return Slowlog.from(client.getObjectMultiBulkReply());
	}
	
	public List<Slowlog> slowlogGet(long entries) {
		client.slowlogGet(entries);
		return Slowlog.from(client.getObjectMultiBulkReply());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT;
||||||| BASE
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE;
=======
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, SLOWLOG;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, FLUSH, EXISTS, LOAD, KILL;
||||||| BASE
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT;
=======
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LEN, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, RESET;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/JedisCommands.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/JedisCommands.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE

    private byte[][] getByteParams(String... params){
    	byte[][] p = new byte[params.length][];
		for(int i=0;i<params.length;i++)
			p[i] = SafeEncoder.encode(params[i]);
		
		return p;
    }
    
    public void eval(String script, int keyCount, String... params) {
		eval(SafeEncoder.encode(script),toByteArray(keyCount), getByteParams(params));		
	}

	public void evalsha(String sha1, int keyCount, String... params) {
		evalsha(SafeEncoder.encode(sha1),toByteArray(keyCount), getByteParams(params));				
	}
	
	public void scriptExists(String... sha1){
		final byte[][] bsha1 = new byte[sha1.length][];
        for (int i = 0; i < bsha1.length; i++) {
        	bsha1[i] = SafeEncoder.encode(sha1[i]);
        }
		scriptExists(bsha1);
    }
	
    public void scriptLoad(String script){
    	scriptLoad(SafeEncoder.encode(script));
    }
||||||| BASE
=======

	public void zadd(String key, Map<Double, String> scoreMembers) {
		HashMap<Double,byte[]> binaryScoreMembers = new HashMap<Double,byte[]>();
		
		for(Map.Entry<Double,String> entry : scoreMembers.entrySet()){
			binaryScoreMembers.put(entry.getKey(), SafeEncoder.encode(entry.getValue()));
		}
	    
		zaddBinary(SafeEncoder.encode(key), binaryScoreMembers);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	client.configSet(parameter, value);
	return client.getStatusCodeReply();
    }

    public Object eval(String script, int keyCount, String... params) {
	client.setTimeoutInfinite();
	client.eval(script, keyCount, params);

	return getEvalResult();
    }

    private String[] getParams(List<String> keys, List<String> args) {
	int keyCount = keys.size();
	int argCount = args.size();

	String[] params = new String[keyCount + args.size()];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return params;
    }

    public Object eval(String script, List<String> keys, List<String> args) {
	return eval(script, keys.size(), getParams(keys, args));
    }

    public Object eval(String script) {
	return eval(script, 0);
    }

    public Object evalsha(String script) {
	return evalsha(script, 0);
    }

    private Object getEvalResult() {
	Object result = client.getOne();

	if (result instanceof byte[])
	    return SafeEncoder.encode((byte[]) result);

	if (result instanceof List<?>) {
	    List<?> list = (List<?>) result;
	    List<String> listResult = new ArrayList<String>(list.size());
	    for (Object bin : list)
		listResult.add(SafeEncoder.encode((byte[]) bin));

	    return listResult;
	}

	return result;
    }

    public Object evalsha(String sha1, List<String> keys, List<String> args) {
	return evalsha(sha1, keys.size(), getParams(keys, args));
    }

    public Object evalsha(String sha1, int keyCount, String... params) {
	checkIsInMulti();
	client.evalsha(sha1, keyCount, params);

	return getEvalResult();
    }

    public Boolean scriptExists(String sha1) {
	String[] a = new String[1];
	a[0] = sha1;
	return scriptExists(a).get(0);
    }

    public List<Boolean> scriptExists(String... sha1) {
	client.scriptExists(sha1);
	List<Long> result = client.getIntegerMultiBulkReply();
	List<Boolean> exists = new ArrayList<Boolean>();

	for (Long value : result)
	    exists.add(value == 1);

	return exists;
    }

    public String scriptLoad(String script) {
	client.scriptLoad(script);
	return client.getBulkReply();
    }

    public List<Slowlog> slowlogGet() {
	client.slowlogGet();
	return Slowlog.from(client.getObjectMultiBulkReply());
    }

    public List<Slowlog> slowlogGet(long entries) {
	client.slowlogGet(entries);
	return Slowlog.from(client.getObjectMultiBulkReply());
    }
||||||| BASE
        client.configSet(parameter, value);
        return client.getStatusCodeReply();
    }    
=======
        client.configSet(parameter, value);
        return client.getStatusCodeReply();
    }

	public Long objectRefcount(String string) {
		client.objectRefcount(string);
		return client.getIntegerReply();
	}
	
	public String objectEncoding(String string) {
		client.objectEncoding(string);
		return client.getBulkReply();
	}

	public Long objectIdletime(String string) {
		client.objectIdletime(string);
		return client.getIntegerReply();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
    
||||||| BASE
=======
    
    Long objectRefcount(byte[] key);
	
	Long objectIdletime(byte[] key);
	
	byte[] objectEncoding(byte[] key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG;
||||||| BASE
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE;
=======
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, OBJECT;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, RESET, FLUSH, EXISTS, LOAD, KILL, LEN;
	public final byte[] raw;
||||||| BASE
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT;
        public final byte[] raw;
=======
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, REFCOUNT, ENCODING, IDLETIME;
        public final byte[] raw;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_42f19c7_ded776f/rev_42f19c7-ded776f/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE

    Long objectRefcount(byte[] key);

    Long objectIdletime(byte[] key);

    byte[] objectEncoding(byte[] key);
||||||| BASE
=======

    Long lpushx(byte[] key, byte[] string);    

    Long rpushx(byte[] key, byte[] string); 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<String> zrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrange(key, start, end);
||||||| BASE
    public Set<String> zrange(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrange(key, start, end);
=======
    public Set<String> zrange(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrange(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<String> zrevrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrange(key, start, end);
||||||| BASE
    public Set<String> zrevrange(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrevrange(key, start, end);
=======
    public Set<String> zrevrange(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrevrange(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<Tuple> zrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrangeWithScores(key, start, end);
||||||| BASE
    public Set<Tuple> zrangeWithScores(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrangeWithScores(key, start, end);
=======
    public Set<Tuple> zrangeWithScores(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrangeWithScores(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<Tuple> zrevrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrangeWithScores(key, start, end);
||||||| BASE
    public Set<Tuple> zrevrangeWithScores(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zrevrangeWithScores(key, start, end);
=======
    public Set<Tuple> zrevrangeWithScores(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrevrangeWithScores(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Long zremrangeByRank(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zremrangeByRank(key, start, end);
||||||| BASE
    public Long zremrangeByRank(String key, int start, int end) {
        Jedis j = getShard(key);
        return j.zremrangeByRank(key, start, end);
=======
    public Long zremrangeByRank(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zremrangeByRank(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrange(final byte[] key, final int start, final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
||||||| BASE
    public void zrange(final byte[] key, final int start, final int end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
=======
    public void zrange(final byte[] key, final long start, final long end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrange(final byte[] key, final int start, final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
||||||| BASE
    public void zrevrange(final byte[] key, final int start, final int end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
=======
    public void zrevrange(final byte[] key, final long start, final long end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
||||||| BASE
    public void zrangeWithScores(final byte[] key, final int start,
            final int end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
=======
    public void zrangeWithScores(final byte[] key, final long start,
            final long end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
||||||| BASE
    public void zrevrangeWithScores(final byte[] key, final int start,
            final int end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
=======
    public void zrevrangeWithScores(final byte[] key, final long start,
            final long end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zremrangeByRank(final byte[] key, final int start, final int end) {
	sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
||||||| BASE
    public void zremrangeByRank(final byte[] key, final int start, final int end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
=======
    public void zremrangeByRank(final byte[] key, final long start, final long end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<String> zrange(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
||||||| BASE
    public Set<String> zrange(final String key, final int start, final int end) {
        checkIsInMulti();
        client.zrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
=======
    public Set<String> zrange(final String key, final long start, final long end) {
        checkIsInMulti();
        client.zrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<String> zrevrange(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
||||||| BASE
    public Set<String> zrevrange(final String key, final int start,
            final int end) {
        checkIsInMulti();
        client.zrevrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
=======
    public Set<String> zrevrange(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrevrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<Tuple> zrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
||||||| BASE
    public Set<Tuple> zrangeWithScores(final String key, final int start,
            final int end) {
        checkIsInMulti();
        client.zrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
=======
    public Set<Tuple> zrangeWithScores(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<Tuple> zrevrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
||||||| BASE
    public Set<Tuple> zrevrangeWithScores(final String key, final int start,
            final int end) {
        checkIsInMulti();
        client.zrevrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
=======
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrevrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Long zremrangeByRank(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
||||||| BASE
    public Long zremrangeByRank(final String key, final int start, final int end) {
        checkIsInMulti();
        client.zremrangeByRank(key, start, end);
        return client.getIntegerReply();
=======
    public Long zremrangeByRank(final String key, final long start, final long end) {
        checkIsInMulti();
        client.zremrangeByRank(key, start, end);
        return client.getIntegerReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrange(final String key, final int start, final int end) {
	zrange(SafeEncoder.encode(key), start, end);
||||||| BASE
    public void zrange(final String key, final int start, final int end) {
        zrange(SafeEncoder.encode(key), start, end);
=======
    public void zrange(final String key, final long start, final long end) {
        zrange(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrevrange(final String key, final int start, final int end) {
	zrevrange(SafeEncoder.encode(key), start, end);
||||||| BASE
    public void zrevrange(final String key, final int start, final int end) {
        zrevrange(SafeEncoder.encode(key), start, end);
=======
    public void zrevrange(final String key, final long start, final long end) {
        zrevrange(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrangeWithScores(final String key, final int start,
	    final int end) {
	zrangeWithScores(SafeEncoder.encode(key), start, end);
||||||| BASE
    public void zrangeWithScores(final String key, final int start,
            final int end) {
        zrangeWithScores(SafeEncoder.encode(key), start, end);
=======
    public void zrangeWithScores(final String key, final long start,
            final long end) {
        zrangeWithScores(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrevrangeWithScores(final String key, final int start,
	    final int end) {
	zrevrangeWithScores(SafeEncoder.encode(key), start, end);
||||||| BASE
    public void zrevrangeWithScores(final String key, final int start,
            final int end) {
        zrevrangeWithScores(SafeEncoder.encode(key), start, end);
=======
    public void zrevrangeWithScores(final String key, final long start,
            final long end) {
        zrevrangeWithScores(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zremrangeByRank(final String key, final int start, final int end) {
	zremrangeByRank(SafeEncoder.encode(key), start, end);
||||||| BASE
    public void zremrangeByRank(final String key, final int start, final int end) {
        zremrangeByRank(SafeEncoder.encode(key), start, end);
=======
    public void zremrangeByRank(final String key, final long start, final long end) {
        zremrangeByRank(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
    public void zadd(final String key, final Map<Double, String> scoreMembers);

    public void zrange(final String key, final int start, final int end);
||||||| BASE
    public void zrange(final String key, final int start, final int end);
=======
    public void zrange(final String key, final long start, final long end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
    public void zrangeWithScores(final String key, final int start,
	    final int end);
||||||| BASE
    public void zrangeWithScores(final String key, final int start,
            final int end);
=======
    public void zrangeWithScores(final String key, final long start,
            final long end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
    public void zrevrangeWithScores(final String key, final int start,
	    final int end);
||||||| BASE
    public void zrevrangeWithScores(final String key, final int start,
            final int end);
=======
    public void zrevrangeWithScores(final String key, final long start,
            final long end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1a96769_4570329/rev_1a96769-4570329/src/main/java/redis/clients/jedis/JedisCommands.java;<<<<<<< MINE

    List<String> blpop(String arg);

    List<String> brpop(String arg);

    Long del(String key);

    String echo(String string);

    Long move(String key, int dbIndex);
||||||| BASE
=======

    Long bitcount(final String key);

    Long bitcount(final String key, long start, long end);

    Long bitop(BitOP op, final String destKey, String... srcKeys);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE

    public void bitcount(byte[] key) {
        sendCommand(BITCOUNT, key);
    }

    public void bitcount(byte[] key, long start, long end) {
        sendCommand(BITCOUNT, key, toByteArray(start), toByteArray(end));
    }

    public void bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
        Keyword kw = Keyword.AND;
        int len = srcKeys.length;
        switch (op) {
            case AND:
                kw = Keyword.AND;
                break;
            case OR:
                kw = Keyword.OR;
                break;
            case XOR:
                kw = Keyword.XOR;
                break;
            case NOT:
                kw = Keyword.NOT;
                len = Math.min(1, len);
                break;
        }

        byte[][] bargs = new byte[len + 2][];
        bargs[0] = kw.raw;
        bargs[1] = destKey;
        for (int i = 0; i < len; ++i) {
            bargs[i + 2] = srcKeys[i];
        }

        sendCommand(BITOP, bargs);
    }
||||||| BASE
=======

    public void sentinel(final byte[]... args) {
  sendCommand(SENTINEL, args);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    public Long bitcount(final String key) {
        client.bitcount(key);
        return client.getIntegerReply();
    }

    public Long bitcount(final String key, long start, long end) {
        client.bitcount(key, start, end);
        return client.getIntegerReply();
    }

    public Long bitop(BitOP op, final String destKey, String... srcKeys) {
        client.bitop(op, destKey, srcKeys);
        return client.getIntegerReply();
    }
||||||| BASE
=======

  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel masters
   * 1)  1) "name"
   *     2) "mymaster"
   *     3) "ip"
   *     4) "127.0.0.1"
   *     5) "port"
   *     6) "6379"
   *     7) "runid"
   *     8) "93d4d4e6e9c06d0eea36e27f31924ac26576081d"
   *     9) "flags"
   *    10) "master"
   *    11) "pending-commands"
   *    12) "0"
   *    13) "last-ok-ping-reply"
   *    14) "423"
   *    15) "last-ping-reply"
   *    16) "423"
   *    17) "info-refresh"
   *    18) "6107"
   *    19) "num-slaves"
   *    20) "1"
   *    21) "num-other-sentinels"
   *    22) "2"
   *    23) "quorum"
   *    24) "2"
   *
   * </pre>
   *
   * @return
   */
  public List<Map<String, String>> sentinelMasters() {
    client.sentinel(Protocol.SENTINEL_MASTERS);
    final List<Object> reply = client.getObjectMultiBulkReply();

    final List<Map<String,String>> masters = new ArrayList<Map<String,String>>();
    for (Object obj : reply) {
      masters.add(BuilderFactory.STRING_MAP.build((List) obj));
    }
    return masters;
  }

  
  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel get-master-addr-by-name mymaster
   * 1) "127.0.0.1"
   * 2) "6379"
   * </pre>
   * 
   * @param masterName
   * @return two elements list of strings : host and port.
   */
  public List<String> sentinelGetMasterAddrByName(String masterName) {
    client.sentinel(Protocol.SENTINEL_GET_MASTER_ADDR_BY_NAME, masterName);
    final List<Object> reply = client.getObjectMultiBulkReply();
    return BuilderFactory.STRING_LIST.build(reply);
  }

  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel reset mymaster
   * (integer) 1
   * </pre>
   * 
   * @param pattern
   * @return
   */
  public Long sentinelReset(String pattern) {
    client.sentinel(Protocol.SENTINEL_RESET, pattern);
    return client.getIntegerReply();
  }

  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel slaves mymaster
   * 1)  1) "name"
   *     2) "127.0.0.1:6380"
   *     3) "ip"
   *     4) "127.0.0.1"
   *     5) "port"
   *     6) "6380"
   *     7) "runid"
   *     8) "d7f6c0ca7572df9d2f33713df0dbf8c72da7c039"
   *     9) "flags"
   *    10) "slave"
   *    11) "pending-commands"
   *    12) "0"
   *    13) "last-ok-ping-reply"
   *    14) "47"
   *    15) "last-ping-reply"
   *    16) "47"
   *    17) "info-refresh"
   *    18) "657"
   *    19) "master-link-down-time"
   *    20) "0"
   *    21) "master-link-status"
   *    22) "ok"
   *    23) "master-host"
   *    24) "localhost"
   *    25) "master-port"
   *    26) "6379"
   *    27) "slave-priority"
   *    28) "100"
   * </pre>
   * 
   * @param masterName
   * @return
   */
  public List<Map<String, String>> sentinelSlaves(String masterName) {
    client.sentinel(Protocol.SENTINEL_SLAVES, masterName);
    final List<Object> reply = client.getObjectMultiBulkReply();

    final List<Map<String,String>> slaves = new ArrayList<Map<String,String>>();
    for (Object obj : reply) {
      slaves.add(BuilderFactory.STRING_MAP.build((List) obj));
    }
    return slaves;
  }
  
  /**
   * <pre>
   * redis 127.0.0.1:26381> SENTINEL is-master-down-by-addr 127.0.0.1 1
   * 1) (integer) 0
   * 2) "?"
   * redis 127.0.0.1:26381> SENTINEL is-master-down-by-addr 127.0.0.1 6379
   * 1) (integer) 0
   * 2) "aaef11fbb2712346a386078c7f9834e72ed51e96"
   * </pre>
   * @return Long followed by the String (runid)
   */
  public List<? extends Object> sentinelIsMasterDownByAddr(String host, int port) {
    client.sentinel(Protocol.SENTINEL_IS_MASTER_DOWN_BY_ADDR, host, port);
    final List<Object> reply = client.getObjectMultiBulkReply();
    return Arrays.asList(BuilderFactory.LONG.build(reply.get(0)), BuilderFactory.STRING.build(reply.get(1)));
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE

    public void bitcount(final String key) {
        bitcount(SafeEncoder.encode(key));
    }

    public void bitcount(final String key, long start, long end) {
        bitcount(SafeEncoder.encode(key), start, end);
    }

    public void bitop(BitOP op, final String destKey, String... srcKeys) {
        bitop(op, SafeEncoder.encode(destKey), getByteParams(srcKeys));
    }
||||||| BASE
=======


  public void sentinel(final String... args) {
    final byte[][] arg = new byte[args.length][];
    for (int i = 0; i < arg.length; i++) {
      arg[i] = SafeEncoder.encode(args[i]);
    }
    sentinel(arg);
  }

  public void sentinel(final String cmd, String arg1, int arg2) {
    sentinel(SafeEncoder.encode(cmd), SafeEncoder.encode(arg1), toByteArray(arg2));
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP;
||||||| BASE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/ClassRule.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_610f7d4_69f5340/rev_610f7d4-69f5340/src/main/java/redis/clients/jedis/Pipeline.java;<<<<<<< MINE
    public Response<Long> append(String key, String value) {
        client.append(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(byte[] key, byte[] value) {
        client.append(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> blpop(String... args) {
        client.blpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(byte[]... args) {
        client.blpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(String... args) {
        client.brpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(byte[]... args) {
        client.brpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> decr(String key) {
        client.decr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(byte[] key) {
        client.decr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(String key, long integer) {
        client.decrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(byte[] key, long integer) {
        client.decrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(String... keys) {
        client.del(keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
        client.del(keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> echo(String string) {
        client.echo(string);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> echo(byte[] string) {
        client.echo(string);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> exists(String key) {
        client.exists(key);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> exists(byte[] key) {
        client.exists(key);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
        client.expire(key, seconds);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expire(byte[] key, int seconds) {
        client.expire(key, seconds);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
        client.expireAt(key, unixTime);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(byte[] key, long unixTime) {
        client.expireAt(key, unixTime);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> get(String key) {
        client.get(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> get(byte[] key) {
        client.get(key);
        return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> getbit(String key, long offset) {
        client.getbit(key, offset);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> getrange(String key, long startOffset,
            long endOffset) {
        client.getrange(key, startOffset, endOffset);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> getSet(String key, String value) {
        client.getSet(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> getSet(byte[] key, byte[] value) {
        client.getSet(key, value);
        return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> hdel(String key, String field) {
        client.hdel(key, field);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(byte[] key, byte[] field) {
        client.hdel(key, field);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> hexists(String key, String field) {
        client.hexists(key, field);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> hexists(byte[] key, byte[] field) {
        client.hexists(key, field);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> hget(String key, String field) {
        client.hget(key, field);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hget(byte[] key, byte[] field) {
        client.hget(key, field);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Map<String, String>> hgetAll(String key) {
        client.hgetAll(key);
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Map<String, String>> hgetAll(byte[] key) {
        client.hgetAll(key);
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Long> hincrBy(String key, String field, long value) {
        client.hincrBy(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
        client.hincrBy(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> hincrByFloat(String key, String field, double value) {
        client.hincrByFloat(key, field, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> hincrByFloat(byte[] key, byte[] field, double value) {
        client.hincrByFloat(key, field, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Set<String>> hkeys(String key) {
        client.hkeys(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> hkeys(byte[] key) {
        client.hkeys(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> hlen(String key) {
        client.hlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(byte[] key) {
        client.hlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hmget(String key, String... fields) {
        client.hmget(key, fields);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> hmget(byte[] key, byte[]... fields) {
        client.hmget(key, fields);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
        client.hmset(key, hash);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
        client.hmset(key, hash);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
        client.hset(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
        client.hset(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
        client.hsetnx(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
        client.hsetnx(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hvals(String key) {
        client.hvals(key);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> hvals(byte[] key) {
        client.hvals(key);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> incr(String key) {
        client.incr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incr(byte[] key) {
        client.incr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, long integer) {
        client.incrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(byte[] key, long integer) {
        client.incrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> incrByFloat(String key, double value) {
        client.incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double value) {
        client.incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Set<String>> keys(String pattern) {
        client.keys(pattern);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> keys(byte[] pattern) {
        client.keys(pattern);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<String> lindex(String key, int index) {
        client.lindex(key, index);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lindex(byte[] key, int index) {
        client.lindex(key, index);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> linsert(String key, LIST_POSITION where,
            String pivot, String value) {
        client.linsert(key, where, pivot, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(byte[] key, LIST_POSITION where,
            byte[] pivot, byte[] value) {
        client.linsert(key, where, pivot, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
        client.llen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(byte[] key) {
        client.llen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
        client.lpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lpop(byte[] key) {
        client.lpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lpush(String key, String string) {
        client.lpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(byte[] key, byte[] string) {
        client.lpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(String key, String string) {
        client.lpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(byte[] key, byte[] bytes) {
        client.lpushx(key, bytes);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, long start, long end) {
        client.lrange(key, start, end);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> lrange(byte[] key, long start, long end) {
        client.lrange(key, start, end);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> lrem(String key, long count, String value) {
        client.lrem(key, count, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lrem(byte[] key, long count, byte[] value) {
        client.lrem(key, count, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lset(String key, long index, String value) {
        client.lset(key, index, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(byte[] key, long index, byte[] value) {
        client.lset(key, index, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(String key, long start, long end) {
        client.ltrim(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(byte[] key, long start, long end) {
        client.ltrim(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> mget(String... keys) {
        client.mget(keys);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> mget(byte[]... keys) {
        client.mget(keys);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> move(String key, int dbIndex) {
        client.move(key, dbIndex);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> move(byte[] key, int dbIndex) {
        client.move(key, dbIndex);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> mset(String... keysvalues) {
        client.mset(keysvalues);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
        client.mset(keysvalues);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
        client.msetnx(keysvalues);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
        client.msetnx(keysvalues);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(String key) {
        client.persist(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(byte[] key) {
        client.persist(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
        client.rename(oldkey, newkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
        client.rename(oldkey, newkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
        client.renamenx(oldkey, newkey);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
        client.renamenx(oldkey, newkey);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpop(String key) {
        client.rpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpop(byte[] key) {
        client.rpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
        client.rpoplpush(srckey, dstkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpoplpush(byte[] srckey, byte[] dstkey) {
        client.rpoplpush(srckey, dstkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> rpush(String key, String string) {
        client.rpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpush(byte[] key, byte[] string) {
        client.rpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(String key, String string) {
        client.rpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(byte[] key, byte[] string) {
        client.rpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(String key, String member) {
        client.sadd(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(byte[] key, byte[] member) {
        client.sadd(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(String key) {
        client.scard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(byte[] key) {
        client.scard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sdiff(String... keys) {
        client.sdiff(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sdiff(byte[]... keys) {
        client.sdiff(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
        client.sdiffstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
        client.sdiffstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> set(String key, String value) {
        client.set(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value) {
        client.set(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
        client.setbit(key, offset, value);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> setex(String key, int seconds, String value) {
        client.setex(key, seconds, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> setex(byte[] key, int seconds, byte[] value) {
        client.setex(key, seconds, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
        client.setnx(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setnx(byte[] key, byte[] value) {
        client.setnx(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
        client.sinter(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sinter(byte[]... keys) {
        client.sinter(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
        client.sinterstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
        client.sinterstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
        client.sismember(key, member);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> sismember(byte[] key, byte[] member) {
        client.sismember(key, member);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Set<String>> smembers(String key) {
        client.smembers(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> smembers(byte[] key) {
        client.smembers(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
        client.smove(srckey, dstkey, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
        client.smove(srckey, dstkey, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key) {
        client.sort(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key) {
        client.sort(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> sort(String key,
            SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key,
            SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(String key,
            SortingParams sortingParameters, String dstkey) {
        client.sort(key, sortingParameters, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key,
            SortingParams sortingParameters, byte[] dstkey) {
        client.sort(key, sortingParameters, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(String key, String dstkey) {
        client.sort(key, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key, byte[] dstkey) {
        client.sort(key, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> spop(String key) {
        client.spop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> spop(byte[] key) {
        client.spop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> srandmember(String key) {
        client.srandmember(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> srandmember(byte[] key) {
        client.srandmember(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> srem(String key, String member) {
        client.srem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> srem(byte[] key, byte[] member) {
        client.srem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(String key) {
        client.strlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(byte[] key) {
        client.strlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
        client.substr(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> substr(byte[] key, int start, int end) {
        client.substr(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Set<String>> sunion(String... keys) {
        client.sunion(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sunion(byte[]... keys) {
        client.sunion(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
        client.sunionstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
        client.sunionstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(String key) {
        client.ttl(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(byte[] key) {
        client.ttl(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> type(String key) {
        client.type(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> type(byte[] key) {
        client.type(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(String... keys) {
        client.watch(keys);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
        client.watch(keys);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
        client.zadd(key, score, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(byte[] key, double score, byte[] member) {
        client.zadd(key, score, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(String key) {
        client.zcard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(byte[] key) {
        client.zcard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, double min, double max) {
        client.zcount(key, min, max);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(byte[] key, double min, double max) {
        client.zcount(key, toByteArray(min), toByteArray(max));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
        client.zincrby(key, score, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zincrby(byte[] key, double score, byte[] member) {
        client.zincrby(key, score, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
        client.zinterstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
        client.zinterstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
            String... sets) {
        client.zinterstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
            byte[]... sets) {
        client.zinterstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrange(String key, int start, int end) {
        client.zrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrange(byte[] key, int start, int end) {
        client.zrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
            double max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, double min,
            double max) {
        return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }
    
    public Response<Set<String>> zrangeByScore(String key, String min,
            String max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, byte[] min,
            byte[] max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
            double max, int offset, int count) {
        client.zrangeByScore(key, min, max, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, double min,
            double max, int offset, int count) {
        return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
    }
    
    public Response<Set<String>> zrangeByScore(byte[] key, byte[] min,
    		byte[] max, int offset, int count) {
        client.zrangeByScore(key, min, max, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
            double max) {
        client.zrangeByScoreWithScores(key, min, max);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
            double max) {
        return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }
    
    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
    		byte[] max) {
        client.zrangeByScoreWithScores(key, min, max);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
            double max, int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
            double max, int offset, int count) {
        client.zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
    		byte[] max, int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
            double min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, double max,
            double min) {
        client.zrevrangeByScore(key, toByteArray(max), toByteArray(min));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
            String min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, byte[] max,
            byte[] min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
            double min, int offset, int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, double max,
            double min, int offset, int count) {
        client.zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }
    
    public Response<Set<String>> zrevrangeByScore(byte[] key, byte[] max,
    		byte[] min, int offset, int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
            double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
            double max, double min) {
        client.zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
    		byte[] max, byte[] min) {
        client.zrevrangeByScoreWithScores(key, max, min);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
            double max, double min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
            double max, double min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
    		byte[] max, byte[] min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
        client.zrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(byte[] key, int start, int end) {
        client.zrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrank(String key, String member) {
        client.zrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrank(byte[] key, byte[] member) {
        client.zrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(String key, String member) {
        client.zrem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(byte[] key, byte[] member) {
        client.zrem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(String key, int start, int end) {
        client.zremrangeByRank(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(byte[] key, int start, int end) {
        client.zremrangeByRank(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
        client.zremrangeByScore(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
        client.zremrangeByScore(key, toByteArray(start), toByteArray(end));
        return getResponse(BuilderFactory.LONG);
    }
    
    public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
        client.zremrangeByScore(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, int start, int end) {
        client.zrevrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrange(byte[] key, int start, int end) {
        client.zrevrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, int start,
            int end) {
        client.zrevrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, int start,
            int end) {
        client.zrevrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrevrank(String key, String member) {
        client.zrevrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(byte[] key, byte[] member) {
        client.zrevrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
        client.zscore(key, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zscore(byte[] key, byte[] member) {
        client.zscore(key, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
        client.zunionstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
        client.zunionstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
            String... sets) {
        client.zunionstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
            byte[]... sets) {
        client.zunionstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
        client.bgrewriteaof();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
        client.bgsave();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
        client.configGet(pattern);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
        client.configSet(parameter, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
            int timeout) {
        client.brpoplpush(source, destination, timeout);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(byte[] source, byte[] destination,
            int timeout) {
        client.brpoplpush(source, destination, timeout);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configResetStat() {
        client.configResetStat();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
        client.save();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
        client.lastsave();
        return getResponse(BuilderFactory.LONG);
    }

||||||| BASE
    public Response<Long> append(String key, String value) {
        client.append(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(byte[] key, byte[] value) {
        client.append(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> blpop(String... args) {
        client.blpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(byte[]... args) {
        client.blpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(String... args) {
        client.brpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(byte[]... args) {
        client.brpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> decr(String key) {
        client.decr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(byte[] key) {
        client.decr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(String key, long integer) {
        client.decrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(byte[] key, long integer) {
        client.decrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(String... keys) {
        client.del(keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
        client.del(keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> echo(String string) {
        client.echo(string);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> echo(byte[] string) {
        client.echo(string);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> exists(String key) {
        client.exists(key);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> exists(byte[] key) {
        client.exists(key);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
        client.expire(key, seconds);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expire(byte[] key, int seconds) {
        client.expire(key, seconds);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
        client.expireAt(key, unixTime);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(byte[] key, long unixTime) {
        client.expireAt(key, unixTime);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> get(String key) {
        client.get(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> get(byte[] key) {
        client.get(key);
        return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> getbit(String key, long offset) {
        client.getbit(key, offset);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> getrange(String key, long startOffset,
            long endOffset) {
        client.getrange(key, startOffset, endOffset);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> getSet(String key, String value) {
        client.getSet(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> getSet(byte[] key, byte[] value) {
        client.getSet(key, value);
        return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> hdel(String key, String field) {
        client.hdel(key, field);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(byte[] key, byte[] field) {
        client.hdel(key, field);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> hexists(String key, String field) {
        client.hexists(key, field);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> hexists(byte[] key, byte[] field) {
        client.hexists(key, field);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> hget(String key, String field) {
        client.hget(key, field);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hget(byte[] key, byte[] field) {
        client.hget(key, field);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Map<String, String>> hgetAll(String key) {
        client.hgetAll(key);
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Map<String, String>> hgetAll(byte[] key) {
        client.hgetAll(key);
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Long> hincrBy(String key, String field, long value) {
        client.hincrBy(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
        client.hincrBy(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> hkeys(String key) {
        client.hkeys(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> hkeys(byte[] key) {
        client.hkeys(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> hlen(String key) {
        client.hlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(byte[] key) {
        client.hlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hmget(String key, String... fields) {
        client.hmget(key, fields);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> hmget(byte[] key, byte[]... fields) {
        client.hmget(key, fields);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
        client.hmset(key, hash);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
        client.hmset(key, hash);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
        client.hset(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
        client.hset(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
        client.hsetnx(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
        client.hsetnx(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hvals(String key) {
        client.hvals(key);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> hvals(byte[] key) {
        client.hvals(key);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> incr(String key) {
        client.incr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incr(byte[] key) {
        client.incr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, long integer) {
        client.incrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(byte[] key, long integer) {
        client.incrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
        client.keys(pattern);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> keys(byte[] pattern) {
        client.keys(pattern);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<String> lindex(String key, int index) {
        client.lindex(key, index);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lindex(byte[] key, int index) {
        client.lindex(key, index);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> linsert(String key, LIST_POSITION where,
            String pivot, String value) {
        client.linsert(key, where, pivot, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(byte[] key, LIST_POSITION where,
            byte[] pivot, byte[] value) {
        client.linsert(key, where, pivot, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
        client.llen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(byte[] key) {
        client.llen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
        client.lpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lpop(byte[] key) {
        client.lpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lpush(String key, String string) {
        client.lpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(byte[] key, byte[] string) {
        client.lpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(String key, String string) {
        client.lpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(byte[] key, byte[] bytes) {
        client.lpushx(key, bytes);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, long start, long end) {
        client.lrange(key, start, end);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> lrange(byte[] key, long start, long end) {
        client.lrange(key, start, end);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> lrem(String key, long count, String value) {
        client.lrem(key, count, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lrem(byte[] key, long count, byte[] value) {
        client.lrem(key, count, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lset(String key, long index, String value) {
        client.lset(key, index, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(byte[] key, long index, byte[] value) {
        client.lset(key, index, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(String key, long start, long end) {
        client.ltrim(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(byte[] key, long start, long end) {
        client.ltrim(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> mget(String... keys) {
        client.mget(keys);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> mget(byte[]... keys) {
        client.mget(keys);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> move(String key, int dbIndex) {
        client.move(key, dbIndex);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> move(byte[] key, int dbIndex) {
        client.move(key, dbIndex);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> mset(String... keysvalues) {
        client.mset(keysvalues);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
        client.mset(keysvalues);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
        client.msetnx(keysvalues);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
        client.msetnx(keysvalues);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(String key) {
        client.persist(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(byte[] key) {
        client.persist(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
        client.rename(oldkey, newkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
        client.rename(oldkey, newkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
        client.renamenx(oldkey, newkey);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
        client.renamenx(oldkey, newkey);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpop(String key) {
        client.rpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpop(byte[] key) {
        client.rpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
        client.rpoplpush(srckey, dstkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpoplpush(byte[] srckey, byte[] dstkey) {
        client.rpoplpush(srckey, dstkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> rpush(String key, String string) {
        client.rpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpush(byte[] key, byte[] string) {
        client.rpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(String key, String string) {
        client.rpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(byte[] key, byte[] string) {
        client.rpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(String key, String member) {
        client.sadd(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(byte[] key, byte[] member) {
        client.sadd(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(String key) {
        client.scard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(byte[] key) {
        client.scard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sdiff(String... keys) {
        client.sdiff(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sdiff(byte[]... keys) {
        client.sdiff(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
        client.sdiffstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
        client.sdiffstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> set(String key, String value) {
        client.set(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value) {
        client.set(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
        client.setbit(key, offset, value);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> setex(String key, int seconds, String value) {
        client.setex(key, seconds, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> setex(byte[] key, int seconds, byte[] value) {
        client.setex(key, seconds, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
        client.setnx(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setnx(byte[] key, byte[] value) {
        client.setnx(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
        client.sinter(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sinter(byte[]... keys) {
        client.sinter(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
        client.sinterstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
        client.sinterstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
        client.sismember(key, member);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> sismember(byte[] key, byte[] member) {
        client.sismember(key, member);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Set<String>> smembers(String key) {
        client.smembers(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> smembers(byte[] key) {
        client.smembers(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
        client.smove(srckey, dstkey, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
        client.smove(srckey, dstkey, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key) {
        client.sort(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key) {
        client.sort(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> sort(String key,
            SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key,
            SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(String key,
            SortingParams sortingParameters, String dstkey) {
        client.sort(key, sortingParameters, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key,
            SortingParams sortingParameters, byte[] dstkey) {
        client.sort(key, sortingParameters, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(String key, String dstkey) {
        client.sort(key, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key, byte[] dstkey) {
        client.sort(key, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> spop(String key) {
        client.spop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> spop(byte[] key) {
        client.spop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> srandmember(String key) {
        client.srandmember(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> srandmember(byte[] key) {
        client.srandmember(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> srem(String key, String member) {
        client.srem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> srem(byte[] key, byte[] member) {
        client.srem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(String key) {
        client.strlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(byte[] key) {
        client.strlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
        client.substr(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> substr(byte[] key, int start, int end) {
        client.substr(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Set<String>> sunion(String... keys) {
        client.sunion(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sunion(byte[]... keys) {
        client.sunion(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
        client.sunionstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
        client.sunionstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(String key) {
        client.ttl(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(byte[] key) {
        client.ttl(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> type(String key) {
        client.type(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> type(byte[] key) {
        client.type(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(String... keys) {
        client.watch(keys);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
        client.watch(keys);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
        client.zadd(key, score, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(byte[] key, double score, byte[] member) {
        client.zadd(key, score, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(String key) {
        client.zcard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(byte[] key) {
        client.zcard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, double min, double max) {
        client.zcount(key, min, max);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(byte[] key, double min, double max) {
        client.zcount(key, toByteArray(min), toByteArray(max));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
        client.zincrby(key, score, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zincrby(byte[] key, double score, byte[] member) {
        client.zincrby(key, score, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
        client.zinterstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
        client.zinterstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
            String... sets) {
        client.zinterstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
            byte[]... sets) {
        client.zinterstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrange(String key, int start, int end) {
        client.zrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrange(byte[] key, int start, int end) {
        client.zrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
            double max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, double min,
            double max) {
        return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }
    
    public Response<Set<String>> zrangeByScore(String key, String min,
            String max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, byte[] min,
            byte[] max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
            double max, int offset, int count) {
        client.zrangeByScore(key, min, max, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, double min,
            double max, int offset, int count) {
        return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
    }
    
    public Response<Set<String>> zrangeByScore(byte[] key, byte[] min,
    		byte[] max, int offset, int count) {
        client.zrangeByScore(key, min, max, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
            double max) {
        client.zrangeByScoreWithScores(key, min, max);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
            double max) {
        return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }
    
    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
    		byte[] max) {
        client.zrangeByScoreWithScores(key, min, max);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
            double max, int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
            double max, int offset, int count) {
        client.zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
    		byte[] max, int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
            double min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, double max,
            double min) {
        client.zrevrangeByScore(key, toByteArray(max), toByteArray(min));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
            String min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, byte[] max,
            byte[] min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
            double min, int offset, int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, double max,
            double min, int offset, int count) {
        client.zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }
    
    public Response<Set<String>> zrevrangeByScore(byte[] key, byte[] max,
    		byte[] min, int offset, int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
            double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
            double max, double min) {
        client.zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
    		byte[] max, byte[] min) {
        client.zrevrangeByScoreWithScores(key, max, min);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
            double max, double min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
            double max, double min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
    		byte[] max, byte[] min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
        client.zrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(byte[] key, int start, int end) {
        client.zrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrank(String key, String member) {
        client.zrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrank(byte[] key, byte[] member) {
        client.zrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(String key, String member) {
        client.zrem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(byte[] key, byte[] member) {
        client.zrem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(String key, int start, int end) {
        client.zremrangeByRank(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(byte[] key, int start, int end) {
        client.zremrangeByRank(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
        client.zremrangeByScore(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
        client.zremrangeByScore(key, toByteArray(start), toByteArray(end));
        return getResponse(BuilderFactory.LONG);
    }
    
    public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
        client.zremrangeByScore(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, int start, int end) {
        client.zrevrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrange(byte[] key, int start, int end) {
        client.zrevrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, int start,
            int end) {
        client.zrevrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, int start,
            int end) {
        client.zrevrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrevrank(String key, String member) {
        client.zrevrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(byte[] key, byte[] member) {
        client.zrevrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
        client.zscore(key, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zscore(byte[] key, byte[] member) {
        client.zscore(key, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
        client.zunionstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
        client.zunionstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
            String... sets) {
        client.zunionstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
            byte[]... sets) {
        client.zunionstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
        client.bgrewriteaof();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
        client.bgsave();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
        client.configGet(pattern);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
        client.configSet(parameter, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
            int timeout) {
        client.brpoplpush(source, destination, timeout);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(byte[] source, byte[] destination,
            int timeout) {
        client.brpoplpush(source, destination, timeout);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configResetStat() {
        client.configResetStat();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
        client.save();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
        client.lastsave();
        return getResponse(BuilderFactory.LONG);
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_610f7d4_69f5340/rev_610f7d4-69f5340/src/main/java/redis/clients/jedis/ShardedJedisPipeline.java;<<<<<<< MINE
    public Response<String> set(String key, String value) {
        Client c = getClient(key);
        c.set(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> get(String key) {
        Client c = getClient(key);
        c.get(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> del(String key) {
        Client c = getClient(key);
        c.del(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> exists(String key) {
        Client c = getClient(key);
        c.exists(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> type(String key) {
        Client c = getClient(key);
        c.type(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
        Client c = getClient(key);
        c.expire(key, seconds);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
        Client c = getClient(key);
        c.expireAt(key, unixTime);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(String key) {
        Client c = getClient(key);
        c.ttl(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> getSet(String key, String value) {
        Client c = getClient(key);
        c.getSet(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
        Client c = getClient(key);
        c.setnx(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setex(String key, int seconds, String value) {
        Client c = getClient(key);
        c.setex(key, seconds, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);        
    }

    public Response<Long> decrBy(String key, long integer) {
        Client c = getClient(key);
        c.decrBy(key, integer);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(String key) {
        Client c = getClient(key);
        c.decr(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, int integer) {
        Client c = getClient(key);
        c.incrBy(key, integer);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> incrByFloat(String key, double value) {
        Client c = getClient(key);
        c.incrByFloat(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> incr(String key) {
        Client c = getClient(key);
        c.incr(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(String key, String value) {
        Client c = getClient(key);
        c.append(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
        Client c = getClient(key);
        c.substr(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
        Client c = getClient(key);
        c.hset(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> hget(String key, String field) {
        Client c = getClient(key);
        c.hget(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
        Client c = getClient(key);
        c.hsetnx(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
        Client c = getClient(key);
        c.hmset(key, hash);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> hmget(String key, String... fields) {
        Client c = getClient(key);
        c.hmget(key, fields);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> hincrBy(String key, String field, int value) {
        Client c = getClient(key);
        c.hincrBy(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> hincrByFloat(String key, String field, double value) {
        Client c = getClient(key);
        c.hincrByFloat(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Boolean> hexists(String key, String field) {
        Client c = getClient(key);
        c.hexists(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> hdel(String key, String field) {
        Client c = getClient(key);
        c.hdel(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(String key) {
        Client c = getClient(key);
        c.hlen(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> hkeys(String key) {
        Client c = getClient(key);
        c.hkeys(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> hvals(String key) {
        Client c = getClient(key);
        c.hvals(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Map<String, String>> hgetAll(String key) {
        Client c = getClient(key);
        c.hgetAll(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Long> rpush(String key, String string) {
        Client c = getClient(key);
        c.rpush(key, string);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(String key, String string) {
        Client c = getClient(key);
        c.lpush(key, string);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
        Client c = getClient(key);
        c.llen(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, int start, int end) {
        Client c = getClient(key);
        c.lrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> ltrim(String key, int start, int end) {
        Client c = getClient(key);
        c.ltrim(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lindex(String key, int index) {
        Client c = getClient(key);
        c.lindex(key, index);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(String key, int index, String value) {
        Client c = getClient(key);
        c.lset(key, index, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lrem(String key, int count, String value) {
        Client c = getClient(key);
        c.lrem(key, count, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
        Client c = getClient(key);
        c.lpop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpop(String key) {
        Client c = getClient(key);
        c.rpop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> sadd(String key, String member) {
        Client c = getClient(key);
        c.sadd(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> smembers(String key) {
        Client c = getClient(key);
        c.smembers(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> srem(String key, String member) {
        Client c = getClient(key);
        c.srem(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> spop(String key) {
        Client c = getClient(key);
        c.spop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> scard(String key) {
        Client c = getClient(key);
        c.scard(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
        Client c = getClient(key);
        c.sismember(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> srandmember(String key) {
        Client c = getClient(key);
        c.srandmember(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
        Client c = getClient(key);
        c.zadd(key, score, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrange(String key, int start, int end) {
        Client c = getClient(key);
        c.zrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Long> zrem(String key, String member) {
        Client c = getClient(key);
        c.zrem(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
        Client c = getClient(key);
        c.zincrby(key, score, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zrank(String key, String member) {
        Client c = getClient(key);
        c.zrank(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(String key, String member) {
        Client c = getClient(key);
        c.zrevrank(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, int start, int end) {
        Client c = getClient(key);
        c.zrevrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
        Client c = getClient(key);
        c.zrangeWithScores(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, int start, int end) {
        Client c = getClient(key);
        c.zrevrangeWithScores(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zcard(String key) {
        Client c = getClient(key);
        c.zcard(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
        Client c = getClient(key);
        c.zscore(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> sort(String key) {
        Client c = getClient(key);
        c.sort(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<List<String>> sort(String key, SortingParams sortingParameters) {
        Client c = getClient(key);
        c.sort(key, sortingParameters);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> zcount(String key, double min, double max) {
        Client c = getClient(key);
        c.zcount(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrangeByScore(String key, double min, double max) {
        Client c = getClient(key);
        c.zrangeByScore(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min, double max,
                                               int offset, int count) {
        Client c = getClient(key);
        c.zrangeByScore(key, min, max, offset, count);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max) {
        Client c = getClient(key);
        c.zrangeByScoreWithScores(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max,
            int offset, int count) {
        Client c = getClient(key);
        c.zrangeByScoreWithScores(key, min, max, offset, count);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zremrangeByRank(String key, int start, int end) {
        Client c = getClient(key);
        c.zremrangeByRank(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
        Client c = getClient(key);
        c.zremrangeByScore(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(String key, LIST_POSITION where, String pivot,
                                  String value) {
        Client c = getClient(key);
        c.linsert(key, where, pivot, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> getbit(String key, long offset) {
        Client c = getClient(key);
        c.getbit(key, offset);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
        Client c = getClient(key);
        c.setbit(key, offset, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> setrange(String key, long offset, String value) {
        Client c = getClient(key);
        c.setrange(key, offset, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);

    }

    public Response<Long> getrange(String key, long startOffset, long endOffset) {
        Client c = getClient(key);
        c.getrange(key, startOffset, endOffset);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

||||||| BASE
    public Response<String> set(String key, String value) {
        Client c = getClient(key);
        c.set(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> get(String key) {
        Client c = getClient(key);
        c.get(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> del(String key) {
        Client c = getClient(key);
        c.del(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> exists(String key) {
        Client c = getClient(key);
        c.exists(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> type(String key) {
        Client c = getClient(key);
        c.type(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
        Client c = getClient(key);
        c.expire(key, seconds);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
        Client c = getClient(key);
        c.expireAt(key, unixTime);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(String key) {
        Client c = getClient(key);
        c.ttl(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> getSet(String key, String value) {
        Client c = getClient(key);
        c.getSet(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
        Client c = getClient(key);
        c.setnx(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setex(String key, int seconds, String value) {
        Client c = getClient(key);
        c.setex(key, seconds, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);        
    }

    public Response<Long> decrBy(String key, long integer) {
        Client c = getClient(key);
        c.decrBy(key, integer);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(String key) {
        Client c = getClient(key);
        c.decr(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, int integer) {
        Client c = getClient(key);
        c.incrBy(key, integer);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incr(String key) {
        Client c = getClient(key);
        c.incr(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(String key, String value) {
        Client c = getClient(key);
        c.append(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
        Client c = getClient(key);
        c.substr(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
        Client c = getClient(key);
        c.hset(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> hget(String key, String field) {
        Client c = getClient(key);
        c.hget(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
        Client c = getClient(key);
        c.hsetnx(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
        Client c = getClient(key);
        c.hmset(key, hash);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> hmget(String key, String... fields) {
        Client c = getClient(key);
        c.hmget(key, fields);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> hincrBy(String key, String field, int value) {
        Client c = getClient(key);
        c.hincrBy(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> hexists(String key, String field) {
        Client c = getClient(key);
        c.hexists(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> hdel(String key, String field) {
        Client c = getClient(key);
        c.hdel(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(String key) {
        Client c = getClient(key);
        c.hlen(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> hkeys(String key) {
        Client c = getClient(key);
        c.hkeys(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> hvals(String key) {
        Client c = getClient(key);
        c.hvals(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Map<String, String>> hgetAll(String key) {
        Client c = getClient(key);
        c.hgetAll(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Long> rpush(String key, String string) {
        Client c = getClient(key);
        c.rpush(key, string);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(String key, String string) {
        Client c = getClient(key);
        c.lpush(key, string);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
        Client c = getClient(key);
        c.llen(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, int start, int end) {
        Client c = getClient(key);
        c.lrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> ltrim(String key, int start, int end) {
        Client c = getClient(key);
        c.ltrim(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lindex(String key, int index) {
        Client c = getClient(key);
        c.lindex(key, index);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(String key, int index, String value) {
        Client c = getClient(key);
        c.lset(key, index, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lrem(String key, int count, String value) {
        Client c = getClient(key);
        c.lrem(key, count, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
        Client c = getClient(key);
        c.lpop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpop(String key) {
        Client c = getClient(key);
        c.rpop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> sadd(String key, String member) {
        Client c = getClient(key);
        c.sadd(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> smembers(String key) {
        Client c = getClient(key);
        c.smembers(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> srem(String key, String member) {
        Client c = getClient(key);
        c.srem(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> spop(String key) {
        Client c = getClient(key);
        c.spop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> scard(String key) {
        Client c = getClient(key);
        c.scard(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
        Client c = getClient(key);
        c.sismember(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> srandmember(String key) {
        Client c = getClient(key);
        c.srandmember(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
        Client c = getClient(key);
        c.zadd(key, score, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrange(String key, int start, int end) {
        Client c = getClient(key);
        c.zrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Long> zrem(String key, String member) {
        Client c = getClient(key);
        c.zrem(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
        Client c = getClient(key);
        c.zincrby(key, score, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zrank(String key, String member) {
        Client c = getClient(key);
        c.zrank(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(String key, String member) {
        Client c = getClient(key);
        c.zrevrank(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, int start, int end) {
        Client c = getClient(key);
        c.zrevrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
        Client c = getClient(key);
        c.zrangeWithScores(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, int start, int end) {
        Client c = getClient(key);
        c.zrevrangeWithScores(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zcard(String key) {
        Client c = getClient(key);
        c.zcard(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
        Client c = getClient(key);
        c.zscore(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> sort(String key) {
        Client c = getClient(key);
        c.sort(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<List<String>> sort(String key, SortingParams sortingParameters) {
        Client c = getClient(key);
        c.sort(key, sortingParameters);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> zcount(String key, double min, double max) {
        Client c = getClient(key);
        c.zcount(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrangeByScore(String key, double min, double max) {
        Client c = getClient(key);
        c.zrangeByScore(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min, double max,
                                               int offset, int count) {
        Client c = getClient(key);
        c.zrangeByScore(key, min, max, offset, count);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max) {
        Client c = getClient(key);
        c.zrangeByScoreWithScores(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max,
            int offset, int count) {
        Client c = getClient(key);
        c.zrangeByScoreWithScores(key, min, max, offset, count);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zremrangeByRank(String key, int start, int end) {
        Client c = getClient(key);
        c.zremrangeByRank(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
        Client c = getClient(key);
        c.zremrangeByScore(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(String key, LIST_POSITION where, String pivot,
                                  String value) {
        Client c = getClient(key);
        c.linsert(key, where, pivot, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> getbit(String key, long offset) {
        Client c = getClient(key);
        c.getbit(key, offset);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
        Client c = getClient(key);
        c.setbit(key, offset, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> setrange(String key, long offset, String value) {
        Client c = getClient(key);
        c.setrange(key, offset, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);

    }

    public Response<Long> getrange(String key, long startOffset, long endOffset) {
        Client c = getClient(key);
        c.getrange(key, startOffset, endOffset);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_610f7d4_69f5340/rev_610f7d4-69f5340/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCRBYFLOAT, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HINCRBYFLOAT, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT;
||||||| BASE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zcount(final byte[] key, final double min, final double max) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZCOUNT, key, byteArrayMin, byteArrayMax);
    }

    public void zcount(final byte[] key, final byte min[], final byte max[]) {
        sendCommand(ZCOUNT, key, min, max);
    }

    public void zcount(final byte[] key, final String min, final String max) {
        sendCommand(ZCOUNT, key, min.getBytes(), max.getBytes());
||||||| BASE
    public void zcount(final byte[] key, final double min, final double max) {
        sendCommand(ZCOUNT, key, toByteArray(min), toByteArray(max));
=======
    public void zcount(final byte[] key, final byte[] min, final byte[] max) {
	sendCommand(ZCOUNT, key, min, max);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScore(final byte[] key, final double min,
            final double max) {
||||||| BASE
    public void zrangeByScore(final byte[] key, final double min,
            final double max) {
        sendCommand(ZRANGEBYSCORE, key, toByteArray(min), toByteArray(max));
    }
=======
    public void zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max) {
	sendCommand(ZRANGEBYSCORE, key, min, max);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax);
||||||| BASE
    public void zrevrangeByScore(final byte[] key, final double max,
            final double min) {
        sendCommand(ZREVRANGEBYSCORE, key, toByteArray(max), toByteArray(min));
=======
    public void zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScore(final byte[] key, final String max,
            final String min) {
        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes());
    }

    public void zrangeByScore(final byte[] key, final double min,
            final double max, final int offset, int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrangeByScore(final byte[] key, final byte min[],
            final byte max[], final int offset, int count) {

        sendCommand(ZRANGEBYSCORE, key, min, max,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrangeByScore(final byte[] key, final String min,
            final String max, final int offset, int count) {

        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
||||||| BASE
    public void zrangeByScore(final byte[] key, final double min,
            final double max, final int offset, int count) {
        sendCommand(ZRANGEBYSCORE, key, toByteArray(min), toByteArray(max),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
=======
    public void zrangeByScoreWithScores(final byte[] key, final byte[] min,
	    final byte[] max) {
	sendCommand(ZRANGEBYSCORE, key, min, max, WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScore(final byte[] key, final double max,
            final double min, final int offset, int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

     public void zrevrangeByScore(final byte[] key, final byte max[],
            final byte min[], final int offset, int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrevrangeByScore(final byte[] key, final String max,
            final String min, final int offset, int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
||||||| BASE
    public void zrevrangeByScore(final byte[] key, final double max,
            final double min, final int offset, int count) {
        sendCommand(ZREVRANGEBYSCORE, key, toByteArray(max), toByteArray(min),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
=======
    public void zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
	    final byte[] min) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min, WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final byte min[],
            final byte max[]) {

        sendCommand(ZRANGEBYSCORE, key, min, max,
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final String min,
            final String max) {

        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                WITHSCORES.raw);
||||||| BASE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max) {
        sendCommand(ZRANGEBYSCORE, key, toByteArray(min), toByteArray(max),
                WITHSCORES.raw);
=======
    public void zrangeByScoreWithScores(final byte[] key, final byte[] min,
	    final byte[] max, final int offset, final int count) {
	sendCommand(ZRANGEBYSCORE, key, min, max, LIMIT.raw,
		toByteArray(offset), toByteArray(count), WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final byte max[],
            final byte min[]) {
        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final String max,
            final String min) {
        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                WITHSCORES.raw);
||||||| BASE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min) {
        sendCommand(ZREVRANGEBYSCORE, key, toByteArray(max), toByteArray(min),
                WITHSCORES.raw);
=======
    public void zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
	    final byte[] min, final int offset, final int count) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min, LIMIT.raw,
		toByteArray(offset), toByteArray(count), WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max, final int offset, final int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final byte min[],
            final byte max[], final int offset, final int count) {
        sendCommand(ZRANGEBYSCORE, key, min, max,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final String min,
            final String max, final int offset, final int count) {
        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
||||||| BASE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max, final int offset, final int count) {
        sendCommand(ZRANGEBYSCORE, key, toByteArray(min), toByteArray(max),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
=======
    public void zremrangeByRank(final byte[] key, final long start,
	    final long end) {
	sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min, final int offset, final int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final byte max[],
            final byte min[], final int offset, final int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final String max,
            final String min, final int offset, final int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zremrangeByRank(final byte[] key, final int start, final int end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
    }

    public void zremrangeByScore(final byte[] key, final double start,
            final double end) {
        sendCommand(ZREMRANGEBYSCORE, key, toByteArray(start), toByteArray(end));
||||||| BASE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min, final int offset, final int count) {
        sendCommand(ZREVRANGEBYSCORE, key, toByteArray(max), toByteArray(min),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zremrangeByRank(final byte[] key, final int start, final int end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
    }

    public void zremrangeByScore(final byte[] key, final double start,
            final double end) {
        sendCommand(ZREMRANGEBYSCORE, key, toByteArray(start), toByteArray(end));
=======
    public void zremrangeByScore(final byte[] key, final byte[] start,
	    final byte[] end) {
	sendCommand(ZREMRANGEBYSCORE, key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest.java;<<<<<<< MINE
    protected static HostAndPort master = HostAndPortUtil.getRedisServers()
	    .get(2);
    protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
	    .get(3);
    protected static HostAndPort slave2 = HostAndPortUtil.getRedisServers()
	    .get(4);
    protected static HostAndPort sentinel1 = HostAndPortUtil
	    .getSentinelServers().get(1);
    protected static HostAndPort sentinel2 = HostAndPortUtil
	    .getSentinelServers().get(2);

    protected static Jedis masterJedis;
    protected static Jedis slaveJedis1;
    protected static Jedis slaveJedis2;

    protected static int slaveCount = 0;

    protected Set<String> sentinels = new HashSet<String>();

    @Before
    public void setUp() throws Exception {

	// set up master and slaves
	masterJedis = new Jedis(master.host, master.port);
	masterJedis.auth("foobared");
	masterJedis.slaveofNoOne();

	slaveJedis1 = new Jedis(slave1.host, slave1.port);
	slaveJedis1.auth("foobared");
	slaveJedis1.slaveof(master.host, master.port);
	slaveCount++;

	slaveJedis2 = new Jedis(slave2.host, slave2.port);
	slaveJedis2.auth("foobared");
	slaveJedis2.slaveof(master.host, master.port);
	slaveCount++;

	sentinels.add(sentinel1.toString());
	sentinels.add(sentinel2.toString());

	// FIXME: The following allows the master/slave relationship to
	// be established, and let sentinels know about this relationship.
	// We can do this more elegantly.
	Thread.sleep(10000);
    }

    @Test
    public void ensureSafeTwiceFailover() throws InterruptedException {
	JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinels,
		new GenericObjectPoolConfig(), 1000, "foobared", 2);

	// perform failover
	doSegFaultMaster(pool);

	// perform failover once again
	doSegFaultMaster(pool);

	// you can test failover as much as possible
	// but you need to prepare additional slave per failover
    }

    private void doSegFaultMaster(JedisSentinelPool pool)
	    throws InterruptedException {
	// jedis connection should be master
	Jedis jedis = pool.getResource();
	assertEquals("PONG", jedis.ping());

	try {
	    jedis.debug(DebugParams.SEGFAULT());
	} catch (Exception e) {
	}

	// wait for the sentinel to promote a master
	// FIXME: we can query the sentinel and sleep
	// right until the master is promoted
	Thread.sleep(35000);

	jedis = pool.getResource();
	assertEquals("PONG", jedis.ping());
	assertEquals("foobared", jedis.configGet("requirepass").get(1));
	assertEquals(2, jedis.getDB().intValue());
    }
||||||| BASE
    protected static HostAndPort master = HostAndPortUtil.getRedisServers()
	    .get(2);
    protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
	    .get(3);
    protected static HostAndPort slave2 = HostAndPortUtil.getRedisServers()
    	.get(4);
    protected static HostAndPort sentinel1 = HostAndPortUtil
	    .getSentinelServers().get(1);
    protected static HostAndPort sentinel2 = HostAndPortUtil
	    .getSentinelServers().get(2);

    protected static Jedis masterJedis;
    protected static Jedis slaveJedis1;
    protected static Jedis slaveJedis2;
    
    protected static int slaveCount = 0;

    protected Set<String> sentinels = new HashSet<String>();

    @Before
    public void setUp() throws Exception {

	// set up master and slaves
	masterJedis = new Jedis(master.host, master.port);
	masterJedis.auth("foobared");
	masterJedis.slaveofNoOne();

	slaveJedis1 = new Jedis(slave1.host, slave1.port);
	slaveJedis1.auth("foobared");
	slaveJedis1.slaveof(master.host, master.port);
	slaveCount++;
	
	slaveJedis2 = new Jedis(slave2.host, slave2.port);
	slaveJedis2.auth("foobared");
	slaveJedis2.slaveof(master.host, master.port);
	slaveCount++;

	sentinels.add(sentinel1.toString());
	sentinels.add(sentinel2.toString());

	// FIXME: The following allows the master/slave relationship to
	// be established, and let sentinels know about this relationship. 
	// We can do this more elegantly.
	Thread.sleep(10000);
    }

    @Test
    public void ensureSafeTwiceFailover() throws InterruptedException {
    	JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinels,
    			new Config(), 1000, "foobared", 2);
    		
    	// perform failover
    	doSegFaultMaster(pool);
    	
    	// perform failover once again
    	doSegFaultMaster(pool);
    	
    	// you can test failover as much as possible
    	// but you need to prepare additional slave per failover
    }
    
    private void doSegFaultMaster(JedisSentinelPool pool) throws InterruptedException {
    	// jedis connection should be master
    	Jedis jedis = pool.getResource();
    	assertEquals("PONG", jedis.ping());

    	try {
    		jedis.debug(DebugParams.SEGFAULT());
    	} catch (Exception e) {
    	}

    	// wait for the sentinel to promote a master
    	// FIXME: we can query the sentinel and sleep
    	// right until the master is promoted
    	Thread.sleep(35000);

    	jedis = pool.getResource();
    	assertEquals("PONG", jedis.ping());
    	assertEquals("foobared", jedis.configGet("requirepass").get(1));
    	assertEquals(2, jedis.getDB().intValue());
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/benchmark/PoolBenchmark.java;<<<<<<< MINE
	final JedisPool pool = new JedisPool(new GenericObjectPoolConfig(),
		hnp.host, hnp.port, 2000, "foobared");
	List<Thread> tds = new ArrayList<Thread>();

	final AtomicInteger ind = new AtomicInteger();
	for (int i = 0; i < 50; i++) {
	    Thread hj = new Thread(new Runnable() {
		public void run() {
		    for (int i = 0; (i = ind.getAndIncrement()) < TOTAL_OPERATIONS;) {
			try {
			    Jedis j = pool.getResource();
			    final String key = "foo" + i;
			    j.set(key, key);
			    j.get(key);
			    pool.returnResource(j);
			} catch (Exception e) {
			    e.printStackTrace();
			}
		    }
		}
	    });
	    tds.add(hj);
	    hj.start();
	}
||||||| BASE
        final JedisPool pool = new JedisPool(new Config(), hnp.host, hnp.port,
                2000, "foobared");
        List<Thread> tds = new ArrayList<Thread>();

        final AtomicInteger ind = new AtomicInteger();
        for (int i = 0; i < 50; i++) {
            Thread hj = new Thread(new Runnable() {
                public void run() {
                    for (int i = 0; (i = ind.getAndIncrement()) < TOTAL_OPERATIONS;) {
                        try {
                            Jedis j = pool.getResource();
                            final String key = "foo" + i;
                            j.set(key, key);
                            j.get(key);
                            pool.returnResource(j);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            });
            tds.add(hj);
            hj.start();
        }
=======
        final JedisPool pool = new JedisPool(new Config(), hnp.getHost(), hnp.getPort(),
                2000, "foobared");
        List<Thread> tds = new ArrayList<Thread>();

        final AtomicInteger ind = new AtomicInteger();
        for (int i = 0; i < 50; i++) {
            Thread hj = new Thread(new Runnable() {
                public void run() {
                    for (int i = 0; (i = ind.getAndIncrement()) < TOTAL_OPERATIONS;) {
                        try {
                            Jedis j = pool.getResource();
                            final String key = "foo" + i;
                            j.set(key, key);
                            j.get(key);
                            pool.returnResource(j);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            });
            tds.add(hj);
            hj.start();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
||||||| BASE
import redis.clients.jedis.BinaryJedis;
=======
import redis.clients.jedis.BinaryJedis;
import redis.clients.jedis.HostAndPort;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "0");
	pool.returnResource(jedis);

	jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
||||||| BASE
        JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
                hnp.port);
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");
        pool.returnResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
=======
    	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");
        pool.returnResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.quit();
	pool.returnBrokenResource(jedis);

	jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
||||||| BASE
        JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
                hnp.port);
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.quit();
        pool.returnBrokenResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
=======
    	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.quit();
        pool.returnBrokenResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisPool pool = new JedisPool(config, hnp.host, hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "0");

	Jedis newJedis = pool.getResource();
	newJedis.auth("foobared");
	newJedis.incr("foo");
||||||| BASE
        Config config = new Config();
        config.maxActive = 1;
        config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
        JedisPool pool = new JedisPool(config, hnp.host, hnp.port);
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");

        Jedis newJedis = pool.getResource();
        newJedis.auth("foobared");
        newJedis.incr("foo");
=======
        Config config = new Config();
        config.maxActive = 1;
        config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
        JedisPool pool = new JedisPool(config, hnp.getHost(), hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");

        Jedis newJedis = pool.getResource();
        newJedis.auth("foobared");
        newJedis.incr("foo");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool0 = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared");
	Jedis jedis0 = pool0.getResource();
	jedis0.set("foo", "bar");
	assertEquals("bar", jedis0.get("foo"));
	pool0.returnResource(jedis0);
	pool0.destroy();

	JedisPool pool1 = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared", 1);
	Jedis jedis1 = pool1.getResource();
	assertNull(jedis1.get("foo"));
	pool1.returnResource(jedis1);
	pool1.destroy();
||||||| BASE
        JedisPool pool0 = new JedisPool(new JedisPoolConfig(), hnp.host,
                hnp.port, 2000, "foobared");
        Jedis jedis0 = pool0.getResource();
        jedis0.set("foo", "bar");
        assertEquals( "bar", jedis0.get("foo") );
        pool0.returnResource(jedis0);
        pool0.destroy();

        JedisPool pool1 = new JedisPool(new JedisPoolConfig(), hnp.host,
                hnp.port, 2000, "foobared", 1);
        Jedis jedis1 = pool1.getResource();
        assertNull( jedis1.get("foo") );
        pool1.returnResource(jedis0);
        pool1.destroy();
    }

    @Test
    public void returnBinary() {
        JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
                hnp.port, 2000);
        BinaryJedis jedis = pool.getResource();
        pool.returnResource(jedis);
        pool.destroy();
=======
        JedisPool pool0 = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000, "foobared");
        Jedis jedis0 = pool0.getResource();
        jedis0.set("foo", "bar");
        assertEquals( "bar", jedis0.get("foo") );
        pool0.returnResource(jedis0);
        pool0.destroy();

        JedisPool pool1 = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000, "foobared", 1);
        Jedis jedis1 = pool1.getResource();
        assertNull( jedis1.get("foo") );
        pool1.returnResource(jedis0);
        pool1.destroy();
    }

    @Test
    public void returnBinary() {
        JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000);
        BinaryJedis jedis = pool.getResource();
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
    @Test
    public void selectDatabaseOnActivation() {
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared");

	Jedis jedis0 = pool.getResource();
	assertEquals(0L, jedis0.getDB().longValue());

	jedis0.select(1);
	assertEquals(1L, jedis0.getDB().longValue());

	pool.returnResource(jedis0);

	Jedis jedis1 = pool.getResource();
	assertTrue("Jedis instance was not reused", jedis1 == jedis0);
	assertEquals(0L, jedis1.getDB().longValue());

	pool.returnResource(jedis1);
	pool.destroy();
    }
||||||| BASE
	@Test
	public void selectDatabaseOnActivation() {
		JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host, hnp.port, 2000, "foobared");

		Jedis jedis0 = pool.getResource();
		assertEquals(0L, jedis0.getDB().longValue());
		
		jedis0.select(1);
		assertEquals(1L, jedis0.getDB().longValue());

		pool.returnResource(jedis0);

		Jedis jedis1 = pool.getResource();
		assertTrue("Jedis instance was not reused", jedis1	== jedis0);
		assertEquals(0L, jedis1.getDB().longValue());

		pool.returnResource(jedis1);
		pool.destroy();
	}
=======
	@Test
	public void selectDatabaseOnActivation() {
		JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
				hnp.getPort(), 2000, "foobared");

		Jedis jedis0 = pool.getResource();
		assertEquals(0L, jedis0.getDB().longValue());
		
		jedis0.select(1);
		assertEquals(1L, jedis0.getDB().longValue());

		pool.returnResource(jedis0);

		Jedis jedis1 = pool.getResource();
		assertTrue("Jedis instance was not reused", jedis1	== jedis0);
		assertEquals(0L, jedis1.getDB().longValue());

		pool.returnResource(jedis1);
		pool.destroy();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/ShardedJedisPipelineTest.java;<<<<<<< MINE
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil
	    .getRedisServers().get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil
	    .getRedisServers().get(1);
||||||| BASE
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil
            .getRedisServers().get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil
            .getRedisServers().get(1);
=======
    private static HostAndPort redis1 = HostAndPortUtil
            .getRedisServers().get(0);
    private static HostAndPort redis2 = HostAndPortUtil
            .getRedisServers().get(1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/ShardedJedisPipelineTest.java;<<<<<<< MINE
	Jedis jedis = new Jedis(redis1.host, redis1.port);
	jedis.auth("foobared");
	jedis.flushAll();
	jedis.disconnect();
	jedis = new Jedis(redis2.host, redis2.port);
	jedis.auth("foobared");
	jedis.flushAll();
	jedis.disconnect();

	JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.host, redis1.port);
	JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.host, redis2.port);
	shardInfo1.setPassword("foobared");
	shardInfo2.setPassword("foobared");
	List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
	shards.add(shardInfo1);
	shards.add(shardInfo2);
	this.jedis = new ShardedJedis(shards);
||||||| BASE
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();

        JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.host, redis1.port);
        JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.host, redis2.port);
        shardInfo1.setPassword("foobared");
        shardInfo2.setPassword("foobared");
        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(shardInfo1);
        shards.add(shardInfo2);
        this.jedis = new ShardedJedis(shards);
=======
        Jedis jedis = new Jedis(redis1.getHost(), redis1.getPort());
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.getHost(), redis2.getPort());
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();

        JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.getHost(), redis1.getPort());
        JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.getHost(), redis2.getPort());
        shardInfo1.setPassword("foobared");
        shardInfo2.setPassword("foobared");
        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(shardInfo1);
        shards.add(shardInfo2);
        this.jedis = new ShardedJedis(shards);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisSentinelTest.java;<<<<<<< MINE
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

||||||| BASE
import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertFalse;
import static junit.framework.Assert.assertTrue;

=======
import java.util.ArrayList;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    
    public void scan(int cursor, final ScanParams params) {
	final List<byte[]> args = new ArrayList<byte[]>();
	args.add(toByteArray(cursor));
	args.addAll(params.getParams());
	sendCommand(SCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void hscan(final byte[] key, int cursor, final ScanParams params) {
 	final List<byte[]> args = new ArrayList<byte[]>();
 	args.add(key);
 	args.add(toByteArray(cursor));
 	args.addAll(params.getParams());
 	sendCommand(HSCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void sscan(final byte[] key, int cursor, final ScanParams params) {
 	final List<byte[]> args = new ArrayList<byte[]>();
 	args.add(key);
 	args.add(toByteArray(cursor));
 	args.addAll(params.getParams());
 	sendCommand(SSCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void zscan(final byte[] key, int cursor, final ScanParams params) {
 	final List<byte[]> args = new ArrayList<byte[]>();
 	args.add(key);
 	args.add(toByteArray(cursor));
 	args.addAll(params.getParams());
 	sendCommand(ZSCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void waitReplicas(int replicas, long timeout) {
	sendCommand(WAIT, toByteArray(replicas), toByteArray(timeout));
    }
||||||| BASE
=======
    
    public void cluster(final byte[]... args) {
    	sendCommand(CLUSTER, args);
    }
    public void asking() {
    	sendCommand(Command.ASKING);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, BasicCommands {
||||||| BASE
import java.net.URI;
import java.util.*;

public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands {
=======
import java.net.URI;
import java.util.*;

public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, ClusterCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    public ScanResult<String> scan(int cursor) {
	return scan(cursor, new ScanParams());
    }
    
    public ScanResult<String> scan(int cursor, final ScanParams params) {
	checkIsInMulti();
	client.scan(cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }
    
    public ScanResult<Map.Entry<String, String>> hscan(final String key, int cursor) {
	return hscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Map.Entry<String, String>> hscan(final String key, int cursor, final ScanParams params) {
	checkIsInMulti();
	client.hscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<Map.Entry<String, String>> results = new ArrayList<Map.Entry<String, String>>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while(iterator.hasNext()) {
	    results.add(new AbstractMap.SimpleEntry<String, String>(SafeEncoder.encode(iterator.next()), SafeEncoder.encode(iterator.next())));
	}
	return new ScanResult<Map.Entry<String, String>>(newcursor, results);
    }
    
    public ScanResult<String> sscan(final String key, int cursor) {
	return sscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<String> sscan(final String key, int cursor, final ScanParams params) {
	checkIsInMulti();
	client.sscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }
    
    public ScanResult<Tuple> zscan(final String key, int cursor) {
	return zscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Tuple> zscan(final String key, int cursor, final ScanParams params) {
	checkIsInMulti();
	client.zscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<Tuple> results = new ArrayList<Tuple>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while(iterator.hasNext()) {
	    results.add(new Tuple(SafeEncoder.encode(iterator.next()), Double.valueOf(SafeEncoder.encode(iterator.next()))));
	}
	return new ScanResult<Tuple>(newcursor, results);
    }
||||||| BASE
=======

    public String clusterNodes() {
    	checkIsInMulti();
    	client.clusterNodes();
    	return client.getBulkReply();
    }
    
    public String clusterMeet(final String ip, final int port) {
    	checkIsInMulti();
    	client.clusterMeet(ip, port);
    	return client.getStatusCodeReply();
    }
    
    public String clusterAddSlots(final int ...slots) {
    	checkIsInMulti();
    	client.clusterAddSlots(slots);
    	return client.getStatusCodeReply();
    }
    
    public String clusterDelSlots(final int ...slots) {
    	checkIsInMulti();
    	client.clusterDelSlots(slots);
    	return client.getStatusCodeReply();
    }
    
    public String clusterInfo() {
    	checkIsInMulti();
    	client.clusterInfo();
    	return client.getStatusCodeReply();
    }
    
    public List<String> clusterGetKeysInSlot(final int slot, final int count) {
    	checkIsInMulti();
    	client.clusterGetKeysInSlot(slot, count);
    	return client.getMultiBulkReply();
    }
    
    public String clusterSetSlotNode(final int slot, final String nodeId) {
    	checkIsInMulti();
    	client.clusterSetSlotNode(slot, nodeId);
    	return client.getStatusCodeReply();
    }
    
    public String clusterSetSlotMigrating(final int slot, final String nodeId) {
    	checkIsInMulti();
    	client.clusterSetSlotMigrating(slot, nodeId);
    	return client.getStatusCodeReply();
    }
    
    public String clusterSetSlotImporting(final int slot, final String nodeId) {
    	checkIsInMulti();
    	client.clusterSetSlotImporting(slot, nodeId);
    	return client.getStatusCodeReply();
    }

	public String asking() {
		checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    
    public void hscan(final String key, int cursor, final ScanParams params) {
 	hscan(SafeEncoder.encode(key), cursor, params);
    }
    
    public void sscan(final String key, int cursor, final ScanParams params) {
 	sscan(SafeEncoder.encode(key), cursor, params);
    }
    
    public void zscan(final String key, int cursor, final ScanParams params) {
 	zscan(SafeEncoder.encode(key), cursor, params);
    }
||||||| BASE
=======

    public void cluster(final String subcommand, final int... args) {
	final byte[][] arg = new byte[args.length+1][];
	for (int i = 1; i < arg.length; i++) {
	    arg[i] = toByteArray(args[i-1]);
	}
	arg[0] = SafeEncoder.encode(subcommand);
	cluster(arg);
    }

    public void cluster(final String subcommand, final String... args) {
	final byte[][] arg = new byte[args.length+1][];
	for (int i = 1; i < arg.length; i++) {
	    arg[i] = SafeEncoder.encode(args[i-1]);
	}
	arg[0] = SafeEncoder.encode(subcommand);
	cluster(arg);
    }
    
    public void cluster(final String subcommand) {
	final byte[][] arg = new byte[1][];
	arg[0] = SafeEncoder.encode(subcommand);
	cluster(arg);
    }
    
    public void clusterNodes() {
	cluster(Protocol.CLUSTER_NODES);
    }
    
    public void clusterMeet(final String ip, final int port) {
	cluster(Protocol.CLUSTER_MEET, ip, String.valueOf(port));
    }
    
    public void clusterAddSlots(final int ...slots) {
	cluster(Protocol.CLUSTER_ADDSLOTS, slots);
    }
    
    public void clusterDelSlots(final int ...slots) {
	cluster(Protocol.CLUSTER_DELSLOTS, slots);
    }
    
    public void clusterInfo() {
	cluster(Protocol.CLUSTER_INFO);
    }
    
    public void clusterGetKeysInSlot(final int slot, final int count) {
    	final int[] args = new int[]{ slot, count };
    	cluster(Protocol.CLUSTER_GETKEYSINSLOT, args);
    }
    
    public void clusterSetSlotNode(final int slot, final String nodeId) {
	cluster(Protocol.CLUSTER_SETSLOT, String.valueOf(slot), Protocol.CLUSTER_SETSLOT_NODE, nodeId);
    }
    
    public void clusterSetSlotMigrating(final int slot, final String nodeId) {
	cluster(Protocol.CLUSTER_SETSLOT, String.valueOf(slot), Protocol.CLUSTER_SETSLOT_MIGRATING, nodeId);
    }
    
    public void clusterSetSlotImporting(final int slot, final String nodeId) {
	cluster(Protocol.CLUSTER_SETSLOT, String.valueOf(slot), Protocol.CLUSTER_SETSLOT_IMPORTING, nodeId);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT;
||||||| BASE
	DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT;
=======
	DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, CLUSTER, ASKING;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2cd3988_9995466/rev_2cd3988-9995466/src/main/java/org/junit/rules/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2cd3988_9995466/rev_2cd3988-9995466/src/main/java/org/junit/rules/ExpectedException.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d7c5823_f11c162/rev_d7c5823-f11c162/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
	flush();
	pipelinedCommands--;
	return (List<Object>) Protocol.read(inputStream);
||||||| BASE
        flush();
        pipelinedCommands--;
        return (List<Object>) Protocol.read(inputStream);
=======
        flush();
        pipelinedCommands--;
        return getRawObjectMultiBulkReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public String asking() {
	checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
    }

    public List<String> pubSubChannels(String pattern) {
	checkIsInMulti();
	client.pubSubChannels(pattern);
	return client.getMultiBulkReply();
    }

    public Long pubSubNumPat() {
	checkIsInMulti();
	client.pubSubNumPat();
	return client.getIntegerReply();
    }

    public Map<String, Long> pubSubNumSub(String... channels) {
	checkIsInMulti();
  	client.pubSubNumSub(channels);
  	return BuilderFactory.STRING_LONG_MAP
  		.build(client.getBinaryMultiBulkReply());
    }
||||||| BASE
	public String asking() {
		checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
	}
=======
    public String asking() {
	checkIsInMulti();
	client.asking();
	return client.getStatusCodeReply();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Client.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Client.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/test/java/redis/clients/jedis/tests/commands/PublishSubscribeCommandsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/test/java/redis/clients/jedis/tests/commands/PublishSubscribeCommandsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8fef62e_10c131b/rev_8fef62e-10c131b/src/test/java/redis/clients/jedis/tests/commands/TransactionCommandsTest.java;<<<<<<< MINE

    @Test
    public void testResetStateWhenInMulti() {
	jedis.auth("foobared");

	Transaction t = jedis.multi();
	t.set("foooo", "barrr");

	jedis.resetState();
	assertEquals(null, jedis.get("foooo"));
    }

    @Test
    public void testResetStateWhenInMultiWithinPipeline() {
	jedis.auth("foobared");

	Pipeline p = jedis.pipelined();
	p.multi();
	p.set("foooo", "barrr");

	jedis.resetState();
	assertEquals(null, jedis.get("foooo"));
    }

    @Test
    public void testResetStateWhenInWatch() {
	jedis.watch("mykey", "somekey");

	// state reset : unwatch
	jedis.resetState();

	Transaction t = jedis.multi();

	nj.connect();
	nj.auth("foobared");
	nj.set("mykey", "bar");
	nj.disconnect();

	t.set("mykey", "foo");
	List<Object> resp = t.exec();
	assertNotNull(resp);
	assertEquals(1, resp.size());
	assertEquals("foo", jedis.get("mykey"));
    }
||||||| BASE
=======
    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_68356eb_2d04a38/rev_68356eb-2d04a38/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_68356eb_2d04a38/rev_68356eb-2d04a38/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands {
||||||| BASE
public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands {
=======
public class Jedis extends BinaryJedis implements JedisCommands,
	MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands,
	BasicCommands, ClusterCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_68356eb_2d04a38/rev_68356eb-2d04a38/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	public String asking() {
		checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
	}

||||||| BASE
	public String asking() {
		checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
	}
=======
    public Map<String, String> pubsubNumSub(String... channels) {
	checkIsInMulti();
  	client.pubsubNumSub(channels);
  	return BuilderFactory.STRING_MAP
  		.build(client.getBinaryMultiBulkReply());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	return evalResult(client.getOne());
    }

    private Object evalResult(Object result) {
||||||| BASE
	Object result = client.getOne();
	
=======
	Object result = client.getOne();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.hasItem;
||||||| BASE
import org.junit.Test;

import redis.clients.jedis.exceptions.JedisDataException;
import redis.clients.util.SafeEncoder;
=======
import org.junit.Test;

import redis.clients.jedis.BinaryJedis;
import redis.clients.jedis.exceptions.JedisDataException;
import redis.clients.util.SafeEncoder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    @Test
    public void scriptEvalReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }
||||||| BASE
	@Test
	public void scriptEvalReturnNullValues() {
		String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
		List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
		assertEquals(results.get(0), "key1");
		assertEquals(results.get(1), "key2");
		assertEquals(results.get(2), "1");
		assertEquals(results.get(3), "2");
	}
=======
    @Test
    public void scriptEvalReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	List<String> results = (List<String>) jedis.eval(script, 2, "key1",
		"key2", "1", "2");
	assertEquals(results.get(0), "key1");
	assertEquals(results.get(1), "key2");
	assertEquals(results.get(2), "1");
	assertEquals(results.get(3), "2");
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    @Test
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }
||||||| BASE
	@Test
	public void scriptEvalShaReturnNullValues() {
		String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
		String sha = jedis.scriptLoad(script);
		List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
		assertEquals(results.get(0), "key1");
		assertEquals(results.get(1), "key2");
		assertEquals(results.get(2), "1");
		assertEquals(results.get(3), "2");
=======
    @Test
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1",
		"key2", "1", "2");
	assertEquals(results.get(0), "key1");
	assertEquals(results.get(1), "key2");
	assertEquals(results.get(2), "1");
	assertEquals(results.get(3), "2");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    private <T> CombinableMatcher<List<T>> listWithItem(T expected) {
	return both(CoreMatchers.<List<T>>instanceOf(List.class)).and(hasItem(equalTo(expected)));
    }
||||||| BASE
	}
=======
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/test/java/org/junit/tests/assertion/AssertionTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c2bdb1a_34d2943/rev_c2bdb1a-34d2943/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
||||||| BASE
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
=======
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c2bdb1a_34d2943/rev_c2bdb1a-34d2943/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
import org.hamcrest.TypeSafeMatcher;
import org.junit.Assert;
||||||| BASE
import org.junit.Assert;
import org.junit.internal.matchers.TypeSafeMatcher;
=======
import org.junit.internal.AssumptionViolatedException;
import org.junit.internal.matchers.TypeSafeMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c2bdb1a_34d2943/rev_c2bdb1a-34d2943/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}||||||| BASE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6b943e5_34d2943/rev_6b943e5-34d2943/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import org.hamcrest.CoreMatchers;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}

        @Test
        public void throwsIllegalArgumentExceptionWithCause() {
            NullPointerException expectedCause = new NullPointerException("expected cause");

            thrown.expect(IllegalArgumentException.class);
            thrown.expectMessage("Ack!");
            thrown.expectCause(is(expectedCause));

            throw new IllegalArgumentException("Ack!", expectedCause);
        }

        @Test
        public void throwsIllegalArgumentExceptionWithCauseExplicitlyNull() {
            thrown.expect(IllegalArgumentException.class);
            thrown.expectMessage("Ack!");
            thrown.expectCause(CoreMatchers.<Throwable>nullValue());

            throw new IllegalArgumentException("Ack!");
        }
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}

	public static class HasWrongCause {
        public static final NullPointerException EXPECTED_CAUSE = new NullPointerException("expected cause");

        @Rule
		public ExpectedException thrown= ExpectedException.none();

        @Test
		public void throwWithCause() {
            thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
            thrown.expectCause(is(EXPECTED_CAUSE));

			throw new IllegalArgumentException("Ack!", new NullPointerException("an unexpected cause"));
		}
	}

	@Test
	public void failsWithWrongCause() {
		assertThat(testResult(HasWrongCause.class),
            hasSingleFailureContaining(HasWrongCause.EXPECTED_CAUSE.toString()));
	}
}||||||| BASE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_db76522_e7bc4f5/rev_db76522-e7bc4f5/src/main/java/redis/clients/jedis/JedisSlotBasedConnectionHandler.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

||||||| BASE
=======
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_db76522_e7bc4f5/rev_db76522-e7bc4f5/src/main/java/redis/clients/jedis/JedisSlotBasedConnectionHandler.java;<<<<<<< MINE
    private Jedis currentConnection;

    public JedisSlotBasedConnectionHandler(Set<HostAndPort> nodes,
        final GenericObjectPoolConfig poolConfig) {
	super(nodes, poolConfig);
||||||| BASE
    private Jedis currentConnection;

    public JedisSlotBasedConnectionHandler(Set<HostAndPort> nodes) {
	super(nodes);
=======
    public JedisSlotBasedConnectionHandler(Set<HostAndPort> nodes) {
	super(nodes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e381886_3f6e3ef/rev_e381886-3f6e3ef/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.failureIs;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.causedBy;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}
	
	@Test
	public void expectedExceptionClauseExists() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				failureIs(causedBy(instanceOf(IllegalArgumentException.class))));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}||||||| BASE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e381886_3f6e3ef/rev_e381886-3f6e3ef/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	BlockJUnit4ClassRunnerTest.class,
	CauseMatcherTest.class
||||||| BASE
	BlockJUnit4ClassRunnerTest.class
=======
	BlockJUnit4ClassRunnerTest.class,
	MethodSorterTest.class,
	TestedOnSupplierTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_c2cf79c_ac53759/rev_c2cf79c-ac53759/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    
    public void pfadd(final byte[] key, final byte[]... elements) {
   	sendCommand(PFADD, joinParameters(key, elements));
    }
    
    public void pfcount(final byte[] key) {
   	sendCommand(PFCOUNT, key);
    }
    public void pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
   	sendCommand(PFMERGE, joinParameters(destkey, sourcekeys));
    }
||||||| BASE
    
    public void pfadd(final byte[] key, final byte[]... elements) {
   	sendCommand(PFADD, joinParameters(key, elements));
    }
    
    public void pfcount(final byte[] key) {
   	sendCommand(PFCOUNT, key);
    }
    public void pfmerge(final byte[] deskey, final byte[]... sourcekeys) {
   	sendCommand(PFMERGE, joinParameters(deskey, sourcekeys));
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_c2cf79c_ac53759/rev_c2cf79c-ac53759/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    public Long pfadd(final String key, final String... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    public long pfcount(final String key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    public String pfmerge(final String destkey, final String... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }
||||||| BASE

    public Long pfadd(final String key, String... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    public long pfcount(final String key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    public String pfmerge(final String destkey, final String... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_c2cf79c_ac53759/rev_c2cf79c-ac53759/src/test/java/redis/clients/jedis/tests/commands/HyperLogLogCommandsTest.java;<<<<<<< MINE
package redis.clients.jedis.tests.commands;

import org.junit.Test;

import redis.clients.util.SafeEncoder;

public class HyperLogLogCommandsTest extends JedisCommandTestBase {


    @Test
    public void pfadd() {
	long status = jedis.pfadd("foo", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("foo", "a");
	assertEquals(0, status);
    }
    
    @Test
    public void pfaddBinary() {
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bBar2 = SafeEncoder.encode("bar2");
	
	long status = jedis.pfadd(bFoo, bBar, bBar2);
	assertEquals(1, status);
	
	status = jedis.pfadd(bFoo, bBar, bBar2);
	assertEquals(0, status);
    }
    
    @Test
    public void pfcount() {
	long status = jedis.pfadd("hll", "foo", "bar", "zap");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll", "zap", "zap", "zap");
	assertEquals(0, status);
	
	status = jedis.pfadd("hll", "foo", "bar");
	assertEquals(0, status);
	
	status = jedis.pfcount("hll");
	assertEquals(3, status);
    }
    
    @Test
    public void pfcountBinary() {
	byte[] bHll = SafeEncoder.encode("hll");
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bZap = SafeEncoder.encode("zap");
	
	long status = jedis.pfadd(bHll, bFoo, bBar, bZap);
	assertEquals(1, status);
	
	status = jedis.pfadd(bHll, bZap, bZap, bZap);
	assertEquals(0, status);
	
	status = jedis.pfadd(bHll, bFoo, bBar);
	assertEquals(0, status);
	
	status = jedis.pfcount(bHll);
	assertEquals(3, status);
    }
    
    @Test
    public void pfmerge() {
	long status = jedis.pfadd("hll1", "foo", "bar", "zap", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll2", "a", "b", "c", "foo");
	assertEquals(1, status);
	
	String mergeStatus = jedis.pfmerge("hll3", "hll1", "hll2");
	assertEquals("OK", mergeStatus);
	
	status = jedis.pfcount("hll3");
	assertEquals(6, status);
    }
    
    @Test
    public void pfmergeBinary() {
	byte[] bHll1 = SafeEncoder.encode("hll1");
	byte[] bHll2 = SafeEncoder.encode("hll2");
	byte[] bHll3 = SafeEncoder.encode("hll3");
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bZap = SafeEncoder.encode("zap");
	byte[] bA = SafeEncoder.encode("a");
	byte[] bB = SafeEncoder.encode("b");
	byte[] bC = SafeEncoder.encode("c");
	
	long status = jedis.pfadd(bHll1, bFoo, bBar, bZap, bA);
	assertEquals(1, status);
	
	status = jedis.pfadd(bHll2, bA, bB, bC, bFoo);
	assertEquals(1, status);
	
	String mergeStatus = jedis.pfmerge(bHll3, bHll1, bHll2);
	assertEquals("OK", mergeStatus);
	
	status = jedis.pfcount("hll3");
	assertEquals(6, status);
    }
}||||||| BASE
package redis.clients.jedis.tests.commands;

import org.junit.Test;

public class HyperLogLogCommandsTest extends JedisCommandTestBase {


    @Test
    public void pfadd() {
	long status = jedis.pfadd("foo", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("foo", "a");
	assertEquals(0, status);
    }
    
    @Test
    public void pfcount() {
	long status = jedis.pfadd("hll", "foo", "bar", "zap");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll", "zap", "zap", "zap");
	assertEquals(0, status);
	
	status = jedis.pfadd("hll", "foo", "bar");
	assertEquals(0, status);
	
	status = jedis.pfcount("hll");
	assertEquals(3, status);
    }
    
    @Test
    public void pfmerge() {
	long status = jedis.pfadd("hll1", "foo", "bar", "zap", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll2", "a", "b", "c", "foo");
	assertEquals(1, status);
	
	String mergeStatus = jedis.pfmerge("hll3", "hll1", "hll2");
	assertEquals("OK", mergeStatus);
	
	status = jedis.pfcount("hll3");
	assertEquals(6, status);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_72e10d3_d4755d0/rev_72e10d3-d4755d0/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	
	/**
	 * Asserts that two floats are equal to within a positive delta.
	 * If they are not, an {@link AssertionError} is thrown with the given
	 * message. If the expected value is infinity then the delta value is
	 * ignored. NaNs are considered equal:
	 * <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expected
	 *            expected value
	 * @param actual
	 *            the value to check against <code>expected</code>
	 * @param delta
	 *            the maximum delta between <code>expected</code> and
	 *            <code>actual</code> for which both numbers are still
	 *            considered equal.
	 */
	static public void assertEquals(String message, float expected,
			float actual, float delta) {
		if (Float.compare(expected, actual) == 0)
			return;
		if (!(Math.abs(expected - actual) <= delta))
			failNotEquals(message, new Float(expected), new Float(actual));
	}
||||||| BASE
=======
	
	static private boolean doubleIsDifferent(double d1, double d2, double delta) {
		if (Double.compare(d1, d2) == 0)
			return false;
		if ((Math.abs(d1 - d2) <= delta))
			return false;
		
		return true;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_167a782_81c8308/rev_167a782-81c8308/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
    public T runBinary(byte[] key) {
        if (key == null) {
            throw new JedisClusterException(
                "No way to dispatch this command to Redis Cluster.");
        }

        return runWithRetries(key, this.redirections, false, false);
    }
    
    public T runScript(String... keys) {
||||||| BASE
    public T runScript(String... keys) {
=======
    public T run(int keyCount, String... keys) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
import org.hamcrest.core.CombinableMatcher;
||||||| BASE
import org.junit.internal.matchers.CombinableMatcher;
import org.junit.internal.matchers.Each;
import org.junit.internal.matchers.IsCollectionContaining;
import org.junit.internal.matchers.StringContains;
=======
import org.junit.internal.matchers.CombinableMatcher;
import org.junit.internal.matchers.Each;
import org.junit.internal.matchers.IsCollectionContaining;
import org.junit.internal.matchers.StringContains;
import org.junit.internal.matchers.CauseMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.startsWith;
||||||| BASE
=======
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java;<<<<<<< MINE
||||||| BASE
import org.hamcrest.Description;
=======
import org.hamcrest.CoreMatchers;
import org.hamcrest.Description;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java;<<<<<<< MINE
||||||| BASE

	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}

			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
=======

	public static class ThrowExceptionWithMatchingCause {
		@Rule
		public ExpectedException thrown = none();

		@Test
		public void throwExceptionWithMatchingCause() {
			NullPointerException expectedCause = new NullPointerException("expected cause");

			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(is(expectedCause));

			throw new IllegalArgumentException("Ack!", expectedCause);
		}
	}

	public static class ThrowExpectedNullCause {
		@Rule
		public ExpectedException thrown = none();

		@Test
		public void throwExpectedNullCause() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(CoreMatchers.<Throwable>nullValue());

			throw new IllegalArgumentException("Ack!");
		}
	}

	public static class ThrowUnexpectedCause {

		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwWithCause() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(is(new NullPointerException("expected cause")));

			throw new IllegalArgumentException("Ack!", new NullPointerException("an unexpected cause"));
		}
	}


	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}

			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6106f5b_e1f50b5/rev_6106f5b-e1f50b5/src/main/java/redis/clients/jedis/ScanParams.java;<<<<<<< MINE
    public ScanParams match(final String pattern) {
||||||| BASE
    public void match(final String pattern) {
=======
    public void match(final byte[] pattern) {
	params.add(MATCH.raw);
	params.add(pattern);
    }
    
    public void match(final String pattern) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6106f5b_e1f50b5/rev_6106f5b-e1f50b5/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
    @Override
    public Long pfadd(final byte[] key, final byte[]... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    @Override
    public long pfcount(final byte[] key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    @Override
    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }

    @Override
    public Long pfcount(byte[]... keys) {
        checkIsInMulti();
        client.pfcount(keys);
        return client.getIntegerReply();
    }

||||||| BASE
=======
    public ScanResult<byte[]> scan(final byte[] cursor) {
	return scan(cursor, new ScanParams());
    }
    
    public ScanResult<byte[]> scan(final byte[] cursor, final ScanParams params) {
	checkIsInMulti();
	client.scan(cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	return new ScanResult<byte[]>(newcursor, rawResults);
    }
    
    public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key,
	    final byte[] cursor) {
	return hscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key,
	    final byte[] cursor, final ScanParams params) {
	checkIsInMulti();
	client.hscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<Map.Entry<byte[], byte[]>> results = new ArrayList<Map.Entry<byte[], byte[]>>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new AbstractMap.SimpleEntry<byte[], byte[]>(iterator.next(), 
		    iterator.next()));
	}
	return new ScanResult<Map.Entry<byte[], byte[]>>(newcursor, results);
    }
    
    public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor) {
	return sscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.sscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	return new ScanResult<byte[]>(newcursor, rawResults);
    }
    
    public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor) {
	return zscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.zscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<Tuple> results = new ArrayList<Tuple>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new Tuple(iterator.next(), Double
		    .valueOf(SafeEncoder.encode(iterator.next()))));
	}
	return new ScanResult<Tuple>(newcursor, results);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_daeda1a_2162def/rev_daeda1a-2162def/src/main/java/org/junit/rules/TestWatcher.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0d5062c_6af41cd/rev_0d5062c-6af41cd/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
    public Response<String> lindex(String key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.STRING);
||||||| BASE
    public Response<String> lindex(String key, int index) {
        getClient(key).lindex(key, index);
        return getResponse(BuilderFactory.STRING);
=======
    public Response<Double> incrByFloat(String key, double value) {
        getClient(key).incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double value) {
        getClient(key).incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<String> lindex(String key, int index) {
        getClient(key).lindex(key, index);
        return getResponse(BuilderFactory.STRING);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0d5062c_6af41cd/rev_0d5062c-6af41cd/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, PFADD, PFCOUNT, PFMERGE;
||||||| BASE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCRBYFLOAT, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HINCRBYFLOAT, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_be8d4ee_2e53904/rev_be8d4ee-2e53904/src/test/java/org/junit/tests/experimental/rules/TestRuleTest.java;<<<<<<< MINE
||||||| BASE
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.containsString;

import java.util.LinkedList;
import java.util.List;

=======
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;

import java.util.LinkedList;
import java.util.List;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
import java.io.Closeable;
||||||| BASE
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.util.Hashing;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.util.Hashing;
import redis.clients.util.Pool;

public class ShardedJedis extends BinaryShardedJedis implements JedisCommands,
	Closeable {

    protected Pool<ShardedJedis> dataSource = null;

||||||| BASE
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.util.Hashing;

public class ShardedJedis extends BinaryShardedJedis implements JedisCommands {
=======
public class ShardedJedis extends BinaryShardedJedis implements JedisCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE

    @Override
    public void close() {
	if (dataSource != null) {
	    boolean broken = false;

	    for (Jedis jedis : getAllShards()) {
		if (jedis.getClient().isBroken()) {
		    broken = true;
		}
	    }

	    if (broken) {
		dataSource.returnBrokenResource(this);
	    } else {
		this.resetState();
		dataSource.returnResource(this);
	    }

	} else {
	    disconnect();
	}
    }

    public void setDataSource(Pool<ShardedJedis> shardedJedisPool) {
	this.dataSource = shardedJedisPool;
    }

    public void resetState() {
	for (Jedis jedis : getAllShards()) {
	    jedis.resetState();
	}
    }
||||||| BASE
=======

    @Override
    public Long pfadd(String key, String... elements) {
	Jedis j = getShard(key);
	return j.pfadd(key, elements);
    }

    @Override
    public long pfcount(String key) {
	Jedis j = getShard(key);
	return j.pfcount(key);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    @Override
    public void close() {
	if (dataSource != null) {
	    if (client.isBroken()) {
		this.dataSource.returnBrokenResource(this);
	    } else {
		this.dataSource.returnResource(this);
	    }
	} else {
	    client.close();
	}
    }

    public void setDataSource(Pool<Jedis> jedisPool) {
	this.dataSource = jedisPool;
    }
||||||| BASE
=======

    public Long pfadd(final String key, final String... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    public long pfcount(final String key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    @Override
    public long pfcount(String... keys) {
        checkIsInMulti();
        client.pfcount(keys);
        return client.getIntegerReply();
    }

    public String pfmerge(final String destkey, final String... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
||||||| BASE
    public void returnBrokenResource(final Jedis resource) {
	returnBrokenResourceObject(resource);
    }

    public void returnResource(final Jedis resource) {
	resource.resetState();
	returnResourceObject(resource);
    }

=======
    public void returnBrokenResource(final Jedis resource) {
	if (resource != null) {
	    returnBrokenResourceObject(resource);
	}
    }

    public void returnResource(final Jedis resource) {
	if (resource != null) {
	    resource.resetState();
	    returnResourceObject(resource);
	}
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE

    @Test
    public void checkResourceIsCloseable() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisPool pool = new JedisPool(config, hnp.getHost(), hnp.getPort(),
		2000, "foobared");

	Jedis jedis = pool.getResource();
	try {
	    jedis.set("hello", "jedis");
	} finally {
	    jedis.close();
	}

	Jedis jedis2 = pool.getResource();
	try {
	    assertEquals(jedis, jedis2);
	} finally {
	    jedis2.close();
	}
    }
||||||| BASE
=======
    
    @Test
    public void returnNullObjectShouldNotFail() {
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(),
		hnp.getPort(), 2000, "foobared", 0, "my_shiny_client_name");

	pool.returnBrokenResource(null);
	pool.returnResource(null);
	pool.returnResourceObject(null);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.Set;
||||||| BASE
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.Set;
=======
import java.util.*;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
	    HostAndPort node = getHostAndPortFromNodeLine(nodeInfo, jedis);
        setNodeIfNotExist(node);

	    JedisPool nodePool = nodes.get(getNodeKey(node));
	    populateNodeSlots(nodeInfo, nodePool);
	}
    }
    
    private void setNodeIfNotExist(HostAndPort node) {
	String nodeKey = getNodeKey(node);
	if (nodes.containsKey(nodeKey))
	    return;
	
	JedisPool nodePool = new JedisPool(poolConfig, node.getHost(), node.getPort());
	nodes.put(nodeKey, nodePool);
    }
||||||| BASE
	    HostAndPort node = getHostAndPortFromNodeLine(nodeInfo, jedis);
	    setNodeIfNotExist(node);
	    
	    JedisPool nodePool = nodes.get(getNodeKey(node));
	    populateNodeSlots(nodeInfo, nodePool);
	}
    }
    
    private void setNodeIfNotExist(HostAndPort node) {
	String nodeKey = getNodeKey(node);
	if (nodes.containsKey(nodeKey))
	    return;
	
	JedisPool nodePool = new JedisPool(node.getHost(), node.getPort());
	nodes.put(nodeKey, nodePool);
    }
=======
	    ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
		    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
			    jedis.getClient().getPort()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import redis.clients.jedis.BinaryClient.LIST_POSITION;

||||||| BASE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
import redis.clients.jedis.exceptions.*;
||||||| BASE
import redis.clients.jedis.exceptions.JedisAskDataException;
import redis.clients.jedis.exceptions.JedisClusterException;
import redis.clients.jedis.exceptions.JedisClusterMaxRedirectionsException;
import redis.clients.jedis.exceptions.JedisMovedDataException;
=======
import redis.clients.jedis.exceptions.JedisAskDataException;
import redis.clients.jedis.exceptions.JedisClusterException;
import redis.clients.jedis.exceptions.JedisClusterMaxRedirectionsException;
import redis.clients.jedis.exceptions.JedisException;
import redis.clients.jedis.exceptions.JedisMovedDataException;
import redis.clients.jedis.tests.utils.JedisClusterTestUtil;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

    private void waitForClusterReady() throws InterruptedException {
	boolean clusterOk = false;
	while (!clusterOk) {
	    if (node1.clusterInfo().split("\n")[0].contains("ok")
		    && node2.clusterInfo().split("\n")[0].contains("ok")
		    && node3.clusterInfo().split("\n")[0].contains("ok")) {
		clusterOk = true;
||||||| BASE
    private void waitForClusterReady() throws InterruptedException {
	boolean clusterOk = false;
	while (!clusterOk) {
	    if (node1.clusterInfo().split("\n")[0].contains("ok")
		    && node2.clusterInfo().split("\n")[0].contains("ok")
		    && node3.clusterInfo().split("\n")[0].contains("ok")) {
		clusterOk = true;
=======
    private List<Integer> getSlotsBeingMigrated(String infoLine) {
	List<Integer> inconsistentSlots = new ArrayList<Integer>();
	
	String[] splitted = infoLine.split(" ");
	
	if (splitted.length > 8) {
	    for (int index = 8 ; index < splitted.length ; index++) {
		String info = splitted[index];
		Integer slot = getSlotFromMigrationInfo(info);
		if (slot != null) {
		    inconsistentSlots.add(slot);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_737112a_79d27ef/rev_737112a-79d27ef/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster implements JedisCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
||||||| BASE
public class JedisCluster implements JedisCommands, BasicCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
=======
public class JedisCluster extends BinaryJedisCluster implements JedisCommands, 
        JedisClusterScriptingCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_737112a_79d27ef/rev_737112a-79d27ef/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

||||||| BASE
    @Override
    public String ping() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ping();
	    }
	}.run(null);
    }

    @Override
    public String quit() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.quit();
	    }
	}.run(null);
    }

    @Override
    public String flushDB() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushDB();
	    }
	}.run(null);
    }

    @Override
    public Long dbSize() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.dbSize();
	    }
	}.run(null);
    }

    @Override
    public String select(final int index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.select(index);
	    }
	}.run(null);
    }

    @Override
    public String flushAll() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushAll();
	    }
	}.run(null);
    }

    @Override
    public String auth(final String password) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.auth(password);
	    }
	}.run(null);
    }

    @Override
    public String save() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.save();
	    }
	}.run(null);
    }

    @Override
    public String bgsave() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgsave();
	    }
	}.run(null);
    }

    @Override
    public String bgrewriteaof() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgrewriteaof();
	    }
	}.run(null);
    }

    @Override
    public Long lastsave() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lastsave();
	    }
	}.run(null);
    }

    @Override
    public String shutdown() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.shutdown();
	    }
	}.run(null);
    }

    @Override
    public String info() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info();
	    }
	}.run(null);
    }

    @Override
    public String info(final String section) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info(section);
	    }
	}.run(null);
    }

    @Override
    public String slaveof(final String host, final int port) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveof(host, port);
	    }
	}.run(null);
    }

    @Override
    public String slaveofNoOne() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveofNoOne();
	    }
	}.run(null);
    }

    @Override
    public Long getDB() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.getDB();
	    }
	}.run(null);
    }

    @Override
    public String debug(final DebugParams params) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.debug(params);
	    }
	}.run(null);
    }

    @Override
    public String configResetStat() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.configResetStat();
	    }
	}.run(null);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public Long waitReplicas(int replicas, long timeout) {
	// TODO Auto-generated method stub
	return null;
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_737112a_79d27ef/rev_737112a-79d27ef/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_5939d5b_76df52e/rev_5939d5b-76df52e/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
||||||| BASE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
=======
public class JedisCluster implements JedisCommands, BasicCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_5939d5b_76df52e/rev_5939d5b-76df52e/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    
    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object eval(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script);
        }
    }.run(key);
    }
    
    @Override
    public Object eval(final String script, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String sha1, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object evalsha(final String sha1, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(script);
        }
    }.run(key);
    }
    
    @Override
    public Boolean scriptExists(final String sha1, final String key) {
    return new JedisClusterCommand<Boolean>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Boolean execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public List<Boolean> scriptExists(final String key, final String... sha1) {
    return new JedisClusterCommand<List<Boolean>>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public List<Boolean> execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
    return new JedisClusterCommand<String>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public String execute(Jedis connection) {
        return connection.scriptLoad(script);
        }
    }.run(key);
    }
||||||| BASE
=======

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return (List<byte[]>) Protocol.read(inputStream);
||||||| BASE
        flush();
        pipelinedCommands--;
        return (List<byte[]>) Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return (List<byte[]>) readProtocolWithCheckingBroken();
    }

    public void resetPipelinedCount() {
	pipelinedCommands = 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return (List<Object>) Protocol.read(inputStream);
||||||| BASE
        flush();
        pipelinedCommands--;
        return (List<Object>) Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return getRawObjectMultiBulkReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
||||||| BASE
    public List<Object> getAll() {
        return getAll(0);
    }

    public List<Object> getAll(int except) {
        List<Object> all = new ArrayList<Object>();
        flush();
        while (pipelinedCommands > except) {
        	try{
                all.add(Protocol.read(inputStream));
        	}catch(JedisDataException e){
        		all.add(e);
        	}
            pipelinedCommands--;
        }
        return all;
    }

=======
    public List<Object> getAll() {
	return getAll(0);
    }

    public List<Object> getAll(int except) {
	List<Object> all = new ArrayList<Object>();
	flush();
	while (pipelinedCommands > except) {
	    try {
		all.add(readProtocolWithCheckingBroken());
	    } catch (JedisDataException e) {
		all.add(e);
	    }
	    pipelinedCommands--;
	}
	return all;
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return Protocol.read(inputStream);
||||||| BASE
        flush();
        pipelinedCommands--;
        return Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return readProtocolWithCheckingBroken();
    }

    public boolean isBroken() {
	return broken;
    }

    protected void flush() {
	try {
	    outputStream.flush();
	} catch (IOException ex) {
	    broken = true;
	    throw new JedisConnectionException(ex);
	}
    }

    protected Object readProtocolWithCheckingBroken() {
	try {
	    return Protocol.read(inputStream);
	} catch (JedisConnectionException exc) {
	    broken = true;
	    throw exc;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Entry<String, String>> hscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.hscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.sscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.zscan(key, cursor);
    }

    public ScanResult<Entry<String, String>> hscan(String key,
	    final String cursor) {
||||||| BASE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Entry<String, String>> hscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.hscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.sscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.zscan(key, cursor);
    }
    
    public ScanResult<Entry<String, String>> hscan(String key, final String cursor) {
=======
    public ScanResult<Entry<String, String>> hscan(String key, final String cursor) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }
    
||||||| BASE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute() {
		return connectionHandler.getConnection().hscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute() {
		return connectionHandler.getConnection().sscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute() {
		return connectionHandler.getConnection().zscan(key, cursor);
	    }
	}.run(null);
    }
    
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> scan(int cursor) {
	return scan(cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> scan(int cursor, final ScanParams params) {
	checkIsInMulti();
	client.scan(cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Map.Entry<String, String>> hscan(final String key,
	    int cursor) {
	return hscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Map.Entry<String, String>> hscan(final String key,
	    int cursor, final ScanParams params) {
	checkIsInMulti();
	client.hscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<Map.Entry<String, String>> results = new ArrayList<Map.Entry<String, String>>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new AbstractMap.SimpleEntry<String, String>(SafeEncoder
		    .encode(iterator.next()), SafeEncoder.encode(iterator
		    .next())));
	}
	return new ScanResult<Map.Entry<String, String>>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(final String key, int cursor) {
	return sscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(final String key, int cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.sscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(final String key, int cursor) {
	return zscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(final String key, int cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.zscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<Tuple> results = new ArrayList<Tuple>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new Tuple(SafeEncoder.encode(iterator.next()), Double
		    .valueOf(SafeEncoder.encode(iterator.next()))));
	}
	return new ScanResult<Tuple>(newcursor, results);
    }

||||||| BASE
    public Double hincrByFloat(final String key, final String field,
	    double increment) {
	checkIsInMulti();
	client.hincrByFloat(key, field, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> scan(int cursor) {
	return scan(cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> scan(int cursor, final ScanParams params) {
	checkIsInMulti();
	client.scan(cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Map.Entry<String, String>> hscan(final String key,
	    int cursor) {
	return hscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Map.Entry<String, String>> hscan(final String key,
	    int cursor, final ScanParams params) {
	checkIsInMulti();
	client.hscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<Map.Entry<String, String>> results = new ArrayList<Map.Entry<String, String>>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new AbstractMap.SimpleEntry<String, String>(SafeEncoder
		    .encode(iterator.next()), SafeEncoder.encode(iterator
		    .next())));
	}
	return new ScanResult<Map.Entry<String, String>>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(final String key, int cursor) {
	return sscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(final String key, int cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.sscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(final String key, int cursor) {
	return zscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(final String key, int cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.zscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<Tuple> results = new ArrayList<Tuple>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new Tuple(SafeEncoder.encode(iterator.next()), Double
		    .valueOf(SafeEncoder.encode(iterator.next()))));
	}
	return new ScanResult<Tuple>(newcursor, results);
    }
    
=======
    public Double hincrByFloat(final String key, final String field,
	    double increment) {
	checkIsInMulti();
	client.hincrByFloat(key, field, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/ScanResult.java;<<<<<<< MINE
    
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531
     * @return int(currently), but will be changed to String, so be careful to prepare! 
     */
    public int getCursor() {
	return Integer.parseInt(getStringCursor());
    }

    /**
     * FIXME: This method should be changed to getCursor() on next major release
     */
    public String getStringCursor() {
	return SafeEncoder.encode(cursor);
    }
    
    public byte[] getCursorAsBytes() {
||||||| BASE

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531
     * @return int(currently), but will be changed to String, so be careful to prepare! 
     */
    public int getCursor() {
	return Integer.parseInt(cursor);
    }

    /**
     * FIXME: This method should be changed to getCursor() on next major release
     */
    public String getStringCursor() {
=======

    public String getCursor() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/rules/MethodRule.java;<<<<<<< MINE
 * 
 * Note that {@link MethodRule} has been replaced by {@link TestRule},
 * which has the added benefit of supporting class rules.
||||||| BASE
 * 
 * Note that {@link MethodRule} is now deprecated, you should be using {@link TestRule} instead.
=======
 *
 * Note that {@link MethodRule} is now deprecated, you should be using {@link TestRule} instead.
 *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/rules/TestWatchman.java;<<<<<<< MINE
 * 
 * @deprecated Use {@link TestWatcher} (which implements {@link TestRule}) instead.
 * @since 4.7
||||||| BASE
 * 
 * @deprecated {@link MethodRule} is deprecated.  
 *             Use {@link TestWatcher} implements {@link TestRule} instead.
 * @since 4.7
=======
 *
 * @since 4.7
 * @deprecated {@link MethodRule} is deprecated.
 *             Use {@link TestWatcher} implements {@link TestRule} instead.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	/**
	 * Creates a BlockJUnit4ClassRunner to run {@code klass}
	 * 
	 * @throws InitializationError
	 *             if the test class is malformed.
	 */
	public BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {
		super(klass);
	}

	//
	// Implementation of ParentRunner
	// 

	@Override
	protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
		Description description= describeChild(method);
		if (method.getAnnotation(Ignore.class) != null) {
			notifier.fireTestIgnored(description);
		} else {
			runLeaf(methodBlock(method), description, notifier);
		}
	}

	@Override
	protected Description describeChild(FrameworkMethod method) {
		return Description.createTestDescription(getTestClass().getJavaClass(),
				testName(method), method.getAnnotations());
	}

	@Override
	protected List<FrameworkMethod> getChildren() {
		return computeTestMethods();
	}

	//
	// Override in subclasses
	//

	/**
	 * Returns the methods that run tests. Default implementation returns all
	 * methods annotated with {@code @Test} on this class and superclasses that
	 * are not overridden.
	 */
	protected List<FrameworkMethod> computeTestMethods() {
		return getTestClass().getAnnotatedMethods(Test.class);
	}

	@Override
	protected void collectInitializationErrors(List<Throwable> errors) {
		super.collectInitializationErrors(errors);

		validateNoNonStaticInnerClass(errors);
		validateConstructor(errors);
		validateInstanceMethods(errors);
		validateFields(errors);
		validateMethods(errors);
	}

	protected void validateNoNonStaticInnerClass(List<Throwable> errors) {
		if (getTestClass().isANonStaticInnerClass()) {
			String gripe= "The inner class " + getTestClass().getName()
					+ " is not static.";
			errors.add(new Exception(gripe));
		}
	}

	/**
	 * Adds to {@code errors} if the test class has more than one constructor,
	 * or if the constructor takes parameters. Override if a subclass requires
	 * different validation rules.
	 */
	protected void validateConstructor(List<Throwable> errors) {
		validateOnlyOneConstructor(errors);
		validateZeroArgConstructor(errors);
	}

	/**
	 * Adds to {@code errors} if the test class has more than one constructor
	 * (do not override)
	 */
	protected void validateOnlyOneConstructor(List<Throwable> errors) {
		if (!hasOneConstructor()) {
			String gripe= "Test class should have exactly one public constructor";
			errors.add(new Exception(gripe));
		}
	}

	/**
	 * Adds to {@code errors} if the test class's single constructor takes
	 * parameters (do not override)
	 */
	protected void validateZeroArgConstructor(List<Throwable> errors) {
		if (!getTestClass().isANonStaticInnerClass()
				&& hasOneConstructor()
				&& (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {
			String gripe= "Test class should have exactly one public zero-argument constructor";
			errors.add(new Exception(gripe));
		}
	}

	private boolean hasOneConstructor() {
		return getTestClass().getJavaClass().getConstructors().length == 1;
	}

	/**
	 * Adds to {@code errors} for each method annotated with {@code @Test},
	 * {@code @Before}, or {@code @After} that is not a public, void instance
	 * method with no arguments.
	 * 
	 * @deprecated unused API, will go away in future version
	 */
	@Deprecated
	protected void validateInstanceMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(After.class, false, errors);
		validatePublicVoidNoArgMethods(Before.class, false, errors);
		validateTestMethods(errors);

		if (computeTestMethods().size() == 0)
			errors.add(new Exception("No runnable methods"));
	}

	protected void validateFields(List<Throwable> errors) {
		RULE_VALIDATOR.validate(getTestClass(), errors);
	}

	private void validateMethods(List<Throwable> errors) {
		RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
	}

	/**
	 * Adds to {@code errors} for each method annotated with {@code @Test}that
	 * is not a public, void instance method with no arguments.
	 */
	protected void validateTestMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(Test.class, false, errors);
	}

	/**
	 * Returns a new fixture for running a test. Default implementation executes
	 * the test class's no-argument constructor (validation should have ensured
	 * one exists).
	 */
	protected Object createTest() throws Exception {
		return getTestClass().getOnlyConstructor().newInstance();
	}

	/**
	 * Returns the name that describes {@code method} for {@link Description}s.
	 * Default implementation is the method's name
	 */
	protected String testName(FrameworkMethod method) {
		return method.getName();
	}

	/**
	 * Returns a Statement that, when executed, either returns normally if
	 * {@code method} passes, or throws an exception if {@code method} fails.
	 * 
	 * Here is an outline of the default implementation:
	 * 
	 * <ul>
	 * <li>Invoke {@code method} on the result of {@code createTest()}, and
	 * throw any exceptions thrown by either operation.
	 * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
	 * expecting} attribute, return normally only if the previous step threw an
	 * exception of the correct type, and throw an exception otherwise.
	 * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
	 * timeout} attribute, throw an exception if the previous step takes more
	 * than the specified number of milliseconds.
	 * <li>ALWAYS run all non-overridden {@code @Before} methods on this class
	 * and superclasses before any of the previous steps; if any throws an
	 * Exception, stop execution and pass the exception on.
	 * <li>ALWAYS run all non-overridden {@code @After} methods on this class
	 * and superclasses after any of the previous steps; all After methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from After methods into a
	 * {@link MultipleFailureException}.
	 * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the
	 * above steps. A {@code Rule} may prevent all execution of the above steps,
	 * or add additional behavior before and after, or modify thrown exceptions.
	 * For more information, see {@link TestRule}
	 * </ul>
	 * 
	 * This can be overridden in subclasses, either by overriding this method,
	 * or the implementations creating each sub-statement.
	 */
	protected Statement methodBlock(FrameworkMethod method) {
		Object test;
		try {
			test= new ReflectiveCallable() {
				@Override
				protected Object runReflectiveCall() throws Throwable {
					return createTest();
				}
			}.run();
		} catch (Throwable e) {
			return new Fail(e);
		}

		Statement statement= methodInvoker(method, test);
		statement= possiblyExpectingExceptions(method, test, statement);
		statement= withPotentialTimeout(method, test, statement);
		statement= withBefores(method, test, statement);
		statement= withAfters(method, test, statement);
		statement= withRules(method, test, statement);
		return statement;
	}

	//
	// Statement builders
	//

	/**
	 * Returns a {@link Statement} that invokes {@code method} on {@code test}
	 */
	protected Statement methodInvoker(FrameworkMethod method, Object test) {
		return new InvokeMethod(method, test);
	}

	/**
	 * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
	 * has the {@code expecting} attribute, return normally only if {@code next}
	 * throws an exception of the correct type, and throw an exception
	 * otherwise.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement possiblyExpectingExceptions(FrameworkMethod method,
			Object test, Statement next) {
		Test annotation= method.getAnnotation(Test.class);
		return expectsException(annotation) ? new ExpectException(next,
				getExpectedException(annotation)) : next;
	}

	/**
	 * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
	 * has the {@code timeout} attribute, throw an exception if {@code next}
	 * takes more than the specified number of milliseconds.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withPotentialTimeout(FrameworkMethod method,
			Object test, Statement next) {
		long timeout= getTimeout(method.getAnnotation(Test.class));
		return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
	}

	/**
	 * Returns a {@link Statement}: run all non-overridden {@code @Before}
	 * methods on this class and superclasses before running {@code next}; if
	 * any throws an Exception, stop execution and pass the exception on.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withBefores(FrameworkMethod method, Object target,
			Statement statement) {
		List<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(
				Before.class);
		return befores.isEmpty() ? statement : new RunBefores(statement,
				befores, target);
	}

	/**
	 * Returns a {@link Statement}: run all non-overridden {@code @After}
	 * methods on this class and superclasses before running {@code next}; all
	 * After methods are always executed: exceptions thrown by previous steps
	 * are combined, if necessary, with exceptions from After methods into a
	 * {@link MultipleFailureException}.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withAfters(FrameworkMethod method, Object target,
			Statement statement) {
		List<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(
				After.class);
		return afters.isEmpty() ? statement : new RunAfters(statement, afters,
				target);
	}

	private Statement withRules(FrameworkMethod method, Object target,
			Statement statement) {
		List<TestRule> testRules= getTestRules(target);
		Statement result= statement;
		result= withMethodRules(method, testRules, target, result);
		result= withTestRules(method, testRules, result);
		
		return result;
	}

	private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
			Object target, Statement result) {
		for (org.junit.rules.MethodRule each : getMethodRules(target))
			if (! testRules.contains(each))
				result= each.apply(result, method, target);
		return result;
	}

	private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
		return rules(target);
	}

	/**
	 * @param target
	 *            the test case instance
	 * @return a list of MethodRules that should be applied when executing this
	 *         test
	 */
	protected List<org.junit.rules.MethodRule> rules(Object target) {
		return getTestClass().getAnnotatedFieldValues(target, Rule.class,
				org.junit.rules.MethodRule.class);
	}

	/**
	 * Returns a {@link Statement}: apply all non-static {@link Value} fields
	 * annotated with {@link Rule}.
	 * @param method 
	 * @param testRules 
	 * @param statement The base statement
	 * @return a RunRules statement if any class-level {@link Rule}s are
	 *         found, or the base statement
	 */
	private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,
			Statement statement) {
		return testRules.isEmpty() ? statement :
			new RunRules(statement, testRules, describeChild(method));
	}

	/**
	 * @param target
	 *            the test case instance
	 * @return a list of TestRules that should be applied when executing this
	 *         test
	 */
	protected List<TestRule> getTestRules(Object target) {
		List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,
				Rule.class, TestRule.class);
			
		result.addAll(getTestClass().getAnnotatedFieldValues(target,
				Rule.class, TestRule.class));

		return result;
	}
	
	private Class<? extends Throwable> getExpectedException(Test annotation) {
		if (annotation == null || annotation.expected() == None.class)
			return null;
		else
			return annotation.expected();
	}

	private boolean expectsException(Test annotation) {
		return getExpectedException(annotation) != null;
	}

	private long getTimeout(Test annotation) {
		if (annotation == null)
			return 0;
		return annotation.timeout();
	}
||||||| BASE
	/**
	 * Creates a BlockJUnit4ClassRunner to run {@code klass}
	 * 
	 * @throws InitializationError
	 *             if the test class is malformed.
	 */
	public BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {
		super(klass);
	}

	//
	// Implementation of ParentRunner
	// 

	@Override
	protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
		Description description= describeChild(method);
		if (method.getAnnotation(Ignore.class) != null) {
			notifier.fireTestIgnored(description);
		} else {
			runLeaf(methodBlock(method), description, notifier);
		}
	}

	@Override
	protected Description describeChild(FrameworkMethod method) {
		return Description.createTestDescription(getTestClass().getJavaClass(),
				testName(method), method.getAnnotations());
	}

	@Override
	protected List<FrameworkMethod> getChildren() {
		return computeTestMethods();
	}

	//
	// Override in subclasses
	//

	/**
	 * Returns the methods that run tests. Default implementation returns all
	 * methods annotated with {@code @Test} on this class and superclasses that
	 * are not overridden.
	 */
	protected List<FrameworkMethod> computeTestMethods() {
		return getTestClass().getAnnotatedMethods(Test.class);
	}

	@Override
	protected void collectInitializationErrors(List<Throwable> errors) {
		super.collectInitializationErrors(errors);

		validateNoNonStaticInnerClass(errors);
		validateConstructor(errors);
		validateInstanceMethods(errors);
		validateFields(errors);
		validateMethods(errors);
	}

	protected void validateNoNonStaticInnerClass(List<Throwable> errors) {
		if (getTestClass().isANonStaticInnerClass()) {
			String gripe= "The inner class " + getTestClass().getName()
					+ " is not static.";
			errors.add(new Exception(gripe));
		}
	}

	/**
	 * Adds to {@code errors} if the test class has more than one constructor,
	 * or if the constructor takes parameters. Override if a subclass requires
	 * different validation rules.
	 */
	protected void validateConstructor(List<Throwable> errors) {
		validateOnlyOneConstructor(errors);
		validateZeroArgConstructor(errors);
	}

	/**
	 * Adds to {@code errors} if the test class has more than one constructor
	 * (do not override)
	 */
	protected void validateOnlyOneConstructor(List<Throwable> errors) {
		if (!hasOneConstructor()) {
			String gripe= "Test class should have exactly one public constructor";
			errors.add(new Exception(gripe));
		}
	}

	/**
	 * Adds to {@code errors} if the test class's single constructor takes
	 * parameters (do not override)
	 */
	protected void validateZeroArgConstructor(List<Throwable> errors) {
		if (!getTestClass().isANonStaticInnerClass()
				&& hasOneConstructor()
				&& (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {
			String gripe= "Test class should have exactly one public zero-argument constructor";
			errors.add(new Exception(gripe));
		}
	}

	private boolean hasOneConstructor() {
		return getTestClass().getJavaClass().getConstructors().length == 1;
	}

	/**
	 * Adds to {@code errors} for each method annotated with {@code @Test},
	 * {@code @Before}, or {@code @After} that is not a public, void instance
	 * method with no arguments.
	 * 
	 * @deprecated unused API, will go away in future version
	 */
	@Deprecated
	protected void validateInstanceMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(After.class, false, errors);
		validatePublicVoidNoArgMethods(Before.class, false, errors);
		validateTestMethods(errors);

		if (computeTestMethods().size() == 0)
			errors.add(new Exception("No runnable methods"));
	}

	protected void validateFields(List<Throwable> errors) {
		RULE_VALIDATOR.validate(getTestClass(), errors);
	}

	private void validateMethods(List<Throwable> errors) {
		RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
	}

	/**
	 * Adds to {@code errors} for each method annotated with {@code @Test}that
	 * is not a public, void instance method with no arguments.
	 */
	protected void validateTestMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(Test.class, false, errors);
	}

	/**
	 * Returns a new fixture for running a test. Default implementation executes
	 * the test class's no-argument constructor (validation should have ensured
	 * one exists).
	 */
	protected Object createTest() throws Exception {
		return getTestClass().getOnlyConstructor().newInstance();
	}

	/**
	 * Returns the name that describes {@code method} for {@link Description}s.
	 * Default implementation is the method's name
	 */
	protected String testName(FrameworkMethod method) {
		return method.getName();
	}

	/**
	 * Returns a Statement that, when executed, either returns normally if
	 * {@code method} passes, or throws an exception if {@code method} fails.
	 * 
	 * Here is an outline of the default implementation:
	 * 
	 * <ul>
	 * <li>Invoke {@code method} on the result of {@code createTest()}, and
	 * throw any exceptions thrown by either operation.
	 * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
	 * expecting} attribute, return normally only if the previous step threw an
	 * exception of the correct type, and throw an exception otherwise.
	 * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
	 * timeout} attribute, throw an exception if the previous step takes more
	 * than the specified number of milliseconds.
	 * <li>ALWAYS run all non-overridden {@code @Before} methods on this class
	 * and superclasses before any of the previous steps; if any throws an
	 * Exception, stop execution and pass the exception on.
	 * <li>ALWAYS run all non-overridden {@code @After} methods on this class
	 * and superclasses after any of the previous steps; all After methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from After methods into a
	 * {@link MultipleFailureException}.
	 * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the
	 * above steps. A {@code Rule} may prevent all execution of the above steps,
	 * or add additional behavior before and after, or modify thrown exceptions.
	 * For more information, see {@link TestRule}
	 * </ul>
	 * 
	 * This can be overridden in subclasses, either by overriding this method,
	 * or the implementations creating each sub-statement.
	 */
	protected Statement methodBlock(FrameworkMethod method) {
		Object test;
		try {
			test= new ReflectiveCallable() {
				@Override
				protected Object runReflectiveCall() throws Throwable {
					return createTest();
				}
			}.run();
		} catch (Throwable e) {
			return new Fail(e);
		}

		Statement statement= methodInvoker(method, test);
		statement= possiblyExpectingExceptions(method, test, statement);
		statement= withPotentialTimeout(method, test, statement);
		statement= withBefores(method, test, statement);
		statement= withAfters(method, test, statement);
		statement= withRules(method, test, statement);
		return statement;
	}

	//
	// Statement builders
	//

	/**
	 * Returns a {@link Statement} that invokes {@code method} on {@code test}
	 */
	protected Statement methodInvoker(FrameworkMethod method, Object test) {
		return new InvokeMethod(method, test);
	}

	/**
	 * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
	 * has the {@code expecting} attribute, return normally only if {@code next}
	 * throws an exception of the correct type, and throw an exception
	 * otherwise.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement possiblyExpectingExceptions(FrameworkMethod method,
			Object test, Statement next) {
		Test annotation= method.getAnnotation(Test.class);
		return expectsException(annotation) ? new ExpectException(next,
				getExpectedException(annotation)) : next;
	}

	/**
	 * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
	 * has the {@code timeout} attribute, throw an exception if {@code next}
	 * takes more than the specified number of milliseconds.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withPotentialTimeout(FrameworkMethod method,
			Object test, Statement next) {
		long timeout= getTimeout(method.getAnnotation(Test.class));
		return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
	}

	/**
	 * Returns a {@link Statement}: run all non-overridden {@code @Before}
	 * methods on this class and superclasses before running {@code next}; if
	 * any throws an Exception, stop execution and pass the exception on.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withBefores(FrameworkMethod method, Object target,
			Statement statement) {
		List<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(
				Before.class);
		return befores.isEmpty() ? statement : new RunBefores(statement,
				befores, target);
	}

	/**
	 * Returns a {@link Statement}: run all non-overridden {@code @After}
	 * methods on this class and superclasses before running {@code next}; all
	 * After methods are always executed: exceptions thrown by previous steps
	 * are combined, if necessary, with exceptions from After methods into a
	 * {@link MultipleFailureException}.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withAfters(FrameworkMethod method, Object target,
			Statement statement) {
		List<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(
				After.class);
		return afters.isEmpty() ? statement : new RunAfters(statement, afters,
				target);
	}

	private Statement withRules(FrameworkMethod method, Object target,
			Statement statement) {
		List<TestRule> testRules= getTestRules(target);
		Statement result= statement;
		result= withMethodRules(method, testRules, target, result);
		result= withTestRules(method, testRules, result);
		
		return result;
	}

	@SuppressWarnings("deprecation")
	private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
			Object target, Statement result) {
		for (org.junit.rules.MethodRule each : getMethodRules(target))
			if (! testRules.contains(each))
				result= each.apply(result, method, target);
		return result;
	}

	@SuppressWarnings("deprecation")
	private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
		return rules(target);
	}

	/**
	 * @param target
	 *            the test case instance
	 * @return a list of MethodRules that should be applied when executing this
	 *         test
	 * @deprecated {@link org.junit.rules.MethodRule} is a deprecated interface. Port to
	 *             {@link TestRule} and
	 *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}
	 */
	@Deprecated
	protected List<org.junit.rules.MethodRule> rules(Object target) {
		return getTestClass().getAnnotatedFieldValues(target, Rule.class,
				org.junit.rules.MethodRule.class);
	}

	/**
	 * Returns a {@link Statement}: apply all non-static {@link Value} fields
	 * annotated with {@link Rule}.
	 * @param method 
	 * @param testRules 
	 * @param statement The base statement
	 * @return a RunRules statement if any class-level {@link Rule}s are
	 *         found, or the base statement
	 */
	private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,
			Statement statement) {
		return testRules.isEmpty() ? statement :
			new RunRules(statement, testRules, describeChild(method));
	}

	/**
	 * @param target
	 *            the test case instance
	 * @return a list of TestRules that should be applied when executing this
	 *         test
	 */
	protected List<TestRule> getTestRules(Object target) {
		List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,
				Rule.class, TestRule.class);
			
		result.addAll(getTestClass().getAnnotatedFieldValues(target,
				Rule.class, TestRule.class));

		return result;
	}
	
	private Class<? extends Throwable> getExpectedException(Test annotation) {
		if (annotation == null || annotation.expected() == None.class)
			return null;
		else
			return annotation.expected();
	}

	private boolean expectsException(Test annotation) {
		return getExpectedException(annotation) != null;
	}

	private long getTimeout(Test annotation) {
		if (annotation == null)
			return 0;
		return annotation.timeout();
	}
=======
    /**
     * Creates a BlockJUnit4ClassRunner to run {@code klass}
     *
     * @throws InitializationError if the test class is malformed.
     */
    public BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {
        super(klass);
    }

    //
    // Implementation of ParentRunner
    //

    @Override
    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
        Description description = describeChild(method);
        if (method.getAnnotation(Ignore.class) != null) {
            notifier.fireTestIgnored(description);
        } else {
            runLeaf(methodBlock(method), description, notifier);
        }
    }

    @Override
    protected Description describeChild(FrameworkMethod method) {
        return Description.createTestDescription(getTestClass().getJavaClass(),
                testName(method), method.getAnnotations());
    }

    @Override
    protected List<FrameworkMethod> getChildren() {
        return computeTestMethods();
    }

    //
    // Override in subclasses
    //

    /**
     * Returns the methods that run tests. Default implementation returns all
     * methods annotated with {@code @Test} on this class and superclasses that
     * are not overridden.
     */
    protected List<FrameworkMethod> computeTestMethods() {
        return getTestClass().getAnnotatedMethods(Test.class);
    }

    @Override
    protected void collectInitializationErrors(List<Throwable> errors) {
        super.collectInitializationErrors(errors);

        validateNoNonStaticInnerClass(errors);
        validateConstructor(errors);
        validateInstanceMethods(errors);
        validateFields(errors);
        validateMethods(errors);
    }

    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {
        if (getTestClass().isANonStaticInnerClass()) {
            String gripe = "The inner class " + getTestClass().getName()
                    + " is not static.";
            errors.add(new Exception(gripe));
        }
    }

    /**
     * Adds to {@code errors} if the test class has more than one constructor,
     * or if the constructor takes parameters. Override if a subclass requires
     * different validation rules.
     */
    protected void validateConstructor(List<Throwable> errors) {
        validateOnlyOneConstructor(errors);
        validateZeroArgConstructor(errors);
    }

    /**
     * Adds to {@code errors} if the test class has more than one constructor
     * (do not override)
     */
    protected void validateOnlyOneConstructor(List<Throwable> errors) {
        if (!hasOneConstructor()) {
            String gripe = "Test class should have exactly one public constructor";
            errors.add(new Exception(gripe));
        }
    }

    /**
     * Adds to {@code errors} if the test class's single constructor takes
     * parameters (do not override)
     */
    protected void validateZeroArgConstructor(List<Throwable> errors) {
        if (!getTestClass().isANonStaticInnerClass()
                && hasOneConstructor()
                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {
            String gripe = "Test class should have exactly one public zero-argument constructor";
            errors.add(new Exception(gripe));
        }
    }

    private boolean hasOneConstructor() {
        return getTestClass().getJavaClass().getConstructors().length == 1;
    }

    /**
     * Adds to {@code errors} for each method annotated with {@code @Test},
     * {@code @Before}, or {@code @After} that is not a public, void instance
     * method with no arguments.
     *
     * @deprecated unused API, will go away in future version
     */
    @Deprecated
    protected void validateInstanceMethods(List<Throwable> errors) {
        validatePublicVoidNoArgMethods(After.class, false, errors);
        validatePublicVoidNoArgMethods(Before.class, false, errors);
        validateTestMethods(errors);

        if (computeTestMethods().size() == 0) {
            errors.add(new Exception("No runnable methods"));
        }
    }

    protected void validateFields(List<Throwable> errors) {
        RULE_VALIDATOR.validate(getTestClass(), errors);
    }

    private void validateMethods(List<Throwable> errors) {
        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
    }

    /**
     * Adds to {@code errors} for each method annotated with {@code @Test}that
     * is not a public, void instance method with no arguments.
     */
    protected void validateTestMethods(List<Throwable> errors) {
        validatePublicVoidNoArgMethods(Test.class, false, errors);
    }

    /**
     * Returns a new fixture for running a test. Default implementation executes
     * the test class's no-argument constructor (validation should have ensured
     * one exists).
     */
    protected Object createTest() throws Exception {
        return getTestClass().getOnlyConstructor().newInstance();
    }

    /**
     * Returns the name that describes {@code method} for {@link Description}s.
     * Default implementation is the method's name
     */
    protected String testName(FrameworkMethod method) {
        return method.getName();
    }

    /**
     * Returns a Statement that, when executed, either returns normally if
     * {@code method} passes, or throws an exception if {@code method} fails.
     *
     * Here is an outline of the default implementation:
     *
     * <ul>
     * <li>Invoke {@code method} on the result of {@code createTest()}, and
     * throw any exceptions thrown by either operation.
     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
     * expecting} attribute, return normally only if the previous step threw an
     * exception of the correct type, and throw an exception otherwise.
     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
     * timeout} attribute, throw an exception if the previous step takes more
     * than the specified number of milliseconds.
     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class
     * and superclasses before any of the previous steps; if any throws an
     * Exception, stop execution and pass the exception on.
     * <li>ALWAYS run all non-overridden {@code @After} methods on this class
     * and superclasses after any of the previous steps; all After methods are
     * always executed: exceptions thrown by previous steps are combined, if
     * necessary, with exceptions from After methods into a
     * {@link MultipleFailureException}.
     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the
     * above steps. A {@code Rule} may prevent all execution of the above steps,
     * or add additional behavior before and after, or modify thrown exceptions.
     * For more information, see {@link TestRule}
     * </ul>
     *
     * This can be overridden in subclasses, either by overriding this method,
     * or the implementations creating each sub-statement.
     */
    protected Statement methodBlock(FrameworkMethod method) {
        Object test;
        try {
            test = new ReflectiveCallable() {
                @Override
                protected Object runReflectiveCall() throws Throwable {
                    return createTest();
                }
            }.run();
        } catch (Throwable e) {
            return new Fail(e);
        }

        Statement statement = methodInvoker(method, test);
        statement = possiblyExpectingExceptions(method, test, statement);
        statement = withPotentialTimeout(method, test, statement);
        statement = withBefores(method, test, statement);
        statement = withAfters(method, test, statement);
        statement = withRules(method, test, statement);
        return statement;
    }

    //
    // Statement builders
    //

    /**
     * Returns a {@link Statement} that invokes {@code method} on {@code test}
     */
    protected Statement methodInvoker(FrameworkMethod method, Object test) {
        return new InvokeMethod(method, test);
    }

    /**
     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
     * has the {@code expecting} attribute, return normally only if {@code next}
     * throws an exception of the correct type, and throw an exception
     * otherwise.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement possiblyExpectingExceptions(FrameworkMethod method,
            Object test, Statement next) {
        Test annotation = method.getAnnotation(Test.class);
        return expectsException(annotation) ? new ExpectException(next,
                getExpectedException(annotation)) : next;
    }

    /**
     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
     * has the {@code timeout} attribute, throw an exception if {@code next}
     * takes more than the specified number of milliseconds.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement withPotentialTimeout(FrameworkMethod method,
            Object test, Statement next) {
        long timeout = getTimeout(method.getAnnotation(Test.class));
        return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
    }

    /**
     * Returns a {@link Statement}: run all non-overridden {@code @Before}
     * methods on this class and superclasses before running {@code next}; if
     * any throws an Exception, stop execution and pass the exception on.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement withBefores(FrameworkMethod method, Object target,
            Statement statement) {
        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(
                Before.class);
        return befores.isEmpty() ? statement : new RunBefores(statement,
                befores, target);
    }

    /**
     * Returns a {@link Statement}: run all non-overridden {@code @After}
     * methods on this class and superclasses before running {@code next}; all
     * After methods are always executed: exceptions thrown by previous steps
     * are combined, if necessary, with exceptions from After methods into a
     * {@link MultipleFailureException}.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement withAfters(FrameworkMethod method, Object target,
            Statement statement) {
        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(
                After.class);
        return afters.isEmpty() ? statement : new RunAfters(statement, afters,
                target);
    }

    private Statement withRules(FrameworkMethod method, Object target,
            Statement statement) {
        List<TestRule> testRules = getTestRules(target);
        Statement result = statement;
        result = withMethodRules(method, testRules, target, result);
        result = withTestRules(method, testRules, result);

        return result;
    }

    @SuppressWarnings("deprecation")
    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
            Object target, Statement result) {
        for (org.junit.rules.MethodRule each : getMethodRules(target)) {
            if (!testRules.contains(each)) {
                result = each.apply(result, method, target);
            }
        }
        return result;
    }

    @SuppressWarnings("deprecation")
    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
        return rules(target);
    }

    /**
     * @param target the test case instance
     * @return a list of MethodRules that should be applied when executing this
     *         test
     * @deprecated {@link org.junit.rules.MethodRule} is a deprecated interface. Port to
     *             {@link TestRule} and
     *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}
     */
    @Deprecated
    protected List<org.junit.rules.MethodRule> rules(Object target) {
        return getTestClass().getAnnotatedFieldValues(target, Rule.class,
                org.junit.rules.MethodRule.class);
    }

    /**
     * Returns a {@link Statement}: apply all non-static {@link Value} fields
     * annotated with {@link Rule}.
     *
     * @param statement The base statement
     * @return a RunRules statement if any class-level {@link Rule}s are
     *         found, or the base statement
     */
    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,
            Statement statement) {
        return testRules.isEmpty() ? statement :
                new RunRules(statement, testRules, describeChild(method));
    }

    /**
     * @param target the test case instance
     * @return a list of TestRules that should be applied when executing this
     *         test
     */
    protected List<TestRule> getTestRules(Object target) {
        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,
                Rule.class, TestRule.class);

        result.addAll(getTestClass().getAnnotatedFieldValues(target,
                Rule.class, TestRule.class));

        return result;
    }

    private Class<? extends Throwable> getExpectedException(Test annotation) {
        if (annotation == null || annotation.expected() == None.class) {
            return null;
        } else {
            return annotation.expected();
        }
    }

    private boolean expectsException(Test annotation) {
        return getExpectedException(annotation) != null;
    }

    private long getTimeout(Test annotation) {
        if (annotation == null) {
            return 0;
        }
        return annotation.timeout();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/Rule.java;<<<<<<< MINE
 * Annotates fields that reference rules or methods that return a rule. A field must be public, not
 * static, and a subtype of {@link org.junit.rules.TestRule} (preferred) or
 * {@link org.junit.rules.MethodRule}. A method must be public, not static
 * and must return a subtype of {@link org.junit.rules.TestRule} (preferred) or
 * {@link org.junit.rules.MethodRule}.<p>
 *
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link Before} methods, 
||||||| BASE
 * Annotates fields that contain rules or methods that return a rule. A field must be public, not
 * static, and a subtype of {@link org.junit.rules.TestRule}. A method must be public, not static
 * and must return a subtype of {@link org.junit.rules.TestRule}.   
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link Before} methods, 
=======
 * Annotates fields that contain rules or methods that return a rule. A field must be public, not
 * static, and a subtype of {@link org.junit.rules.TestRule}. A method must be public, not static
 * and must return a subtype of {@link org.junit.rules.TestRule}.
 * The {@link org.junit.runners.model.Statement} passed
 * to the {@link org.junit.rules.TestRule} will run any {@link Before} methods,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/Rule.java;<<<<<<< MINE
 * 
 * For more information and more examples, see 
 * {@link org.junit.rules.TestRule}. 
||||||| BASE
 * 
 * For more information and more examples, see 
 * {@link org.junit.rules.TestRule}. 
 *
 * Note: for backwards compatibility, this annotation may also mark
 * fields or methods of type {@link org.junit.rules.MethodRule}, which will be honored.  However,
 * this is a deprecated interface and feature.
=======
 *
 * For more information and more examples, see
 * {@link org.junit.rules.TestRule}.
 *
 * Note: for backwards compatibility, this annotation may also mark
 * fields or methods of type {@link org.junit.rules.MethodRule}, which will be honored.  However,
 * this is a deprecated interface and feature.
 *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/ClassRule.java;<<<<<<< MINE
 * a subtype of {@link org.junit.rules.TestRule}.<p>
 *
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods, 
||||||| BASE
 * a subtype of {@link org.junit.rules.TestRule} 
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods, 
=======
 * a subtype of {@link org.junit.rules.TestRule}
 * The {@link org.junit.runners.model.Statement} passed
 * to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_5bf4a69_92f6785/rev_5bf4a69-92f6785/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    @Deprecated
    public void pexpire(final String key, final int milliseconds) {
	pexpire(key, (long) milliseconds);
    }
    
||||||| BASE
    @Deprecated
    public void pexpire(final String key, final int milliseconds) {
	pexpire(key, (long) milliseconds);
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6fb53a7_2f879b9/rev_6fb53a7-2f879b9/src/main/java/org/junit/rules/TestWatcher.java;<<<<<<< MINE
	public Statement apply(final Statement base, final Description description) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				List<Throwable> errors = new ArrayList<Throwable>();

				startingQuietly(description, errors);
				try {
					base.evaluate();
					succeededQuietly(description, errors);
				} catch (AssumptionViolatedException e) {
					errors.add(e);
					skippedQuietly(e, description, errors);
				} catch (Throwable t) {
					errors.add(t);
					failedQuietly(t, description, errors);
				} finally {
					finishedQuietly(description, errors);
				}
				
				MultipleFailureException.assertEmpty(errors);
			}
		};
	}

	private void succeededQuietly(Description description,
			List<Throwable> errors) {
		try {
			succeeded(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	private void failedQuietly(Throwable t, Description description,
			List<Throwable> errors) {
		try {
			failed(t, description);
		} catch (Throwable t1) {
			errors.add(t1);
		}
	}

	private void skippedQuietly(AssumptionViolatedException e, Description description,
			List<Throwable> errors) {
		try {
			skipped(e, description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}

	private void startingQuietly(Description description,
			List<Throwable> errors) {
		try {
			starting(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	private void finishedQuietly(Description description,
			List<Throwable> errors) {
		try {
			finished(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	/**
	 * Invoked when a test succeeds
	 * 
	 * @param description
	 */
	protected void succeeded(Description description) {
	}

	/**
	 * Invoked when a test fails
	 * 
	 * @param e 
	 * @param description
	 */
	protected void failed(Throwable e, Description description) {
	}

	/**
	 * Invoked when a test is skipped due to a failed assumption.
	 *
	 * @param e
	 * @param description
	 */
	protected void skipped(AssumptionViolatedException e, Description description) {
	}

	/**
	 * Invoked when a test is about to start
	 * 
	 * @param description  
	 */
	protected void starting(Description description) {
	}

	/**
	 * Invoked when a test method finishes (whether passing or failing)
	 * 
	 * @param description  
	 */
	protected void finished(Description description) {
	}
||||||| BASE
	public Statement apply(final Statement base, final Description description) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				List<Throwable> errors = new ArrayList<Throwable>();

				startingQuietly(description, errors);
				try {
					base.evaluate();
					succeededQuietly(description, errors);
				} catch (AssumptionViolatedException e) {
					skipped(e, description);
					throw e;
				} catch (Throwable t) {
					errors.add(t);
					failedQuietly(t, description, errors);
				} finally {
					finishedQuietly(description, errors);
				}
				
				MultipleFailureException.assertEmpty(errors);
			}
		};
	}

	private void succeededQuietly(Description description,
			List<Throwable> errors) {
		try {
			succeeded(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	private void failedQuietly(Throwable t, Description description,
			List<Throwable> errors) {
		try {
			failed(t, description);
		} catch (Throwable t1) {
			errors.add(t1);
		}
	}

	private void startingQuietly(Description description, 
			List<Throwable> errors) {
		try {
			starting(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	private void finishedQuietly(Description description,
			List<Throwable> errors) {
		try {
			finished(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	/**
	 * Invoked when a test succeeds
	 * 
	 * @param description
	 */
	protected void succeeded(Description description) {
	}

	/**
	 * Invoked when a test fails
	 * 
	 * @param e 
	 * @param description
	 */
	protected void failed(Throwable e, Description description) {
	}

	/**
	 * Invoked when a test is skipped due to a failed assumption.
	 *
	 * @param e
	 * @param description
	 */
	protected void skipped(AssumptionViolatedException e, Description description) {
	}

	/**
	 * Invoked when a test is about to start
	 * 
	 * @param description  
	 */
	protected void starting(Description description) {
	}

	/**
	 * Invoked when a test method finishes (whether passing or failing)
	 * 
	 * @param description  
	 */
	protected void finished(Description description) {
	}
=======
    public Statement apply(final Statement base, final Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                List<Throwable> errors = new ArrayList<Throwable>();

                startingQuietly(description, errors);
                try {
                    base.evaluate();
                    succeededQuietly(description, errors);
                } catch (AssumptionViolatedException e) {
                    skipped(e, description);
                    throw e;
                } catch (Throwable t) {
                    errors.add(t);
                    failedQuietly(t, description, errors);
                } finally {
                    finishedQuietly(description, errors);
                }

                MultipleFailureException.assertEmpty(errors);
            }
        };
    }

    private void succeededQuietly(Description description,
            List<Throwable> errors) {
        try {
            succeeded(description);
        } catch (Throwable t) {
            errors.add(t);
        }
    }

    private void failedQuietly(Throwable t, Description description,
            List<Throwable> errors) {
        try {
            failed(t, description);
        } catch (Throwable t1) {
            errors.add(t1);
        }
    }

    private void startingQuietly(Description description,
            List<Throwable> errors) {
        try {
            starting(description);
        } catch (Throwable t) {
            errors.add(t);
        }
    }

    private void finishedQuietly(Description description,
            List<Throwable> errors) {
        try {
            finished(description);
        } catch (Throwable t) {
            errors.add(t);
        }
    }

    /**
     * Invoked when a test succeeds
     */
    protected void succeeded(Description description) {
    }

    /**
     * Invoked when a test fails
     */
    protected void failed(Throwable e, Description description) {
    }

    /**
     * Invoked when a test is skipped due to a failed assumption.
     */
    protected void skipped(AssumptionViolatedException e, Description description) {
    }

    /**
     * Invoked when a test is about to start
     */
    protected void starting(Description description) {
    }

    /**
     * Invoked when a test method finishes (whether passing or failing)
     */
    protected void finished(Description description) {
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6fb53a7_2f879b9/rev_6fb53a7-2f879b9/src/test/java/org/junit/tests/experimental/rules/TestWatcherTest.java;<<<<<<< MINE
		@Test
		public void succeeds() {
			assumeTrue(false);
		}
	}

	@Test
	public void neitherLogSuccessNorFailedForViolatedAssumption() {
		ViolatedAssumptionTest.watchedLog= new StringBuilder();
		runClasses(ViolatedAssumptionTest.class);
		assertThat(ViolatedAssumptionTest.watchedLog.toString(),
				is("starting finished "));
	}

	public static class TestWatcherSkippedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void skipped(AssumptionViolatedException e, Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new AssumptionViolatedException("test failure");
		}
	}

	@Test
	public void testWatcherSkippedThrowsException() {
		PrintableResult result= testResult(TestWatcherSkippedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}

	public static class FailingTest {
		private static StringBuilder watchedLog= new StringBuilder();

		@Rule
		public TestRule watcher= new LoggingTestWatcher(watchedLog);

		@Test
		public void succeeds() {
			fail();
		}
	}

	@Test
	public void logFailingTest() {
		FailingTest.watchedLog= new StringBuilder();
		runClasses(FailingTest.class);
		assertThat(FailingTest.watchedLog.toString(),
				is("starting failed finished "));
	}
	
	public static class TestWatcherFailedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable e, Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherStartingThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void starting(Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherStartingThrowsException() {
		PrintableResult result= testResult(TestWatcherStartingThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherFailedAndFinishedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable t, Description description) {
				throw new RuntimeException("watcher failed failure");
			}
			
			@Override
			protected void finished(Description description) {
				throw new RuntimeException("watcher finished failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedAndFinishedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(3));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failed failure"));
		assertThat(result, hasFailureContaining("watcher finished failure"));
	}	
||||||| BASE
		@Test
		public void succeeds() {
			assumeTrue(false);
		}
	}

	@Test
	public void neitherLogSuccessNorFailedForViolatedAssumption() {
		ViolatedAssumptionTest.watchedLog= new StringBuilder();
		runClasses(ViolatedAssumptionTest.class);
		assertThat(ViolatedAssumptionTest.watchedLog.toString(),
				is("starting finished "));
	}

	public static class FailingTest {
		private static StringBuilder watchedLog= new StringBuilder();

		@Rule
		public TestRule watcher= new LoggingTestWatcher(watchedLog);

		@Test
		public void succeeds() {
			fail();
		}
	}

	@Test
	public void logFailingTest() {
		FailingTest.watchedLog= new StringBuilder();
		runClasses(FailingTest.class);
		assertThat(FailingTest.watchedLog.toString(),
				is("starting failed finished "));
	}
	
	public static class TestWatcherFailedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable e, Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherStartingThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void starting(Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherStartingThrowsException() {
		PrintableResult result= testResult(TestWatcherStartingThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherFailedAndFinishedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable t, Description description) {
				throw new RuntimeException("watcher failed failure");
			}
			
			@Override
			protected void finished(Description description) {
				throw new RuntimeException("watcher finished failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedAndFinishedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(3));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failed failure"));
		assertThat(result, hasFailureContaining("watcher finished failure"));
	}	
=======
        @Test
        public void succeeds() {
            assumeTrue(false);
        }
    }

    @Test
    public void neitherLogSuccessNorFailedForViolatedAssumption() {
        ViolatedAssumptionTest.watchedLog = new StringBuilder();
        runClasses(ViolatedAssumptionTest.class);
        assertThat(ViolatedAssumptionTest.watchedLog.toString(),
                is("starting finished "));
    }

    public static class FailingTest {
        private static StringBuilder watchedLog = new StringBuilder();

        @Rule
        public TestRule watcher = new LoggingTestWatcher(watchedLog);

        @Test
        public void succeeds() {
            fail();
        }
    }

    @Test
    public void logFailingTest() {
        FailingTest.watchedLog = new StringBuilder();
        runClasses(FailingTest.class);
        assertThat(FailingTest.watchedLog.toString(),
                is("starting failed finished "));
    }

    public static class TestWatcherFailedThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void failed(Throwable e, Description description) {
                throw new RuntimeException("watcher failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherFailedThrowsException() {
        PrintableResult result = testResult(TestWatcherFailedThrowsExceptionTest.class);
        assertThat(result, failureCountIs(2));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failure"));
    }

    public static class TestWatcherStartingThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void starting(Description description) {
                throw new RuntimeException("watcher failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherStartingThrowsException() {
        PrintableResult result = testResult(TestWatcherStartingThrowsExceptionTest.class);
        assertThat(result, failureCountIs(2));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failure"));
    }

    public static class TestWatcherFailedAndFinishedThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void failed(Throwable t, Description description) {
                throw new RuntimeException("watcher failed failure");
            }

            @Override
            protected void finished(Description description) {
                throw new RuntimeException("watcher finished failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherFailedAndFinishedThrowsException() {
        PrintableResult result = testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
        assertThat(result, failureCountIs(3));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failed failure"));
        assertThat(result, hasFailureContaining("watcher finished failure"));
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

||||||| BASE
=======

    @Override
    public void close() {
	if (dataSource != null) {
	    if (client.isBroken()) {
		this.dataSource.returnBrokenResource(this);
	    } else {
		this.dataSource.returnResource(this);
	    }
	} else {
	    client.close();
	}
    }

    public void setDataSource(Pool<Jedis> jedisPool) {
        this.dataSource = jedisPool;
    }

    public Long pfadd(final String key, final String... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    public long pfcount(final String key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    @Override
    public long pfcount(String... keys) {
        checkIsInMulti();
	client.pfcount(keys);
	return client.getIntegerReply();
    }

    public String pfmerge(final String destkey, final String... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, ZLEXCOUNT, ZRANGEBYLEX, ZREMRANGEBYLEX, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING;
||||||| BASE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, PFADD, PFCOUNT, PFMERGE;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE

||||||| BASE
=======
    
    @Override
    public Long pfadd(final byte[] key, final byte[]... elements) {
	Jedis j = getShard(key);
	return j.pfadd(key, elements);
    }

    @Override
    public long pfcount(final byte[] key) {
	Jedis j = getShard(key);
	return j.pfcount(key);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/test/java/redis/clients/jedis/tests/commands/SortedSetCommandsTest.java;<<<<<<< MINE
    final byte[] bInclusiveB = { 0x5B, 0x0B }; 
    final byte[] bExclusiveC = { 0x28, 0x0C }; 
    final byte[] bLexMinusInf = { 0x2D };
    final byte[] bLexPlusInf = { 0x2B };
||||||| BASE
=======
    
    final byte[] bbar1 = { 0x05, 0x06, 0x07, 0x08, 0x0A };
    final byte[] bbar2 = { 0x05, 0x06, 0x07, 0x08, 0x0B };
    final byte[] bbar3 = { 0x05, 0x06, 0x07, 0x08, 0x0C };
    final byte[] bbarstar = { 0x05, 0x06, 0x07, 0x08, '*' };
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6766336_b04c86a/rev_6766336-b04c86a/src/test/java/org/junit/internal/MethodSorterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/Client.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/Protocol.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/ClusterCommands.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/test/java/redis/clients/jedis/tests/commands/ClusterCommandsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/test/java/redis/clients/jedis/tests/commands/ClusterCommandsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_992ae7a_a30598b/rev_992ae7a-a30598b/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE

||||||| BASE
=======

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_992ae7a_a30598b/rev_992ae7a-a30598b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

||||||| BASE
=======

    @Override
    public List<String> blpop(int timeout, String key) {
	checkIsInMulti();
	List<String> args = new ArrayList<String>();
	args.add(key);
	args.add(String.valueOf(timeout));
	client.blpop(args.toArray(new String[args.size()]));
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    @Override
    public List<String> brpop(int timeout, String key) {
	checkIsInMulti();
	List<String> args = new ArrayList<String>();
	args.add(key);
	args.add(String.valueOf(timeout));
	client.brpop(args.toArray(new String[args.size()]));
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }  

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    public JedisSentinelPool(String masterName, Set<String> sentinels,
	    final GenericObjectPoolConfig poolConfig, int timeout,
	    final String password, final int database) {

	this.poolConfig = poolConfig;
	this.timeout = timeout;
	this.password = password;
	this.database = database;
||||||| BASE
    public JedisSentinelPool(String masterName, Set<String> sentinels,
	    final GenericObjectPoolConfig poolConfig, int timeout,
	    final String password, final int database) {
	this.poolConfig = poolConfig;
	this.timeout = timeout;
	this.password = password;
	this.database = database;
=======
	public JedisSentinelPool(String masterName, Set<String> sentinels,
			final GenericObjectPoolConfig poolConfig, int timeout,
			final String password, final int database) {
		this.poolConfig = poolConfig;
		this.timeout = timeout;
		this.password = password;
		this.database = database;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
	HostAndPort master = initSentinels(sentinels, masterName);
	initPool(master);
    }

    private volatile JedisFactory factory;
    private volatile HostAndPort currentHostMaster;

    public void destroy() {
	for (MasterListener m : masterListeners) {
	    m.shutdown();
||||||| BASE
	HostAndPort master = initSentinels(sentinels, masterName);
	initPool(master);
    }

    public void returnBrokenResource(final Jedis resource) {
	if (resource != null) {
	    returnBrokenResourceObject(resource);
	}
    }

    public void returnResource(final Jedis resource) {
	if (resource != null) {
	    resource.resetState();
	    returnResourceObject(resource);
	}
    }

    private volatile HostAndPort currentHostMaster;

    public void destroy() {
	for (MasterListener m : masterListeners) {
	    m.shutdown();
=======
		HostAndPort master = initSentinels(sentinels, masterName);
		initPool(master);
	}

	public void returnBrokenResource(final Jedis resource) {
		if (resource != null) {
			returnBrokenResourceObject(resource);
		}
	}

	public void returnResource(final Jedis resource) {
		if (resource != null) {
			resource.resetState();
			returnResourceObject(resource);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    private void initPool(HostAndPort master) {
	if (!master.equals(currentHostMaster)) {
	    currentHostMaster = master;
	    if (factory == null) {
	        factory = new JedisFactory(master.getHost(), master.getPort(),
	                                   timeout, password, database);
	        initPool(poolConfig, factory);
	    } else {
	        factory.setHostAndPort(currentHostMaster);
	        // although we clear the pool, we still have to check the returned object
	        // in getResource, this call only clears idle instances, not borrowed instances
	        internalPool.clear();
	    }

	    log.info("Created JedisPool to master at " + master);
||||||| BASE
    private void initPool(HostAndPort master) {
	if (!master.equals(currentHostMaster)) {
	    currentHostMaster = master;
	    log.info("Created JedisPool to master at " + master);
	    initPool(poolConfig,
		    new JedisFactory(master.getHost(), master.getPort(),
			    timeout, password, database));
=======
		super.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
		Jedis jedis = null;
		try {
		    jedis = new Jedis(hap.getHost(), hap.getPort());
||||||| BASE
		try {
		    Jedis jedis = new Jedis(hap.getHost(), hap.getPort());
=======
		log.info("Redis master running at " + master
				+ ", starting Sentinel listeners...");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
		    if (master == null) {
			master = toHostAndPort(jedis
				.sentinelGetMasterAddrByName(masterName));
			log.fine("Found Redis master at " + master);
			break outer;
		    }
		} catch (JedisConnectionException e) {
		    log.warning("Cannot connect to sentinel running @ " + hap
			    + ". Trying next one.");
		} finally {
		    if (jedis != null) {
	        jedis.close();
		    }
||||||| BASE
		    if (master == null) {
			master = toHostAndPort(jedis
				.sentinelGetMasterAddrByName(masterName));
			log.fine("Found Redis master at " + master);
			jedis.disconnect();
			break outer;
		    }
		} catch (JedisConnectionException e) {
		    log.warning("Cannot connect to sentinel running @ " + hap
			    + ". Trying next one.");
=======
		for (String sentinel : sentinels) {
			final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel
					.split(":")));
			MasterListener masterListener = new MasterListener(masterName,
					hap.getHost(), hap.getPort());
			masterListeners.add(masterListener);
			masterListener.start();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    @Override
    public Jedis getResource() {
	while (true) {
	    Jedis jedis = super.getResource();
	    jedis.setDataSource(this);

	    // get a reference because it can change concurrently
	    final HostAndPort master = currentHostMaster;
	    final HostAndPort connection = new HostAndPort(jedis.getClient().getHost(),
	       jedis.getClient().getPort());

	    if (master.equals(connection)) {
	        // connected to the correct master
	        return jedis;
	    } else {
	        returnBrokenResource(jedis);
	    }
	}
    }

    public void returnBrokenResource(final Jedis resource) {
	if (resource != null) {
	    returnBrokenResourceObject(resource);
	}
    }

    public void returnResource(final Jedis resource) {
	if (resource != null) {
	    resource.resetState();
	    returnResourceObject(resource);
	}
    }

    protected class JedisPubSubAdapter extends JedisPubSub {
	@Override
	public void onMessage(String channel, String message) {
	}
||||||| BASE
    protected class JedisPubSubAdapter extends JedisPubSub {
	@Override
	public void onMessage(String channel, String message) {
	}
=======
		@Override
		public void onPUnsubscribe(String pattern, int subscribedChannels) {
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest.java;<<<<<<< MINE
    protected static HostAndPort master = HostAndPortUtil.getRedisServers()
	    .get(2);
    protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
	    .get(3);

    protected static HostAndPort sentinel1 = HostAndPortUtil
	    .getSentinelServers().get(1);
    protected static HostAndPort sentinel2 = HostAndPortUtil
            .getSentinelServers().get(3);

    protected static Jedis sentinelJedis1;
    protected static Jedis sentinelJedis2;

    protected Set<String> sentinels = new HashSet<String>();

    @Before
    public void setUp() throws Exception {
	sentinels.add(sentinel1.toString());
	sentinels.add(sentinel2.toString());

	sentinelJedis1 = new Jedis(sentinel1.getHost(), sentinel1.getPort());
	sentinelJedis2 = new Jedis(sentinel2.getHost(), sentinel2.getPort());
    }
    
    @Test
    public void checkCloseableConnections() throws Exception {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();

	JedisSentinelPool pool = new JedisSentinelPool(
		MASTER_NAME, sentinels, config, 1000, "foobared", 2);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.close();
	assertTrue(pool.isClosed());
    }

    @Test
    public void ensureSafeTwiceFailover() throws InterruptedException {
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		new GenericObjectPoolConfig(), 1000, "foobared", 2);

	forceFailover(pool);
	// after failover sentinel needs a bit of time to stabilize before a new failover
	Thread.sleep(100);
	forceFailover(pool);

	// you can test failover as much as possible
    }
    
    @Test
    public void returnResourceShouldResetState() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis jedis = pool.getResource();
	Jedis jedis2 = null;
	
	try {
	    jedis.set("hello", "jedis");
	    Transaction t = jedis.multi();
	    t.set("hello", "world");
	    pool.returnResource(jedis);
	    
	    jedis2 = pool.getResource();

	    assertTrue(jedis == jedis2);
	    assertEquals("jedis", jedis2.get("hello"));
	} catch (JedisConnectionException e) {
	    if (jedis2 != null) {
		pool.returnBrokenResource(jedis2);
		jedis2 = null;
	    }
	} finally {
	    if (jedis2 != null)
		pool.returnResource(jedis2);
	    
	    pool.destroy();
	}
    }
    
    @Test
    public void checkResourceIsCloseable() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis jedis = pool.getResource();
	try {
	    jedis.set("hello", "jedis");
	} finally {
	    jedis.close();
	}

	Jedis jedis2 = pool.getResource();
	try {
	    assertEquals(jedis, jedis2);
	} finally {
	    jedis2.close();
	}
    }

    @Test
    public void returnResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnResource(nullJedis);
	pool.destroy();
    }

    @Test
    public void returnBrokenResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnBrokenResource(nullJedis);
	pool.destroy();
    }

    private void forceFailover(JedisSentinelPool pool)
	    throws InterruptedException {
	HostAndPort oldMaster = pool.getCurrentHostMaster();

	// jedis connection should be master
	Jedis beforeFailoverJedis = pool.getResource();
	assertEquals("PONG", beforeFailoverJedis.ping());

	waitForFailover(pool, oldMaster);

	Jedis afterFailoverJedis = pool.getResource();
	assertEquals("PONG", afterFailoverJedis.ping());
	assertEquals("foobared", afterFailoverJedis.configGet("requirepass").get(1));
	assertEquals(2, afterFailoverJedis.getDB().intValue());
	
	// returning both connections to the pool should not throw
	beforeFailoverJedis.close();
	afterFailoverJedis.close();
    }

    private void waitForFailover(JedisSentinelPool pool, HostAndPort oldMaster)
	    throws InterruptedException {
	HostAndPort newMaster = JedisSentinelTestUtil
		.waitForNewPromotedMaster(MASTER_NAME, sentinelJedis1, sentinelJedis2);

	waitForJedisSentinelPoolRecognizeNewMaster(pool, newMaster);
    }

    private void waitForJedisSentinelPoolRecognizeNewMaster(
	    JedisSentinelPool pool, HostAndPort newMaster)
	    throws InterruptedException {

	while (true) {
	    HostAndPort currentHostMaster = pool.getCurrentHostMaster();

	    if (newMaster.equals(currentHostMaster))
		break;
||||||| BASE
    protected static HostAndPort master = HostAndPortUtil.getRedisServers()
	    .get(2);
    protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
	    .get(3);
    protected static HostAndPort sentinel1 = HostAndPortUtil
	    .getSentinelServers().get(1);

    protected static Jedis sentinelJedis1;

    protected Set<String> sentinels = new HashSet<String>();

    @Before
    public void setUp() throws Exception {
	sentinels.add(sentinel1.toString());

	sentinelJedis1 = new Jedis(sentinel1.getHost(), sentinel1.getPort());
    }

    @Test
    public void ensureSafeTwiceFailover() throws InterruptedException {
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		new GenericObjectPoolConfig(), 1000, "foobared", 2);

	forceFailover(pool);
	forceFailover(pool);

	// you can test failover as much as possible
    }
    
    @Test
    public void returnResourceShouldResetState() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis jedis = pool.getResource();
	Jedis jedis2 = null;
	
	try {
	    jedis.set("hello", "jedis");
	    Transaction t = jedis.multi();
	    t.set("hello", "world");
	    pool.returnResource(jedis);
	    
	    jedis2 = pool.getResource();

	    assertTrue(jedis == jedis2);
	    assertEquals("jedis", jedis2.get("hello"));
	} catch (JedisConnectionException e) {
	    if (jedis2 != null) {
		pool.returnBrokenResource(jedis2);
		jedis2 = null;
	    }
	} finally {
	    if (jedis2 != null)
		pool.returnResource(jedis2);
	    
	    pool.destroy();
	}
    }

    @Test
    public void returnResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnResource(nullJedis);
	pool.destroy();
    }

    @Test
    public void returnBrokenResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnBrokenResource(nullJedis);
	pool.destroy();
    }

    private void forceFailover(JedisSentinelPool pool)
	    throws InterruptedException {
	HostAndPort oldMaster = pool.getCurrentHostMaster();

	// jedis connection should be master
	Jedis jedis = pool.getResource();
	assertEquals("PONG", jedis.ping());

	// It can throw JedisDataException while there's no slave to promote
	// There's nothing we can do, so we just pass Exception to make test
	// fail fast
	sentinelJedis1.sentinelFailover(MASTER_NAME);
	
	waitForFailover(pool, oldMaster);
	// JedisSentinelPool recognize master but may not changed internal pool
	// yet
	Thread.sleep(100);
	
	jedis = pool.getResource();
	assertEquals("PONG", jedis.ping());
	assertEquals("foobared", jedis.configGet("requirepass").get(1));
	assertEquals(2, jedis.getDB().intValue());
    }

    private void waitForFailover(JedisSentinelPool pool, HostAndPort oldMaster)
	    throws InterruptedException {
	HostAndPort newMaster = JedisSentinelTestUtil
		.waitForNewPromotedMaster(sentinelJedis1);

	waitForJedisSentinelPoolRecognizeNewMaster(pool, newMaster);
    }

    private void waitForJedisSentinelPoolRecognizeNewMaster(
	    JedisSentinelPool pool, HostAndPort newMaster)
	    throws InterruptedException {

	while (true) {
	    String host = pool.getCurrentHostMaster().getHost();
	    int port = pool.getCurrentHostMaster().getPort();

	    if (host.equals(newMaster.getHost()) && port == newMaster.getPort())
		break;
=======
	protected static HostAndPort master = HostAndPortUtil.getRedisServers()
			.get(2);
	protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
			.get(3);
	protected static HostAndPort sentinel1 = HostAndPortUtil
			.getSentinelServers().get(1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

import java.util.*;
||||||| BASE
import java.util.*;
=======
import redis.clients.jedis.exceptions.JedisConnectionException;

import java.util.Map;
import java.util.Random;
import java.util.Set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
    public static ClusterNodeInformationParser nodeInfoParser = new ClusterNodeInformationParser();

    protected Map<String, JedisPool> nodes = new HashMap<String, JedisPool>();
    protected Map<Integer, JedisPool> slots = new HashMap<Integer, JedisPool>();
    final protected GenericObjectPoolConfig poolConfig;
||||||| BASE
    public static ClusterNodeInformationParser nodeInfoParser = new ClusterNodeInformationParser();

    protected Map<String, JedisPool> nodes = new HashMap<String, JedisPool>();
    protected Map<Integer, JedisPool> slots = new HashMap<Integer, JedisPool>();
=======
    protected JedisClusterInfoCache cache = new JedisClusterInfoCache();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
    private void discoverClusterNodesAndSlots(Jedis jedis) {
        String localNodes = jedis.clusterNodes();
        for (String nodeInfo : localNodes.split("\n")) {
            ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
                    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
                    jedis.getClient().getPort()));

            HostAndPort targetNode = clusterNodeInfo.getNode();
            setNodeIfNotExist(targetNode);
            assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);
        }
    }

    public void assignSlotToNode(int slot, HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}
	slots.put(slot, targetPool);
    }

    public void assignSlotsToNode(List<Integer> targetSlots,
	    HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}

	for (Integer slot : targetSlots) {
	    slots.put(slot, targetPool);
||||||| BASE
    private void discoverClusterNodesAndSlots(Jedis jedis) {
	String localNodes = jedis.clusterNodes();
	for (String nodeInfo : localNodes.split("\n")) {
	    ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
		    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
			    jedis.getClient().getPort()));

	    HostAndPort targetNode = clusterNodeInfo.getNode();
	    setNodeIfNotExist(targetNode);
	    assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);
	}
    }

    public void assignSlotToNode(int slot, HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}
	slots.put(slot, targetPool);
    }

    public void assignSlotsToNode(List<Integer> targetSlots,
	    HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}

	for (Integer slot : targetSlots) {
	    slots.put(slot, targetPool);
=======
    public void renewSlotCache() {
	for (JedisPool jp : cache.getNodes().values()) {
	    Jedis jedis = null;
	    try {
		jedis = jp.getResource();
		cache.discoverClusterSlots(jedis);
		break;
	    } finally {
		if (jedis != null) {
		    jedis.close();
		}
	    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
    protected String getNodeKey(HostAndPort hnp) {
	return hnp.getHost() + ":" + hnp.getPort();
    }

    protected String getNodeKey(Client client) {
	return client.getHost() + ":" + client.getPort();
    }

    private void setNodeIfNotExist(HostAndPort node) {
	String nodeKey = getNodeKey(node);
	if (nodes.containsKey(nodeKey))
	    return;

	JedisPool nodePool = new JedisPool(poolConfig, node.getHost(), node.getPort());
	nodes.put(nodeKey, nodePool);
    }
||||||| BASE
    protected String getNodeKey(HostAndPort hnp) {
	return hnp.getHost() + ":" + hnp.getPort();
    }

    protected String getNodeKey(Client client) {
	return client.getHost() + ":" + client.getPort();
    }

    private void setNodeIfNotExist(HostAndPort node) {
	String nodeKey = getNodeKey(node);
	if (nodes.containsKey(nodeKey))
	    return;

	JedisPool nodePool = new JedisPool(node.getHost(), node.getPort());
	nodes.put(nodeKey, nodePool);
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

public class JedisCluster implements JedisCommands, BasicCommands {
||||||| BASE
public class JedisCluster implements JedisCommands, BasicCommands {
=======
public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
import redis.clients.jedis.exceptions.*;
||||||| BASE
import redis.clients.jedis.exceptions.JedisAskDataException;
import redis.clients.jedis.exceptions.JedisClusterException;
import redis.clients.jedis.exceptions.JedisClusterMaxRedirectionsException;
import redis.clients.jedis.exceptions.JedisException;
import redis.clients.jedis.exceptions.JedisMovedDataException;
=======
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.exceptions.JedisAskDataException;
import redis.clients.jedis.exceptions.JedisClusterException;
import redis.clients.jedis.exceptions.JedisClusterMaxRedirectionsException;
import redis.clients.jedis.exceptions.JedisConnectionException;
import redis.clients.jedis.exceptions.JedisException;
import redis.clients.jedis.exceptions.JedisMovedDataException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE

    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

||||||| BASE
    
=======
    
    @Test
    public void testCloseable() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	
	JedisCluster jc = null;
	try {
	    jc = new JedisCluster(jedisClusterNode);
	    jc.set("51", "foo");
	} finally {
	    if (jc != null) {
		jc.close();
	    }
	}

	Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
	while (poolIterator.hasNext()) {
	    JedisPool pool = poolIterator.next();
	    try {
		pool.getResource();
		fail("JedisCluster's internal pools should be already destroyed");
	    } catch (JedisConnectionException e) {
		// ok to go...
	    }
	}
    }
    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8b0d35b_067ed0a/rev_8b0d35b-067ed0a/src/main/java/junit/runner/Version.java;<<<<<<< MINE
    private static final String VERSION = getVersion();

	private Version() {
		// don't instantiate
	}
||||||| BASE
    private Version() {
        // don't instantiate
    }
=======
	private Version() {
		// don't instantiate
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8b0d35b_067ed0a/rev_8b0d35b-067ed0a/src/main/java/junit/runner/Version.java;<<<<<<< MINE
	public static String id() {
		return VERSION;
	}
	
	public static void main(String[] args) {
		System.out.println(id());
	}

	private static InputStream getPomPropertiesAsStream(String artifactId) {
		return Version.class.getResourceAsStream("/META-INF/maven/junit/" + artifactId + "/pom.properties");
	}
    
	private static String getVersion() {
		try {
			final Properties properties= new Properties();
			InputStream pomProps= getPomPropertiesAsStream("junit");
			if (pomProps != null) properties.load(pomProps);
			String version= properties.getProperty("version", "<version>");
			if (pomProps != null) pomProps.close();
			assert !version.equals("<version>") : "your class loader does not load resources at /META-INF/maven/junit/...";
			return version;
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
    }
||||||| BASE
    public static String id() {
        return "4.11-SNAPSHOT";
    }

    public static void main(String[] args) {
        System.out.println(id());
    }
=======
	public static String id() {
		return "4.12-SNAPSHOT";
	}
	
	public static void main(String[] args) {
		System.out.println(id());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
||||||| BASE
public class JedisCluster implements JedisCommands, BasicCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
=======
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
    
    public static enum Reset {SOFT, HARD}

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	    int maxRedirections) {
	super(jedisClusterNode, timeout, maxRedirections);
||||||| BASE
	    int maxRedirections) {
	this.connectionHandler = new JedisSlotBasedConnectionHandler(
		jedisClusterNode);
	this.timeout = timeout;
	this.maxRedirections = maxRedirections;
=======
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
    this.connectionHandler = new JedisSlotBasedConnectionHandler(
            jedisClusterNode, poolConfig);
    this.timeout = timeout;
    this.maxRedirections = maxRedirections;
    }
    
    @Override
    public void close() {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }
    
||||||| BASE
    @Override
    public String ping() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ping();
	    }
	}.run(null);
    }

    @Override
    public String quit() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.quit();
	    }
	}.run(null);
    }

    @Override
    public String flushDB() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushDB();
	    }
	}.run(null);
    }

    @Override
    public Long dbSize() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.dbSize();
	    }
	}.run(null);
    }

    @Override
    public String select(final int index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.select(index);
	    }
	}.run(null);
    }

    @Override
    public String flushAll() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushAll();
	    }
	}.run(null);
    }

    @Override
    public String auth(final String password) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.auth(password);
	    }
	}.run(null);
    }

    @Override
    public String save() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.save();
	    }
	}.run(null);
    }

    @Override
    public String bgsave() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgsave();
	    }
	}.run(null);
    }

    @Override
    public String bgrewriteaof() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgrewriteaof();
	    }
	}.run(null);
    }

    @Override
    public Long lastsave() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lastsave();
	    }
	}.run(null);
    }

    @Override
    public String shutdown() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.shutdown();
	    }
	}.run(null);
    }

    @Override
    public String info() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info();
	    }
	}.run(null);
    }

    @Override
    public String info(final String section) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info(section);
	    }
	}.run(null);
    }

    @Override
    public String slaveof(final String host, final int port) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveof(host, port);
	    }
	}.run(null);
    }

    @Override
    public String slaveofNoOne() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveofNoOne();
	    }
	}.run(null);
    }

    @Override
    public Long getDB() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.getDB();
	    }
	}.run(null);
    }

    @Override
    public String debug(final DebugParams params) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.debug(params);
	    }
	}.run(null);
    }

    @Override
    public String configResetStat() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.configResetStat();
	    }
	}.run(null);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public Long waitReplicas(int replicas, long timeout) {
	// TODO Auto-generated method stub
	return null;
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }
    
=======
    @Override
    public String ping() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ping();
	    }
	}.run(null);
    }

    @Override
    public String quit() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.quit();
	    }
	}.run(null);
    }

    @Override
    public String flushDB() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushDB();
	    }
	}.run(null);
    }

    @Override
    public Long dbSize() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.dbSize();
	    }
	}.run(null);
    }

    @Override
    public String select(final int index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.select(index);
	    }
	}.run(null);
    }

    @Override
    public String flushAll() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushAll();
	    }
	}.run(null);
    }

    @Override
    public String auth(final String password) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.auth(password);
	    }
	}.run(null);
    }

    @Override
    public String save() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.save();
	    }
	}.run(null);
    }

    @Override
    public String bgsave() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgsave();
	    }
	}.run(null);
    }

    @Override
    public String bgrewriteaof() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgrewriteaof();
	    }
	}.run(null);
    }

    @Override
    public Long lastsave() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lastsave();
	    }
	}.run(null);
    }

    @Override
    public String shutdown() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.shutdown();
	    }
	}.run(null);
    }

    @Override
    public String info() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info();
	    }
	}.run(null);
    }

    @Override
    public String info(final String section) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info(section);
	    }
	}.run(null);
    }

    @Override
    public String slaveof(final String host, final int port) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveof(host, port);
	    }
	}.run(null);
    }

    @Override
    public String slaveofNoOne() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveofNoOne();
	    }
	}.run(null);
    }

    @Override
    public Long getDB() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.getDB();
	    }
	}.run(null);
    }

    @Override
    public String debug(final DebugParams params) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.debug(params);
	    }
	}.run(null);
    }

    @Override
    public String configResetStat() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.configResetStat();
	    }
	}.run(null);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public Long waitReplicas(int replicas, long timeout) {
	// TODO Auto-generated method stub
	return null;
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
    
    private T runWithRetries(byte[] key, int redirections,
            boolean tryRandomNode, boolean asking) {
        if (redirections <= 0) {
            throw new JedisClusterMaxRedirectionsException(
                "Too many Cluster redirections?");
        }

        Jedis connection = null;
        try {
            if (tryRandomNode) {
            connection = connectionHandler.getConnection();
            } else {
            connection = connectionHandler
                .getConnectionFromSlot(JedisClusterCRC16.getSlot(key));
            }

            if (asking) {
            // TODO: Pipeline asking with the original command to make it
            // faster....
            connection.asking();

            // if asking success, reset asking flag
            asking = false;
            }

            return execute(connection);
        } catch (JedisConnectionException jce) {
            if (tryRandomNode) {
            // maybe all connection is down
            throw jce;
            }
            
            releaseConnection(connection, true);
            connection = null;
            
            // retry with random connection
            return runWithRetries(key, redirections--, true, asking);
        } catch (JedisRedirectionException jre) {
            if (jre instanceof JedisAskDataException) {
            asking = true;
            } else if (jre instanceof JedisMovedDataException) {
            // TODO : In antirez's redis-rb-cluster implementation, 
            // it rebuilds cluster's slot and node cache
            }

            this.connectionHandler.assignSlotToNode(jre.getSlot(),
                jre.getTargetNode());

            releaseConnection(connection, false);
            connection = null;
            
            return runWithRetries(key, redirections - 1, false, asking);
        } finally {
            releaseConnection(connection, false);
        }

        }
    
||||||| BASE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    private static int getCRC16(byte[] key, int s, int e) {
        int crc = 0x0000;
        for (int i = s; i < e; i++){
            for (int j = 0; j < 8; j++) {
                boolean bit = ((key[i] >> (7 - j) & 1) == 1);
                boolean c15 = ((crc >> 15 & 1) == 1);
                crc <<= 1;
                // If coefficient of bit and remainder polynomial = 1 xor crc
                // with polynomial
                if (c15 ^ bit)
                    crc ^= polynomial;
                }
        }
     
        return crc &= 0xffff ;
    }
||||||| BASE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
||||||| BASE
        JedisClusterScriptingCommands {
=======
        JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}

    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(key);
||||||| BASE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
=======
    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(key);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(key);
    }
    
||||||| BASE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }
    
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE

    @Override
    public Long del(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> blpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> brpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> mget(final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.run(keys.length - 1, keys);
    }

    @Override
    public String mset(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long msetnx(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public String rename(final String oldkey, final String newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final String oldkey, final String newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public String rpoplpush(final String srckey, final String dstkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Set<String> sdiff(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Set<String> sinter(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sinterstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long smove(final String srckey, final String dstkey,
	    final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Long sort(final String key, final SortingParams sortingParameters,
	    final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Long sort(final String key, final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Set<String> sunion(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sunionstore(final String dstkey, final String... keys) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final String... sets) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String brpoplpush(final String source, final String destination,
	    final int timeout) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.run(2, source, destination);
    }

    @Override
    public Long publish(final String channel, final String message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final JedisPubSub jedisPubSub,
	    final String... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final JedisPubSub jedisPubSub,
	    final String... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final String destKey,
	    final String... srcKeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String pfmerge(final String destkey, final String... sourcekeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public long pfcount(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.run(keys.length, keys);
    }
||||||| BASE
=======

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
	MultiKeyBinaryJedisClusterCommands, JedisClusterBinaryScriptingCommands {
||||||| BASE
        JedisClusterBinaryScriptingCommands {
=======
        JedisClusterBinaryScriptingCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
    
    @Override
    public Long del(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> mget(final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.runBinary(keys.length - 1, keys);
    }

    @Override
    public String mset(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long msetnx(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public String rename(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public byte[] rpoplpush(final byte[] srckey, final byte[] dstkey) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Set<byte[]> sdiff(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Set<byte[]> sinter(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sinterstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long smove(final byte[] srckey, final byte[] dstkey,
	    final byte[] member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Set<byte[]> sunion(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sunionstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public byte[] brpoplpush(final byte[] source, final byte[] destination,
	    final int timeout) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.runBinary(2, source, destination);
    }

    @Override
    public Long publish(final byte[] channel, final byte[] message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final byte[] destKey,
	    final byte[]... srcKeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long pfcount(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.runBinary(keys.length, keys);
    }
||||||| BASE
=======

    @Override
    public void close() throws IOException {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}	
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_321e513_d710591/rev_321e513-d710591/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_321e513_d710591/rev_321e513-d710591/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/BinaryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/BinaryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3495402_3ebc25e/rev_3495402-3ebc25e/src/main/java/redis/clients/jedis/PipelineBlock.java;<<<<<<< MINE
package redis.clients.jedis;

@Deprecated
/**
 * This method is deprecated due to its error prone with multi
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class PipelineBlock extends Pipeline {
    // For shadowing
    @SuppressWarnings("unused")
    private Client client;

    public abstract void execute();
}||||||| BASE
package redis.clients.jedis;

@Deprecated
/**
 * This method is deprecated due to its error prone with multi
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class PipelineBlock extends Pipeline {
    public abstract void execute();
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3495402_3ebc25e/rev_3495402-3ebc25e/src/main/java/redis/clients/jedis/TransactionBlock.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.exceptions.JedisException;

@Deprecated
/**
 * This class is deprecated due to its error prone
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class TransactionBlock extends Transaction {
    // For shadowing
    @SuppressWarnings("unused")
    private Client client;

    public TransactionBlock(Client client) {
	super(client);
    }

    public TransactionBlock() {
    }

    public abstract void execute() throws JedisException;

    public void setClient(Client client) {
	super.setClient(client);
    }
}||||||| BASE
package redis.clients.jedis;

import redis.clients.jedis.exceptions.JedisException;

@Deprecated
/**
 * This class is deprecated due to its error prone
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class TransactionBlock extends Transaction {
    public TransactionBlock(Client client) {
	super(client);
    }

    public TransactionBlock() {
    }

    public abstract void execute() throws JedisException;

    public void setClient(Client client) {
	this.client = client;
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f7995a7_a8891cb/rev_f7995a7-a8891cb/src/test/java/redis/clients/jedis/tests/PipeliningTest.java;<<<<<<< MINE
	assertTrue(result.get(1) instanceof JedisDataException);
||||||| BASE
        assertEquals("val1", result.get(0));

        assertTrue(result.get(1) instanceof JedisDataException);

        Map<String, String> hashMapReceived = (Map<String, String>)result.get(2);
        Iterator<String> iterator = hashMapReceived.keySet().iterator();
        String mapKey1 = iterator.next();
        String mapKey2 = iterator.next();
        assertFalse(iterator.hasNext());
        verifyHasBothValues(mapKey1, mapKey2, field1, field2);
        String mapValue1 = hashMapReceived.get(mapKey1);
        String mapValue2 = hashMapReceived.get(mapKey2);
        verifyHasBothValues(mapValue1, mapValue2, value1, value2);

        assertTrue(result.get(3) instanceof JedisDataException);
    }
=======
        assertEquals("val1", result.get(0));

        assertTrue(result.get(1) instanceof JedisDataException);

        Map<String, String> hashMapReceived = (Map<String, String>)result.get(2);
        Iterator<String> iterator = hashMapReceived.keySet().iterator();
        String mapKey1 = iterator.next();
        String mapKey2 = iterator.next();
        assertFalse(iterator.hasNext());
        verifyHasBothValues(mapKey1, mapKey2, field1, field2);
        String mapValue1 = hashMapReceived.get(mapKey1);
        String mapValue2 = hashMapReceived.get(mapKey2);
        verifyHasBothValues(mapValue1, mapValue2, value1, value2);

        assertTrue(result.get(3) instanceof JedisDataException);
    }
    
    @Test
    public void testSyncWithNoCommandQueued() {
	// we need to test with fresh instance of Jedis
	Jedis jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	
	Pipeline pipeline = jedis2.pipelined();
	pipeline.sync();
	
	jedis2.close();
	
	jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	
	pipeline = jedis2.pipelined();
	List<Object> resp = pipeline.syncAndReturnAll();
	assertTrue(resp.isEmpty());
	
	jedis2.close();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_318adee_e012e06/rev_318adee-e012e06/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
        StopwatchTest.class,
        FilterOptionIntegrationTest.class,
        JUnitCommandLineParserTest.class,
        FilterFactoryFactoryTest.class,
        FilterFactoryParamsTest.class,
        CategoryFilterFactoryTest.class
||||||| BASE
        StopwatchTest.class
=======
        StopwatchTest.class,
        RunNotifierTest.class,
        ConcurrentRunNotifierTest.class,
        SynchronizedRunListenerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

||||||| BASE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

import java.io.Closeable;
=======
import java.io.Closeable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}
||||||| BASE
public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
    
    public static enum Reset {SOFT, HARD}
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 1;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

  public static enum Reset {
    SOFT, HARD
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }
||||||| BASE
    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
=======
  private int timeout;
  private int maxRedirections;

  private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> nodes, int timeout,
	    int maxRedirections) {
        this(nodes, timeout, maxRedirections,
                new GenericObjectPoolConfig());
    }
||||||| BASE
    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
	    int maxRedirections) {
        this(nodes, timeout, maxRedirections,
                new GenericObjectPoolConfig());
    }
=======
  public JedisCluster(Set<HostAndPort> nodes) {
    this(nodes, DEFAULT_TIMEOUT);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, int maxRedirections) {
    this(nodes, timeout, maxRedirections, new GenericObjectPoolConfig());
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	super(jedisClusterNode, timeout, maxRedirections, poolConfig);
    }
    
    @Override
    public String set(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.set(key, value);
	    }
	}.run(key);
    }

    @Override
    public String set(final String key, final String value, final String nxxx,
                      final String expx, final long time) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.set(key, value, nxxx, expx, time);
            }
        }.run(key);
    }

    @Override
    public String get(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.get(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean exists(final String key) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.exists(key);
	    }
	}.run(key);
    }

    @Override
    public Long persist(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.persist(key);
	    }
	}.run(key);
    }

    @Override
    public String type(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.type(key);
	    }
	}.run(key);
    }

    @Override
    public Long expire(final String key, final int seconds) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.expire(key, seconds);
	    }
	}.run(key);
    }

    @Override
    public Long expireAt(final String key, final long unixTime) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.expireAt(key, unixTime);
	    }
	}.run(key);
    }

    @Override
    public Long ttl(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.ttl(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final boolean value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final String value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean getbit(final String key, final long offset) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.getbit(key, offset);
	    }
	}.run(key);
    }

    @Override
    public Long setrange(final String key, final long offset, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setrange(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public String getrange(final String key, final long startOffset,
	    final long endOffset) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getrange(key,
			startOffset, endOffset);
	    }
	}.run(key);
    }

    @Override
    public String getSet(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getSet(key, value);
	    }
	}.run(key);
    }

    @Override
    public Long setnx(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setnx(key, value);
	    }
	}.run(key);
    }

    @Override
    public String setex(final String key, final int seconds, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.setex(key, seconds,
			value);
	    }
	}.run(key);
    }

    @Override
    public Long decrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long decr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decr(key);
	    }
	}.run(key);
    }

    @Override
    public Long incrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long incr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incr(key);
	    }
	}.run(key);
    }

    @Override
    public Long append(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.append(key, value);
	    }
	}.run(key);
    }

    @Override
    public String substr(final String key, final int start, final int end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.substr(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long hset(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.hset(key, field, value);
	    }
	}.run(key);
    }

    @Override
    public String hget(final String key, final String field) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hget(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hsetnx(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hsetnx(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public String hmset(final String key, final Map<String, String> hash) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hmset(key, hash);
	    }
	}.run(key);
    }

    @Override
    public List<String> hmget(final String key, final String... fields) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hmget(key, fields);
	    }
	}.run(key);
    }
||||||| BASE
    public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
    this.connectionHandler = new JedisSlotBasedConnectionHandler(
            jedisClusterNode, poolConfig);
    this.timeout = timeout;
    this.maxRedirections = maxRedirections;
    }
    
    @Override
    public void close() {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}
    }

    @Override
    public String set(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.set(key, value);
	    }
	}.run(key);
    }

    @Override
    public String set(final String key, final String value, final String nxxx,
                      final String expx, final long time) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.set(key, value, nxxx, expx, time);
            }
        }.run(key);
    }

    @Override
    public String get(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.get(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean exists(final String key) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.exists(key);
	    }
	}.run(key);
    }

    @Override
    public Long persist(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.persist(key);
	    }
	}.run(key);
    }

    @Override
    public String type(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.type(key);
	    }
	}.run(key);
    }

    @Override
    public Long expire(final String key, final int seconds) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.expire(key, seconds);
	    }
	}.run(key);
    }

    @Override
    public Long expireAt(final String key, final long unixTime) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.expireAt(key, unixTime);
	    }
	}.run(key);
    }

    @Override
    public Long ttl(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.ttl(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final boolean value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final String value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean getbit(final String key, final long offset) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.getbit(key, offset);
	    }
	}.run(key);
    }

    @Override
    public Long setrange(final String key, final long offset, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setrange(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public String getrange(final String key, final long startOffset,
	    final long endOffset) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getrange(key,
			startOffset, endOffset);
	    }
	}.run(key);
    }

    @Override
    public String getSet(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getSet(key, value);
	    }
	}.run(key);
    }

    @Override
    public Long setnx(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setnx(key, value);
	    }
	}.run(key);
    }

    @Override
    public String setex(final String key, final int seconds, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.setex(key, seconds,
			value);
	    }
	}.run(key);
    }

    @Override
    public Long decrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long decr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decr(key);
	    }
	}.run(key);
    }

    @Override
    public Long incrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long incr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incr(key);
	    }
	}.run(key);
    }

    @Override
    public Long append(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.append(key, value);
	    }
	}.run(key);
    }

    @Override
    public String substr(final String key, final int start, final int end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.substr(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long hset(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.hset(key, field, value);
	    }
	}.run(key);
    }

    @Override
    public String hget(final String key, final String field) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hget(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hsetnx(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hsetnx(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public String hmset(final String key, final Map<String, String> hash) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hmset(key, hash);
	    }
	}.run(key);
    }

    @Override
    public List<String> hmget(final String key, final String... fields) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hmget(key, fields);
	    }
	}.run(key);
    }
=======
  public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout, int maxRedirections,
      final GenericObjectPoolConfig poolConfig) {
    this.connectionHandler = new JedisSlotBasedConnectionHandler(jedisClusterNode, poolConfig);
    this.timeout = timeout;
    this.maxRedirections = maxRedirections;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Override
    public Set<Tuple> zrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrangeWithScores(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrevrangeWithScores(
			key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zcard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcard(key);
	    }
	}.run(key);
    }

    @Override
    public Double zscore(final String key, final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zscore(key, member);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key,
	    final SortingParams sortingParameters) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key,
			sortingParameters);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final double min, final double max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByRank(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByRank(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final double start,
	    final double end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final String start,
	    final String end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }
    
    @Override
    public Long zlexcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long linsert(final String key, final LIST_POSITION where,
	    final String pivot, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.linsert(key, where,
			pivot, value);
	    }
	}.run(key);
    }

    @Override
    public Long lpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long rpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(arg);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(arg);
	    }
	}.run(null);
    }

    @Override
    public Long del(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(key);
	    }
	}.run(key);
    }

    @Override
    public String echo(final String string) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.echo(string);
	    }
	}.run(null);
    }

    @Override
    public Long move(final String key, final int dbIndex) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.move(key, dbIndex);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key, final long start, final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key, start,
			end);
	    }
	}.run(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final String cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<String> sscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<Tuple> zscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }

    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object eval(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script);
        }
    }.run(key);
    }
    
    @Override
    public Object eval(final String script, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String sha1, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object evalsha(final String sha1, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(script);
        }
    }.run(key);
    }
    
    @Override
    public Boolean scriptExists(final String sha1, final String key) {
    return new JedisClusterCommand<Boolean>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Boolean execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public List<Boolean> scriptExists(final String key, final String... sha1) {
    return new JedisClusterCommand<List<Boolean>>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public List<Boolean> execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
        return new JedisClusterCommand<String>(connectionHandler,
                timeout, maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.scriptLoad(script);
            }
        }.run(key);
    }

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
||||||| BASE
    @Override
    public Set<Tuple> zrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrangeWithScores(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrevrangeWithScores(
			key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zcard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcard(key);
	    }
	}.run(key);
    }

    @Override
    public Double zscore(final String key, final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zscore(key, member);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key,
	    final SortingParams sortingParameters) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key,
			sortingParameters);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final double min, final double max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByRank(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByRank(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final double start,
	    final double end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final String start,
	    final String end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }
    
    @Override
    public Long zlexcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long linsert(final String key, final LIST_POSITION where,
	    final String pivot, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.linsert(key, where,
			pivot, value);
	    }
	}.run(key);
    }

    @Override
    public Long lpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long rpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(arg);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(arg);
	    }
	}.run(null);
    }

    @Override
    public Long del(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(key);
	    }
	}.run(key);
    }

    @Override
    public String echo(final String string) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.echo(string);
	    }
	}.run(null);
    }

    @Override
    public Long move(final String key, final int dbIndex) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.move(key, dbIndex);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key, final long start, final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key, start,
			end);
	    }
	}.run(key);
    }

    @Override
    public String ping() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ping();
	    }
	}.run(null);
    }

    @Override
    public String quit() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.quit();
	    }
	}.run(null);
    }

    @Override
    public String flushDB() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushDB();
	    }
	}.run(null);
    }

    @Override
    public Long dbSize() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.dbSize();
	    }
	}.run(null);
    }

    @Override
    public String select(final int index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.select(index);
	    }
	}.run(null);
    }

    @Override
    public String flushAll() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushAll();
	    }
	}.run(null);
    }

    @Override
    public String auth(final String password) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.auth(password);
	    }
	}.run(null);
    }

    @Override
    public String save() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.save();
	    }
	}.run(null);
    }

    @Override
    public String bgsave() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgsave();
	    }
	}.run(null);
    }

    @Override
    public String bgrewriteaof() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgrewriteaof();
	    }
	}.run(null);
    }

    @Override
    public Long lastsave() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lastsave();
	    }
	}.run(null);
    }

    @Override
    public String shutdown() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.shutdown();
	    }
	}.run(null);
    }

    @Override
    public String info() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info();
	    }
	}.run(null);
    }

    @Override
    public String info(final String section) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info(section);
	    }
	}.run(null);
    }

    @Override
    public String slaveof(final String host, final int port) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveof(host, port);
	    }
	}.run(null);
    }

    @Override
    public String slaveofNoOne() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveofNoOne();
	    }
	}.run(null);
    }

    @Override
    public Long getDB() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.getDB();
	    }
	}.run(null);
    }

    @Override
    public String debug(final DebugParams params) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.debug(params);
	    }
	}.run(null);
    }

    @Override
    public String configResetStat() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.configResetStat();
	    }
	}.run(null);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public Long waitReplicas(int replicas, long timeout) {
	// TODO Auto-generated method stub
	return null;
    }

    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final String cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<String> sscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<Tuple> zscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
		// if asking success, reset asking flag
		asking = false;
	    }

	    return execute(connection);
	} catch (JedisConnectionException jce) {
	    if (tryRandomNode) {
		// maybe all connection is down
		throw jce;
	    }

	    releaseConnection(connection, true);
	    connection = null;

	    // retry with random connection
	    return runWithRetries(key, redirections--, true, asking);
	} catch (JedisRedirectionException jre) {
	    if (jre instanceof JedisAskDataException) {
		asking = true;
	    } else if (jre instanceof JedisMovedDataException) {
		// TODO : In antirez's redis-rb-cluster implementation, 
		// it rebuilds cluster's slot and node cache
	    }

	    this.connectionHandler.assignSlotToNode(jre.getSlot(),
		    jre.getTargetNode());

	    releaseConnection(connection, false);
	    connection = null;

	    return runWithRetries(key, redirections - 1, false, asking);
	} finally {
	    releaseConnection(connection, false);
	}

    }
    
    private void releaseConnection(Jedis connection, boolean broken) {
	if (connection != null) {
	    if (broken) {
		connectionHandler.returnBrokenConnection(connection);
	    } else {
		connectionHandler.returnConnection(connection);
	    }
	}
||||||| BASE
    private void releaseConnection(Jedis connection, boolean broken) {
	if (connection != null) {
	    if (broken) {
		connectionHandler.returnBrokenConnection(connection);
	    } else {
		connectionHandler.returnConnection(connection);
	    }
	}
=======
  }

  private void releaseConnection(Jedis connection, boolean broken) {
    if (connection != null) {
      if (broken) {
        connectionHandler.returnBrokenConnection(connection);
      } else {
        connectionHandler.returnConnection(connection);
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    public static int getSlot(byte[] key) {
        int s = -1;
        int e = -1;
        boolean sFound = false;
        for (int i = 0; i < key.length; i++) {
            if (key[i] == '{' && !sFound) {
                s = i;
                sFound = true;
            }
            if (key[i] == '}' && sFound) {
                e = i;
                break;
            }
        }
        if (s > -1 && e > -1 && e != s + 1) {
            return getCRC16(key, s+1, e) & (16384 - 1);
        }
        return getCRC16(key) & (16384 - 1);
    }
||||||| BASE
=======
    // optimization with modulo operator with power of 2
    // equivalent to getCRC16(key) % 16384
    return getCRC16(key) & (16384 - 1);
  }

  /**
   * Create a CRC16 checksum from the bytes. implementation is from mp911de/lettuce, modified with
   * some more optimizations
   * @param bytes
   * @return CRC16 as integer value
   * @see https://github.com/xetorthio/jedis/pull/733#issuecomment-55840331
   */
  public static int getCRC16(byte[] bytes) {
    int crc = 0x0000;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    /**
     * Create a CRC16 checksum from the bytes.
     * implementation is from mp911de/lettuce, modified with some more optimizations
     * 
     * @param bytes
     * @return CRC16 as integer value
     * @see https://github.com/xetorthio/jedis/pull/733#issuecomment-55840331
     */
    public static int getCRC16(byte[] bytes, int s, int e) {
	int crc = 0x0000;

	for (int i = s; i < e; i++) {
	    crc = ((crc << 8) ^ LOOKUP_TABLE[((crc >>> 8) ^ (bytes[i] & 0xFF)) & 0xFF]);
	}
	return crc & 0xFFFF;
||||||| BASE
    /**
     * Create a CRC16 checksum from the bytes.
     * implementation is from mp911de/lettuce, modified with some more optimizations
     * 
     * @param bytes
     * @return CRC16 as integer value
     * @see https://github.com/xetorthio/jedis/pull/733#issuecomment-55840331
     */
    public static int getCRC16(byte[] bytes) {
	int crc = 0x0000;

	for (byte b : bytes) {
	    crc = ((crc << 8) ^ LOOKUP_TABLE[((crc >>> 8) ^ (b & 0xFF)) & 0xFF]);
	}
	return crc & 0xFFFF;
=======
    for (byte b : bytes) {
      crc = ((crc << 8) ^ LOOKUP_TABLE[((crc >>> 8) ^ (b & 0xFF)) & 0xFF]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    public static int getCRC16(byte[] bytes) {
	return getCRC16(bytes, 0, bytes.length);
    }
||||||| BASE
=======
    return crc & 0xFFFF;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    public static int getCRC16(String key) {
	byte[] bytesKey = SafeEncoder.encode(key);
	return getCRC16(bytesKey, 0, bytesKey.length);
    }
||||||| BASE
    public static int getCRC16(String key) {
	return getCRC16(key.getBytes());
    }

=======
  public static int getCRC16(String key) {
    return getCRC16(SafeEncoder.encode(key));
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/utils/JedisClusterCRC16Test.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/utils/JedisClusterCRC16Test.java;<<<<<<< MINE
    @Test
    public void testGetCRC16() throws Exception {
	Map<String, Integer> solutions = prepareSolutionSet();
	
	for (Entry<String, Integer> entry : solutions.entrySet()) {
	    // string version
	    String key = entry.getKey();
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(key));
	    
	    // byte array version
	    byte[] bytesKey = SafeEncoder.encode(key);
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(bytesKey));
	}
    }
    
    @Test
    public void testGetSlot() {
	assertEquals(7186, JedisClusterCRC16.getSlot("51"));
||||||| BASE
    @Test
    public void testGetCRC16() throws Exception {
	Map<String, Integer> solutions = prepareSolutionSet();
	
	for (Entry<String, Integer> entry : solutions.entrySet()) {
	    // string version
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(entry.getKey()));
	    
	    // byte array version
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(entry.getKey().getBytes()));
	}
    }
    
    @Test
    public void testGetSlot() {
	assertEquals(7186, JedisClusterCRC16.getSlot("51"));
=======
  @Test
  public void testGetCRC16() throws Exception {
    Map<String, Integer> solutions = prepareSolutionSet();

    for (Entry<String, Integer> entry : solutions.entrySet()) {
      // string version
      assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(entry.getKey()));

      // byte array version
      assertEquals(entry.getValue().intValue(),
        JedisClusterCRC16.getCRC16(SafeEncoder.encode(entry.getKey())));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
    private static Jedis node1;
    private static Jedis node2;
    private static Jedis node3;
    private static Jedis node4;

    private HostAndPort nodeInfo1 = HostAndPortUtil.getClusterServers().get(0);
    private HostAndPort nodeInfo2 = HostAndPortUtil.getClusterServers().get(1);
    private HostAndPort nodeInfo3 = HostAndPortUtil.getClusterServers().get(2);
    private HostAndPort nodeInfo4 = HostAndPortUtil.getClusterServers().get(3);
    
    @Before
    public void setUp() throws InterruptedException {
	node1 = new Jedis(nodeInfo1.getHost(), nodeInfo1.getPort());
	node1.connect();
	node1.flushAll();

	node2 = new Jedis(nodeInfo2.getHost(), nodeInfo2.getPort());
	node2.connect();
	node2.flushAll();

	node3 = new Jedis(nodeInfo3.getHost(), nodeInfo3.getPort());
	node3.connect();
	node3.flushAll();
	
	node4 = new Jedis(nodeInfo4.getHost(), nodeInfo4.getPort());
	node4.connect();
	node4.flushAll();

	// ---- configure cluster

	// add nodes to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo2.getPort());
	node1.clusterMeet("127.0.0.1", nodeInfo3.getPort());

	// split available slots across the three nodes
	int slotsPerNode = JedisCluster.HASHSLOTS / 3;
	int[] node1Slots = new int[slotsPerNode];
	int[] node2Slots = new int[slotsPerNode+1];
	int[] node3Slots = new int[slotsPerNode];
	for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0 ; i < JedisCluster.HASHSLOTS; i++) {
	    if (i < slotsPerNode) {
		node1Slots[slot1++] = i;
	    } else if (i > slotsPerNode * 2) {
		node3Slots[slot3++] = i;
	    } else {
		node2Slots[slot2++] = i;
	    }
	}
	
	node1.clusterAddSlots(node1Slots);
	node2.clusterAddSlots(node2Slots);
	node3.clusterAddSlots(node3Slots);
	
	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
    }
    
    @AfterClass
    public static void cleanUp() {
	node1.flushDB();
	node2.flushDB();
	node3.flushDB();
	node4.flushDB();
	node1.clusterReset(Reset.SOFT);
	node2.clusterReset(Reset.SOFT);
	node3.clusterReset(Reset.SOFT);
	node4.clusterReset(Reset.SOFT);
    }

    @After
    public void tearDown() throws InterruptedException {
	cleanUp();
    }

    @Test(expected = JedisMovedDataException.class)
    public void testThrowMovedException() {
	node1.set("foo", "bar");
    }

    @Test
    public void testMovedExceptionParameters() {
	try {
	    node1.set("foo", "bar");
	} catch (JedisMovedDataException jme) {
	    assertEquals(12182, jme.getSlot());
	    assertEquals(new HostAndPort("127.0.0.1", 7381),
		    jme.getTargetNode());
	    return;
	}
	fail();
    }

    @Test(expected = JedisAskDataException.class)
    public void testThrowAskException() {
	int keySlot = JedisClusterCRC16.getSlot("test");
	String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
	node2.clusterSetSlotMigrating(keySlot, node3Id);
	node2.get("test");
    }

    @Test
    public void testDiscoverNodesAutomatically() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	assertEquals(3, jc.getClusterNodes().size());
    }

    @Test
    public void testCalculateConnectionPerSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	jc.set("test", "test");
	assertEquals("bar", node3.get("foo"));
	assertEquals("test", node2.get("test"));
    }

    @Test
    public void testRecalculateSlotsWhenMoved() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node2.clusterDelSlots(slot51);
	node3.clusterDelSlots(slot51);
	node3.clusterAddSlots(slot51);

	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test
    public void testAskResponse() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisClusterMaxRedirectionsException.class)
    public void testRedisClusterMaxRedirections() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	// This will cause an infinite redirection loop
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
    }
    
    @Test
    public void testRedisHashtag() {
	assertEquals(JedisClusterCRC16.getSlot("{bar"), JedisClusterCRC16.getSlot("foo{{bar}}zap"));
	assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"), JedisClusterCRC16.getSlot("{user1000}.followers"));
	assertNotEquals(JedisClusterCRC16.getSlot("foo{}{bar}"), JedisClusterCRC16.getSlot("bar"));
	assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"), JedisClusterCRC16.getSlot("bar"));
    }

    @Test
    public void testClusterForgetNode() throws InterruptedException {
	// at first, join node4 to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo4.getPort());
	
	String node7Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());
	
	JedisClusterTestUtil.assertNodeIsKnown(node3, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node2, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node1, node7Id, 1000);
	
	assertNodeHandshakeEnded(node3, 1000);
	assertNodeHandshakeEnded(node2, 1000);
	assertNodeHandshakeEnded(node1, 1000);
	
	assertEquals(4, node1.clusterNodes().split("\n").length);
	assertEquals(4, node2.clusterNodes().split("\n").length);
	assertEquals(4, node3.clusterNodes().split("\n").length);
	
	// do cluster forget
        node1.clusterForget(node7Id);
        node2.clusterForget(node7Id);
        node3.clusterForget(node7Id);
        
        JedisClusterTestUtil.assertNodeIsUnknown(node1, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node2, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node3, node7Id, 1000);
        
        assertEquals(3, node1.clusterNodes().split("\n").length);
        assertEquals(3, node2.clusterNodes().split("\n").length);
        assertEquals(3, node3.clusterNodes().split("\n").length);
    }
    
    @Test
    public void testClusterFlushSlots() {
	String slotRange = getNodeServingSlotRange(node1.clusterNodes()); 
	assertNotNull(slotRange);
	
	try {
	    node1.clusterFlushSlots();
	    assertNull(getNodeServingSlotRange(node1.clusterNodes()));
	} finally {
	    // rollback
	    String[] rangeInfo = slotRange.split("-");
	    int lower = Integer.parseInt(rangeInfo[0]);
	    int upper = Integer.parseInt(rangeInfo[1]);
	    
	    int[] node1Slots = new int[upper - lower + 1];
	    for (int i = 0 ; lower <= upper ; ) {
		node1Slots[i++] = lower++;
	    }
	    node1.clusterAddSlots(node1Slots);
	}
    }
    
    @Test
    public void testClusterKeySlot() {
	// It assumes JedisClusterCRC16 is correctly implemented
	assertEquals(node1.clusterKeySlot("foo{bar}zap}").intValue(), JedisClusterCRC16.getSlot("foo{bar}zap"));
	assertEquals(node1.clusterKeySlot("{user1000}.following").intValue(), JedisClusterCRC16.getSlot("{user1000}.following"));
    }
    
    @Test
    public void testClusterCountKeysInSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	for (int index = 0 ; index < 5 ; index++) {
	    jc.set("foo{bar}" + index, "hello");
	}
	
	int slot = JedisClusterCRC16.getSlot("foo{bar}");
	assertEquals(5, node1.clusterCountKeysInSlot(slot).intValue());
    }
    
    @Test
    public void testStableSlotWhenMigratingNodeOrImportingNodeIsNotSpecified() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	int slot51 = JedisClusterCRC16.getSlot("51");
	jc.set("51", "foo");
	// node2 is responsible of taking care of slot51 (7186)
	
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	assertEquals("foo", jc.get("51"));
	node3.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
	
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	//assertEquals("foo", jc.get("51")); // it leads Max Redirections
	node2.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

    @Test
    public void testCloseable() throws IOException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	
	JedisCluster jc = null;
	try {
	    jc = new JedisCluster(jedisClusterNode);
	    jc.set("51", "foo");
	} finally {
	    if (jc != null) {
		jc.close();
	    }
	}

	Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
	while (poolIterator.hasNext()) {
	    JedisPool pool = poolIterator.next();
	    try {
		pool.getResource();
		fail("JedisCluster's internal pools should be already destroyed");
	    } catch (JedisConnectionException e) {
		// ok to go...
	    }
	}
    }
    
    @Test
    public void testJedisClusterRunsWithMultithreaded() throws InterruptedException, ExecutionException, IOException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	final JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	
	ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 100, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10));
	List<Future<String>> futures = new ArrayList<Future<String>>();
	for (int i = 0 ; i < 50 ; i++) {
	    executor.submit(new Callable<String>() {
		@Override
		public String call() throws Exception {
		    // FIXME : invalidate slot cache from JedisCluster to test random connection also does work
		    return jc.get("foo");
		}
	    });
	}

	for (Future<String> future : futures) {
	    String value = future.get();
	    assertEquals("bar", value);
	}
	
	jc.close();
    }
    
    private static String getNodeServingSlotRange(String infoOutput) {
	// f4f3dc4befda352a4e0beccf29f5e8828438705d 127.0.0.1:7380 master - 0 1394372400827 0 connected 5461-10922
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("myself")) {
		try {
		    return infoLine.split(" ")[8];
		} catch (ArrayIndexOutOfBoundsException e) {
		    return null;
		}
	    }
	}
	return null;
    }
    
    private void assertNodeHandshakeEnded(Jedis node, int timeoutMs) {
	int sleepInterval = 100;
	for (int sleepTime = 0 ; sleepTime <= timeoutMs ; sleepTime += sleepInterval) {
	    boolean isHandshaking = isAnyNodeHandshaking(node);
	    if (!isHandshaking)
		return;
	    
	    try {
		Thread.sleep(sleepInterval);
	    } catch (InterruptedException e) {
	    }
	}
	
	throw new JedisException("Node handshaking is not ended");
    }
    
    private boolean isAnyNodeHandshaking(Jedis node) {
	String infoOutput = node.clusterNodes();
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("handshake")) {
		return true;
	    }
	}
	return false;
||||||| BASE
    private static Jedis node1;
    private static Jedis node2;
    private static Jedis node3;
    private static Jedis node4;

    private HostAndPort nodeInfo1 = HostAndPortUtil.getClusterServers().get(0);
    private HostAndPort nodeInfo2 = HostAndPortUtil.getClusterServers().get(1);
    private HostAndPort nodeInfo3 = HostAndPortUtil.getClusterServers().get(2);
    private HostAndPort nodeInfo4 = HostAndPortUtil.getClusterServers().get(3);
    
    @Before
    public void setUp() throws InterruptedException {
	node1 = new Jedis(nodeInfo1.getHost(), nodeInfo1.getPort());
	node1.connect();
	node1.flushAll();

	node2 = new Jedis(nodeInfo2.getHost(), nodeInfo2.getPort());
	node2.connect();
	node2.flushAll();

	node3 = new Jedis(nodeInfo3.getHost(), nodeInfo3.getPort());
	node3.connect();
	node3.flushAll();
	
	node4 = new Jedis(nodeInfo4.getHost(), nodeInfo4.getPort());
	node4.connect();
	node4.flushAll();

	// ---- configure cluster

	// add nodes to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo2.getPort());
	node1.clusterMeet("127.0.0.1", nodeInfo3.getPort());

	// split available slots across the three nodes
	int slotsPerNode = JedisCluster.HASHSLOTS / 3;
	int[] node1Slots = new int[slotsPerNode];
	int[] node2Slots = new int[slotsPerNode+1];
	int[] node3Slots = new int[slotsPerNode];
	for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0 ; i < JedisCluster.HASHSLOTS; i++) {
	    if (i < slotsPerNode) {
		node1Slots[slot1++] = i;
	    } else if (i > slotsPerNode * 2) {
		node3Slots[slot3++] = i;
	    } else {
		node2Slots[slot2++] = i;
	    }
	}
	
	node1.clusterAddSlots(node1Slots);
	node2.clusterAddSlots(node2Slots);
	node3.clusterAddSlots(node3Slots);
	
	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
    }
    
    @AfterClass
    public static void cleanUp() {
	node1.flushDB();
	node2.flushDB();
	node3.flushDB();
	node4.flushDB();
	node1.clusterReset(Reset.SOFT);
	node2.clusterReset(Reset.SOFT);
	node3.clusterReset(Reset.SOFT);
	node4.clusterReset(Reset.SOFT);
    }

    @After
    public void tearDown() throws InterruptedException {
	cleanUp();
    }

    @Test(expected = JedisMovedDataException.class)
    public void testThrowMovedException() {
	node1.set("foo", "bar");
    }

    @Test
    public void testMovedExceptionParameters() {
	try {
	    node1.set("foo", "bar");
	} catch (JedisMovedDataException jme) {
	    assertEquals(12182, jme.getSlot());
	    assertEquals(new HostAndPort("127.0.0.1", 7381),
		    jme.getTargetNode());
	    return;
	}
	fail();
    }

    @Test(expected = JedisAskDataException.class)
    public void testThrowAskException() {
	int keySlot = JedisClusterCRC16.getSlot("test");
	String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
	node2.clusterSetSlotMigrating(keySlot, node3Id);
	node2.get("test");
    }

    @Test
    public void testDiscoverNodesAutomatically() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	assertEquals(3, jc.getClusterNodes().size());
    }

    @Test
    public void testCalculateConnectionPerSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	jc.set("test", "test");
	assertEquals("bar", node3.get("foo"));
	assertEquals("test", node2.get("test"));
    }

    @Test
    public void testRecalculateSlotsWhenMoved() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node2.clusterDelSlots(slot51);
	node3.clusterDelSlots(slot51);
	node3.clusterAddSlots(slot51);

	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test
    public void testAskResponse() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisClusterException.class)
    public void testThrowExceptionWithoutKey() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.ping();
    }

    @Test(expected = JedisClusterMaxRedirectionsException.class)
    public void testRedisClusterMaxRedirections() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	// This will cause an infinite redirection loop
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
    }
    
    @Test
    public void testRedisHashtag() {
	assertEquals(JedisClusterCRC16.getSlot("{bar"), JedisClusterCRC16.getSlot("foo{{bar}}zap"));
	assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"), JedisClusterCRC16.getSlot("{user1000}.followers"));
	assertNotEquals(JedisClusterCRC16.getSlot("foo{}{bar}"), JedisClusterCRC16.getSlot("bar"));
	assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"), JedisClusterCRC16.getSlot("bar"));
    }

    @Test
    public void testClusterForgetNode() throws InterruptedException {
	// at first, join node4 to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo4.getPort());
	
	String node7Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());
	
	JedisClusterTestUtil.assertNodeIsKnown(node3, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node2, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node1, node7Id, 1000);
	
	assertNodeHandshakeEnded(node3, 1000);
	assertNodeHandshakeEnded(node2, 1000);
	assertNodeHandshakeEnded(node1, 1000);
	
	assertEquals(4, node1.clusterNodes().split("\n").length);
	assertEquals(4, node2.clusterNodes().split("\n").length);
	assertEquals(4, node3.clusterNodes().split("\n").length);
	
	// do cluster forget
        node1.clusterForget(node7Id);
        node2.clusterForget(node7Id);
        node3.clusterForget(node7Id);
        
        JedisClusterTestUtil.assertNodeIsUnknown(node1, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node2, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node3, node7Id, 1000);
        
        assertEquals(3, node1.clusterNodes().split("\n").length);
        assertEquals(3, node2.clusterNodes().split("\n").length);
        assertEquals(3, node3.clusterNodes().split("\n").length);
    }
    
    @Test
    public void testClusterFlushSlots() {
	String slotRange = getNodeServingSlotRange(node1.clusterNodes()); 
	assertNotNull(slotRange);
	
	try {
	    node1.clusterFlushSlots();
	    assertNull(getNodeServingSlotRange(node1.clusterNodes()));
	} finally {
	    // rollback
	    String[] rangeInfo = slotRange.split("-");
	    int lower = Integer.parseInt(rangeInfo[0]);
	    int upper = Integer.parseInt(rangeInfo[1]);
	    
	    int[] node1Slots = new int[upper - lower + 1];
	    for (int i = 0 ; lower <= upper ; ) {
		node1Slots[i++] = lower++;
	    }
	    node1.clusterAddSlots(node1Slots);
	}
    }
    
    @Test
    public void testClusterKeySlot() {
	// It assumes JedisClusterCRC16 is correctly implemented
	assertEquals(node1.clusterKeySlot("foo{bar}zap}").intValue(), JedisClusterCRC16.getSlot("foo{bar}zap"));
	assertEquals(node1.clusterKeySlot("{user1000}.following").intValue(), JedisClusterCRC16.getSlot("{user1000}.following"));
    }
    
    @Test
    public void testClusterCountKeysInSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	for (int index = 0 ; index < 5 ; index++) {
	    jc.set("foo{bar}" + index, "hello");
	}
	
	int slot = JedisClusterCRC16.getSlot("foo{bar}");
	assertEquals(5, node1.clusterCountKeysInSlot(slot).intValue());
    }
    
    @Test
    public void testStableSlotWhenMigratingNodeOrImportingNodeIsNotSpecified() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	int slot51 = JedisClusterCRC16.getSlot("51");
	jc.set("51", "foo");
	// node2 is responsible of taking care of slot51 (7186)
	
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	assertEquals("foo", jc.get("51"));
	node3.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
	
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	//assertEquals("foo", jc.get("51")); // it leads Max Redirections
	node2.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

    @Test
    public void testCloseable() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	
	JedisCluster jc = null;
	try {
	    jc = new JedisCluster(jedisClusterNode);
	    jc.set("51", "foo");
	} finally {
	    if (jc != null) {
		jc.close();
	    }
	}

	Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
	while (poolIterator.hasNext()) {
	    JedisPool pool = poolIterator.next();
	    try {
		pool.getResource();
		fail("JedisCluster's internal pools should be already destroyed");
	    } catch (JedisConnectionException e) {
		// ok to go...
	    }
	}
    }
    
    @Test
    public void testJedisClusterRunsWithMultithreaded() throws InterruptedException, ExecutionException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	final JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	
	ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 100, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10));
	List<Future<String>> futures = new ArrayList<Future<String>>();
	for (int i = 0 ; i < 50 ; i++) {
	    executor.submit(new Callable<String>() {
		@Override
		public String call() throws Exception {
		    // FIXME : invalidate slot cache from JedisCluster to test random connection also does work
		    return jc.get("foo");
		}
	    });
	}

	for (Future<String> future : futures) {
	    String value = future.get();
	    assertEquals("bar", value);
	}
	
	jc.close();
    }
    
    private static String getNodeServingSlotRange(String infoOutput) {
	// f4f3dc4befda352a4e0beccf29f5e8828438705d 127.0.0.1:7380 master - 0 1394372400827 0 connected 5461-10922
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("myself")) {
		try {
		    return infoLine.split(" ")[8];
		} catch (ArrayIndexOutOfBoundsException e) {
		    return null;
		}
	    }
	}
	return null;
    }
    
    private void assertNodeHandshakeEnded(Jedis node, int timeoutMs) {
	int sleepInterval = 100;
	for (int sleepTime = 0 ; sleepTime <= timeoutMs ; sleepTime += sleepInterval) {
	    boolean isHandshaking = isAnyNodeHandshaking(node);
	    if (!isHandshaking)
		return;
	    
	    try {
		Thread.sleep(sleepInterval);
	    } catch (InterruptedException e) {
	    }
	}
	
	throw new JedisException("Node handshaking is not ended");
    }
    
    private boolean isAnyNodeHandshaking(Jedis node) {
	String infoOutput = node.clusterNodes();
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("handshake")) {
		return true;
	    }
	}
	return false;
=======
  private static Jedis node1;
  private static Jedis node2;
  private static Jedis node3;
  private static Jedis node4;
  private String localHost = "127.0.0.1";

  private HostAndPort nodeInfo1 = HostAndPortUtil.getClusterServers().get(0);
  private HostAndPort nodeInfo2 = HostAndPortUtil.getClusterServers().get(1);
  private HostAndPort nodeInfo3 = HostAndPortUtil.getClusterServers().get(2);
  private HostAndPort nodeInfo4 = HostAndPortUtil.getClusterServers().get(3);
  protected Logger log = Logger.getLogger(getClass().getName());

  @Before
  public void setUp() throws InterruptedException {
    node1 = new Jedis(nodeInfo1.getHost(), nodeInfo1.getPort());
    node1.connect();
    node1.flushAll();

    node2 = new Jedis(nodeInfo2.getHost(), nodeInfo2.getPort());
    node2.connect();
    node2.flushAll();

    node3 = new Jedis(nodeInfo3.getHost(), nodeInfo3.getPort());
    node3.connect();
    node3.flushAll();

    node4 = new Jedis(nodeInfo4.getHost(), nodeInfo4.getPort());
    node4.connect();
    node4.flushAll();

    // ---- configure cluster

    // add nodes to cluster
    node1.clusterMeet(localHost, nodeInfo2.getPort());
    node1.clusterMeet(localHost, nodeInfo3.getPort());

    // split available slots across the three nodes
    int slotsPerNode = JedisCluster.HASHSLOTS / 3;
    int[] node1Slots = new int[slotsPerNode];
    int[] node2Slots = new int[slotsPerNode + 1];
    int[] node3Slots = new int[slotsPerNode];
    for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0; i < JedisCluster.HASHSLOTS; i++) {
      if (i < slotsPerNode) {
        node1Slots[slot1++] = i;
      } else if (i > slotsPerNode * 2) {
        node3Slots[slot3++] = i;
      } else {
        node2Slots[slot2++] = i;
      }
    }

    node1.clusterAddSlots(node1Slots);
    node2.clusterAddSlots(node2Slots);
    node3.clusterAddSlots(node3Slots);

    JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
  }

  @AfterClass
  public static void cleanUp() {
    node1.flushDB();
    node2.flushDB();
    node3.flushDB();
    node4.flushDB();
    node1.clusterReset(Reset.SOFT);
    node2.clusterReset(Reset.SOFT);
    node3.clusterReset(Reset.SOFT);
    node4.clusterReset(Reset.SOFT);
  }

  @After
  public void tearDown() throws InterruptedException {
    cleanUp();
  }

  @Test(expected = JedisMovedDataException.class)
  public void testThrowMovedException() {
    node1.set("foo", "bar");
  }

  @Test
  public void testMovedExceptionParameters() {
    try {
      node1.set("foo", "bar");
    } catch (JedisMovedDataException jme) {
      assertEquals(12182, jme.getSlot());
      assertEquals(new HostAndPort("127.0.0.1", 7381), jme.getTargetNode());
      return;
    }
    fail();
  }

  @Test(expected = JedisAskDataException.class)
  public void testThrowAskException() {
    int keySlot = JedisClusterCRC16.getSlot("test");
    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    node2.clusterSetSlotMigrating(keySlot, node3Id);
    node2.get("test");
  }

  @Test
  public void testDiscoverNodesAutomatically() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    assertEquals(3, jc.getClusterNodes().size());
  }

  @Test
  public void testCalculateConnectionPerSlot() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.set("foo", "bar");
    jc.set("test", "test");
    assertEquals("bar", node3.get("foo"));
    assertEquals("test", node2.get("test"));
  }

  /**
   * slot->nodes 15363 node3 e
   */
  @Test
  public void testMigrate() {
    log.info("test migrate slot");
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(nodeInfo1);
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    String node2Id = JedisClusterTestUtil.getNodeId(node2.clusterNodes());
    node3.clusterSetSlotMigrating(15363, node2Id);
    node2.clusterSetSlotImporting(15363, node3Id);
    try {
      node2.set("e", "e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }

    try {
      node3.set("e", "e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo2.getPort()), jae.getTargetNode());
    }

    jc.set("e", "e");

    try {
      node2.get("e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }
    try {
      node3.get("e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo2.getPort()), jae.getTargetNode());
    }

    assertEquals("e", jc.get("e"));

    node2.clusterSetSlotNode(15363, node2Id);
    node3.clusterSetSlotNode(15363, node2Id);
    // assertEquals("e", jc.get("e"));
    assertEquals("e", node2.get("e"));

    // assertEquals("e", node3.get("e"));

  }

  @Test
  public void testMigrateToNewNode() throws InterruptedException {
    log.info("test migrate slot to new node");
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(nodeInfo1);
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    node4.clusterMeet(localHost, nodeInfo1.getPort());

    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    String node4Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());
    JedisClusterTestUtil.waitForClusterReady(node4);
    node3.clusterSetSlotMigrating(15363, node4Id);
    node4.clusterSetSlotImporting(15363, node3Id);
    try {
      node4.set("e", "e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }

    try {
      node3.set("e", "e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo4.getPort()), jae.getTargetNode());
    }

    jc.set("e", "e");

    try {
      node4.get("e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }
    try {
      node3.get("e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo4.getPort()), jae.getTargetNode());
    }

    assertEquals("e", jc.get("e"));

    node4.clusterSetSlotNode(15363, node4Id);
    node3.clusterSetSlotNode(15363, node4Id);
    // assertEquals("e", jc.get("e"));
    assertEquals("e", node4.get("e"));

    // assertEquals("e", node3.get("e"));

  }

  @Test
  public void testRecalculateSlotsWhenMoved() throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    node2.clusterDelSlots(slot51);
    node3.clusterDelSlots(slot51);
    node3.clusterAddSlots(slot51);

    JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
    jc.set("51", "foo");
    assertEquals("foo", jc.get("51"));
  }

  @Test
  public void testAskResponse() throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    jc.set("51", "foo");
    assertEquals("foo", jc.get("51"));
  }

  @Test(expected = JedisClusterException.class)
  public void testThrowExceptionWithoutKey() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.ping();
  }

  @Test(expected = JedisClusterMaxRedirectionsException.class)
  public void testRedisClusterMaxRedirections() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    // This will cause an infinite redirection loop
    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    jc.set("51", "foo");
  }

  @Test
  public void testRedisHashtag() {
    assertEquals(JedisClusterCRC16.getSlot("{bar"), JedisClusterCRC16.getSlot("foo{{bar}}zap"));
    assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"),
      JedisClusterCRC16.getSlot("{user1000}.followers"));
    assertNotEquals(JedisClusterCRC16.getSlot("foo{}{bar}"), JedisClusterCRC16.getSlot("bar"));
    assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"), JedisClusterCRC16.getSlot("bar"));
  }

  @Test
  public void testClusterForgetNode() throws InterruptedException {
    // at first, join node4 to cluster
    node1.clusterMeet("127.0.0.1", nodeInfo4.getPort());

    String node7Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());

    JedisClusterTestUtil.assertNodeIsKnown(node3, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsKnown(node2, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsKnown(node1, node7Id, 1000);

    assertNodeHandshakeEnded(node3, 1000);
    assertNodeHandshakeEnded(node2, 1000);
    assertNodeHandshakeEnded(node1, 1000);

    assertEquals(4, node1.clusterNodes().split("\n").length);
    assertEquals(4, node2.clusterNodes().split("\n").length);
    assertEquals(4, node3.clusterNodes().split("\n").length);

    // do cluster forget
    node1.clusterForget(node7Id);
    node2.clusterForget(node7Id);
    node3.clusterForget(node7Id);

    JedisClusterTestUtil.assertNodeIsUnknown(node1, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsUnknown(node2, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsUnknown(node3, node7Id, 1000);

    assertEquals(3, node1.clusterNodes().split("\n").length);
    assertEquals(3, node2.clusterNodes().split("\n").length);
    assertEquals(3, node3.clusterNodes().split("\n").length);
  }

  @Test
  public void testClusterFlushSlots() {
    String slotRange = getNodeServingSlotRange(node1.clusterNodes());
    assertNotNull(slotRange);

    try {
      node1.clusterFlushSlots();
      assertNull(getNodeServingSlotRange(node1.clusterNodes()));
    } finally {
      // rollback
      String[] rangeInfo = slotRange.split("-");
      int lower = Integer.parseInt(rangeInfo[0]);
      int upper = Integer.parseInt(rangeInfo[1]);

      int[] node1Slots = new int[upper - lower + 1];
      for (int i = 0; lower <= upper;) {
        node1Slots[i++] = lower++;
      }
      node1.clusterAddSlots(node1Slots);
    }
  }

  @Test
  public void testClusterKeySlot() {
    // It assumes JedisClusterCRC16 is correctly implemented
    assertEquals(node1.clusterKeySlot("foo{bar}zap}").intValue(),
      JedisClusterCRC16.getSlot("foo{bar}zap"));
    assertEquals(node1.clusterKeySlot("{user1000}.following").intValue(),
      JedisClusterCRC16.getSlot("{user1000}.following"));
  }

  @Test
  public void testClusterCountKeysInSlot() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
    JedisCluster jc = new JedisCluster(jedisClusterNode);

    for (int index = 0; index < 5; index++) {
      jc.set("foo{bar}" + index, "hello");
    }

    int slot = JedisClusterCRC16.getSlot("foo{bar}");
    assertEquals(5, node1.clusterCountKeysInSlot(slot).intValue());
  }

  @Test
  public void testStableSlotWhenMigratingNodeOrImportingNodeIsNotSpecified()
      throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
    JedisCluster jc = new JedisCluster(jedisClusterNode);

    int slot51 = JedisClusterCRC16.getSlot("51");
    jc.set("51", "foo");
    // node2 is responsible of taking care of slot51 (7186)

    node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
    assertEquals("foo", jc.get("51"));
    node3.clusterSetSlotStable(slot51);
    assertEquals("foo", jc.get("51"));

    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    // assertEquals("foo", jc.get("51")); // it leads Max Redirections
    node2.clusterSetSlotStable(slot51);
    assertEquals("foo", jc.get("51"));
  }

  @Test(expected = JedisConnectionException.class)
  public void testIfPoolConfigAppliesToClusterPools() {
    GenericObjectPoolConfig config = new GenericObjectPoolConfig();
    config.setMaxTotal(0);
    config.setMaxWaitMillis(2000);
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode, config);
    jc.set("52", "poolTestValue");
  }

  @Test
  public void testCloseable() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));

    JedisCluster jc = null;
    try {
      jc = new JedisCluster(jedisClusterNode);
      jc.set("51", "foo");
    } finally {
      if (jc != null) {
        jc.close();
      }
    }

    Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
    while (poolIterator.hasNext()) {
      JedisPool pool = poolIterator.next();
      try {
        pool.getResource();
        fail("JedisCluster's internal pools should be already destroyed");
      } catch (JedisConnectionException e) {
        // ok to go...
      }
    }
  }

  @Test
  public void testJedisClusterRunsWithMultithreaded() throws InterruptedException,
      ExecutionException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    final JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.set("foo", "bar");

    ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 100, 0, TimeUnit.SECONDS,
        new ArrayBlockingQueue<Runnable>(10));
    List<Future<String>> futures = new ArrayList<Future<String>>();
    for (int i = 0; i < 50; i++) {
      executor.submit(new Callable<String>() {
        @Override
        public String call() throws Exception {
          // FIXME : invalidate slot cache from JedisCluster to test
          // random connection also does work
          return jc.get("foo");
        }
      });
    }

    for (Future<String> future : futures) {
      String value = future.get();
      assertEquals("bar", value);
    }

    jc.close();
  }

  private static String getNodeServingSlotRange(String infoOutput) {
    // f4f3dc4befda352a4e0beccf29f5e8828438705d 127.0.0.1:7380 master - 0
    // 1394372400827 0 connected 5461-10922
    for (String infoLine : infoOutput.split("\n")) {
      if (infoLine.contains("myself")) {
        try {
          return infoLine.split(" ")[8];
        } catch (ArrayIndexOutOfBoundsException e) {
          return null;
        }
      }
    }
    return null;
  }

  private void assertNodeHandshakeEnded(Jedis node, int timeoutMs) {
    int sleepInterval = 100;
    for (int sleepTime = 0; sleepTime <= timeoutMs; sleepTime += sleepInterval) {
      boolean isHandshaking = isAnyNodeHandshaking(node);
      if (!isHandshaking) return;

      try {
        Thread.sleep(sleepInterval);
      } catch (InterruptedException e) {
      }
    }

    throw new JedisException("Node handshaking is not ended");
  }

  private boolean isAnyNodeHandshaking(Jedis node) {
    String infoOutput = node.clusterNodes();
    for (String infoLine : infoOutput.split("\n")) {
      if (infoLine.contains("handshake")) {
        return true;
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
    jedisTransaction.execute();
    results = jedisTransaction.exec();
	return results;
    }

    protected void checkIsInMulti() {
	if (client.isInMulti()) {
	    throw new JedisDataException(
		    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
	}
    }

    public void connect() {
	client.connect();
    }

    public void disconnect() {
	client.disconnect();
    }

    public void resetState() {
	client.resetState();
	client.getAll();
    }

    public String watch(final byte[]... keys) {
	client.watch(keys);
	return client.getStatusCodeReply();
    }

    public String unwatch() {
	client.unwatch();
	return client.getStatusCodeReply();
    }

    @Override
	public void close() {
	client.close();
    }

    /**
     * Sort a Set or a List.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key.
     * By default sorting is numeric with elements being compared as double
     * precision floating point numbers. This is the simplest form of SORT.
     * 
     * @see #sort(byte[], byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * 
     * @param key
     * @return Assuming the Set/List at key contains a list of numbers, the
     *         return value will be the list of numbers ordered from the
     *         smallest to the biggest number.
     */
    public List<byte[]> sort(final byte[] key) {
	checkIsInMulti();
	client.sort(key);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters.
     * <p>
     * <b>examples:</b>
     * <p>
     * Given are the following sets and key/values:
     * 
     * <pre>
     * x = [1, 2, 3]
     * y = [a, b, c]
     * 
     * k1 = z
     * k2 = y
     * k3 = x
     * 
     * w1 = 9
     * w2 = 8
     * w3 = 7
     * </pre>
     * 
     * Sort Order:
     * 
     * <pre>
     * sort(x) or sort(x, sp.asc())
     * -> [1, 2, 3]
     * 
     * sort(x, sp.desc())
     * -> [3, 2, 1]
     * 
     * sort(y)
     * -> [c, a, b]
     * 
     * sort(y, sp.alpha())
     * -> [a, b, c]
     * 
     * sort(y, sp.alpha().desc())
     * -> [c, a, b]
     * </pre>
     * 
     * Limit (e.g. for Pagination):
     * 
     * <pre>
     * sort(x, sp.limit(0, 2))
     * -> [1, 2]
     * 
     * sort(y, sp.alpha().desc().limit(1, 2))
     * -> [b, a]
     * </pre>
     * 
     * Sorting by external keys:
     * 
     * <pre>
     * sort(x, sb.by(w*))
     * -> [3, 2, 1]
     * 
     * sort(x, sb.by(w*).desc())
     * -> [1, 2, 3]
     * </pre>
     * 
     * Getting external keys:
     * 
     * <pre>
     * sort(x, sp.by(w*).get(k*))
     * -> [x, y, z]
     * 
     * sort(x, sp.by(w*).get(#).get(k*))
     * -> [3, x, 2, y, 1, z]
     * </pre>
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param sortingParameters
     * @return a list of sorted elements.
     */
    public List<byte[]> sort(final byte[] key,
	    final SortingParams sortingParameters) {
	checkIsInMulti();
	client.sort(key, sortingParameters);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #brpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.blpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters and store
     * the result at dstkey.
     * 
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[])
     * @see #sort(byte[], byte[])
     * 
     * @param key
     * @param sortingParameters
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, sortingParameters, dstkey);
	return client.getIntegerReply();
    }

    /**
     * Sort a Set or a List and Store the Result at dstkey.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key
     * and store the result at dstkey. By default sorting is numeric with
     * elements being compared as double precision floating point numbers. This
     * is the simplest form of SORT.
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, dstkey);
	return client.getIntegerReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #blpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.brpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();

	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[]... args) {
	checkIsInMulti();
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[]... args) {
	checkIsInMulti();
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(final String password) {
	checkIsInMulti();
	client.auth(password);
	return client.getStatusCodeReply();
    }

    @Deprecated
    /**
     * This method is deprecated due to its error prone with multi
     * and will be removed on next major release
     * You can use pipelined() instead
     * @see https://github.com/xetorthio/jedis/pull/498
     */
    public List<Object> pipelined(final PipelineBlock jedisPipeline) {
	jedisPipeline.setClient(client);
	jedisPipeline.execute();
	return jedisPipeline.syncAndReturnAll();
    }

    public Pipeline pipelined() {
	Pipeline pipeline = new Pipeline();
	pipeline.setClient(client);
	return pipeline;
    }

    public Long zcount(final byte[] key, final double min, final double max) {
	return zcount(key, toByteArray(min), toByteArray(max));
    }

    public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zcount(key, min, max);
	return client.getIntegerReply();
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max, final int offset, final int count) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max), offset,
		count);
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max, final int offset, final int count) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max, final int offset,
	    final int count) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max),
		offset, count);
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    private Set<Tuple> getBinaryTupledSet() {
	checkIsInMulti();
	List<byte[]> membersWithScores = client.getBinaryMultiBulkReply();
	Set<Tuple> set = new LinkedHashSet<Tuple>();
	Iterator<byte[]> iterator = membersWithScores.iterator();
	while (iterator.hasNext()) {
	    set.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder
		    .encode(iterator.next()))));
	}
	return set;
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min));
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min, final int offset, final int count) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min),
		offset, count);
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min, final int offset, final int count) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min));
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min, final int offset,
	    final int count) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min), offset, count);
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Remove all elements in the sorted set at key with rank between start and
     * end. Start and end are 0-based with rank 0 being the element with the
     * lowest score. Both start and end can be negative numbers, where they
     * indicate offsets starting at the element with the highest rank. For
     * example: -1 is the element with the highest score, -2 the element with
     * the second highest score and so forth.
     * <p>
     * <b>Time complexity:</b> O(log(N))+O(M) with N being the number of
     * elements in the sorted set and M the number of elements removed by the
     * operation
     * 
     */
    public Long zremrangeByRank(final byte[] key, final long start,
	    final long end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Remove all the elements in the sorted set at key with a score between min
     * and max (including elements with score equal to min or max).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements removed by the operation
     * 
     * @param key
     * @param start
     * @param end
     * @return Integer reply, specifically the number of elements removed.
     */
    public Long zremrangeByScore(final byte[] key, final double start,
	    final double end) {
	return zremrangeByScore(key, toByteArray(start), toByteArray(end));
    }

    public Long zremrangeByScore(final byte[] key, final byte[] start,
	    final byte[] end) {
	checkIsInMulti();
	client.zremrangeByScore(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk.
     * <p>
     * Save the whole dataset on disk (this means that all the databases are
     * saved, as well as keys with an EXPIRE set (the expire is preserved). The
     * server hangs while the saving is not completed, no connection is served
     * in the meanwhile. An OK code is returned when the DB was fully stored in
     * disk.
     * <p>
     * The background variant of this command is {@link #bgsave() BGSAVE} that
     * is able to perform the saving in the background while the server
     * continues serving other clients.
     * <p>
     * 
     * @return Status code reply
     */
    public String save() {
	client.save();
	return client.getStatusCodeReply();
    }

    /**
     * Asynchronously save the DB on disk.
     * <p>
     * Save the DB in background. The OK code is immediately returned. Redis
     * forks, the parent continues to server the clients, the child saves the DB
     * on disk then exit. A client my be able to check if the operation
     * succeeded using the LASTSAVE command.
     * 
     * @return Status code reply
     */
    public String bgsave() {
	client.bgsave();
	return client.getStatusCodeReply();
    }

    /**
     * Rewrite the append only file in background when it gets too big. Please
     * for detailed information about the Redis Append Only File check the <a
     * href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append
     * Only File Howto</a>.
     * <p>
     * BGREWRITEAOF rewrites the Append Only File in background when it gets too
     * big. The Redis Append Only File is a Journal, so every operation
     * modifying the dataset is logged in the Append Only File (and replayed at
     * startup). This means that the Append Only File always grows. In order to
     * rebuild its content the BGREWRITEAOF creates a new version of the append
     * only file starting directly form the dataset in memory in order to
     * guarantee the generation of the minimal number of commands needed to
     * rebuild the database.
     * <p>
     * 
     * @return Status code reply
     */
    public String bgrewriteaof() {
	client.bgrewriteaof();
	return client.getStatusCodeReply();
    }

    /**
     * Return the UNIX time stamp of the last successfully saving of the dataset
     * on disk.
     * <p>
     * Return the UNIX TIME of the last DB save executed with success. A client
     * may check if a {@link #bgsave() BGSAVE} command succeeded reading the
     * LASTSAVE value, then issuing a BGSAVE command and checking at regular
     * intervals every N seconds if LASTSAVE changed.
     * 
     * @return Integer reply, specifically an UNIX time stamp.
     */
    public Long lastsave() {
	client.lastsave();
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk, then shutdown the server.
     * <p>
     * Stop all the clients, save the DB, then quit the server. This commands
     * makes sure that the DB is switched off without the lost of any data. This
     * is not guaranteed if the client uses simply {@link #save() SAVE} and then
     * {@link #quit() QUIT} because other clients may alter the DB data between
     * the two commands.
     * 
     * @return Status code reply on error. On success nothing is returned since
     *         the server quits and the connection is closed.
     */
    public String shutdown() {
	client.shutdown();
	String status = null;
	try {
	    status = client.getStatusCodeReply();
	} catch (JedisException ex) {
	    status = null;
	}
	return status;
    }

    /**
     * Provide information and statistics about the server.
     * <p>
     * The info command returns different information and statistics about the
     * server in an format that's simple to parse by computers and easy to read
     * by humans.
     * <p>
     * <b>Format of the returned String:</b>
     * <p>
     * All the fields are in the form field:value
     * 
     * <pre>
     * edis_version:0.07
     * connected_clients:1
     * connected_slaves:0
     * used_memory:3187
     * changes_since_last_save:0
     * last_save_time:1237655729
     * total_connections_received:1
     * total_commands_processed:1
     * uptime_in_seconds:25
     * uptime_in_days:0
     * </pre>
     * 
     * <b>Notes</b>
     * <p>
     * used_memory is returned in bytes, and is the total number of bytes
     * allocated by the program using malloc.
     * <p>
     * uptime_in_days is redundant since the uptime in seconds contains already
     * the full uptime information, this field is only mainly present for
     * humans.
     * <p>
     * changes_since_last_save does not refer to the number of key changes, but
     * to the number of operations that produced some kind of change in the
     * dataset.
     * <p>
     * 
     * @return Bulk reply
     */
    public String info() {
	client.info();
	return client.getBulkReply();
    }

    public String info(final String section) {
	client.info(section);
	return client.getBulkReply();
    }

    /**
     * Dump all the received requests in real time.
     * <p>
     * MONITOR is a debugging command that outputs the whole sequence of
     * commands received by the Redis server. is very handy in order to
     * understand what is happening into the database. This command is used
     * directly via telnet.
     * 
     * @param jedisMonitor
     */
    public void monitor(final JedisMonitor jedisMonitor) {
	client.monitor();
	client.getStatusCodeReply();
	jedisMonitor.proceed(client);
    }

    /**
     * Change the replication settings.
     * <p>
     * The SLAVEOF command can change the replication settings of a slave on the
     * fly. If a Redis server is arleady acting as slave, the command SLAVEOF NO
     * ONE will turn off the replicaiton turning the Redis server into a MASTER.
     * In the proper form SLAVEOF hostname port will make the server a slave of
     * the specific server listening at the specified hostname and port.
     * <p>
     * If a server is already a slave of some master, SLAVEOF hostname port will
     * stop the replication against the old server and start the
     * synchrnonization against the new one discarding the old dataset.
     * <p>
     * The form SLAVEOF no one will stop replication turning the server into a
     * MASTER but will not discard the replication. So if the old master stop
     * working it is possible to turn the slave into a master and set the
     * application to use the new master in read/write. Later when the other
     * Redis server will be fixed it can be configured in order to work as
     * slave.
     * <p>
     * 
     * @param host
     * @param port
     * @return Status code reply
     */
    public String slaveof(final String host, final int port) {
	client.slaveof(host, port);
	return client.getStatusCodeReply();
    }

    public String slaveofNoOne() {
	client.slaveofNoOne();
	return client.getStatusCodeReply();
    }

    /**
     * Retrieve the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * CONFIG GET returns the current configuration parameters. This sub command
     * only accepts a single argument, that is glob style pattern. All the
     * configuration parameters matching this parameter are reported as a list
     * of key-value pairs.
     * <p>
     * <b>Example:</b>
     * 
     * <pre>
     * $ redis-cli config get '*'
     * 1. "dbfilename"
     * 2. "dump.rdb"
     * 3. "requirepass"
     * 4. (nil)
     * 5. "masterauth"
     * 6. (nil)
     * 7. "maxmemory"
     * 8. "0\n"
     * 9. "appendfsync"
     * 10. "everysec"
     * 11. "save"
     * 12. "3600 1 300 100 60 10000"
     * 
     * $ redis-cli config get 'm*'
     * 1. "masterauth"
     * 2. (nil)
     * 3. "maxmemory"
     * 4. "0\n"
     * </pre>
     * 
     * @param pattern
     * @return Bulk reply.
     */
    public List<byte[]> configGet(final byte[] pattern) {
	client.configGet(pattern);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Reset the stats returned by INFO
     * 
     * @return
     */
    public String configResetStat() {
	client.configResetStat();
	return client.getStatusCodeReply();
    }

    /**
     * Alter the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * The list of configuration parameters supported by CONFIG SET can be
     * obtained issuing a {@link #configGet(String) CONFIG GET *} command.
     * <p>
     * The configuration set using CONFIG SET is immediately loaded by the Redis
     * server that will start acting as specified starting from the next
     * command.
     * <p>
     * 
     * <b>Parameters value format</b>
     * <p>
     * The value of the configuration parameter is the same as the one of the
     * same parameter in the Redis configuration file, with the following
     * exceptions:
     * <p>
     * <ul>
     * <li>The save paramter is a list of space-separated integers. Every pair
     * of integers specify the time and number of changes limit to trigger a
     * save. For instance the command CONFIG SET save "3600 10 60 10000" will
     * configure the server to issue a background saving of the RDB file every
     * 3600 seconds if there are at least 10 changes in the dataset, and every
     * 60 seconds if there are at least 10000 changes. To completely disable
     * automatic snapshots just set the parameter as an empty string.
     * <li>All the integer parameters representing memory are returned and
     * accepted only using bytes as unit.
     * </ul>
     * 
     * @param parameter
     * @param value
     * @return Status code reply
     */
    public byte[] configSet(final byte[] parameter, final byte[] value) {
	client.configSet(parameter, value);
	return client.getBinaryBulkReply();
    }

    public boolean isConnected() {
	return client.isConnected();
    }

    public Long strlen(final byte[] key) {
	client.strlen(key);
	return client.getIntegerReply();
    }

    public void sync() {
	client.sync();
    }

    public Long lpushx(final byte[] key, final byte[]... string) {
	client.lpushx(key, string);
	return client.getIntegerReply();
    }

    /**
     * Undo a {@link #expire(byte[], int) expire} at turning the expire key into
     * a normal key.
     * <p>
     * Time complexity: O(1)
     * 
     * @param key
     * @return Integer reply, specifically: 1: the key is now persist. 0: the
     *         key is not persist (only happens when key not set).
     */
    public Long persist(final byte[] key) {
	client.persist(key);
	return client.getIntegerReply();
    }

    public Long rpushx(final byte[] key, final byte[]... string) {
	client.rpushx(key, string);
	return client.getIntegerReply();
    }

    public byte[] echo(final byte[] string) {
	client.echo(string);
	return client.getBinaryBulkReply();
    }

    public Long linsert(final byte[] key, final LIST_POSITION where,
	    final byte[] pivot, final byte[] value) {
	client.linsert(key, where, pivot, value);
	return client.getIntegerReply();
    }

    public String debug(final DebugParams params) {
	client.debug(params);
	return client.getStatusCodeReply();
    }

    public Client getClient() {
	return client;
    }

    /**
     * Pop a value from a list, push it to another list and return it; or block
     * until one is available
     * 
     * @param source
     * @param destination
     * @param timeout
     * @return the element
     */
    public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
	client.brpoplpush(source, destination, timeout);
	client.setTimeoutInfinite();
	byte[] reply = client.getBinaryBulkReply();
	client.rollbackTimeout();
	return reply;
    }

    /**
     * Sets or clears the bit at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @param value
     * @return
     */
    public Boolean setbit(byte[] key, long offset, boolean value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    public Boolean setbit(byte[] key, long offset, byte[] value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    /**
     * Returns the bit value at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @return
     */
    public Boolean getbit(byte[] key, long offset) {
	client.getbit(key, offset);
	return client.getIntegerReply() == 1;
    }

    public Long setrange(byte[] key, long offset, byte[] value) {
	client.setrange(key, offset, value);
	return client.getIntegerReply();
    }

    public byte[] getrange(byte[] key, long startOffset, long endOffset) {
	client.getrange(key, startOffset, endOffset);
	return client.getBinaryBulkReply();
    }

    public Long publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return client.getIntegerReply();
    }

    public void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels) {
	client.setTimeoutInfinite();
	jedisPubSub.proceed(client, channels);
	client.rollbackTimeout();
    }

    public void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns) {
	client.setTimeoutInfinite();
	jedisPubSub.proceedWithPatterns(client, patterns);
	client.rollbackTimeout();
    }

    public Long getDB() {
	return client.getDB();
    }

    /**
     * Evaluates scripts using the Lua interpreter built into Redis starting
     * from version 2.6.0.
     * <p>
     * 
     * @return Script result
     */
    public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	client.setTimeoutInfinite();
	client.eval(script, toByteArray(keys.size()), getParamsWithBinary(keys, args));
	return client.getOne();
    }

    protected static byte[][] getParamsWithBinary(List<byte[]> keys, List<byte[]> args) {
	int keyCount = keys.size();
	int argCount = args.size();
	byte[][] params = new byte[keyCount + args.size()][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return params;
    }

    public Object eval(byte[] script, byte[] keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, keyCount, params);
	return client.getOne();
    }

    public Object eval(byte[] script, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, SafeEncoder.encode(Integer.toString(keyCount)),
		params);
	return client.getOne();
    }

    public Object eval(byte[] script) {
	client.setTimeoutInfinite();
	client.eval(script, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {

	int keyCount = keys == null ? 0 : keys.size();
	int argCount = args == null ? 0 : args.size();

	byte[][] params = new byte[keyCount + argCount][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return evalsha(sha1, keyCount, params);
    }

    public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, keyCount, params);
	return client.getOne();
    }

    public String scriptFlush() {
	client.scriptFlush();
	return client.getStatusCodeReply();
    }

    public Long scriptExists(byte[] sha1) {
	byte[][] a = new byte[1][];
	a[0] = sha1;
	return scriptExists(a).get(0);
    }
    
    public List<Long> scriptExists(byte[]... sha1) {
	client.scriptExists(sha1);
	return client.getIntegerMultiBulkReply();
    }

    public byte[] scriptLoad(byte[] script) {
	client.scriptLoad(script);
	return client.getBinaryBulkReply();
    }

    public String scriptKill() {
	client.scriptKill();
	return client.getStatusCodeReply();
    }

    public String slowlogReset() {
	client.slowlogReset();
	return client.getBulkReply();
    }

    public Long slowlogLen() {
	client.slowlogLen();
	return client.getIntegerReply();
    }

    public List<byte[]> slowlogGetBinary() {
	client.slowlogGet();
	return client.getBinaryMultiBulkReply();
    }

    public List<byte[]> slowlogGetBinary(long entries) {
	client.slowlogGet(entries);
	return client.getBinaryMultiBulkReply();
    }

    public Long objectRefcount(byte[] key) {
	client.objectRefcount(key);
	return client.getIntegerReply();
    }

    public byte[] objectEncoding(byte[] key) {
	client.objectEncoding(key);
	return client.getBinaryBulkReply();
    }

    public Long objectIdletime(byte[] key) {
	client.objectIdletime(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key) {
	client.bitcount(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key, long start, long end) {
	client.bitcount(key, start, end);
	return client.getIntegerReply();
    }

    public Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return client.getIntegerReply();
    }

    public byte[] dump(final byte[] key) {
	checkIsInMulti();
	client.dump(key);
	return client.getBinaryBulkReply();
    }

    public String restore(final byte[] key, final int ttl,
	    final byte[] serializedValue) {
	checkIsInMulti();
	client.restore(key, ttl, serializedValue);
	return client.getStatusCodeReply();
    }

    public Long pexpire(final byte[] key, final int milliseconds) {
	checkIsInMulti();
	client.pexpire(key, milliseconds);
	return client.getIntegerReply();
    }

    public Long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
	checkIsInMulti();
	client.pexpireAt(key, millisecondsTimestamp);
	return client.getIntegerReply();
    }

    public Long pttl(final byte[] key) {
	checkIsInMulti();
	client.pttl(key);
	return client.getIntegerReply();
    }

    public Double incrByFloat(final byte[] key, final double increment) {
	checkIsInMulti();
	client.incrByFloat(key, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    public String psetex(final byte[] key, final int milliseconds,
	    final byte[] value) {
	checkIsInMulti();
	client.psetex(key, milliseconds, value);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
	checkIsInMulti();
	client.set(key, value, nxxx);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx,
	    final byte[] expx, final int time) {
	checkIsInMulti();
	client.set(key, value, nxxx, expx, time);
	return client.getStatusCodeReply();
    }

    public String clientKill(final byte[] client) {
	checkIsInMulti();
	this.client.clientKill(client);
	return this.client.getStatusCodeReply();
    }

    public String clientGetname() {
	checkIsInMulti();
	client.clientGetname();
	return client.getBulkReply();
    }

    public String clientList() {
	checkIsInMulti();
	client.clientList();
	return client.getBulkReply();
    }

    public String clientSetname(final byte[] name) {
	checkIsInMulti();
	client.clientSetname(name);
	return client.getBulkReply();
    }

    public List<String> time() {
	checkIsInMulti();
	client.time();
	return client.getMultiBulkReply();
    }

    public String migrate(final byte[] host, final int port, final byte[] key,
	    final int destinationDb, final int timeout) {
	checkIsInMulti();
	client.migrate(host, port, key, destinationDb, timeout);
	return client.getStatusCodeReply();
    }

    public Double hincrByFloat(final byte[] key, final byte[] field,
	    double increment) {
	checkIsInMulti();
	client.hincrByFloat(key, field, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    /**
     * Syncrhonous replication of Redis as described here:
     * http://antirez.com/news/66
     * 
     * Since Java Object class has implemented "wait" method, we cannot use it,
     * so I had to change the name of the method. Sorry :S
     */
    public Long waitReplicas(int replicas, long timeout) {
	checkIsInMulti();
	client.waitReplicas(replicas, timeout);
	return client.getIntegerReply();
||||||| BASE
    jedisTransaction.execute();
    results = jedisTransaction.exec();
	return results;
    }

    protected void checkIsInMulti() {
	if (client.isInMulti()) {
	    throw new JedisDataException(
		    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
	}
    }

    public void connect() {
	client.connect();
    }

    public void disconnect() {
	client.disconnect();
    }

    public void resetState() {
	client.resetState();
	client.getAll();
    }

    public String watch(final byte[]... keys) {
	client.watch(keys);
	return client.getStatusCodeReply();
    }

    public String unwatch() {
	client.unwatch();
	return client.getStatusCodeReply();
    }

    @Override
	public void close() {
	client.close();
    }

    /**
     * Sort a Set or a List.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key.
     * By default sorting is numeric with elements being compared as double
     * precision floating point numbers. This is the simplest form of SORT.
     * 
     * @see #sort(byte[], byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * 
     * @param key
     * @return Assuming the Set/List at key contains a list of numbers, the
     *         return value will be the list of numbers ordered from the
     *         smallest to the biggest number.
     */
    public List<byte[]> sort(final byte[] key) {
	checkIsInMulti();
	client.sort(key);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters.
     * <p>
     * <b>examples:</b>
     * <p>
     * Given are the following sets and key/values:
     * 
     * <pre>
     * x = [1, 2, 3]
     * y = [a, b, c]
     * 
     * k1 = z
     * k2 = y
     * k3 = x
     * 
     * w1 = 9
     * w2 = 8
     * w3 = 7
     * </pre>
     * 
     * Sort Order:
     * 
     * <pre>
     * sort(x) or sort(x, sp.asc())
     * -> [1, 2, 3]
     * 
     * sort(x, sp.desc())
     * -> [3, 2, 1]
     * 
     * sort(y)
     * -> [c, a, b]
     * 
     * sort(y, sp.alpha())
     * -> [a, b, c]
     * 
     * sort(y, sp.alpha().desc())
     * -> [c, a, b]
     * </pre>
     * 
     * Limit (e.g. for Pagination):
     * 
     * <pre>
     * sort(x, sp.limit(0, 2))
     * -> [1, 2]
     * 
     * sort(y, sp.alpha().desc().limit(1, 2))
     * -> [b, a]
     * </pre>
     * 
     * Sorting by external keys:
     * 
     * <pre>
     * sort(x, sb.by(w*))
     * -> [3, 2, 1]
     * 
     * sort(x, sb.by(w*).desc())
     * -> [1, 2, 3]
     * </pre>
     * 
     * Getting external keys:
     * 
     * <pre>
     * sort(x, sp.by(w*).get(k*))
     * -> [x, y, z]
     * 
     * sort(x, sp.by(w*).get(#).get(k*))
     * -> [3, x, 2, y, 1, z]
     * </pre>
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param sortingParameters
     * @return a list of sorted elements.
     */
    public List<byte[]> sort(final byte[] key,
	    final SortingParams sortingParameters) {
	checkIsInMulti();
	client.sort(key, sortingParameters);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #brpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.blpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters and store
     * the result at dstkey.
     * 
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[])
     * @see #sort(byte[], byte[])
     * 
     * @param key
     * @param sortingParameters
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, sortingParameters, dstkey);
	return client.getIntegerReply();
    }

    /**
     * Sort a Set or a List and Store the Result at dstkey.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key
     * and store the result at dstkey. By default sorting is numeric with
     * elements being compared as double precision floating point numbers. This
     * is the simplest form of SORT.
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, dstkey);
	return client.getIntegerReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #blpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.brpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();

	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[]... args) {
	checkIsInMulti();
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[]... args) {
	checkIsInMulti();
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(final String password) {
	checkIsInMulti();
	client.auth(password);
	return client.getStatusCodeReply();
    }

    @Deprecated
    /**
     * This method is deprecated due to its error prone with multi
     * and will be removed on next major release
     * You can use pipelined() instead
     * @see https://github.com/xetorthio/jedis/pull/498
     */
    public List<Object> pipelined(final PipelineBlock jedisPipeline) {
	jedisPipeline.setClient(client);
	jedisPipeline.execute();
	return jedisPipeline.syncAndReturnAll();
    }

    public Pipeline pipelined() {
	Pipeline pipeline = new Pipeline();
	pipeline.setClient(client);
	return pipeline;
    }

    public Long zcount(final byte[] key, final double min, final double max) {
	return zcount(key, toByteArray(min), toByteArray(max));
    }

    public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zcount(key, min, max);
	return client.getIntegerReply();
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max, final int offset, final int count) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max), offset,
		count);
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max, final int offset, final int count) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max, final int offset,
	    final int count) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max),
		offset, count);
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    private Set<Tuple> getBinaryTupledSet() {
	checkIsInMulti();
	List<byte[]> membersWithScores = client.getBinaryMultiBulkReply();
	Set<Tuple> set = new LinkedHashSet<Tuple>();
	Iterator<byte[]> iterator = membersWithScores.iterator();
	while (iterator.hasNext()) {
	    set.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder
		    .encode(iterator.next()))));
	}
	return set;
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min));
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min, final int offset, final int count) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min),
		offset, count);
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min, final int offset, final int count) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min));
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min, final int offset,
	    final int count) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min), offset, count);
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Remove all elements in the sorted set at key with rank between start and
     * end. Start and end are 0-based with rank 0 being the element with the
     * lowest score. Both start and end can be negative numbers, where they
     * indicate offsets starting at the element with the highest rank. For
     * example: -1 is the element with the highest score, -2 the element with
     * the second highest score and so forth.
     * <p>
     * <b>Time complexity:</b> O(log(N))+O(M) with N being the number of
     * elements in the sorted set and M the number of elements removed by the
     * operation
     * 
     */
    public Long zremrangeByRank(final byte[] key, final long start,
	    final long end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Remove all the elements in the sorted set at key with a score between min
     * and max (including elements with score equal to min or max).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements removed by the operation
     * 
     * @param key
     * @param start
     * @param end
     * @return Integer reply, specifically the number of elements removed.
     */
    public Long zremrangeByScore(final byte[] key, final double start,
	    final double end) {
	return zremrangeByScore(key, toByteArray(start), toByteArray(end));
    }

    public Long zremrangeByScore(final byte[] key, final byte[] start,
	    final byte[] end) {
	checkIsInMulti();
	client.zremrangeByScore(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk.
     * <p>
     * Save the whole dataset on disk (this means that all the databases are
     * saved, as well as keys with an EXPIRE set (the expire is preserved). The
     * server hangs while the saving is not completed, no connection is served
     * in the meanwhile. An OK code is returned when the DB was fully stored in
     * disk.
     * <p>
     * The background variant of this command is {@link #bgsave() BGSAVE} that
     * is able to perform the saving in the background while the server
     * continues serving other clients.
     * <p>
     * 
     * @return Status code reply
     */
    public String save() {
	client.save();
	return client.getStatusCodeReply();
    }

    /**
     * Asynchronously save the DB on disk.
     * <p>
     * Save the DB in background. The OK code is immediately returned. Redis
     * forks, the parent continues to server the clients, the child saves the DB
     * on disk then exit. A client my be able to check if the operation
     * succeeded using the LASTSAVE command.
     * 
     * @return Status code reply
     */
    public String bgsave() {
	client.bgsave();
	return client.getStatusCodeReply();
    }

    /**
     * Rewrite the append only file in background when it gets too big. Please
     * for detailed information about the Redis Append Only File check the <a
     * href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append
     * Only File Howto</a>.
     * <p>
     * BGREWRITEAOF rewrites the Append Only File in background when it gets too
     * big. The Redis Append Only File is a Journal, so every operation
     * modifying the dataset is logged in the Append Only File (and replayed at
     * startup). This means that the Append Only File always grows. In order to
     * rebuild its content the BGREWRITEAOF creates a new version of the append
     * only file starting directly form the dataset in memory in order to
     * guarantee the generation of the minimal number of commands needed to
     * rebuild the database.
     * <p>
     * 
     * @return Status code reply
     */
    public String bgrewriteaof() {
	client.bgrewriteaof();
	return client.getStatusCodeReply();
    }

    /**
     * Return the UNIX time stamp of the last successfully saving of the dataset
     * on disk.
     * <p>
     * Return the UNIX TIME of the last DB save executed with success. A client
     * may check if a {@link #bgsave() BGSAVE} command succeeded reading the
     * LASTSAVE value, then issuing a BGSAVE command and checking at regular
     * intervals every N seconds if LASTSAVE changed.
     * 
     * @return Integer reply, specifically an UNIX time stamp.
     */
    public Long lastsave() {
	client.lastsave();
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk, then shutdown the server.
     * <p>
     * Stop all the clients, save the DB, then quit the server. This commands
     * makes sure that the DB is switched off without the lost of any data. This
     * is not guaranteed if the client uses simply {@link #save() SAVE} and then
     * {@link #quit() QUIT} because other clients may alter the DB data between
     * the two commands.
     * 
     * @return Status code reply on error. On success nothing is returned since
     *         the server quits and the connection is closed.
     */
    public String shutdown() {
	client.shutdown();
	String status = null;
	try {
	    status = client.getStatusCodeReply();
	} catch (JedisException ex) {
	    status = null;
	}
	return status;
    }

    /**
     * Provide information and statistics about the server.
     * <p>
     * The info command returns different information and statistics about the
     * server in an format that's simple to parse by computers and easy to read
     * by humans.
     * <p>
     * <b>Format of the returned String:</b>
     * <p>
     * All the fields are in the form field:value
     * 
     * <pre>
     * edis_version:0.07
     * connected_clients:1
     * connected_slaves:0
     * used_memory:3187
     * changes_since_last_save:0
     * last_save_time:1237655729
     * total_connections_received:1
     * total_commands_processed:1
     * uptime_in_seconds:25
     * uptime_in_days:0
     * </pre>
     * 
     * <b>Notes</b>
     * <p>
     * used_memory is returned in bytes, and is the total number of bytes
     * allocated by the program using malloc.
     * <p>
     * uptime_in_days is redundant since the uptime in seconds contains already
     * the full uptime information, this field is only mainly present for
     * humans.
     * <p>
     * changes_since_last_save does not refer to the number of key changes, but
     * to the number of operations that produced some kind of change in the
     * dataset.
     * <p>
     * 
     * @return Bulk reply
     */
    public String info() {
	client.info();
	return client.getBulkReply();
    }

    public String info(final String section) {
	client.info(section);
	return client.getBulkReply();
    }

    /**
     * Dump all the received requests in real time.
     * <p>
     * MONITOR is a debugging command that outputs the whole sequence of
     * commands received by the Redis server. is very handy in order to
     * understand what is happening into the database. This command is used
     * directly via telnet.
     * 
     * @param jedisMonitor
     */
    public void monitor(final JedisMonitor jedisMonitor) {
	client.monitor();
	client.getStatusCodeReply();
	jedisMonitor.proceed(client);
    }

    /**
     * Change the replication settings.
     * <p>
     * The SLAVEOF command can change the replication settings of a slave on the
     * fly. If a Redis server is arleady acting as slave, the command SLAVEOF NO
     * ONE will turn off the replicaiton turning the Redis server into a MASTER.
     * In the proper form SLAVEOF hostname port will make the server a slave of
     * the specific server listening at the specified hostname and port.
     * <p>
     * If a server is already a slave of some master, SLAVEOF hostname port will
     * stop the replication against the old server and start the
     * synchrnonization against the new one discarding the old dataset.
     * <p>
     * The form SLAVEOF no one will stop replication turning the server into a
     * MASTER but will not discard the replication. So if the old master stop
     * working it is possible to turn the slave into a master and set the
     * application to use the new master in read/write. Later when the other
     * Redis server will be fixed it can be configured in order to work as
     * slave.
     * <p>
     * 
     * @param host
     * @param port
     * @return Status code reply
     */
    public String slaveof(final String host, final int port) {
	client.slaveof(host, port);
	return client.getStatusCodeReply();
    }

    public String slaveofNoOne() {
	client.slaveofNoOne();
	return client.getStatusCodeReply();
    }

    /**
     * Retrieve the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * CONFIG GET returns the current configuration parameters. This sub command
     * only accepts a single argument, that is glob style pattern. All the
     * configuration parameters matching this parameter are reported as a list
     * of key-value pairs.
     * <p>
     * <b>Example:</b>
     * 
     * <pre>
     * $ redis-cli config get '*'
     * 1. "dbfilename"
     * 2. "dump.rdb"
     * 3. "requirepass"
     * 4. (nil)
     * 5. "masterauth"
     * 6. (nil)
     * 7. "maxmemory"
     * 8. "0\n"
     * 9. "appendfsync"
     * 10. "everysec"
     * 11. "save"
     * 12. "3600 1 300 100 60 10000"
     * 
     * $ redis-cli config get 'm*'
     * 1. "masterauth"
     * 2. (nil)
     * 3. "maxmemory"
     * 4. "0\n"
     * </pre>
     * 
     * @param pattern
     * @return Bulk reply.
     */
    public List<byte[]> configGet(final byte[] pattern) {
	client.configGet(pattern);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Reset the stats returned by INFO
     * 
     * @return
     */
    public String configResetStat() {
	client.configResetStat();
	return client.getStatusCodeReply();
    }

    /**
     * Alter the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * The list of configuration parameters supported by CONFIG SET can be
     * obtained issuing a {@link #configGet(String) CONFIG GET *} command.
     * <p>
     * The configuration set using CONFIG SET is immediately loaded by the Redis
     * server that will start acting as specified starting from the next
     * command.
     * <p>
     * 
     * <b>Parameters value format</b>
     * <p>
     * The value of the configuration parameter is the same as the one of the
     * same parameter in the Redis configuration file, with the following
     * exceptions:
     * <p>
     * <ul>
     * <li>The save paramter is a list of space-separated integers. Every pair
     * of integers specify the time and number of changes limit to trigger a
     * save. For instance the command CONFIG SET save "3600 10 60 10000" will
     * configure the server to issue a background saving of the RDB file every
     * 3600 seconds if there are at least 10 changes in the dataset, and every
     * 60 seconds if there are at least 10000 changes. To completely disable
     * automatic snapshots just set the parameter as an empty string.
     * <li>All the integer parameters representing memory are returned and
     * accepted only using bytes as unit.
     * </ul>
     * 
     * @param parameter
     * @param value
     * @return Status code reply
     */
    public byte[] configSet(final byte[] parameter, final byte[] value) {
	client.configSet(parameter, value);
	return client.getBinaryBulkReply();
    }

    public boolean isConnected() {
	return client.isConnected();
    }

    public Long strlen(final byte[] key) {
	client.strlen(key);
	return client.getIntegerReply();
    }

    public void sync() {
	client.sync();
    }

    public Long lpushx(final byte[] key, final byte[]... string) {
	client.lpushx(key, string);
	return client.getIntegerReply();
    }

    /**
     * Undo a {@link #expire(byte[], int) expire} at turning the expire key into
     * a normal key.
     * <p>
     * Time complexity: O(1)
     * 
     * @param key
     * @return Integer reply, specifically: 1: the key is now persist. 0: the
     *         key is not persist (only happens when key not set).
     */
    public Long persist(final byte[] key) {
	client.persist(key);
	return client.getIntegerReply();
    }

    public Long rpushx(final byte[] key, final byte[]... string) {
	client.rpushx(key, string);
	return client.getIntegerReply();
    }

    public byte[] echo(final byte[] string) {
	client.echo(string);
	return client.getBinaryBulkReply();
    }

    public Long linsert(final byte[] key, final LIST_POSITION where,
	    final byte[] pivot, final byte[] value) {
	client.linsert(key, where, pivot, value);
	return client.getIntegerReply();
    }

    public String debug(final DebugParams params) {
	client.debug(params);
	return client.getStatusCodeReply();
    }

    public Client getClient() {
	return client;
    }

    /**
     * Pop a value from a list, push it to another list and return it; or block
     * until one is available
     * 
     * @param source
     * @param destination
     * @param timeout
     * @return the element
     */
    public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
	client.brpoplpush(source, destination, timeout);
	client.setTimeoutInfinite();
	byte[] reply = client.getBinaryBulkReply();
	client.rollbackTimeout();
	return reply;
    }

    /**
     * Sets or clears the bit at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @param value
     * @return
     */
    public Boolean setbit(byte[] key, long offset, boolean value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    public Boolean setbit(byte[] key, long offset, byte[] value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    /**
     * Returns the bit value at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @return
     */
    public Boolean getbit(byte[] key, long offset) {
	client.getbit(key, offset);
	return client.getIntegerReply() == 1;
    }

    public Long setrange(byte[] key, long offset, byte[] value) {
	client.setrange(key, offset, value);
	return client.getIntegerReply();
    }

    public byte[] getrange(byte[] key, long startOffset, long endOffset) {
	client.getrange(key, startOffset, endOffset);
	return client.getBinaryBulkReply();
    }

    public Long publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return client.getIntegerReply();
    }

    public void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels) {
	client.setTimeoutInfinite();
	jedisPubSub.proceed(client, channels);
	client.rollbackTimeout();
    }

    public void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns) {
	client.setTimeoutInfinite();
	jedisPubSub.proceedWithPatterns(client, patterns);
	client.rollbackTimeout();
    }

    public Long getDB() {
	return client.getDB();
    }

    /**
     * Evaluates scripts using the Lua interpreter built into Redis starting
     * from version 2.6.0.
     * <p>
     * 
     * @return Script result
     */
    public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	client.setTimeoutInfinite();
	client.eval(script, toByteArray(keys.size()), getParams(keys, args));
	return client.getOne();
    }

    private byte[][] getParams(List<byte[]> keys, List<byte[]> args) {
	int keyCount = keys.size();
	int argCount = args.size();
	byte[][] params = new byte[keyCount + args.size()][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return params;
    }

    public Object eval(byte[] script, byte[] keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, keyCount, params);
	return client.getOne();
    }

    public Object eval(byte[] script, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, SafeEncoder.encode(Integer.toString(keyCount)),
		params);
	return client.getOne();
    }

    public Object eval(byte[] script) {
	client.setTimeoutInfinite();
	client.eval(script, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {

	int keyCount = keys == null ? 0 : keys.size();
	int argCount = args == null ? 0 : args.size();

	byte[][] params = new byte[keyCount + argCount][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return evalsha(sha1, keyCount, params);
    }

    public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, keyCount, params);
	return client.getOne();
    }

    public String scriptFlush() {
	client.scriptFlush();
	return client.getStatusCodeReply();
    }

    public List<Long> scriptExists(byte[]... sha1) {
	client.scriptExists(sha1);
	return client.getIntegerMultiBulkReply();
    }

    public byte[] scriptLoad(byte[] script) {
	client.scriptLoad(script);
	return client.getBinaryBulkReply();
    }

    public String scriptKill() {
	client.scriptKill();
	return client.getStatusCodeReply();
    }

    public String slowlogReset() {
	client.slowlogReset();
	return client.getBulkReply();
    }

    public Long slowlogLen() {
	client.slowlogLen();
	return client.getIntegerReply();
    }

    public List<byte[]> slowlogGetBinary() {
	client.slowlogGet();
	return client.getBinaryMultiBulkReply();
    }

    public List<byte[]> slowlogGetBinary(long entries) {
	client.slowlogGet(entries);
	return client.getBinaryMultiBulkReply();
    }

    public Long objectRefcount(byte[] key) {
	client.objectRefcount(key);
	return client.getIntegerReply();
    }

    public byte[] objectEncoding(byte[] key) {
	client.objectEncoding(key);
	return client.getBinaryBulkReply();
    }

    public Long objectIdletime(byte[] key) {
	client.objectIdletime(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key) {
	client.bitcount(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key, long start, long end) {
	client.bitcount(key, start, end);
	return client.getIntegerReply();
    }

    public Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return client.getIntegerReply();
    }

    public byte[] dump(final byte[] key) {
	checkIsInMulti();
	client.dump(key);
	return client.getBinaryBulkReply();
    }

    public String restore(final byte[] key, final int ttl,
	    final byte[] serializedValue) {
	checkIsInMulti();
	client.restore(key, ttl, serializedValue);
	return client.getStatusCodeReply();
    }

    public Long pexpire(final byte[] key, final int milliseconds) {
	checkIsInMulti();
	client.pexpire(key, milliseconds);
	return client.getIntegerReply();
    }

    public Long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
	checkIsInMulti();
	client.pexpireAt(key, millisecondsTimestamp);
	return client.getIntegerReply();
    }

    public Long pttl(final byte[] key) {
	checkIsInMulti();
	client.pttl(key);
	return client.getIntegerReply();
    }

    public Double incrByFloat(final byte[] key, final double increment) {
	checkIsInMulti();
	client.incrByFloat(key, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    public String psetex(final byte[] key, final int milliseconds,
	    final byte[] value) {
	checkIsInMulti();
	client.psetex(key, milliseconds, value);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
	checkIsInMulti();
	client.set(key, value, nxxx);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx,
	    final byte[] expx, final int time) {
	checkIsInMulti();
	client.set(key, value, nxxx, expx, time);
	return client.getStatusCodeReply();
    }

    public String clientKill(final byte[] client) {
	checkIsInMulti();
	this.client.clientKill(client);
	return this.client.getStatusCodeReply();
    }

    public String clientGetname() {
	checkIsInMulti();
	client.clientGetname();
	return client.getBulkReply();
    }

    public String clientList() {
	checkIsInMulti();
	client.clientList();
	return client.getBulkReply();
    }

    public String clientSetname(final byte[] name) {
	checkIsInMulti();
	client.clientSetname(name);
	return client.getBulkReply();
    }

    public List<String> time() {
	checkIsInMulti();
	client.time();
	return client.getMultiBulkReply();
    }

    public String migrate(final byte[] host, final int port, final byte[] key,
	    final int destinationDb, final int timeout) {
	checkIsInMulti();
	client.migrate(host, port, key, destinationDb, timeout);
	return client.getStatusCodeReply();
    }

    public Double hincrByFloat(final byte[] key, final byte[] field,
	    double increment) {
	checkIsInMulti();
	client.hincrByFloat(key, field, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    /**
     * Syncrhonous replication of Redis as described here:
     * http://antirez.com/news/66
     * 
     * Since Java Object class has implemented "wait" method, we cannot use it,
     * so I had to change the name of the method. Sorry :S
     */
    public Long waitReplicas(int replicas, long timeout) {
	checkIsInMulti();
	client.waitReplicas(replicas, timeout);
	return client.getIntegerReply();
=======
    client.getOne(); // expected OK
    transaction = new Transaction(client);
    return transaction;
  }

  protected void checkIsInMulti() {
    if (client.isInMulti()) {
      throw new JedisDataException(
          "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
    }
  }

  public void connect() {
    client.connect();
  }

  public void disconnect() {
    client.disconnect();
  }

  public void resetState() {
    if (client.isConnected()) {
      if (transaction != null) {
        transaction.clear();
      }

      if (pipeline != null) {
        pipeline.clear();
      }

      if (client.isInWatch()) {
        unwatch();
      }

      client.resetState();
    }

    transaction = null;
    pipeline = null;
  }

  public String watch(final byte[]... keys) {
    client.watch(keys);
    return client.getStatusCodeReply();
  }

  public String unwatch() {
    client.unwatch();
    return client.getStatusCodeReply();
  }

  @Override
  public void close() {
    client.close();
  }

  /**
   * Sort a Set or a List.
   * <p>
   * Sort the elements contained in the List, Set, or Sorted Set value at key. By default sorting is
   * numeric with elements being compared as double precision floating point numbers. This is the
   * simplest form of SORT.
   * @see #sort(byte[], byte[])
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @return Assuming the Set/List at key contains a list of numbers, the return value will be the
   *         list of numbers ordered from the smallest to the biggest number.
   */
  public List<byte[]> sort(final byte[] key) {
    checkIsInMulti();
    client.sort(key);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * Sort a Set or a List accordingly to the specified parameters.
   * <p>
   * <b>examples:</b>
   * <p>
   * Given are the following sets and key/values:
   * 
   * <pre>
   * x = [1, 2, 3]
   * y = [a, b, c]
   * 
   * k1 = z
   * k2 = y
   * k3 = x
   * 
   * w1 = 9
   * w2 = 8
   * w3 = 7
   * </pre>
   * 
   * Sort Order:
   * 
   * <pre>
   * sort(x) or sort(x, sp.asc())
   * -> [1, 2, 3]
   * 
   * sort(x, sp.desc())
   * -> [3, 2, 1]
   * 
   * sort(y)
   * -> [c, a, b]
   * 
   * sort(y, sp.alpha())
   * -> [a, b, c]
   * 
   * sort(y, sp.alpha().desc())
   * -> [c, a, b]
   * </pre>
   * 
   * Limit (e.g. for Pagination):
   * 
   * <pre>
   * sort(x, sp.limit(0, 2))
   * -> [1, 2]
   * 
   * sort(y, sp.alpha().desc().limit(1, 2))
   * -> [b, a]
   * </pre>
   * 
   * Sorting by external keys:
   * 
   * <pre>
   * sort(x, sb.by(w*))
   * -> [3, 2, 1]
   * 
   * sort(x, sb.by(w*).desc())
   * -> [1, 2, 3]
   * </pre>
   * 
   * Getting external keys:
   * 
   * <pre>
   * sort(x, sp.by(w*).get(k*))
   * -> [x, y, z]
   * 
   * sort(x, sp.by(w*).get(#).get(k*))
   * -> [3, x, 2, y, 1, z]
   * </pre>
   * @see #sort(byte[])
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @param sortingParameters
   * @return a list of sorted elements.
   */
  public List<byte[]> sort(final byte[] key, final SortingParams sortingParameters) {
    checkIsInMulti();
    client.sort(key, sortingParameters);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this commands as blocking
   * versions of LPOP and RPOP able to block if the specified keys don't exist or contain empty
   * lists.
   * <p>
   * The following is a description of the exact semantic. We describe BLPOP but the two commands
   * are identical, the only difference is that BLPOP pops the element from the left (head) of the
   * list, and BRPOP pops from the right (tail).
   * <p>
   * <b>Non blocking behavior</b>
   * <p>
   * When BLPOP is called, if at least one of the specified keys contain a non empty list, an
   * element is popped from the head of the list and returned to the caller together with the name
   * of the key (BLPOP returns a two elements array, the first element is the key, the second the
   * popped value).
   * <p>
   * Keys are scanned from left to right, so for instance if you issue BLPOP list1 list2 list3 0
   * against a dataset where list1 does not exist but list2 and list3 contain non empty lists, BLPOP
   * guarantees to return an element from the list stored at list2 (since it is the first non empty
   * list starting from the left).
   * <p>
   * <b>Blocking behavior</b>
   * <p>
   * If none of the specified keys exist or contain non empty lists, BLPOP blocks until some other
   * client performs a LPUSH or an RPUSH operation against one of the lists.
   * <p>
   * Once new data is present on one of the lists, the client finally returns with the name of the
   * key unblocking it and the popped value.
   * <p>
   * When blocking, if a non-zero timeout is specified, the client will unblock returning a nil
   * special value if the specified amount of seconds passed without a push operation against at
   * least one of the specified keys.
   * <p>
   * The timeout argument is interpreted as an integer value. A timeout of zero means instead to
   * block forever.
   * <p>
   * <b>Multiple clients blocking for the same keys</b>
   * <p>
   * Multiple clients can block for the same key. They are put into a queue, so the first to be
   * served will be the one that started to wait earlier, in a first-blpopping first-served fashion.
   * <p>
   * <b>blocking POP inside a MULTI/EXEC transaction</b>
   * <p>
   * BLPOP and BRPOP can be used with pipelining (sending multiple commands and reading the replies
   * in batch), but it does not make sense to use BLPOP or BRPOP inside a MULTI/EXEC block (a Redis
   * transaction).
   * <p>
   * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to return a multi-bulk nil
   * reply, exactly what happens when the timeout is reached. If you like science fiction, think at
   * it like if inside MULTI/EXEC the time will flow at infinite speed :)
   * <p>
   * Time complexity: O(1)
   * @see #brpop(int, byte[]...)
   * @param timeout
   * @param keys
   * @return BLPOP returns a two-elements array via a multi bulk reply in order to return both the
   *         unblocking key and the popped value.
   *         <p>
   *         When a non-zero timeout is specified, and the BLPOP operation timed out, the return
   *         value is a nil multi bulk reply. Most client values will return false or nil
   *         accordingly to the programming language used.
   */
  public List<byte[]> blpop(final int timeout, final byte[]... keys) {
    return blpop(getArgsAddTimeout(timeout, keys));
  }

  private byte[][] getArgsAddTimeout(int timeout, byte[][] keys) {
    int size = keys.length;
    final byte[][] args = new byte[size + 1][];
    for (int at = 0; at != size; ++at) {
      args[at] = keys[at];
    }
    args[size] = Protocol.toByteArray(timeout);
    return args;
  }

  /**
   * Sort a Set or a List accordingly to the specified parameters and store the result at dstkey.
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[])
   * @see #sort(byte[], byte[])
   * @param key
   * @param sortingParameters
   * @param dstkey
   * @return The number of elements of the list at dstkey.
   */
  public Long sort(final byte[] key, final SortingParams sortingParameters, final byte[] dstkey) {
    checkIsInMulti();
    client.sort(key, sortingParameters, dstkey);
    return client.getIntegerReply();
  }

  /**
   * Sort a Set or a List and Store the Result at dstkey.
   * <p>
   * Sort the elements contained in the List, Set, or Sorted Set value at key and store the result
   * at dstkey. By default sorting is numeric with elements being compared as double precision
   * floating point numbers. This is the simplest form of SORT.
   * @see #sort(byte[])
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @param dstkey
   * @return The number of elements of the list at dstkey.
   */
  public Long sort(final byte[] key, final byte[] dstkey) {
    checkIsInMulti();
    client.sort(key, dstkey);
    return client.getIntegerReply();
  }

  /**
   * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this commands as blocking
   * versions of LPOP and RPOP able to block if the specified keys don't exist or contain empty
   * lists.
   * <p>
   * The following is a description of the exact semantic. We describe BLPOP but the two commands
   * are identical, the only difference is that BLPOP pops the element from the left (head) of the
   * list, and BRPOP pops from the right (tail).
   * <p>
   * <b>Non blocking behavior</b>
   * <p>
   * When BLPOP is called, if at least one of the specified keys contain a non empty list, an
   * element is popped from the head of the list and returned to the caller together with the name
   * of the key (BLPOP returns a two elements array, the first element is the key, the second the
   * popped value).
   * <p>
   * Keys are scanned from left to right, so for instance if you issue BLPOP list1 list2 list3 0
   * against a dataset where list1 does not exist but list2 and list3 contain non empty lists, BLPOP
   * guarantees to return an element from the list stored at list2 (since it is the first non empty
   * list starting from the left).
   * <p>
   * <b>Blocking behavior</b>
   * <p>
   * If none of the specified keys exist or contain non empty lists, BLPOP blocks until some other
   * client performs a LPUSH or an RPUSH operation against one of the lists.
   * <p>
   * Once new data is present on one of the lists, the client finally returns with the name of the
   * key unblocking it and the popped value.
   * <p>
   * When blocking, if a non-zero timeout is specified, the client will unblock returning a nil
   * special value if the specified amount of seconds passed without a push operation against at
   * least one of the specified keys.
   * <p>
   * The timeout argument is interpreted as an integer value. A timeout of zero means instead to
   * block forever.
   * <p>
   * <b>Multiple clients blocking for the same keys</b>
   * <p>
   * Multiple clients can block for the same key. They are put into a queue, so the first to be
   * served will be the one that started to wait earlier, in a first-blpopping first-served fashion.
   * <p>
   * <b>blocking POP inside a MULTI/EXEC transaction</b>
   * <p>
   * BLPOP and BRPOP can be used with pipelining (sending multiple commands and reading the replies
   * in batch), but it does not make sense to use BLPOP or BRPOP inside a MULTI/EXEC block (a Redis
   * transaction).
   * <p>
   * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to return a multi-bulk nil
   * reply, exactly what happens when the timeout is reached. If you like science fiction, think at
   * it like if inside MULTI/EXEC the time will flow at infinite speed :)
   * <p>
   * Time complexity: O(1)
   * @see #blpop(int, byte[]...)
   * @param timeout
   * @param keys
   * @return BLPOP returns a two-elements array via a multi bulk reply in order to return both the
   *         unblocking key and the popped value.
   *         <p>
   *         When a non-zero timeout is specified, and the BLPOP operation timed out, the return
   *         value is a nil multi bulk reply. Most client values will return false or nil
   *         accordingly to the programming language used.
   */
  public List<byte[]> brpop(final int timeout, final byte[]... keys) {
    return brpop(getArgsAddTimeout(timeout, keys));
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  public List<byte[]> blpop(byte[] arg) {
    return blpop(new byte[][] { arg });
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  public List<byte[]> brpop(byte[] arg) {
    return brpop(new byte[][] { arg });
  }

  public List<byte[]> blpop(byte[]... args) {
    checkIsInMulti();
    client.blpop(args);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryMultiBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  public List<byte[]> brpop(byte[]... args) {
    checkIsInMulti();
    client.brpop(args);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryMultiBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  /**
   * Request for authentication in a password protected Redis server. A Redis server can be
   * instructed to require a password before to allow clients to issue commands. This is done using
   * the requirepass directive in the Redis configuration file. If the password given by the client
   * is correct the server replies with an OK status code reply and starts accepting commands from
   * the client. Otherwise an error is returned and the clients needs to try a new password. Note
   * that for the high performance nature of Redis it is possible to try a lot of passwords in
   * parallel in very short time, so make sure to generate a strong and very long password so that
   * this attack is infeasible.
   * @param password
   * @return Status code reply
   */
  public String auth(final String password) {
    checkIsInMulti();
    client.auth(password);
    return client.getStatusCodeReply();
  }

  public Pipeline pipelined() {
    pipeline = new Pipeline();
    pipeline.setClient(client);
    return pipeline;
  }

  public Long zcount(final byte[] key, final double min, final double max) {
    return zcount(key, toByteArray(min), toByteArray(max));
  }

  public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zcount(key, min, max);
    return client.getIntegerReply();
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max));
  }

  public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByScore(key, min, max);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max,
      final int offset, final int count) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByScore(key, min, max, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
  }

  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByScoreWithScores(key, min, max);
    return getBinaryTupledSet();
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max,
      final int offset, final int count) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByScoreWithScores(key, min, max, offset, count);
    return getBinaryTupledSet();
  }

  private Set<Tuple> getBinaryTupledSet() {
    checkIsInMulti();
    List<byte[]> membersWithScores = client.getBinaryMultiBulkReply();
    Set<Tuple> set = new LinkedHashSet<Tuple>();
    Iterator<byte[]> iterator = membersWithScores.iterator();
    while (iterator.hasNext()) {
      set.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
    }
    return set;
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min) {
    return zrevrangeByScore(key, toByteArray(max), toByteArray(min));
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
    checkIsInMulti();
    client.zrevrangeByScore(key, max, min);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min,
      final int offset, final int count) {
    return zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrevrangeByScore(key, max, min, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
    return zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max,
      final double min, final int offset, final int count) {
    return zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset, count);
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
    checkIsInMulti();
    client.zrevrangeByScoreWithScores(key, max, min);
    return getBinaryTupledSet();
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
      final byte[] min, final int offset, final int count) {
    checkIsInMulti();
    client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getBinaryTupledSet();
  }

  /**
   * Remove all elements in the sorted set at key with rank between start and end. Start and end are
   * 0-based with rank 0 being the element with the lowest score. Both start and end can be negative
   * numbers, where they indicate offsets starting at the element with the highest rank. For
   * example: -1 is the element with the highest score, -2 the element with the second highest score
   * and so forth.
   * <p>
   * <b>Time complexity:</b> O(log(N))+O(M) with N being the number of elements in the sorted set
   * and M the number of elements removed by the operation
   */
  public Long zremrangeByRank(final byte[] key, final long start, final long end) {
    checkIsInMulti();
    client.zremrangeByRank(key, start, end);
    return client.getIntegerReply();
  }

  /**
   * Remove all the elements in the sorted set at key with a score between min and max (including
   * elements with score equal to min or max).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements removed by the operation
   * @param key
   * @param start
   * @param end
   * @return Integer reply, specifically the number of elements removed.
   */
  public Long zremrangeByScore(final byte[] key, final double start, final double end) {
    return zremrangeByScore(key, toByteArray(start), toByteArray(end));
  }

  public Long zremrangeByScore(final byte[] key, final byte[] start, final byte[] end) {
    checkIsInMulti();
    client.zremrangeByScore(key, start, end);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...)} ZINTERSTORE} command requires
   * an element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...)} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
    checkIsInMulti();
    client.zunionstore(dstkey, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @param params
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zunionstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
    checkIsInMulti();
    client.zunionstore(dstkey, params, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
    checkIsInMulti();
    client.zinterstore(dstkey, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @param params
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zinterstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
    checkIsInMulti();
    client.zinterstore(dstkey, params, sets);
    return client.getIntegerReply();
  }

  @Override
  public Long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zlexcount(key, min, max);
    return client.getIntegerReply();
  }

  @Override
  public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByLex(key, min, max);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByLex(key, min, max, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
    checkIsInMulti();
    client.zrevrangeByLex(key, max, min);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
    checkIsInMulti();
    client.zrevrangeByLex(key, max, min, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zremrangeByLex(key, min, max);
    return client.getIntegerReply();
  }

  /**
   * Synchronously save the DB on disk.
   * <p>
   * Save the whole dataset on disk (this means that all the databases are saved, as well as keys
   * with an EXPIRE set (the expire is preserved). The server hangs while the saving is not
   * completed, no connection is served in the meanwhile. An OK code is returned when the DB was
   * fully stored in disk.
   * <p>
   * The background variant of this command is {@link #bgsave() BGSAVE} that is able to perform the
   * saving in the background while the server continues serving other clients.
   * <p>
   * @return Status code reply
   */
  public String save() {
    client.save();
    return client.getStatusCodeReply();
  }

  /**
   * Asynchronously save the DB on disk.
   * <p>
   * Save the DB in background. The OK code is immediately returned. Redis forks, the parent
   * continues to server the clients, the child saves the DB on disk then exit. A client my be able
   * to check if the operation succeeded using the LASTSAVE command.
   * @return Status code reply
   */
  public String bgsave() {
    client.bgsave();
    return client.getStatusCodeReply();
  }

  /**
   * Rewrite the append only file in background when it gets too big. Please for detailed
   * information about the Redis Append Only File check the <a
   * href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append Only File Howto</a>.
   * <p>
   * BGREWRITEAOF rewrites the Append Only File in background when it gets too big. The Redis Append
   * Only File is a Journal, so every operation modifying the dataset is logged in the Append Only
   * File (and replayed at startup). This means that the Append Only File always grows. In order to
   * rebuild its content the BGREWRITEAOF creates a new version of the append only file starting
   * directly form the dataset in memory in order to guarantee the generation of the minimal number
   * of commands needed to rebuild the database.
   * <p>
   * @return Status code reply
   */
  public String bgrewriteaof() {
    client.bgrewriteaof();
    return client.getStatusCodeReply();
  }

  /**
   * Return the UNIX time stamp of the last successfully saving of the dataset on disk.
   * <p>
   * Return the UNIX TIME of the last DB save executed with success. A client may check if a
   * {@link #bgsave() BGSAVE} command succeeded reading the LASTSAVE value, then issuing a BGSAVE
   * command and checking at regular intervals every N seconds if LASTSAVE changed.
   * @return Integer reply, specifically an UNIX time stamp.
   */
  public Long lastsave() {
    client.lastsave();
    return client.getIntegerReply();
  }

  /**
   * Synchronously save the DB on disk, then shutdown the server.
   * <p>
   * Stop all the clients, save the DB, then quit the server. This commands makes sure that the DB
   * is switched off without the lost of any data. This is not guaranteed if the client uses simply
   * {@link #save() SAVE} and then {@link #quit() QUIT} because other clients may alter the DB data
   * between the two commands.
   * @return Status code reply on error. On success nothing is returned since the server quits and
   *         the connection is closed.
   */
  public String shutdown() {
    client.shutdown();
    String status;
    try {
      status = client.getStatusCodeReply();
    } catch (JedisException ex) {
      status = null;
    }
    return status;
  }

  /**
   * Provide information and statistics about the server.
   * <p>
   * The info command returns different information and statistics about the server in an format
   * that's simple to parse by computers and easy to read by humans.
   * <p>
   * <b>Format of the returned String:</b>
   * <p>
   * All the fields are in the form field:value
   * 
   * <pre>
   * edis_version:0.07
   * connected_clients:1
   * connected_slaves:0
   * used_memory:3187
   * changes_since_last_save:0
   * last_save_time:1237655729
   * total_connections_received:1
   * total_commands_processed:1
   * uptime_in_seconds:25
   * uptime_in_days:0
   * </pre>
   * 
   * <b>Notes</b>
   * <p>
   * used_memory is returned in bytes, and is the total number of bytes allocated by the program
   * using malloc.
   * <p>
   * uptime_in_days is redundant since the uptime in seconds contains already the full uptime
   * information, this field is only mainly present for humans.
   * <p>
   * changes_since_last_save does not refer to the number of key changes, but to the number of
   * operations that produced some kind of change in the dataset.
   * <p>
   * @return Bulk reply
   */
  public String info() {
    client.info();
    return client.getBulkReply();
  }

  public String info(final String section) {
    client.info(section);
    return client.getBulkReply();
  }

  /**
   * Dump all the received requests in real time.
   * <p>
   * MONITOR is a debugging command that outputs the whole sequence of commands received by the
   * Redis server. is very handy in order to understand what is happening into the database. This
   * command is used directly via telnet.
   * @param jedisMonitor
   */
  public void monitor(final JedisMonitor jedisMonitor) {
    client.monitor();
    client.getStatusCodeReply();
    jedisMonitor.proceed(client);
  }

  /**
   * Change the replication settings.
   * <p>
   * The SLAVEOF command can change the replication settings of a slave on the fly. If a Redis
   * server is arleady acting as slave, the command SLAVEOF NO ONE will turn off the replicaiton
   * turning the Redis server into a MASTER. In the proper form SLAVEOF hostname port will make the
   * server a slave of the specific server listening at the specified hostname and port.
   * <p>
   * If a server is already a slave of some master, SLAVEOF hostname port will stop the replication
   * against the old server and start the synchrnonization against the new one discarding the old
   * dataset.
   * <p>
   * The form SLAVEOF no one will stop replication turning the server into a MASTER but will not
   * discard the replication. So if the old master stop working it is possible to turn the slave
   * into a master and set the application to use the new master in read/write. Later when the other
   * Redis server will be fixed it can be configured in order to work as slave.
   * <p>
   * @param host
   * @param port
   * @return Status code reply
   */
  public String slaveof(final String host, final int port) {
    client.slaveof(host, port);
    return client.getStatusCodeReply();
  }

  public String slaveofNoOne() {
    client.slaveofNoOne();
    return client.getStatusCodeReply();
  }

  /**
   * Retrieve the configuration of a running Redis server. Not all the configuration parameters are
   * supported.
   * <p>
   * CONFIG GET returns the current configuration parameters. This sub command only accepts a single
   * argument, that is glob style pattern. All the configuration parameters matching this parameter
   * are reported as a list of key-value pairs.
   * <p>
   * <b>Example:</b>
   * 
   * <pre>
   * $ redis-cli config get '*'
   * 1. "dbfilename"
   * 2. "dump.rdb"
   * 3. "requirepass"
   * 4. (nil)
   * 5. "masterauth"
   * 6. (nil)
   * 7. "maxmemory"
   * 8. "0\n"
   * 9. "appendfsync"
   * 10. "everysec"
   * 11. "save"
   * 12. "3600 1 300 100 60 10000"
   * 
   * $ redis-cli config get 'm*'
   * 1. "masterauth"
   * 2. (nil)
   * 3. "maxmemory"
   * 4. "0\n"
   * </pre>
   * @param pattern
   * @return Bulk reply.
   */
  public List<byte[]> configGet(final byte[] pattern) {
    client.configGet(pattern);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * Reset the stats returned by INFO
   * @return
   */
  public String configResetStat() {
    client.configResetStat();
    return client.getStatusCodeReply();
  }

  /**
   * Alter the configuration of a running Redis server. Not all the configuration parameters are
   * supported.
   * <p>
   * The list of configuration parameters supported by CONFIG SET can be obtained issuing a
   * {@link #configGet(byte[]) CONFIG GET *} command.
   * <p>
   * The configuration set using CONFIG SET is immediately loaded by the Redis server that will
   * start acting as specified starting from the next command.
   * <p>
   * <b>Parameters value format</b>
   * <p>
   * The value of the configuration parameter is the same as the one of the same parameter in the
   * Redis configuration file, with the following exceptions:
   * <p>
   * <ul>
   * <li>The save paramter is a list of space-separated integers. Every pair of integers specify the
   * time and number of changes limit to trigger a save. For instance the command CONFIG SET save
   * "3600 10 60 10000" will configure the server to issue a background saving of the RDB file every
   * 3600 seconds if there are at least 10 changes in the dataset, and every 60 seconds if there are
   * at least 10000 changes. To completely disable automatic snapshots just set the parameter as an
   * empty string.
   * <li>All the integer parameters representing memory are returned and accepted only using bytes
   * as unit.
   * </ul>
   * @param parameter
   * @param value
   * @return Status code reply
   */
  public byte[] configSet(final byte[] parameter, final byte[] value) {
    client.configSet(parameter, value);
    return client.getBinaryBulkReply();
  }

  public boolean isConnected() {
    return client.isConnected();
  }

  public Long strlen(final byte[] key) {
    client.strlen(key);
    return client.getIntegerReply();
  }

  public void sync() {
    client.sync();
  }

  public Long lpushx(final byte[] key, final byte[]... string) {
    client.lpushx(key, string);
    return client.getIntegerReply();
  }

  /**
   * Undo a {@link #expire(byte[], int) expire} at turning the expire key into a normal key.
   * <p>
   * Time complexity: O(1)
   * @param key
   * @return Integer reply, specifically: 1: the key is now persist. 0: the key is not persist (only
   *         happens when key not set).
   */
  public Long persist(final byte[] key) {
    client.persist(key);
    return client.getIntegerReply();
  }

  public Long rpushx(final byte[] key, final byte[]... string) {
    client.rpushx(key, string);
    return client.getIntegerReply();
  }

  public byte[] echo(final byte[] string) {
    client.echo(string);
    return client.getBinaryBulkReply();
  }

  public Long linsert(final byte[] key, final LIST_POSITION where, final byte[] pivot,
      final byte[] value) {
    client.linsert(key, where, pivot, value);
    return client.getIntegerReply();
  }

  public String debug(final DebugParams params) {
    client.debug(params);
    return client.getStatusCodeReply();
  }

  public Client getClient() {
    return client;
  }

  /**
   * Pop a value from a list, push it to another list and return it; or block until one is available
   * @param source
   * @param destination
   * @param timeout
   * @return the element
   */
  public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  /**
   * Sets or clears the bit at offset in the string value stored at key
   * @param key
   * @param offset
   * @param value
   * @return
   */
  public Boolean setbit(byte[] key, long offset, boolean value) {
    client.setbit(key, offset, value);
    return client.getIntegerReply() == 1;
  }

  public Boolean setbit(byte[] key, long offset, byte[] value) {
    client.setbit(key, offset, value);
    return client.getIntegerReply() == 1;
  }

  /**
   * Returns the bit value at offset in the string value stored at key
   * @param key
   * @param offset
   * @return
   */
  public Boolean getbit(byte[] key, long offset) {
    client.getbit(key, offset);
    return client.getIntegerReply() == 1;
  }

  public Long bitpos(final byte[] key, final boolean value) {
    return bitpos(key, value, new BitPosParams());
  }

  public Long bitpos(final byte[] key, final boolean value, final BitPosParams params) {
    client.bitpos(key, value, params);
    return client.getIntegerReply();
  }

  public Long setrange(byte[] key, long offset, byte[] value) {
    client.setrange(key, offset, value);
    return client.getIntegerReply();
  }

  public byte[] getrange(byte[] key, long startOffset, long endOffset) {
    client.getrange(key, startOffset, endOffset);
    return client.getBinaryBulkReply();
  }

  public Long publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return client.getIntegerReply();
  }

  public void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels) {
    client.setTimeoutInfinite();
    try {
      jedisPubSub.proceed(client, channels);
    } finally {
      client.rollbackTimeout();
    }
  }

  public void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns) {
    client.setTimeoutInfinite();
    try {
      jedisPubSub.proceedWithPatterns(client, patterns);
    } finally {
      client.rollbackTimeout();
    }
  }

  public Long getDB() {
    return client.getDB();
  }

  /**
   * Evaluates scripts using the Lua interpreter built into Redis starting from version 2.6.0.
   * <p>
   * @return Script result
   */
  public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
    return eval(script, toByteArray(keys.size()), getParams(keys, args));
  }

  private byte[][] getParams(List<byte[]> keys, List<byte[]> args) {
    final int keyCount = keys.size();
    final int argCount = args.size();
    byte[][] params = new byte[keyCount + argCount][];

    for (int i = 0; i < keyCount; i++)
      params[i] = keys.get(i);

    for (int i = 0; i < argCount; i++)
      params[keyCount + i] = args.get(i);

    return params;
  }

  public Object eval(byte[] script, byte[] keyCount, byte[]... params) {
    client.setTimeoutInfinite();
    try {
      client.eval(script, keyCount, params);
      return client.getOne();
    } finally {
      client.rollbackTimeout();
    }
  }

  public Object eval(byte[] script, int keyCount, byte[]... params) {
    return eval(script, toByteArray(keyCount), params);
  }

  public Object eval(byte[] script) {
    return eval(script, 0);
  }

  public Object evalsha(byte[] sha1) {
    return evalsha(sha1, 1);
  }

  public Object evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
    return evalsha(sha1, keys.size(), getParams(keys, args));
  }

  public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
    client.setTimeoutInfinite();
    try {
      client.evalsha(sha1, keyCount, params);
      return client.getOne();
    } finally {
      client.rollbackTimeout();
    }
  }

  public String scriptFlush() {
    client.scriptFlush();
    return client.getStatusCodeReply();
  }

  public List<Long> scriptExists(byte[]... sha1) {
    client.scriptExists(sha1);
    return client.getIntegerMultiBulkReply();
  }

  public byte[] scriptLoad(byte[] script) {
    client.scriptLoad(script);
    return client.getBinaryBulkReply();
  }

  public String scriptKill() {
    client.scriptKill();
    return client.getStatusCodeReply();
  }

  public String slowlogReset() {
    client.slowlogReset();
    return client.getBulkReply();
  }

  public Long slowlogLen() {
    client.slowlogLen();
    return client.getIntegerReply();
  }

  public List<byte[]> slowlogGetBinary() {
    client.slowlogGet();
    return client.getBinaryMultiBulkReply();
  }

  public List<byte[]> slowlogGetBinary(long entries) {
    client.slowlogGet(entries);
    return client.getBinaryMultiBulkReply();
  }

  public Long objectRefcount(byte[] key) {
    client.objectRefcount(key);
    return client.getIntegerReply();
  }

  public byte[] objectEncoding(byte[] key) {
    client.objectEncoding(key);
    return client.getBinaryBulkReply();
  }

  public Long objectIdletime(byte[] key) {
    client.objectIdletime(key);
    return client.getIntegerReply();
  }

  public Long bitcount(final byte[] key) {
    client.bitcount(key);
    return client.getIntegerReply();
  }

  public Long bitcount(final byte[] key, long start, long end) {
    client.bitcount(key, start, end);
    return client.getIntegerReply();
  }

  public Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return client.getIntegerReply();
  }

  public byte[] dump(final byte[] key) {
    checkIsInMulti();
    client.dump(key);
    return client.getBinaryBulkReply();
  }

  public String restore(final byte[] key, final int ttl, final byte[] serializedValue) {
    checkIsInMulti();
    client.restore(key, ttl, serializedValue);
    return client.getStatusCodeReply();
  }

  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  public Long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
    checkIsInMulti();
    client.pexpireAt(key, millisecondsTimestamp);
    return client.getIntegerReply();
  }

  public Long pttl(final byte[] key) {
    checkIsInMulti();
    client.pttl(key);
    return client.getIntegerReply();
  }

  public String psetex(final byte[] key, final int milliseconds, final byte[] value) {
    checkIsInMulti();
    client.psetex(key, milliseconds, value);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
    checkIsInMulti();
    client.set(key, value, nxxx);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final int time) {
    checkIsInMulti();
    client.set(key, value, nxxx, expx, time);
    return client.getStatusCodeReply();
  }

  public String clientKill(final byte[] client) {
    checkIsInMulti();
    this.client.clientKill(client);
    return this.client.getStatusCodeReply();
  }

  public String clientGetname() {
    checkIsInMulti();
    client.clientGetname();
    return client.getBulkReply();
  }

  public String clientList() {
    checkIsInMulti();
    client.clientList();
    return client.getBulkReply();
  }

  public String clientSetname(final byte[] name) {
    checkIsInMulti();
    client.clientSetname(name);
    return client.getBulkReply();
  }

  public List<String> time() {
    checkIsInMulti();
    client.time();
    return client.getMultiBulkReply();
  }

  public String migrate(final byte[] host, final int port, final byte[] key,
      final int destinationDb, final int timeout) {
    checkIsInMulti();
    client.migrate(host, port, key, destinationDb, timeout);
    return client.getStatusCodeReply();
  }

  /**
   * Syncrhonous replication of Redis as described here: http://antirez.com/news/66 Since Java
   * Object class has implemented "wait" method, we cannot use it, so I had to change the name of
   * the method. Sorry :S
   */
  public Long waitReplicas(int replicas, long timeout) {
    checkIsInMulti();
    client.waitReplicas(replicas, timeout);
    return client.getIntegerReply();
  }

  @Override
  public Long pfadd(final byte[] key, final byte[]... elements) {
    checkIsInMulti();
    client.pfadd(key, elements);
    return client.getIntegerReply();
  }

  @Override
  public long pfcount(final byte[] key) {
    checkIsInMulti();
    client.pfcount(key);
    return client.getIntegerReply();
  }

  @Override
  public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
    checkIsInMulti();
    client.pfmerge(destkey, sourcekeys);
    return client.getStatusCodeReply();
  }

  @Override
  public Long pfcount(byte[]... keys) {
    checkIsInMulti();
    client.pfcount(keys);
    return client.getIntegerReply();
  }

  public ScanResult<byte[]> scan(final byte[] cursor) {
    return scan(cursor, new ScanParams());
  }

  public ScanResult<byte[]> scan(final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.scan(cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    return new ScanResult<byte[]>(newcursor, rawResults);
  }

  public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key, final byte[] cursor) {
    return hscan(key, cursor, new ScanParams());
  }

  public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key, final byte[] cursor,
      final ScanParams params) {
    checkIsInMulti();
    client.hscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<Map.Entry<byte[], byte[]>> results = new ArrayList<Map.Entry<byte[], byte[]>>();
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    Iterator<byte[]> iterator = rawResults.iterator();
    while (iterator.hasNext()) {
      results.add(new AbstractMap.SimpleEntry<byte[], byte[]>(iterator.next(), iterator.next()));
    }
    return new ScanResult<Map.Entry<byte[], byte[]>>(newcursor, results);
  }

  public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor) {
    return sscan(key, cursor, new ScanParams());
  }

  public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.sscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    return new ScanResult<byte[]>(newcursor, rawResults);
  }

  public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor) {
    return zscan(key, cursor, new ScanParams());
  }

  public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.zscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<Tuple> results = new ArrayList<Tuple>();
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    Iterator<byte[]> iterator = rawResults.iterator();
    while (iterator.hasNext()) {
      results.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
    public Response<Long> append(String key, String value) {
	getClient(key).append(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(byte[] key, byte[] value) {
	getClient(key).append(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> blpop(String key) {
	String[] temp = new String[1];
	temp[0] = key;
	getClient(key).blpop(temp);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(String key) {
	String[] temp = new String[1];
	temp[0] = key;
	getClient(key).brpop(temp);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> blpop(byte[] key) {
	byte[][] temp = new byte[1][];
	temp[0] = key;
	getClient(key).blpop(temp);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<byte[]>> brpop(byte[] key) {
	byte[][] temp = new byte[1][];
	temp[0] = key;
	getClient(key).brpop(temp);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> decr(String key) {
	getClient(key).decr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(byte[] key) {
	getClient(key).decr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(String key, long integer) {
	getClient(key).decrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(byte[] key, long integer) {
	getClient(key).decrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(String key) {
	getClient(key).del(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[] key) {
	getClient(key).del(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> echo(String string) {
	getClient(string).echo(string);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> echo(byte[] string) {
	getClient(string).echo(string);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> exists(String key) {
	getClient(key).exists(key);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> exists(byte[] key) {
	getClient(key).exists(key);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
	getClient(key).expire(key, seconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expire(byte[] key, int seconds) {
	getClient(key).expire(key, seconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
	getClient(key).expireAt(key, unixTime);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(byte[] key, long unixTime) {
	getClient(key).expireAt(key, unixTime);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> get(String key) {
	getClient(key).get(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> get(byte[] key) {
	getClient(key).get(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> getbit(String key, long offset) {
	getClient(key).getbit(key, offset);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> getbit(byte[] key, long offset) {
	getClient(key).getbit(key, offset);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> getrange(String key, long startOffset,
	    long endOffset) {
	getClient(key).getrange(key, startOffset, endOffset);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> getSet(String key, String value) {
	getClient(key).getSet(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> getSet(byte[] key, byte[] value) {
	getClient(key).getSet(key, value);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> getrange(byte[] key, long startOffset, long endOffset) {
	getClient(key).getrange(key, startOffset, endOffset);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(String key, String... field) {
	getClient(key).hdel(key, field);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(byte[] key, byte[]... field) {
	getClient(key).hdel(key, field);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> hexists(String key, String field) {
	getClient(key).hexists(key, field);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> hexists(byte[] key, byte[] field) {
	getClient(key).hexists(key, field);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> hget(String key, String field) {
	getClient(key).hget(key, field);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> hget(byte[] key, byte[] field) {
	getClient(key).hget(key, field);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Map<String, String>> hgetAll(String key) {
	getClient(key).hgetAll(key);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Map<byte[], byte[]>> hgetAll(byte[] key) {
	getClient(key).hgetAll(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_MAP);
    }

    public Response<Long> hincrBy(String key, String field, long value) {
	getClient(key).hincrBy(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
	getClient(key).hincrBy(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> hkeys(String key) {
	getClient(key).hkeys(key);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> hkeys(byte[] key) {
	getClient(key).hkeys(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> hlen(String key) {
	getClient(key).hlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(byte[] key) {
	getClient(key).hlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hmget(String key, String... fields) {
	getClient(key).hmget(key, fields);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> hmget(byte[] key, byte[]... fields) {
	getClient(key).hmget(key, fields);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
	getClient(key).hmset(key, hash);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
	getClient(key).hmset(key, hash);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
	getClient(key).hset(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
	getClient(key).hset(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
	getClient(key).hsetnx(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
	getClient(key).hsetnx(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hvals(String key) {
	getClient(key).hvals(key);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> hvals(byte[] key) {
	getClient(key).hvals(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> incr(String key) {
	getClient(key).incr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incr(byte[] key) {
	getClient(key).incr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, long integer) {
	getClient(key).incrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(byte[] key, long integer) {
	getClient(key).incrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lindex(String key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> lindex(byte[] key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> linsert(String key, LIST_POSITION where,
	    String pivot, String value) {
	getClient(key).linsert(key, where, pivot, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(byte[] key, LIST_POSITION where,
	    byte[] pivot, byte[] value) {
	getClient(key).linsert(key, where, pivot, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
	getClient(key).llen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(byte[] key) {
	getClient(key).llen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
	getClient(key).lpop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> lpop(byte[] key) {
	getClient(key).lpop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> lpush(String key, String... string) {
	getClient(key).lpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(byte[] key, byte[]... string) {
	getClient(key).lpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(String key, String... string) {
	getClient(key).lpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(byte[] key, byte[]... bytes) {
	getClient(key).lpushx(key, bytes);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, long start, long end) {
	getClient(key).lrange(key, start, end);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> lrange(byte[] key, long start, long end) {
	getClient(key).lrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> lrem(String key, long count, String value) {
	getClient(key).lrem(key, count, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lrem(byte[] key, long count, byte[] value) {
	getClient(key).lrem(key, count, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lset(String key, long index, String value) {
	getClient(key).lset(key, index, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(byte[] key, long index, byte[] value) {
	getClient(key).lset(key, index, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(String key, long start, long end) {
	getClient(key).ltrim(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(byte[] key, long start, long end) {
	getClient(key).ltrim(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> move(String key, int dbIndex) {
	getClient(key).move(key, dbIndex);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> move(byte[] key, int dbIndex) {
	getClient(key).move(key, dbIndex);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(String key) {
	getClient(key).persist(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(byte[] key) {
	getClient(key).persist(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpop(String key) {
	getClient(key).rpop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpop(byte[] key) {
	getClient(key).rpop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> rpush(String key, String... string) {
	getClient(key).rpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpush(byte[] key, byte[]... string) {
	getClient(key).rpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(String key, String... string) {
	getClient(key).rpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(byte[] key, byte[]... string) {
	getClient(key).rpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(String key, String... member) {
	getClient(key).sadd(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(byte[] key, byte[]... member) {
	getClient(key).sadd(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(String key) {
	getClient(key).scard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(byte[] key) {
	getClient(key).scard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> set(String key, String value) {
	getClient(key).set(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value) {
	getClient(key).set(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
	getClient(key).setbit(key, offset, value);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> setbit(byte[] key, long offset, byte[] value) {
	getClient(key).setbit(key, offset, value);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> setex(String key, int seconds, String value) {
	getClient(key).setex(key, seconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> setex(byte[] key, int seconds, byte[] value) {
	getClient(key).setex(key, seconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
	getClient(key).setnx(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setnx(byte[] key, byte[] value) {
	getClient(key).setnx(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(String key, long offset, String value) {
	getClient(key).setrange(key, offset, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(byte[] key, long offset, byte[] value) {
	getClient(key).setrange(key, offset, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
	getClient(key).sismember(key, member);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> sismember(byte[] key, byte[] member) {
	getClient(key).sismember(key, member);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Set<String>> smembers(String key) {
	getClient(key).smembers(key);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> smembers(byte[] key) {
	getClient(key).smembers(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> sort(String key) {
	getClient(key).sort(key);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> sort(byte[] key) {
	getClient(key).sort(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> sort(String key,
	    SortingParams sortingParameters) {
	getClient(key).sort(key, sortingParameters);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> sort(byte[] key,
	    SortingParams sortingParameters) {
	getClient(key).sort(key, sortingParameters);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> spop(String key) {
	getClient(key).spop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> spop(byte[] key) {
	getClient(key).spop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> srandmember(String key) {
	getClient(key).srandmember(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> srandmember(String key, int count) {
	getClient(key).srandmember(key, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<byte[]> srandmember(byte[] key) {
	getClient(key).srandmember(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<List<byte[]>> srandmember(byte[] key, int count) {
	getClient(key).srandmember(key, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> srem(String key, String... member) {
	getClient(key).srem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> srem(byte[] key, byte[]... member) {
	getClient(key).srem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(String key) {
	getClient(key).strlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(byte[] key) {
	getClient(key).strlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
	getClient(key).substr(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> substr(byte[] key, int start, int end) {
	getClient(key).substr(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> ttl(String key) {
	getClient(key).ttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(byte[] key) {
	getClient(key).ttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> type(String key) {
	getClient(key).type(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> type(byte[] key) {
	getClient(key).type(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
	getClient(key).zadd(key, score, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(String key, Map<String, Double> scoreMembers) {
	getClient(key).zadd(key, scoreMembers);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(byte[] key, double score, byte[] member) {
	getClient(key).zadd(key, score, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(String key) {
	getClient(key).zcard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(byte[] key) {
	getClient(key).zcard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, double min, double max) {
	getClient(key).zcount(key, min, max);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, String min, String max) {
	getClient(key).zcount(key, min, max);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(byte[] key, double min, double max) {
	getClient(key).zcount(key, toByteArray(min), toByteArray(max));
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
	getClient(key).zincrby(key, score, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zincrby(byte[] key, double score, byte[] member) {
	getClient(key).zincrby(key, score, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Set<String>> zrange(String key, long start, long end) {
	getClient(key).zrange(key, start, end);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrange(byte[] key, long start, long end) {
	getClient(key).zrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
	    double max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, double min,
	    double max) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }

    public Response<Set<String>> zrangeByScore(String key, String min,
	    String max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min,
	    byte[] max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, String min,
	    String max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, double min,
	    double max, int offset, int count) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max), offset,
		count);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min,
	    byte[] max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
	    double max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min,
	    String max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
	    double max) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
	    byte[] max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min,
	    String max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, toByteArray(min),
		toByteArray(max), offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
	    byte[] max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
	    double min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max,
	    double min) {
	getClient(key)
		.zrevrangeByScore(key, toByteArray(max), toByteArray(min));
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
	    String min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max,
	    byte[] min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
	    double min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
	    String min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max,
	    double min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, toByteArray(max),
		toByteArray(min), offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max,
	    byte[] min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    double max, double min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    String max, String min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    double max, double min) {
	getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min));
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    byte[] max, byte[] min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    double max, double min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    String max, String min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    double max, double min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min), offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    byte[] max, byte[] min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, long start,
	    long end) {
	getClient(key).zrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(byte[] key, long start,
	    long end) {
	getClient(key).zrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Long> zrank(String key, String member) {
	getClient(key).zrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrank(byte[] key, byte[] member) {
	getClient(key).zrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(String key, String... member) {
	getClient(key).zrem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(byte[] key, byte[]... member) {
	getClient(key).zrem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(String key, long start, long end) {
	getClient(key).zremrangeByRank(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(byte[] key, long start, long end) {
	getClient(key).zremrangeByRank(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, String start, String end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
	getClient(key).zremrangeByScore(key, toByteArray(start),
		toByteArray(end));
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, long start, long end) {
	getClient(key).zrevrange(key, start, end);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrange(byte[] key, long start, long end) {
	getClient(key).zrevrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, long start,
	    long end) {
	getClient(key).zrevrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start,
	    long end) {
	getClient(key).zrevrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrevrank(String key, String member) {
	getClient(key).zrevrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(byte[] key, byte[] member) {
	getClient(key).zrevrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
	getClient(key).zscore(key, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zscore(byte[] key, byte[] member) {
	getClient(key).zscore(key, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> bitcount(String key) {
	getClient(key).bitcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(String key, long start, long end) {
	getClient(key).bitcount(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(byte[] key) {
	getClient(key).bitcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(byte[] key, long start, long end) {
	getClient(key).bitcount(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<byte[]> dump(String key) {
	getClient(key).dump(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<byte[]> dump(byte[] key) {
	getClient(key).dump(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> migrate(String host, int port, String key,
	    int destinationDb, int timeout) {
	getClient(key).migrate(host, port, key, destinationDb, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> migrate(byte[] host, int port, byte[] key,
	    int destinationDb, int timeout) {
	getClient(key).migrate(host, port, key, destinationDb, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> objectRefcount(String key) {
	getClient(key).objectRefcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> objectRefcount(byte[] key) {
	getClient(key).objectRefcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> objectEncoding(String key) {
	getClient(key).objectEncoding(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> objectEncoding(byte[] key) {
	getClient(key).objectEncoding(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> objectIdletime(String key) {
	getClient(key).objectIdletime(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> objectIdletime(byte[] key) {
	getClient(key).objectIdletime(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpire(String key, int milliseconds) {
	getClient(key).pexpire(key, milliseconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpire(byte[] key, int milliseconds) {
	getClient(key).pexpire(key, milliseconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpireAt(String key, long millisecondsTimestamp) {
	getClient(key).pexpireAt(key, millisecondsTimestamp);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp) {
	getClient(key).pexpireAt(key, millisecondsTimestamp);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pttl(String key) {
	getClient(key).pttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pttl(byte[] key) {
	getClient(key).pttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> restore(String key, int ttl, byte[] serializedValue) {
	getClient(key).restore(key, ttl, serializedValue);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> restore(byte[] key, int ttl, byte[] serializedValue) {
	getClient(key).restore(key, ttl, serializedValue);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Double> incrByFloat(String key, double increment) {
	getClient(key).incrByFloat(key, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double increment) {
	getClient(key).incrByFloat(key, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<String> psetex(String key, int milliseconds, String value) {
	getClient(key).psetex(key, milliseconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> psetex(byte[] key, int milliseconds, byte[] value) {
	getClient(key).psetex(key, milliseconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(String key, String value, String nxxx) {
	getClient(key).set(key, value, nxxx);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value, byte[] nxxx) {
	getClient(key).set(key, value, nxxx);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(String key, String value, String nxxx,
	    String expx, int time) {
	getClient(key).set(key, value, nxxx, expx, time);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value, byte[] nxxx,
	    byte[] expx, int time) {
	getClient(key).set(key, value, nxxx, expx, time);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Double> hincrByFloat(String key, String field,
	    double increment) {
	getClient(key).hincrByFloat(key, field, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> hincrByFloat(byte[] key, byte[] field,
	    double increment) {
	getClient(key).hincrByFloat(key, field, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

||||||| BASE
    public Response<Long> append(String key, String value) {
	getClient(key).append(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(byte[] key, byte[] value) {
	getClient(key).append(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> blpop(String key) {
	String[] temp = new String[1];
	temp[0] = key;
	getClient(key).blpop(temp);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(String key) {
	String[] temp = new String[1];
	temp[0] = key;
	getClient(key).brpop(temp);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> blpop(byte[] key) {
	byte[][] temp = new byte[1][];
	temp[0] = key;
	getClient(key).blpop(temp);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<byte[]>> brpop(byte[] key) {
	byte[][] temp = new byte[1][];
	temp[0] = key;
	getClient(key).brpop(temp);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> decr(String key) {
	getClient(key).decr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(byte[] key) {
	getClient(key).decr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(String key, long integer) {
	getClient(key).decrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(byte[] key, long integer) {
	getClient(key).decrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(String key) {
	getClient(key).del(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[] key) {
	getClient(key).del(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> echo(String string) {
	getClient(string).echo(string);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> echo(byte[] string) {
	getClient(string).echo(string);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> exists(String key) {
	getClient(key).exists(key);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> exists(byte[] key) {
	getClient(key).exists(key);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
	getClient(key).expire(key, seconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expire(byte[] key, int seconds) {
	getClient(key).expire(key, seconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
	getClient(key).expireAt(key, unixTime);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(byte[] key, long unixTime) {
	getClient(key).expireAt(key, unixTime);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> get(String key) {
	getClient(key).get(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> get(byte[] key) {
	getClient(key).get(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> getbit(String key, long offset) {
	getClient(key).getbit(key, offset);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> getbit(byte[] key, long offset) {
	getClient(key).getbit(key, offset);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> getrange(String key, long startOffset,
	    long endOffset) {
	getClient(key).getrange(key, startOffset, endOffset);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> getSet(String key, String value) {
	getClient(key).getSet(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> getSet(byte[] key, byte[] value) {
	getClient(key).getSet(key, value);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> getrange(byte[] key, long startOffset, long endOffset) {
	getClient(key).getrange(key, startOffset, endOffset);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(String key, String... field) {
	getClient(key).hdel(key, field);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(byte[] key, byte[]... field) {
	getClient(key).hdel(key, field);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> hexists(String key, String field) {
	getClient(key).hexists(key, field);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> hexists(byte[] key, byte[] field) {
	getClient(key).hexists(key, field);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> hget(String key, String field) {
	getClient(key).hget(key, field);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> hget(byte[] key, byte[] field) {
	getClient(key).hget(key, field);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Map<String, String>> hgetAll(String key) {
	getClient(key).hgetAll(key);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Map<byte[], byte[]>> hgetAll(byte[] key) {
	getClient(key).hgetAll(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_MAP);
    }

    public Response<Long> hincrBy(String key, String field, long value) {
	getClient(key).hincrBy(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
	getClient(key).hincrBy(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> hkeys(String key) {
	getClient(key).hkeys(key);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> hkeys(byte[] key) {
	getClient(key).hkeys(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> hlen(String key) {
	getClient(key).hlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(byte[] key) {
	getClient(key).hlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hmget(String key, String... fields) {
	getClient(key).hmget(key, fields);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> hmget(byte[] key, byte[]... fields) {
	getClient(key).hmget(key, fields);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
	getClient(key).hmset(key, hash);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
	getClient(key).hmset(key, hash);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
	getClient(key).hset(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
	getClient(key).hset(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
	getClient(key).hsetnx(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
	getClient(key).hsetnx(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hvals(String key) {
	getClient(key).hvals(key);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> hvals(byte[] key) {
	getClient(key).hvals(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> incr(String key) {
	getClient(key).incr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incr(byte[] key) {
	getClient(key).incr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, long integer) {
	getClient(key).incrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(byte[] key, long integer) {
	getClient(key).incrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lindex(String key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> lindex(byte[] key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> linsert(String key, LIST_POSITION where,
	    String pivot, String value) {
	getClient(key).linsert(key, where, pivot, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(byte[] key, LIST_POSITION where,
	    byte[] pivot, byte[] value) {
	getClient(key).linsert(key, where, pivot, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
	getClient(key).llen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(byte[] key) {
	getClient(key).llen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
	getClient(key).lpop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> lpop(byte[] key) {
	getClient(key).lpop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> lpush(String key, String... string) {
	getClient(key).lpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(byte[] key, byte[]... string) {
	getClient(key).lpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(String key, String... string) {
	getClient(key).lpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(byte[] key, byte[]... bytes) {
	getClient(key).lpushx(key, bytes);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, long start, long end) {
	getClient(key).lrange(key, start, end);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> lrange(byte[] key, long start, long end) {
	getClient(key).lrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> lrem(String key, long count, String value) {
	getClient(key).lrem(key, count, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lrem(byte[] key, long count, byte[] value) {
	getClient(key).lrem(key, count, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lset(String key, long index, String value) {
	getClient(key).lset(key, index, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(byte[] key, long index, byte[] value) {
	getClient(key).lset(key, index, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(String key, long start, long end) {
	getClient(key).ltrim(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(byte[] key, long start, long end) {
	getClient(key).ltrim(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> move(String key, int dbIndex) {
	getClient(key).move(key, dbIndex);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> move(byte[] key, int dbIndex) {
	getClient(key).move(key, dbIndex);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(String key) {
	getClient(key).persist(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(byte[] key) {
	getClient(key).persist(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpop(String key) {
	getClient(key).rpop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpop(byte[] key) {
	getClient(key).rpop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> rpush(String key, String... string) {
	getClient(key).rpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpush(byte[] key, byte[]... string) {
	getClient(key).rpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(String key, String... string) {
	getClient(key).rpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(byte[] key, byte[]... string) {
	getClient(key).rpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(String key, String... member) {
	getClient(key).sadd(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(byte[] key, byte[]... member) {
	getClient(key).sadd(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(String key) {
	getClient(key).scard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(byte[] key) {
	getClient(key).scard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> set(String key, String value) {
	getClient(key).set(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value) {
	getClient(key).set(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
	getClient(key).setbit(key, offset, value);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> setbit(byte[] key, long offset, byte[] value) {
	getClient(key).setbit(key, offset, value);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> setex(String key, int seconds, String value) {
	getClient(key).setex(key, seconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> setex(byte[] key, int seconds, byte[] value) {
	getClient(key).setex(key, seconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
	getClient(key).setnx(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setnx(byte[] key, byte[] value) {
	getClient(key).setnx(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(String key, long offset, String value) {
	getClient(key).setrange(key, offset, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(byte[] key, long offset, byte[] value) {
	getClient(key).setrange(key, offset, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
	getClient(key).sismember(key, member);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> sismember(byte[] key, byte[] member) {
	getClient(key).sismember(key, member);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Set<String>> smembers(String key) {
	getClient(key).smembers(key);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> smembers(byte[] key) {
	getClient(key).smembers(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> sort(String key) {
	getClient(key).sort(key);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> sort(byte[] key) {
	getClient(key).sort(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> sort(String key,
	    SortingParams sortingParameters) {
	getClient(key).sort(key, sortingParameters);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> sort(byte[] key,
	    SortingParams sortingParameters) {
	getClient(key).sort(key, sortingParameters);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> spop(String key) {
	getClient(key).spop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> spop(byte[] key) {
	getClient(key).spop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> srandmember(String key) {
	getClient(key).srandmember(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> srandmember(String key, int count) {
	getClient(key).srandmember(key, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<byte[]> srandmember(byte[] key) {
	getClient(key).srandmember(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<List<byte[]>> srandmember(byte[] key, int count) {
	getClient(key).srandmember(key, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> srem(String key, String... member) {
	getClient(key).srem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> srem(byte[] key, byte[]... member) {
	getClient(key).srem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(String key) {
	getClient(key).strlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(byte[] key) {
	getClient(key).strlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
	getClient(key).substr(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> substr(byte[] key, int start, int end) {
	getClient(key).substr(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> ttl(String key) {
	getClient(key).ttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(byte[] key) {
	getClient(key).ttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> type(String key) {
	getClient(key).type(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> type(byte[] key) {
	getClient(key).type(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
	getClient(key).zadd(key, score, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(String key, Map<String, Double> scoreMembers) {
	getClient(key).zadd(key, scoreMembers);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(byte[] key, double score, byte[] member) {
	getClient(key).zadd(key, score, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(String key) {
	getClient(key).zcard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(byte[] key) {
	getClient(key).zcard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, double min, double max) {
	getClient(key).zcount(key, min, max);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, String min, String max) {
	getClient(key).zcount(key, min, max);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(byte[] key, double min, double max) {
	getClient(key).zcount(key, toByteArray(min), toByteArray(max));
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
	getClient(key).zincrby(key, score, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zincrby(byte[] key, double score, byte[] member) {
	getClient(key).zincrby(key, score, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Set<String>> zrange(String key, long start, long end) {
	getClient(key).zrange(key, start, end);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrange(byte[] key, long start, long end) {
	getClient(key).zrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
	    double max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, double min,
	    double max) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }

    public Response<Set<String>> zrangeByScore(String key, String min,
	    String max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min,
	    byte[] max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, String min,
	    String max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, double min,
	    double max, int offset, int count) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max), offset,
		count);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min,
	    byte[] max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
	    double max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min,
	    String max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
	    double max) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
	    byte[] max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min,
	    String max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, toByteArray(min),
		toByteArray(max), offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
	    byte[] max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
	    double min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max,
	    double min) {
	getClient(key)
		.zrevrangeByScore(key, toByteArray(max), toByteArray(min));
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
	    String min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max,
	    byte[] min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
	    double min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
	    String min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max,
	    double min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, toByteArray(max),
		toByteArray(min), offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max,
	    byte[] min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    double max, double min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    String max, String min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    double max, double min) {
	getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min));
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    byte[] max, byte[] min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    double max, double min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    String max, String min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    double max, double min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min), offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    byte[] max, byte[] min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, long start,
	    long end) {
	getClient(key).zrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(byte[] key, long start,
	    long end) {
	getClient(key).zrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Long> zrank(String key, String member) {
	getClient(key).zrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrank(byte[] key, byte[] member) {
	getClient(key).zrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(String key, String... member) {
	getClient(key).zrem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(byte[] key, byte[]... member) {
	getClient(key).zrem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(String key, long start, long end) {
	getClient(key).zremrangeByRank(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(byte[] key, long start, long end) {
	getClient(key).zremrangeByRank(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, String start, String end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
	getClient(key).zremrangeByScore(key, toByteArray(start),
		toByteArray(end));
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, long start, long end) {
	getClient(key).zrevrange(key, start, end);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrange(byte[] key, long start, long end) {
	getClient(key).zrevrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, long start,
	    long end) {
	getClient(key).zrevrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start,
	    long end) {
	getClient(key).zrevrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrevrank(String key, String member) {
	getClient(key).zrevrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(byte[] key, byte[] member) {
	getClient(key).zrevrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
	getClient(key).zscore(key, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zscore(byte[] key, byte[] member) {
	getClient(key).zscore(key, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> bitcount(String key) {
	getClient(key).bitcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(String key, long start, long end) {
	getClient(key).bitcount(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(byte[] key) {
	getClient(key).bitcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(byte[] key, long start, long end) {
	getClient(key).bitcount(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<byte[]> dump(String key) {
	getClient(key).dump(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<byte[]> dump(byte[] key) {
	getClient(key).dump(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> migrate(String host, int port, String key,
	    int destinationDb, int timeout) {
	getClient(key).migrate(host, port, key, destinationDb, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> migrate(byte[] host, int port, byte[] key,
	    int destinationDb, int timeout) {
	getClient(key).migrate(host, port, key, destinationDb, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> objectRefcount(String key) {
	getClient(key).objectRefcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> objectRefcount(byte[] key) {
	getClient(key).objectRefcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> objectEncoding(String key) {
	getClient(key).objectEncoding(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> objectEncoding(byte[] key) {
	getClient(key).objectEncoding(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> objectIdletime(String key) {
	getClient(key).objectIdletime(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> objectIdletime(byte[] key) {
	getClient(key).objectIdletime(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpire(String key, int milliseconds) {
	getClient(key).pexpire(key, milliseconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpire(byte[] key, int milliseconds) {
	getClient(key).pexpire(key, milliseconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpireAt(String key, long millisecondsTimestamp) {
	getClient(key).pexpireAt(key, millisecondsTimestamp);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp) {
	getClient(key).pexpireAt(key, millisecondsTimestamp);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pttl(String key) {
	getClient(key).pttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pttl(byte[] key) {
	getClient(key).pttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> restore(String key, int ttl, byte[] serializedValue) {
	getClient(key).restore(key, ttl, serializedValue);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> restore(byte[] key, int ttl, byte[] serializedValue) {
	getClient(key).restore(key, ttl, serializedValue);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Double> incrByFloat(String key, double increment) {
	getClient(key).incrByFloat(key, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double increment) {
	getClient(key).incrByFloat(key, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<String> psetex(String key, int milliseconds, String value) {
	getClient(key).psetex(key, milliseconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> psetex(byte[] key, int milliseconds, byte[] value) {
	getClient(key).psetex(key, milliseconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(String key, String value, String nxxx) {
	getClient(key).set(key, value, nxxx);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value, byte[] nxxx) {
	getClient(key).set(key, value, nxxx);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(String key, String value, String nxxx,
	    String expx, int time) {
	getClient(key).set(key, value, nxxx, expx, time);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value, byte[] nxxx,
	    byte[] expx, int time) {
	getClient(key).set(key, value, nxxx, expx, time);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Double> hincrByFloat(String key, String field,
	    double increment) {
	getClient(key).hincrByFloat(key, field, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> hincrByFloat(byte[] key, byte[] field,
	    double increment) {
	getClient(key).hincrByFloat(key, field, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<String> eval(String script) {
	return this.eval(script, 0, new String[0]);
    }

    public Response<String> eval(String script, List<String> keys,
	    List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.eval(script, keys.size(), argv);
    }

    public Response<String> eval(String script, int numKeys, String[] argv) {
	getClient(script).eval(script, numKeys, argv);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> evalsha(String script) {
	return this.evalsha(script, 0, new String[0]);
    }

    public Response<String> evalsha(String sha1, List<String> keys,
	    List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.evalsha(sha1, keys.size(), argv);
    }

    public Response<String> evalsha(String sha1, int numKeys, String[] argv) {
	getClient(sha1).evalsha(sha1, numKeys, argv);
	return getResponse(BuilderFactory.STRING);
    }

=======
  public Response<Long> append(String key, String value) {
    getClient(key).append(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> append(byte[] key, byte[] value) {
    getClient(key).append(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> blpop(String key) {
    String[] temp = new String[1];
    temp[0] = key;
    getClient(key).blpop(temp);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(String key) {
    String[] temp = new String[1];
    temp[0] = key;
    getClient(key).brpop(temp);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> blpop(byte[] key) {
    byte[][] temp = new byte[1][];
    temp[0] = key;
    getClient(key).blpop(temp);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<byte[]>> brpop(byte[] key) {
    byte[][] temp = new byte[1][];
    temp[0] = key;
    getClient(key).brpop(temp);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> decr(String key) {
    getClient(key).decr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> decr(byte[] key) {
    getClient(key).decr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> decrBy(String key, long integer) {
    getClient(key).decrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> decrBy(byte[] key, long integer) {
    getClient(key).decrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(String key) {
    getClient(key).del(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[] key) {
    getClient(key).del(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> echo(String string) {
    getClient(string).echo(string);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> echo(byte[] string) {
    getClient(string).echo(string);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Boolean> exists(String key) {
    getClient(key).exists(key);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> exists(byte[] key) {
    getClient(key).exists(key);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Long> expire(String key, int seconds) {
    getClient(key).expire(key, seconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> expire(byte[] key, int seconds) {
    getClient(key).expire(key, seconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> expireAt(String key, long unixTime) {
    getClient(key).expireAt(key, unixTime);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> expireAt(byte[] key, long unixTime) {
    getClient(key).expireAt(key, unixTime);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> get(String key) {
    getClient(key).get(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> get(byte[] key) {
    getClient(key).get(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Boolean> getbit(String key, long offset) {
    getClient(key).getbit(key, offset);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> getbit(byte[] key, long offset) {
    getClient(key).getbit(key, offset);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Long> bitpos(final String key, final boolean value) {
    return bitpos(key, value, new BitPosParams());
  }

  public Response<Long> bitpos(final String key, final boolean value, final BitPosParams params) {
    getClient(key).bitpos(key, value, params);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitpos(final byte[] key, final boolean value) {
    return bitpos(key, value, new BitPosParams());
  }

  public Response<Long> bitpos(final byte[] key, final boolean value, final BitPosParams params) {
    getClient(key).bitpos(key, value, params);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> getrange(String key, long startOffset, long endOffset) {
    getClient(key).getrange(key, startOffset, endOffset);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> getSet(String key, String value) {
    getClient(key).getSet(key, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> getSet(byte[] key, byte[] value) {
    getClient(key).getSet(key, value);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<byte[]> getrange(byte[] key, long startOffset, long endOffset) {
    getClient(key).getrange(key, startOffset, endOffset);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> hdel(String key, String... field) {
    getClient(key).hdel(key, field);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hdel(byte[] key, byte[]... field) {
    getClient(key).hdel(key, field);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Boolean> hexists(String key, String field) {
    getClient(key).hexists(key, field);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> hexists(byte[] key, byte[] field) {
    getClient(key).hexists(key, field);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<String> hget(String key, String field) {
    getClient(key).hget(key, field);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> hget(byte[] key, byte[] field) {
    getClient(key).hget(key, field);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Map<String, String>> hgetAll(String key) {
    getClient(key).hgetAll(key);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<Map<byte[], byte[]>> hgetAll(byte[] key) {
    getClient(key).hgetAll(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_MAP);
  }

  public Response<Long> hincrBy(String key, String field, long value) {
    getClient(key).hincrBy(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
    getClient(key).hincrBy(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> hkeys(String key) {
    getClient(key).hkeys(key);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> hkeys(byte[] key) {
    getClient(key).hkeys(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> hlen(String key) {
    getClient(key).hlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hlen(byte[] key) {
    getClient(key).hlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> hmget(String key, String... fields) {
    getClient(key).hmget(key, fields);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> hmget(byte[] key, byte[]... fields) {
    getClient(key).hmget(key, fields);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> hmset(String key, Map<String, String> hash) {
    getClient(key).hmset(key, hash);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
    getClient(key).hmset(key, hash);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> hset(String key, String field, String value) {
    getClient(key).hset(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
    getClient(key).hset(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hsetnx(String key, String field, String value) {
    getClient(key).hsetnx(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
    getClient(key).hsetnx(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> hvals(String key) {
    getClient(key).hvals(key);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> hvals(byte[] key) {
    getClient(key).hvals(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> incr(String key) {
    getClient(key).incr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> incr(byte[] key) {
    getClient(key).incr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> incrBy(String key, long integer) {
    getClient(key).incrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> incrBy(byte[] key, long integer) {
    getClient(key).incrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> lindex(String key, long index) {
    getClient(key).lindex(key, index);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> lindex(byte[] key, long index) {
    getClient(key).lindex(key, index);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> linsert(String key, LIST_POSITION where, String pivot, String value) {
    getClient(key).linsert(key, where, pivot, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> linsert(byte[] key, LIST_POSITION where, byte[] pivot, byte[] value) {
    getClient(key).linsert(key, where, pivot, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> llen(String key) {
    getClient(key).llen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> llen(byte[] key) {
    getClient(key).llen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> lpop(String key) {
    getClient(key).lpop(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> lpop(byte[] key) {
    getClient(key).lpop(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> lpush(String key, String... string) {
    getClient(key).lpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lpush(byte[] key, byte[]... string) {
    getClient(key).lpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lpushx(String key, String... string) {
    getClient(key).lpushx(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lpushx(byte[] key, byte[]... bytes) {
    getClient(key).lpushx(key, bytes);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> lrange(String key, long start, long end) {
    getClient(key).lrange(key, start, end);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> lrange(byte[] key, long start, long end) {
    getClient(key).lrange(key, start, end);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> lrem(String key, long count, String value) {
    getClient(key).lrem(key, count, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lrem(byte[] key, long count, byte[] value) {
    getClient(key).lrem(key, count, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> lset(String key, long index, String value) {
    getClient(key).lset(key, index, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> lset(byte[] key, long index, byte[] value) {
    getClient(key).lset(key, index, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ltrim(String key, long start, long end) {
    getClient(key).ltrim(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ltrim(byte[] key, long start, long end) {
    getClient(key).ltrim(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> move(String key, int dbIndex) {
    getClient(key).move(key, dbIndex);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> move(byte[] key, int dbIndex) {
    getClient(key).move(key, dbIndex);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> persist(String key) {
    getClient(key).persist(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> persist(byte[] key) {
    getClient(key).persist(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpop(String key) {
    getClient(key).rpop(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpop(byte[] key) {
    getClient(key).rpop(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> rpush(String key, String... string) {
    getClient(key).rpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> rpush(byte[] key, byte[]... string) {
    getClient(key).rpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> rpushx(String key, String... string) {
    getClient(key).rpushx(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> rpushx(byte[] key, byte[]... string) {
    getClient(key).rpushx(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sadd(String key, String... member) {
    getClient(key).sadd(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sadd(byte[] key, byte[]... member) {
    getClient(key).sadd(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> scard(String key) {
    getClient(key).scard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> scard(byte[] key) {
    getClient(key).scard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> set(String key, String value) {
    getClient(key).set(key, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(byte[] key, byte[] value) {
    getClient(key).set(key, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Boolean> setbit(String key, long offset, boolean value) {
    getClient(key).setbit(key, offset, value);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> setbit(byte[] key, long offset, byte[] value) {
    getClient(key).setbit(key, offset, value);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<String> setex(String key, int seconds, String value) {
    getClient(key).setex(key, seconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> setex(byte[] key, int seconds, byte[] value) {
    getClient(key).setex(key, seconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> setnx(String key, String value) {
    getClient(key).setnx(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> setnx(byte[] key, byte[] value) {
    getClient(key).setnx(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> setrange(String key, long offset, String value) {
    getClient(key).setrange(key, offset, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> setrange(byte[] key, long offset, byte[] value) {
    getClient(key).setrange(key, offset, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Boolean> sismember(String key, String member) {
    getClient(key).sismember(key, member);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> sismember(byte[] key, byte[] member) {
    getClient(key).sismember(key, member);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Set<String>> smembers(String key) {
    getClient(key).smembers(key);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> smembers(byte[] key) {
    getClient(key).smembers(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> sort(String key) {
    getClient(key).sort(key);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> sort(byte[] key) {
    getClient(key).sort(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> sort(String key, SortingParams sortingParameters) {
    getClient(key).sort(key, sortingParameters);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> sort(byte[] key, SortingParams sortingParameters) {
    getClient(key).sort(key, sortingParameters);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> spop(String key) {
    getClient(key).spop(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> spop(byte[] key) {
    getClient(key).spop(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> srandmember(String key) {
    getClient(key).srandmember(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> srandmember(String key, int count) {
    getClient(key).srandmember(key, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<byte[]> srandmember(byte[] key) {
    getClient(key).srandmember(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<List<byte[]>> srandmember(byte[] key, int count) {
    getClient(key).srandmember(key, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> srem(String key, String... member) {
    getClient(key).srem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> srem(byte[] key, byte[]... member) {
    getClient(key).srem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> strlen(String key) {
    getClient(key).strlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> strlen(byte[] key) {
    getClient(key).strlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> substr(String key, int start, int end) {
    getClient(key).substr(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> substr(byte[] key, int start, int end) {
    getClient(key).substr(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> ttl(String key) {
    getClient(key).ttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> ttl(byte[] key) {
    getClient(key).ttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> type(String key) {
    getClient(key).type(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> type(byte[] key) {
    getClient(key).type(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zadd(String key, double score, String member) {
    getClient(key).zadd(key, score, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zadd(String key, Map<String, Double> scoreMembers) {
    getClient(key).zadd(key, scoreMembers);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zadd(byte[] key, double score, byte[] member) {
    getClient(key).zadd(key, score, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcard(String key) {
    getClient(key).zcard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcard(byte[] key) {
    getClient(key).zcard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcount(String key, double min, double max) {
    getClient(key).zcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcount(String key, String min, String max) {
    getClient(key).zcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcount(byte[] key, double min, double max) {
    getClient(key).zcount(key, toByteArray(min), toByteArray(max));
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Double> zincrby(String key, double score, String member) {
    getClient(key).zincrby(key, score, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> zincrby(byte[] key, double score, byte[] member) {
    getClient(key).zincrby(key, score, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Set<String>> zrange(String key, long start, long end) {
    getClient(key).zrange(key, start, end);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrange(byte[] key, long start, long end) {
    getClient(key).zrange(key, start, end);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrangeByScore(String key, double min, double max) {
    getClient(key).zrangeByScore(key, min, max);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max));
  }

  public Response<Set<String>> zrangeByScore(String key, String min, String max) {
    getClient(key).zrangeByScore(key, min, max);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max) {
    getClient(key).zrangeByScore(key, min, max);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrangeByScore(String key, double min, double max, int offset,
      int count) {
    getClient(key).zrangeByScore(key, min, max, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<String>> zrangeByScore(String key, String min, String max, int offset,
      int count) {
    getClient(key).zrangeByScore(key, min, max, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset,
      int count) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset,
      int count) {
    getClient(key).zrangeByScore(key, min, max, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max) {
    getClient(key).zrangeByScoreWithScores(key, min, max);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min, String max) {
    getClient(key).zrangeByScoreWithScores(key, min, max);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max) {
    getClient(key).zrangeByScoreWithScores(key, min, max);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min, String max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<String>> zrevrangeByScore(String key, double max, double min) {
    getClient(key).zrevrangeByScore(key, max, min);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min) {
    getClient(key).zrevrangeByScore(key, toByteArray(max), toByteArray(min));
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrevrangeByScore(String key, String max, String min) {
    getClient(key).zrevrangeByScore(key, max, min);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
    getClient(key).zrevrangeByScore(key, max, min);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrevrangeByScore(String key, double max, double min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, max, min, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<String>> zrevrangeByScore(String key, String max, String min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, max, min, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, max, min, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min) {
    getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset,
      count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrangeWithScores(String key, long start, long end) {
    getClient(key).zrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeWithScores(byte[] key, long start, long end) {
    getClient(key).zrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Long> zrank(String key, String member) {
    getClient(key).zrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrank(byte[] key, byte[] member) {
    getClient(key).zrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrem(String key, String... member) {
    getClient(key).zrem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrem(byte[] key, byte[]... member) {
    getClient(key).zrem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByRank(String key, long start, long end) {
    getClient(key).zremrangeByRank(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByRank(byte[] key, long start, long end) {
    getClient(key).zremrangeByRank(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(String key, double start, double end) {
    getClient(key).zremrangeByScore(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(String key, String start, String end) {
    getClient(key).zremrangeByScore(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
    getClient(key).zremrangeByScore(key, toByteArray(start), toByteArray(end));
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
    getClient(key).zremrangeByScore(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> zrevrange(String key, long start, long end) {
    getClient(key).zrevrange(key, start, end);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrange(byte[] key, long start, long end) {
    getClient(key).zrevrange(key, start, end);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeWithScores(String key, long start, long end) {
    getClient(key).zrevrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start, long end) {
    getClient(key).zrevrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Long> zrevrank(String key, String member) {
    getClient(key).zrevrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrevrank(byte[] key, byte[] member) {
    getClient(key).zrevrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Double> zscore(String key, String member) {
    getClient(key).zscore(key, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> zscore(byte[] key, byte[] member) {
    getClient(key).zscore(key, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  @Override
  public Response<Long> zlexcount(final byte[] key, final byte[] min, final byte[] max) {
    getClient(key).zlexcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> zlexcount(final String key, final String min, final String max) {
    getClient(key).zlexcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    getClient(key).zrangeByLex(key, min, max);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrangeByLex(final String key, final String min, final String max) {
    getClient(key).zrangeByLex(key, min, max);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    getClient(key).zrangeByLex(key, min, max, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrangeByLex(final String key, final String min, final String max,
      final int offset, final int count) {
    getClient(key).zrangeByLex(key, min, max, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min) {
    getClient(key).zrevrangeByLex(key, max, min);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrevrangeByLex(final String key, final String max, final String min) {
    getClient(key).zrevrangeByLex(key, max, min);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
      final int offset, final int count) {
    getClient(key).zrevrangeByLex(key, max, min, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count) {
    getClient(key).zrevrangeByLex(key, max, min, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Long> zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    getClient(key).zremrangeByLex(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> zremrangeByLex(final String key, final String min, final String max) {
    getClient(key).zremrangeByLex(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(String key) {
    getClient(key).bitcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(String key, long start, long end) {
    getClient(key).bitcount(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(byte[] key) {
    getClient(key).bitcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(byte[] key, long start, long end) {
    getClient(key).bitcount(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<byte[]> dump(String key) {
    getClient(key).dump(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<byte[]> dump(byte[] key) {
    getClient(key).dump(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> migrate(String host, int port, String key, int destinationDb, int timeout) {
    getClient(key).migrate(host, port, key, destinationDb, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> migrate(byte[] host, int port, byte[] key, int destinationDb, int timeout) {
    getClient(key).migrate(host, port, key, destinationDb, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> objectRefcount(String key) {
    getClient(key).objectRefcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> objectRefcount(byte[] key) {
    getClient(key).objectRefcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> objectEncoding(String key) {
    getClient(key).objectEncoding(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> objectEncoding(byte[] key) {
    getClient(key).objectEncoding(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> objectIdletime(String key) {
    getClient(key).objectIdletime(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> objectIdletime(byte[] key) {
    getClient(key).objectIdletime(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpire(String key, long milliseconds) {
    getClient(key).pexpire(key, milliseconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpire(byte[] key, long milliseconds) {
    getClient(key).pexpire(key, milliseconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpireAt(String key, long millisecondsTimestamp) {
    getClient(key).pexpireAt(key, millisecondsTimestamp);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp) {
    getClient(key).pexpireAt(key, millisecondsTimestamp);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pttl(String key) {
    getClient(key).pttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pttl(byte[] key) {
    getClient(key).pttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> restore(String key, int ttl, byte[] serializedValue) {
    getClient(key).restore(key, ttl, serializedValue);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> restore(byte[] key, int ttl, byte[] serializedValue) {
    getClient(key).restore(key, ttl, serializedValue);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Double> incrByFloat(String key, double increment) {
    getClient(key).incrByFloat(key, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> incrByFloat(byte[] key, double increment) {
    getClient(key).incrByFloat(key, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<String> psetex(String key, int milliseconds, String value) {
    getClient(key).psetex(key, milliseconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> psetex(byte[] key, int milliseconds, byte[] value) {
    getClient(key).psetex(key, milliseconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(String key, String value, String nxxx) {
    getClient(key).set(key, value, nxxx);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(byte[] key, byte[] value, byte[] nxxx) {
    getClient(key).set(key, value, nxxx);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(String key, String value, String nxxx, String expx, int time) {
    getClient(key).set(key, value, nxxx, expx, time);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, int time) {
    getClient(key).set(key, value, nxxx, expx, time);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Double> hincrByFloat(String key, String field, double increment) {
    getClient(key).hincrByFloat(key, field, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> hincrByFloat(byte[] key, byte[] field, double increment) {
    getClient(key).hincrByFloat(key, field, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<String> eval(String script) {
    return this.eval(script, 0);
  }

  public Response<String> eval(String script, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<String> eval(String script, int numKeys, String... args) {
    getClient(script).eval(script, numKeys, args);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> evalsha(String script) {
    return this.evalsha(script, 0);
  }

  public Response<String> evalsha(String sha1, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<String> evalsha(String sha1, int numKeys, String... args) {
    getClient(sha1).evalsha(sha1, numKeys, args);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<Long> pfadd(byte[] key, byte[]... elements) {
    getClient(key).pfadd(key, elements);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(byte[] key) {
    getClient(key).pfcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfadd(String key, String... elements) {
    getClient(key).pfadd(key, elements);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(String key) {
    getClient(key).pfcount(key);
    return getResponse(BuilderFactory.LONG);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/BuilderFactory.java;<<<<<<< MINE
    public static final Builder<Double> DOUBLE = new Builder<Double>() {
	public Double build(Object data) {
	    String asString = STRING.build(data);
	    return asString == null ? null : Double.valueOf(asString);
	}

	public String toString() {
	    return "double";
	}
    };
    
    public static final Builder<Boolean> BOOLEAN = new Builder<Boolean>() {
	public Boolean build(Object data) {
	    return ((Long) data) == 1;
	}

	public String toString() {
	    return "boolean";
	}
    };
    
    public static final Builder<byte[]> BYTE_ARRAY = new Builder<byte[]>() {
	public byte[] build(Object data) {
	    return ((byte[]) data); // deleted == 1
	}

	public String toString() {
	    return "byte[]";
	}
    };

    public static final Builder<Long> LONG = new Builder<Long>() {
	public Long build(Object data) {
	    return (Long) data;
	}

	public String toString() {
	    return "long";
	}

    };
    
    public static final Builder<String> STRING = new Builder<String>() {
	public String build(Object data) {
	    return data == null ? null : SafeEncoder.encode((byte[]) data);
	}

	public String toString() {
	    return "string";
	}

    };
    
    public static final Builder<List<String>> STRING_LIST = new Builder<List<String>>() {
	@SuppressWarnings("unchecked")
	public List<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final ArrayList<String> result = new ArrayList<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "List<String>";
	}

    };
    
    public static final Builder<Map<String, String>> STRING_MAP = new Builder<Map<String, String>>() {
	@SuppressWarnings("unchecked")
	public Map<String, String> build(Object data) {
	    final List<byte[]> flatHash = (List<byte[]>) data;
	    final Map<String, String> hash = new HashMap<String, String>();
	    final Iterator<byte[]> iterator = flatHash.iterator();
	    while (iterator.hasNext()) {
		hash.put(SafeEncoder.encode(iterator.next()),
			SafeEncoder.encode(iterator.next()));
	    }

	    return hash;
	}

	public String toString() {
	    return "Map<String, String>";
	}

    };

    public static final Builder<Set<String>> STRING_SET = new Builder<Set<String>>() {
	@SuppressWarnings("unchecked")
	public Set<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<String> result = new HashSet<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "Set<String>";
	}

    };

    public static final Builder<List<byte[]>> BYTE_ARRAY_LIST = new Builder<List<byte[]>>() {
	@SuppressWarnings("unchecked")
	public List<byte[]> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;

	    return l;
	}

	public String toString() {
	    return "List<byte[]>";
	}
    };

    public static final Builder<Set<byte[]>> BYTE_ARRAY_ZSET = new Builder<Set<byte[]>>() {
	@SuppressWarnings("unchecked")
	public Set<byte[]> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<byte[]> result = new LinkedHashSet<byte[]>(l);
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(barray);
		}
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<byte[]>";
	}
    };
    
    public static final Builder<Map<byte[], byte[]>> BYTE_ARRAY_MAP = new Builder<Map<byte[], byte[]>>() {
	@SuppressWarnings("unchecked")
	public Map<byte[], byte[]> build(Object data) {
	    final List<byte[]> flatHash = (List<byte[]>) data;
	    final Map<byte[], byte[]> hash = new HashMap<byte[], byte[]>();
	    final Iterator<byte[]> iterator = flatHash.iterator();
	    while (iterator.hasNext()) {
		hash.put(iterator.next(), iterator.next());
	    }

	    return hash;
	}

	public String toString() {
	    return "Map<byte[], byte[]>";
	}

    };

    public static final Builder<Set<String>> STRING_ZSET = new Builder<Set<String>>() {
	@SuppressWarnings("unchecked")
	public Set<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<String> result = new LinkedHashSet<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<String>";
	}

    };

    public static final Builder<Set<Tuple>> TUPLE_ZSET = new Builder<Set<Tuple>>() {
	@SuppressWarnings("unchecked")
	public Set<Tuple> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
	    Iterator<byte[]> iterator = l.iterator();
	    while (iterator.hasNext()) {
		result.add(new Tuple(SafeEncoder.encode(iterator.next()),
			Double.valueOf(SafeEncoder.encode(iterator.next()))));
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<Tuple>";
	}

    };

    public static final Builder<Set<Tuple>> TUPLE_ZSET_BINARY = new Builder<Set<Tuple>>() {
	@SuppressWarnings("unchecked")
	public Set<Tuple> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
	    Iterator<byte[]> iterator = l.iterator();
	    while (iterator.hasNext()) {
		result.add(new Tuple(iterator.next(), Double
			.valueOf(SafeEncoder.encode(iterator.next()))));
	    }

	    return result;

	}

	public String toString() {
	    return "ZSet<Tuple>";
	}
    };
||||||| BASE
    public static final Builder<Double> DOUBLE = new Builder<Double>() {
	public Double build(Object data) {
	    String asString = STRING.build(data);
	    return asString == null ? null : Double.valueOf(asString);
	}

	public String toString() {
	    return "double";
	}
    };
    public static final Builder<Boolean> BOOLEAN = new Builder<Boolean>() {
	public Boolean build(Object data) {
	    return ((Long) data) == 1;
	}

	public String toString() {
	    return "boolean";
	}
    };
    public static final Builder<byte[]> BYTE_ARRAY = new Builder<byte[]>() {
	public byte[] build(Object data) {
	    return ((byte[]) data); // deleted == 1
	}

	public String toString() {
	    return "byte[]";
	}
    };

    public static final Builder<Long> LONG = new Builder<Long>() {
	public Long build(Object data) {
	    return (Long) data;
	}

	public String toString() {
	    return "long";
	}

    };
    public static final Builder<String> STRING = new Builder<String>() {
	public String build(Object data) {
	    return data == null ? null : SafeEncoder.encode((byte[]) data);
	}

	public String toString() {
	    return "string";
	}

    };
    public static final Builder<List<String>> STRING_LIST = new Builder<List<String>>() {
	@SuppressWarnings("unchecked")
	public List<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final ArrayList<String> result = new ArrayList<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "List<String>";
	}

    };
    public static final Builder<Map<String, String>> STRING_MAP = new Builder<Map<String, String>>() {
	@SuppressWarnings("unchecked")
	public Map<String, String> build(Object data) {
	    final List<byte[]> flatHash = (List<byte[]>) data;
	    final Map<String, String> hash = new HashMap<String, String>();
	    final Iterator<byte[]> iterator = flatHash.iterator();
	    while (iterator.hasNext()) {
		hash.put(SafeEncoder.encode(iterator.next()),
			SafeEncoder.encode(iterator.next()));
	    }

	    return hash;
	}

	public String toString() {
	    return "Map<String, String>";
	}

    };
    
    public static final Builder<Set<String>> STRING_SET = new Builder<Set<String>>() {
	@SuppressWarnings("unchecked")
	public Set<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<String> result = new HashSet<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "Set<String>";
	}

    };

    public static final Builder<List<byte[]>> BYTE_ARRAY_LIST = new Builder<List<byte[]>>() {
	@SuppressWarnings("unchecked")
	public List<byte[]> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;

	    return l;
	}

	public String toString() {
	    return "List<byte[]>";
	}
    };

    public static final Builder<Set<byte[]>> BYTE_ARRAY_ZSET = new Builder<Set<byte[]>>() {
	@SuppressWarnings("unchecked")
	public Set<byte[]> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<byte[]> result = new LinkedHashSet<byte[]>(l);
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(barray);
		}
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<byte[]>";
	}
    };
    public static final Builder<Map<byte[], byte[]>> BYTE_ARRAY_MAP = new Builder<Map<byte[], byte[]>>() {
	@SuppressWarnings("unchecked")
	public Map<byte[], byte[]> build(Object data) {
	    final List<byte[]> flatHash = (List<byte[]>) data;
	    final Map<byte[], byte[]> hash = new HashMap<byte[], byte[]>();
	    final Iterator<byte[]> iterator = flatHash.iterator();
	    while (iterator.hasNext()) {
		hash.put(iterator.next(), iterator.next());
	    }

	    return hash;
	}

	public String toString() {
	    return "Map<byte[], byte[]>";
	}

    };

    public static final Builder<Set<String>> STRING_ZSET = new Builder<Set<String>>() {
	@SuppressWarnings("unchecked")
	public Set<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<String> result = new LinkedHashSet<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<String>";
	}

    };

    public static final Builder<Set<Tuple>> TUPLE_ZSET = new Builder<Set<Tuple>>() {
	@SuppressWarnings("unchecked")
	public Set<Tuple> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
	    Iterator<byte[]> iterator = l.iterator();
	    while (iterator.hasNext()) {
		result.add(new Tuple(SafeEncoder.encode(iterator.next()),
			Double.valueOf(SafeEncoder.encode(iterator.next()))));
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<Tuple>";
	}

    };

    public static final Builder<Set<Tuple>> TUPLE_ZSET_BINARY = new Builder<Set<Tuple>>() {
	@SuppressWarnings("unchecked")
	public Set<Tuple> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
	    Iterator<byte[]> iterator = l.iterator();
	    while (iterator.hasNext()) {
		result.add(new Tuple(iterator.next(), Double
			.valueOf(SafeEncoder.encode(iterator.next()))));
	    }

	    return result;

	}

	public String toString() {
	    return "ZSet<Tuple>";
	}
    };
=======
  public static final Builder<Double> DOUBLE = new Builder<Double>() {
    public Double build(Object data) {
      String asString = STRING.build(data);
      return asString == null ? null : Double.valueOf(asString);
    }

    public String toString() {
      return "double";
    }
  };
  public static final Builder<Boolean> BOOLEAN = new Builder<Boolean>() {
    public Boolean build(Object data) {
      return ((Long) data) == 1;
    }

    public String toString() {
      return "boolean";
    }
  };
  public static final Builder<byte[]> BYTE_ARRAY = new Builder<byte[]>() {
    public byte[] build(Object data) {
      return ((byte[]) data); // deleted == 1
    }

    public String toString() {
      return "byte[]";
    }
  };

  public static final Builder<Long> LONG = new Builder<Long>() {
    public Long build(Object data) {
      return (Long) data;
    }

    public String toString() {
      return "long";
    }

  };
  public static final Builder<String> STRING = new Builder<String>() {
    public String build(Object data) {
      return data == null ? null : SafeEncoder.encode((byte[]) data);
    }

    public String toString() {
      return "string";
    }

  };
  public static final Builder<List<String>> STRING_LIST = new Builder<List<String>>() {
    @SuppressWarnings("unchecked")
    public List<String> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final ArrayList<String> result = new ArrayList<String>(l.size());
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(SafeEncoder.encode(barray));
        }
      }
      return result;
    }

    public String toString() {
      return "List<String>";
    }

  };
  public static final Builder<Map<String, String>> STRING_MAP = new Builder<Map<String, String>>() {
    @SuppressWarnings("unchecked")
    public Map<String, String> build(Object data) {
      final List<byte[]> flatHash = (List<byte[]>) data;
      final Map<String, String> hash = new HashMap<String, String>();
      final Iterator<byte[]> iterator = flatHash.iterator();
      while (iterator.hasNext()) {
        hash.put(SafeEncoder.encode(iterator.next()), SafeEncoder.encode(iterator.next()));
      }

      return hash;
    }

    public String toString() {
      return "Map<String, String>";
    }

  };

  public static final Builder<Map<String, String>> PUBSUB_NUMSUB_MAP = new Builder<Map<String, String>>() {
    @SuppressWarnings("unchecked")
    public Map<String, String> build(Object data) {
      final List<Object> flatHash = (List<Object>) data;
      final Map<String, String> hash = new HashMap<String, String>();
      final Iterator<Object> iterator = flatHash.iterator();
      while (iterator.hasNext()) {
        hash.put(SafeEncoder.encode((byte[]) iterator.next()),
          String.valueOf((Long) iterator.next()));
      }

      return hash;
    }

    public String toString() {
      return "PUBSUB_NUMSUB_MAP<String, String>";
    }

  };

  public static final Builder<Set<String>> STRING_SET = new Builder<Set<String>>() {
    @SuppressWarnings("unchecked")
    public Set<String> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<String> result = new HashSet<String>(l.size());
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(SafeEncoder.encode(barray));
        }
      }
      return result;
    }

    public String toString() {
      return "Set<String>";
    }

  };

  public static final Builder<List<byte[]>> BYTE_ARRAY_LIST = new Builder<List<byte[]>>() {
    @SuppressWarnings("unchecked")
    public List<byte[]> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;

      return l;
    }

    public String toString() {
      return "List<byte[]>";
    }
  };

  public static final Builder<Set<byte[]>> BYTE_ARRAY_ZSET = new Builder<Set<byte[]>>() {
    @SuppressWarnings("unchecked")
    public Set<byte[]> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<byte[]> result = new LinkedHashSet<byte[]>(l);
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(barray);
        }
      }
      return result;
    }

    public String toString() {
      return "ZSet<byte[]>";
    }
  };
  public static final Builder<Map<byte[], byte[]>> BYTE_ARRAY_MAP = new Builder<Map<byte[], byte[]>>() {
    @SuppressWarnings("unchecked")
    public Map<byte[], byte[]> build(Object data) {
      final List<byte[]> flatHash = (List<byte[]>) data;
      final Map<byte[], byte[]> hash = new JedisByteHashMap();
      final Iterator<byte[]> iterator = flatHash.iterator();
      while (iterator.hasNext()) {
        hash.put(iterator.next(), iterator.next());
      }

      return hash;
    }

    public String toString() {
      return "Map<byte[], byte[]>";
    }

  };

  public static final Builder<Set<String>> STRING_ZSET = new Builder<Set<String>>() {
    @SuppressWarnings("unchecked")
    public Set<String> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<String> result = new LinkedHashSet<String>(l.size());
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(SafeEncoder.encode(barray));
        }
      }
      return result;
    }

    public String toString() {
      return "ZSet<String>";
    }

  };

  public static final Builder<Set<Tuple>> TUPLE_ZSET = new Builder<Set<Tuple>>() {
    @SuppressWarnings("unchecked")
    public Set<Tuple> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
      Iterator<byte[]> iterator = l.iterator();
      while (iterator.hasNext()) {
        result.add(new Tuple(SafeEncoder.encode(iterator.next()), Double.valueOf(SafeEncoder
            .encode(iterator.next()))));
      }
      return result;
    }

    public String toString() {
      return "ZSet<Tuple>";
    }

  };

  public static final Builder<Set<Tuple>> TUPLE_ZSET_BINARY = new Builder<Set<Tuple>>() {
    @SuppressWarnings("unchecked")
    public Set<Tuple> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
      Iterator<byte[]> iterator = l.iterator();
      while (iterator.hasNext()) {
        result.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
      }

      return result;

    }

    public String toString() {
      return "ZSet<Tuple>";
    }
  };
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/MultiKeyPipelineBase.java;<<<<<<< MINE
abstract class MultiKeyPipelineBase extends PipelineBase implements
	MultiKeyBinaryRedisPipeline, MultiKeyCommandsPipeline, 
	ClusterPipeline, BinaryScriptingCommandsPipeline, ScriptingCommandsPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }
    
    public Response<Object> eval(String script) {
	return this.eval(script, 0, new String[0]);
    }

    public Response<Object> eval(String script, List<String> keys,
	    List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.eval(script, keys.size(), argv);
    }
    
    public Response<Object> eval(String script, int keyCount, String... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_RESULT);
    }

    public Response<Object> evalsha(String script) {
	return this.evalsha(script, 0, new String[0]);
    }

    public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.evalsha(sha1, keys.size(), argv);
    }

    public Response<Object> evalsha(String sha1, int keyCount, String... params) {
	getClient(sha1).evalsha(sha1, keyCount, params);
	return getResponse(BuilderFactory.EVAL_RESULT);
    }

    public Response<Object> eval(byte[] script) {
	return this.eval(script, 0);
    }
    
    public Response<Object> eval(byte[] script, byte[] keyCount, byte[]... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
    
    public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
	return this.eval(script, keys.size(), argv);
    }
    
    public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
    
    public Response<Object> evalsha(byte[] sha1) {
	return this.evalsha(sha1, 0);
    }
    
    public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
	byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
	return this.evalsha(sha1, keys.size(), argv);
    }
    
    public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
	getClient(sha1).evalsha(sha1, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
||||||| BASE
abstract class MultiKeyPipelineBase extends PipelineBase implements
	BasicRedisPipeline, MultiKeyBinaryRedisPipeline,
	MultiKeyCommandsPipeline, ClusterPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }
=======
abstract class MultiKeyPipelineBase extends PipelineBase implements BasicRedisPipeline,
    MultiKeyBinaryRedisPipeline, MultiKeyCommandsPipeline, ClusterPipeline {

  protected Client client = null;

  public Response<List<String>> brpop(String... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(int timeout, String... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(String... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> brpop(byte[]... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> brpop(int timeout, byte[]... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> blpop(byte[]... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> blpop(int timeout, byte[]... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> del(String... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[]... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> keys(String pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> keys(byte[] pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> mget(String... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> mget(byte[]... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> mset(String... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> mset(byte[]... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> msetnx(String... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> msetnx(byte[]... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rename(String oldkey, String newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> rename(byte[] oldkey, byte[] newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> renamenx(String oldkey, String newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpoplpush(String srckey, String dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Set<String>> sdiff(String... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sdiff(byte[]... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sdiffstore(String dstkey, String... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sinter(String... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sinter(byte[]... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sinterstore(String dstkey, String... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(String srckey, String dstkey, String member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, SortingParams sortingParameters, String dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, String dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, byte[] dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sunion(String... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sunion(byte[]... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sunionstore(String dstkey, String... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> watch(String... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> watch(byte[]... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zinterstore(String dstkey, String... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(String dstkey, ZParams params, String... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, String... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, ZParams params, String... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> bgrewriteaof() {
    client.bgrewriteaof();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> bgsave() {
    client.bgsave();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> configGet(String pattern) {
    client.configGet(pattern);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> configSet(String parameter, String value) {
    client.configSet(parameter, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> brpoplpush(String source, String destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> configResetStat() {
    client.configResetStat();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> save() {
    client.save();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> lastsave() {
    client.lastsave();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(String channel, String message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> randomKey() {
    client.randomKey();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> randomKeyBinary() {
    client.randomKey();
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> flushDB() {
    client.flushDB();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> flushAll() {
    client.flushAll();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info() {
    client.info();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> time() {
    client.time();
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> dbSize() {
    client.dbSize();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> shutdown() {
    client.shutdown();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ping() {
    client.ping();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> select(int index) {
    client.select(index);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> clusterNodes() {
    client.clusterNodes();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterMeet(final String ip, final int port) {
    client.clusterMeet(ip, port);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterAddSlots(final int... slots) {
    client.clusterAddSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterDelSlots(final int... slots) {
    client.clusterDelSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterInfo() {
    client.clusterInfo();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> clusterGetKeysInSlot(final int slot, final int count) {
    client.clusterGetKeysInSlot(slot, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> clusterSetSlotNode(final int slot, final String nodeId) {
    client.clusterSetSlotNode(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotMigrating(final int slot, final String nodeId) {
    client.clusterSetSlotMigrating(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotImporting(final int slot, final String nodeId) {
    client.clusterSetSlotImporting(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(String destkey, String... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<Long> pfcount(String... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(final byte[]... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    @SuppressWarnings("unchecked")
    @Test
    public void evalMultiBulk() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");
	keys.add("key2");

	List<String> args = new ArrayList<String>();
	args.add("first");
	args.add("second");
	args.add("third");

	List<String> response = (List<String>) jedis.eval(script, keys, args);

	assertEquals(5, response.size());
	assertEquals("key1", response.get(0));
	assertEquals("key2", response.get(1));
	assertEquals("first", response.get(2));
	assertEquals("second", response.get(3));
	assertEquals("third", response.get(4));
    }

    @SuppressWarnings("unchecked")
    @Test
    public void evalMultiBulkWithBinaryJedis() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
	List<byte[]> keys = new ArrayList<byte[]>();
	keys.add("key1".getBytes());
	keys.add("key2".getBytes());

	List<byte[]> args = new ArrayList<byte[]>();
	args.add("first".getBytes());
	args.add("second".getBytes());
	args.add("third".getBytes());

	BinaryJedis binaryJedis = new BinaryJedis(hnp.getHost(), hnp.getPort(),
		500);
	binaryJedis.connect();
	binaryJedis.auth("foobared");

	List<byte[]> responses = (List<byte[]>) binaryJedis.eval(
		script.getBytes(), keys, args);
	assertEquals(5, responses.size());
	assertEquals("key1", new String(responses.get(0)));
	assertEquals("key2", new String(responses.get(1)));
	assertEquals("first", new String(responses.get(2)));
	assertEquals("second", new String(responses.get(3)));
	assertEquals("third", new String(responses.get(4)));
	
	binaryJedis.close();
    }

    @Test
    public void evalBulk() {
	String script = "return KEYS[1]";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");

	List<String> args = new ArrayList<String>();
	args.add("first");

	String response = (String) jedis.eval(script, keys, args);

	assertEquals("key1", response);
    }

    @Test
    public void evalInt() {
	String script = "return 2";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");

	Long response = (Long) jedis
		.eval(script, keys, new ArrayList<String>());

	assertEquals(new Long(2), response);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void evalNestedLists() {
	String script = "return { {KEYS[1]} , {2} }";
	List<?> results = (List<?>) jedis.eval(script, 1, "key1");

	assertThat((List<String>) results.get(0), listWithItem("key1"));
	assertThat((List<Long>) results.get(1), listWithItem(2L));
    }

    @Test
    public void evalNoArgs() {
	String script = "return KEYS[1]";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");
	String response = (String) jedis.eval(script, keys,
		new ArrayList<String>());

	assertEquals("key1", response);
    }

    @Test
    public void evalsha() {
	jedis.set("foo", "bar");
	jedis.eval("return redis.call('get','foo')");
	String result = (String) jedis
		.evalsha("6b1bf486c81ceb7edf3c093f4c48582e38c0e791");

	assertEquals("bar", result);
    }

    @Test(expected = JedisDataException.class)
    public void evalshaShaNotFound() {
	jedis.evalsha("ffffffffffffffffffffffffffffffffffffffff");
    }

    @Test
    public void scriptFlush() {
	jedis.set("foo", "bar");
	jedis.eval("return redis.call('get','foo')");
	jedis.scriptFlush();
	assertFalse(jedis
		.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    }

    @Test
    public void scriptExists() {
	jedis.scriptLoad("return redis.call('get','foo')");
	List<Boolean> exists = jedis.scriptExists(
		"ffffffffffffffffffffffffffffffffffffffff",
		"6b1bf486c81ceb7edf3c093f4c48582e38c0e791");
	assertFalse(exists.get(0));
	assertTrue(exists.get(1));
    }

    @Test
    public void scriptExistsBinary() {
	jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
	List<Long> exists = jedis.scriptExists(
		SafeEncoder.encode("ffffffffffffffffffffffffffffffffffffffff"),
		SafeEncoder.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
	assertEquals(new Long(0), exists.get(0));
	assertEquals(new Long(1), exists.get(1));
    }

    @Test
    public void scriptLoad() {
	jedis.scriptLoad("return redis.call('get','foo')");
	assertTrue(jedis
		.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    }

    @Test
    public void scriptLoadBinary() {
	jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
	byte[][] scripts = new byte[1][];
	scripts[0] = SafeEncoder.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791");
	List<Long> exists = jedis.scriptExists(scripts);
	assertEquals(new Long(1), exists.get(0));
    }

    @Test
    public void scriptKill() {
	try {
	    jedis.scriptKill();
	} catch (JedisDataException e) {
	    assertTrue(e.getMessage().contains(
		    "No scripts in execution right now."));
	}
    }

    @Test
    @SuppressWarnings("unchecked")
    public void scriptEvalReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	
	List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }

    @Test
    @SuppressWarnings("unchecked")
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }

    private <T> Matcher<Iterable<? super T>> listWithItem(T expected) {
	return CoreMatchers.<T>hasItem(equalTo(expected));
    }
||||||| BASE
    @SuppressWarnings("unchecked")
    @Test
    public void evalMultiBulk() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");
	keys.add("key2");

	List<String> args = new ArrayList<String>();
	args.add("first");
	args.add("second");
	args.add("third");

	List<String> response = (List<String>) jedis.eval(script, keys, args);

	assertEquals(5, response.size());
	assertEquals("key1", response.get(0));
	assertEquals("key2", response.get(1));
	assertEquals("first", response.get(2));
	assertEquals("second", response.get(3));
	assertEquals("third", response.get(4));
    }

    @SuppressWarnings("unchecked")
    @Test
    public void evalMultiBulkWithBinaryJedis() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
	List<byte[]> keys = new ArrayList<byte[]>();
	keys.add("key1".getBytes());
	keys.add("key2".getBytes());

	List<byte[]> args = new ArrayList<byte[]>();
	args.add("first".getBytes());
	args.add("second".getBytes());
	args.add("third".getBytes());

	BinaryJedis binaryJedis = new BinaryJedis(hnp.getHost(), hnp.getPort(),
		500);
	binaryJedis.connect();
	binaryJedis.auth("foobared");

	List<byte[]> responses = (List<byte[]>) binaryJedis.eval(
		script.getBytes(), keys, args);
	assertEquals(5, responses.size());
	assertEquals("key1", new String(responses.get(0)));
	assertEquals("key2", new String(responses.get(1)));
	assertEquals("first", new String(responses.get(2)));
	assertEquals("second", new String(responses.get(3)));
	assertEquals("third", new String(responses.get(4)));
    }

    @Test
    public void evalBulk() {
	String script = "return KEYS[1]";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");

	List<String> args = new ArrayList<String>();
	args.add("first");

	String response = (String) jedis.eval(script, keys, args);

	assertEquals("key1", response);
    }

    @Test
    public void evalInt() {
	String script = "return 2";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");

	Long response = (Long) jedis
		.eval(script, keys, new ArrayList<String>());

	assertEquals(new Long(2), response);
    }

    @Test
    public void evalNestedLists() {
	String script = "return { {KEYS[1]} , {2} }";
	List<?> results = (List<?>) jedis.eval(script, 1, "key1");

	assertThat((List<String>) results.get(0), listWithItem("key1"));
	assertThat((List<Long>) results.get(1), listWithItem(2L));
    }

    @Test
    public void evalNoArgs() {
	String script = "return KEYS[1]";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");
	String response = (String) jedis.eval(script, keys,
		new ArrayList<String>());

	assertEquals("key1", response);
    }

    @Test
    public void evalsha() {
	jedis.set("foo", "bar");
	jedis.eval("return redis.call('get','foo')");
	String result = (String) jedis
		.evalsha("6b1bf486c81ceb7edf3c093f4c48582e38c0e791");

	assertEquals("bar", result);
    }

    @Test(expected = JedisDataException.class)
    public void evalshaShaNotFound() {
	jedis.evalsha("ffffffffffffffffffffffffffffffffffffffff");
    }

    @Test
    public void scriptFlush() {
	jedis.set("foo", "bar");
	jedis.eval("return redis.call('get','foo')");
	jedis.scriptFlush();
	assertFalse(jedis
		.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    }

    @Test
    public void scriptExists() {
	jedis.scriptLoad("return redis.call('get','foo')");
	List<Boolean> exists = jedis.scriptExists(
		"ffffffffffffffffffffffffffffffffffffffff",
		"6b1bf486c81ceb7edf3c093f4c48582e38c0e791");
	assertFalse(exists.get(0));
	assertTrue(exists.get(1));
    }

    @Test
    public void scriptExistsBinary() {
	jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
	List<Long> exists = jedis.scriptExists(
		SafeEncoder.encode("ffffffffffffffffffffffffffffffffffffffff"),
		SafeEncoder.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
	assertEquals(new Long(0), exists.get(0));
	assertEquals(new Long(1), exists.get(1));
    }

    @Test
    public void scriptLoad() {
	jedis.scriptLoad("return redis.call('get','foo')");
	assertTrue(jedis
		.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    }

    @Test
    public void scriptLoadBinary() {
	jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
	List<Long> exists = jedis.scriptExists(SafeEncoder
		.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
	assertEquals(new Long(1), exists.get(0));
    }

    @Test
    public void scriptKill() {
	try {
	    jedis.scriptKill();
	} catch (JedisDataException e) {
	    assertTrue(e.getMessage().contains(
		    "No scripts in execution right now."));
	}
    }

    @Test
    public void scriptEvalReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }

    @Test
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }

    private <T> Matcher<Iterable<? super T>> listWithItem(T expected) {
	return CoreMatchers.<T>hasItem(equalTo(expected));
    }
=======
  @SuppressWarnings("unchecked")
  @Test
  public void evalMultiBulk() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");
    keys.add("key2");

    List<String> args = new ArrayList<String>();
    args.add("first");
    args.add("second");
    args.add("third");

    List<String> response = (List<String>) jedis.eval(script, keys, args);

    assertEquals(5, response.size());
    assertEquals("key1", response.get(0));
    assertEquals("key2", response.get(1));
    assertEquals("first", response.get(2));
    assertEquals("second", response.get(3));
    assertEquals("third", response.get(4));
  }

  @SuppressWarnings("unchecked")
  @Test
  public void evalMultiBulkWithBinaryJedis() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
    List<byte[]> keys = new ArrayList<byte[]>();
    keys.add("key1".getBytes());
    keys.add("key2".getBytes());

    List<byte[]> args = new ArrayList<byte[]>();
    args.add("first".getBytes());
    args.add("second".getBytes());
    args.add("third".getBytes());

    BinaryJedis binaryJedis = new BinaryJedis(hnp.getHost(), hnp.getPort(), 500);
    binaryJedis.connect();
    binaryJedis.auth("foobared");

    List<byte[]> responses = (List<byte[]>) binaryJedis.eval(script.getBytes(), keys, args);
    assertEquals(5, responses.size());
    assertEquals("key1", new String(responses.get(0)));
    assertEquals("key2", new String(responses.get(1)));
    assertEquals("first", new String(responses.get(2)));
    assertEquals("second", new String(responses.get(3)));
    assertEquals("third", new String(responses.get(4)));
  }

  @Test
  public void evalBulk() {
    String script = "return KEYS[1]";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");

    List<String> args = new ArrayList<String>();
    args.add("first");

    String response = (String) jedis.eval(script, keys, args);

    assertEquals("key1", response);
  }

  @Test
  public void evalInt() {
    String script = "return 2";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");

    Long response = (Long) jedis.eval(script, keys, new ArrayList<String>());

    assertEquals(new Long(2), response);
  }

  @Test
  public void evalNestedLists() {
    String script = "return { {KEYS[1]} , {2} }";
    List<?> results = (List<?>) jedis.eval(script, 1, "key1");

    assertThat((List<String>) results.get(0), listWithItem("key1"));
    assertThat((List<Long>) results.get(1), listWithItem(2L));
  }

  @Test
  public void evalNoArgs() {
    String script = "return KEYS[1]";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");
    String response = (String) jedis.eval(script, keys, new ArrayList<String>());

    assertEquals("key1", response);
  }

  @Test
  public void evalsha() {
    jedis.set("foo", "bar");
    jedis.eval("return redis.call('get','foo')");
    String result = (String) jedis.evalsha("6b1bf486c81ceb7edf3c093f4c48582e38c0e791");

    assertEquals("bar", result);
  }

  @Test(expected = JedisDataException.class)
  public void evalshaShaNotFound() {
    jedis.evalsha("ffffffffffffffffffffffffffffffffffffffff");
  }

  @Test
  public void scriptFlush() {
    jedis.set("foo", "bar");
    jedis.eval("return redis.call('get','foo')");
    jedis.scriptFlush();
    assertFalse(jedis.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
  }

  @Test
  public void scriptExists() {
    jedis.scriptLoad("return redis.call('get','foo')");
    List<Boolean> exists = jedis.scriptExists("ffffffffffffffffffffffffffffffffffffffff",
      "6b1bf486c81ceb7edf3c093f4c48582e38c0e791");
    assertFalse(exists.get(0));
    assertTrue(exists.get(1));
  }

  @Test
  public void scriptExistsBinary() {
    jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
    List<Long> exists = jedis.scriptExists(
      SafeEncoder.encode("ffffffffffffffffffffffffffffffffffffffff"),
      SafeEncoder.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    assertEquals(new Long(0), exists.get(0));
    assertEquals(new Long(1), exists.get(1));
  }

  @Test
  public void scriptLoad() {
    jedis.scriptLoad("return redis.call('get','foo')");
    assertTrue(jedis.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
  }

  @Test
  public void scriptLoadBinary() {
    jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
    List<Long> exists = jedis.scriptExists(SafeEncoder
        .encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    assertEquals(new Long(1), exists.get(0));
  }

  @Test
  public void scriptKill() {
    try {
      jedis.scriptKill();
    } catch (JedisDataException e) {
      assertTrue(e.getMessage().contains("No scripts in execution right now."));
    }
  }

  @Test
  public void scriptEvalReturnNullValues() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
    List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
    assertEquals("key1", results.get(0));
    assertEquals("key2", results.get(1));
    assertEquals("1", results.get(2));
    assertEquals("2", results.get(3));
  }

  @Test
  public void scriptEvalShaReturnNullValues() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
    String sha = jedis.scriptLoad(script);
    List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
    assertEquals("key1", results.get(0));
    assertEquals("key2", results.get(1));
    assertEquals("1", results.get(2));
    assertEquals("2", results.get(3));
  }

  private <T> Matcher<Iterable<? super T>> listWithItem(T expected) {
    return CoreMatchers.<T> hasItem(equalTo(expected));
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/test/java/redis/clients/jedis/tests/PipeliningTest.java;<<<<<<< MINE
    @Before
    public void setUp() throws Exception {
	jedis = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	jedis.connect();
	jedis.auth("foobared");
	jedis.flushAll();
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
	Pipeline p = jedis.pipelined();
	p.set("foo", "bar");
	p.get("foo");
	List<Object> results = p.syncAndReturnAll();

	assertEquals(2, results.size());
	assertEquals("OK", results.get(0));
	assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
	jedis.set("string", "foo");
	jedis.lpush("list", "foo");
	jedis.hset("hash", "foo", "bar");
	jedis.zadd("zset", 1, "foo");
	jedis.sadd("set", "foo");

	Pipeline p = jedis.pipelined();
	Response<String> string = p.get("string");
	Response<String> list = p.lpop("list");
	Response<String> hash = p.hget("hash", "foo");
	Response<Set<String>> zset = p.zrange("zset", 0, -1);
	Response<String> set = p.spop("set");
	Response<Boolean> blist = p.exists("list");
	Response<Double> zincrby = p.zincrby("zset", 1, "foo");
	Response<Long> zcard = p.zcard("zset");
	p.lpush("list", "bar");
	Response<List<String>> lrange = p.lrange("list", 0, -1);
	Response<Map<String, String>> hgetAll = p.hgetAll("hash");
	p.sadd("set", "foo");
	Response<Set<String>> smembers = p.smembers("set");
	Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
		-1);
	p.sync();

	assertEquals("foo", string.get());
	assertEquals("foo", list.get());
	assertEquals("bar", hash.get());
	assertEquals("foo", zset.get().iterator().next());
	assertEquals("foo", set.get());
	assertEquals(false, blist.get());
	assertEquals(Double.valueOf(2), zincrby.get());
	assertEquals(Long.valueOf(1), zcard.get());
	assertEquals(1, lrange.get().size());
	assertNotNull(hgetAll.get().get("foo"));
	assertEquals(1, smembers.get().size());
	assertEquals(1, zrangeWithScores.get().size());
    }

    @Test
    public void pipelineResponseWithData() {
	jedis.zadd("zset", 1, "foo");

	Pipeline p = jedis.pipelined();
	Response<Double> score = p.zscore("zset", "foo");
	p.sync();

	assertNotNull(score.get());
    }

    @Test
    public void pipelineBinarySafeHashCommands() {
	jedis.hset("key".getBytes(), "f1".getBytes(), "v111".getBytes());
	jedis.hset("key".getBytes(), "f22".getBytes(), "v2222".getBytes());

	Pipeline p = jedis.pipelined();
	Response<Map<byte[], byte[]>> fmap = p.hgetAll("key".getBytes());
	Response<Set<byte[]>> fkeys = p.hkeys("key".getBytes());
	Response<List<byte[]>> fordered = p.hmget("key".getBytes(),
		"f22".getBytes(), "f1".getBytes());
	Response<List<byte[]>> fvals = p.hvals("key".getBytes());
	p.sync();

	assertNotNull(fmap.get());
	// we have to do these strange contortions because byte[] is not a very
	// good key
	// for a java Map. It only works with equality (you need the exact key
	// object to retrieve
	// the value) I recommend we switch to using ByteBuffer or something
	// similar:
	// http://stackoverflow.com/questions/1058149/using-a-byte-array-as-hashmap-key-java
	Map<byte[], byte[]> map = fmap.get();
	Set<byte[]> mapKeys = map.keySet();
	Iterator<byte[]> iterMap = mapKeys.iterator();
	byte[] firstMapKey = iterMap.next();
	byte[] secondMapKey = iterMap.next();
	assertFalse(iterMap.hasNext());
	verifyHasBothValues(firstMapKey, secondMapKey, "f1".getBytes(),
		"f22".getBytes());
	byte[] firstMapValue = map.get(firstMapKey);
	byte[] secondMapValue = map.get(secondMapKey);
	verifyHasBothValues(firstMapValue, secondMapValue, "v111".getBytes(),
		"v2222".getBytes());

	assertNotNull(fkeys.get());
	Iterator<byte[]> iter = fkeys.get().iterator();
	byte[] firstKey = iter.next();
	byte[] secondKey = iter.next();
	assertFalse(iter.hasNext());
	verifyHasBothValues(firstKey, secondKey, "f1".getBytes(),
		"f22".getBytes());

	assertNotNull(fordered.get());
	assertArrayEquals("v2222".getBytes(), fordered.get().get(0));
	assertArrayEquals("v111".getBytes(), fordered.get().get(1));

	assertNotNull(fvals.get());
	assertEquals(2, fvals.get().size());
	byte[] firstValue = fvals.get().get(0);
	byte[] secondValue = fvals.get().get(1);
	verifyHasBothValues(firstValue, secondValue, "v111".getBytes(),
		"v2222".getBytes());
    }

    private void verifyHasBothValues(byte[] firstKey, byte[] secondKey,
	    byte[] value1, byte[] value2) {
	assertFalse(Arrays.equals(firstKey, secondKey));
	assertTrue(Arrays.equals(firstKey, value1)
		|| Arrays.equals(firstKey, value2));
	assertTrue(Arrays.equals(secondKey, value1)
		|| Arrays.equals(secondKey, value2));
    }

    @Test
    public void pipelineSelect() {
	Pipeline p = jedis.pipelined();
	p.select(1);
	p.sync();
    }

    @Test
    public void pipelineResponseWithoutData() {
	jedis.zadd("zset", 1, "foo");

	Pipeline p = jedis.pipelined();
	Response<Double> score = p.zscore("zset", "bar");
	p.sync();

	assertNull(score.get());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
	jedis.set("string", "foo");

	Pipeline p = jedis.pipelined();
	Response<String> string = p.get("string");
	string.get();
	p.sync();
    }

    @Test
    public void pipelineWithPubSub() {
	Pipeline pipelined = jedis.pipelined();
	Response<Long> p1 = pipelined.publish("foo", "bar");
	Response<Long> p2 = pipelined.publish("foo".getBytes(),
		"bar".getBytes());
	pipelined.sync();
	assertEquals(0, p1.get().longValue());
	assertEquals(0, p2.get().longValue());
    }

    @Test
    public void canRetrieveUnsetKey() {
	Pipeline p = jedis.pipelined();
	Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
	p.sync();
	assertNull(shouldNotExist.get());
    }

    @Test
    public void piplineWithError() {
	Pipeline p = jedis.pipelined();
	p.set("foo", "bar");
	Response<Set<String>> error = p.smembers("foo");
	Response<String> r = p.get("foo");
	p.sync();
	try {
	    error.get();
	    fail();
	} catch (JedisDataException e) {
	    // that is fine we should be here
	}
	assertEquals(r.get(), "bar");
    }

    @Test
    public void multi() {
	Pipeline p = jedis.pipelined();
	p.multi();
	Response<Long> r1 = p.hincrBy("a", "f1", -1);
	Response<Long> r2 = p.hincrBy("a", "f1", -2);
	Response<List<Object>> r3 = p.exec();
	List<Object> result = p.syncAndReturnAll();

	assertEquals(new Long(-1), r1.get());
	assertEquals(new Long(-3), r2.get());

	assertEquals(4, result.size());

	assertEquals("OK", result.get(0));
	assertEquals("QUEUED", result.get(1));
	assertEquals("QUEUED", result.get(2));

	// 4th result is a list with the results from the multi
	@SuppressWarnings("unchecked")
	List<Object> multiResult = (List<Object>) result.get(3);
	assertEquals(new Long(-1), multiResult.get(0));
	assertEquals(new Long(-3), multiResult.get(1));

	assertEquals(new Long(-1), r3.get().get(0));
	assertEquals(new Long(-3), r3.get().get(1));

    }

    @Test
    public void multiWithSync() {
	jedis.set("foo", "314");
	jedis.set("bar", "foo");
	jedis.set("hello", "world");
	Pipeline p = jedis.pipelined();
	Response<String> r1 = p.get("bar");
	p.multi();
	Response<String> r2 = p.get("foo");
	p.exec();
	Response<String> r3 = p.get("hello");
	p.sync();
	
	// before multi
	assertEquals("foo", r1.get());
	// It should be readable whether exec's response was built or not
	assertEquals("314", r2.get());
	// after multi
	assertEquals("world", r3.get());
    }

    @Test
    public void testDiscardInPipeline() {
	Pipeline pipeline = jedis.pipelined();
	pipeline.multi();
	pipeline.set("foo", "bar");
	Response<String> discard = pipeline.discard();
	Response<String> get = pipeline.get("foo");
	pipeline.sync();
	discard.get();
	get.get();
    }

    @Test
    public void testEval() {
	String script = "return 'success!'";

	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(script);
	p.sync();

	assertEquals("success!", result.get());
    }
    
    @Test
    public void testEvalWithBinary() {
	String script = "return 'success!'";

	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(SafeEncoder.encode(script));
	p.sync();

	assertArrayEquals(SafeEncoder.encode("success!"), (byte[]) result.get());
    }

    @Test
    public void testEvalKeyAndArg() {
	String key = "test";
	String arg = "3";
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";

	Pipeline p = jedis.pipelined();
	p.set(key, "0");
	Response<Object> result0 = p.eval(script, Arrays.asList(key),
		Arrays.asList(arg));
	p.incr(key);
	Response<Object> result1 = p.eval(script, Arrays.asList(key),
		Arrays.asList(arg));
	Response<String> result2 = p.get(key);
	p.sync();

	assertNull(result0.get());
	assertNull(result1.get());
	assertEquals("13", result2.get());
    }
    
    @Test
    public void testEvalKeyAndArgWithBinary() {
	// binary
	byte[] bKey = SafeEncoder.encode("test");
	byte[] bArg = SafeEncoder.encode("3");
	byte[] bScript = SafeEncoder.encode("redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])");
	
	Pipeline bP = jedis.pipelined();
	bP.set(bKey, SafeEncoder.encode("0"));
	Response<Object> bResult0 = bP.eval(bScript, Arrays.asList(bKey),
		Arrays.asList(bArg));
	bP.incr(bKey);
	Response<Object> bResult1 = bP.eval(bScript, Arrays.asList(bKey),
		Arrays.asList(bArg));
	Response<byte[]> bResult2 = bP.get(bKey);
	bP.sync();

	assertNull(bResult0.get());
	assertNull(bResult1.get());
	assertArrayEquals(SafeEncoder.encode("13"), bResult2.get());
    }
    
    @Test
    public void testEvalNestedLists() {
	String script = "return { {KEYS[1]} , {2} }";
	
	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(script, 1, "key1");
	p.sync();
	
	List<?> results = (List<?>) result.get();
	assertThat((List<String>) results.get(0), listWithItem("key1"));
	assertThat((List<Long>) results.get(1), listWithItem(2L));
    }
    
    @Test
    public void testEvalNestedListsWithBinary() {
	byte[] bScript = SafeEncoder.encode("return { {KEYS[1]} , {2} }");
	byte[] bKey = SafeEncoder.encode("key1"); 
	
	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(bScript, 1, bKey);
	p.sync();
	
	List<?> results = (List<?>) result.get();
	assertThat((List<byte[]>) results.get(0), listWithItem(bKey));
	assertThat((List<Long>) results.get(1), listWithItem(2L));
    }

    @Test
    public void testEvalsha() {
	String script = "return 'success!'";
	String sha1 = jedis.scriptLoad(script);

	assertTrue(jedis.scriptExists(sha1));

	Pipeline p = jedis.pipelined();
	Response<Object> result = p.evalsha(sha1);
	p.sync();

	assertEquals("success!", result.get());
    }

    @Test
    public void testEvalshaKeyAndArg() {
	String key = "test";
	String arg = "3";
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
	String sha1 = jedis.scriptLoad(script);

	assertTrue(jedis.scriptExists(sha1));

	Pipeline p = jedis.pipelined();
	p.set(key, "0");
	Response<Object> result0 = p.evalsha(sha1, Arrays.asList(key),
		Arrays.asList(arg));
	p.incr(key);
	Response<Object> result1 = p.evalsha(sha1, Arrays.asList(key),
		Arrays.asList(arg));
	Response<String> result2 = p.get(key);
	p.sync();

	assertNull(result0.get());
	assertNull(result1.get());
	assertEquals("13", result2.get());
    }
    
    @Test
    public void testEvalshaKeyAndArgWithBinary() {
	byte[] bKey = SafeEncoder.encode("test");
	byte[] bArg = SafeEncoder.encode("3");
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
	byte[] bScript = SafeEncoder.encode(script);
	byte[] bSha1 = jedis.scriptLoad(bScript);
	
	assertTrue(jedis.scriptExists(bSha1) == 1);
	
	Pipeline p = jedis.pipelined();
	p.set(bKey, SafeEncoder.encode("0"));
	Response<Object> result0 = p.evalsha(bSha1, Arrays.asList(bKey),
		Arrays.asList(bArg));
	p.incr(bKey);
	Response<Object> result1 = p.evalsha(bSha1, Arrays.asList(bKey),
		Arrays.asList(bArg));
	Response<byte[]> result2 = p.get(bKey);
	p.sync();
	
	assertNull(result0.get());
	assertNull(result1.get());
	assertArrayEquals(SafeEncoder.encode("13"), result2.get());
    }
    
    private <T> Matcher<Iterable<? super T>> listWithItem(T expected) {
	return CoreMatchers.<T>hasItem(equalTo(expected));
    }
||||||| BASE
    @Before
    public void setUp() throws Exception {
	jedis = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	jedis.connect();
	jedis.auth("foobared");
	jedis.flushAll();
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
	Pipeline p = jedis.pipelined();
	p.set("foo", "bar");
	p.get("foo");
	List<Object> results = p.syncAndReturnAll();

	assertEquals(2, results.size());
	assertEquals("OK", results.get(0));
	assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
	jedis.set("string", "foo");
	jedis.lpush("list", "foo");
	jedis.hset("hash", "foo", "bar");
	jedis.zadd("zset", 1, "foo");
	jedis.sadd("set", "foo");

	Pipeline p = jedis.pipelined();
	Response<String> string = p.get("string");
	Response<String> list = p.lpop("list");
	Response<String> hash = p.hget("hash", "foo");
	Response<Set<String>> zset = p.zrange("zset", 0, -1);
	Response<String> set = p.spop("set");
	Response<Boolean> blist = p.exists("list");
	Response<Double> zincrby = p.zincrby("zset", 1, "foo");
	Response<Long> zcard = p.zcard("zset");
	p.lpush("list", "bar");
	Response<List<String>> lrange = p.lrange("list", 0, -1);
	Response<Map<String, String>> hgetAll = p.hgetAll("hash");
	p.sadd("set", "foo");
	Response<Set<String>> smembers = p.smembers("set");
	Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
		-1);
	p.sync();

	assertEquals("foo", string.get());
	assertEquals("foo", list.get());
	assertEquals("bar", hash.get());
	assertEquals("foo", zset.get().iterator().next());
	assertEquals("foo", set.get());
	assertEquals(false, blist.get());
	assertEquals(Double.valueOf(2), zincrby.get());
	assertEquals(Long.valueOf(1), zcard.get());
	assertEquals(1, lrange.get().size());
	assertNotNull(hgetAll.get().get("foo"));
	assertEquals(1, smembers.get().size());
	assertEquals(1, zrangeWithScores.get().size());
    }

    @Test
    public void pipelineResponseWithData() {
	jedis.zadd("zset", 1, "foo");

	Pipeline p = jedis.pipelined();
	Response<Double> score = p.zscore("zset", "foo");
	p.sync();

	assertNotNull(score.get());
    }

    @Test
    public void pipelineBinarySafeHashCommands() {
	jedis.hset("key".getBytes(), "f1".getBytes(), "v111".getBytes());
	jedis.hset("key".getBytes(), "f22".getBytes(), "v2222".getBytes());

	Pipeline p = jedis.pipelined();
	Response<Map<byte[], byte[]>> fmap = p.hgetAll("key".getBytes());
	Response<Set<byte[]>> fkeys = p.hkeys("key".getBytes());
	Response<List<byte[]>> fordered = p.hmget("key".getBytes(),
		"f22".getBytes(), "f1".getBytes());
	Response<List<byte[]>> fvals = p.hvals("key".getBytes());
	p.sync();

	assertNotNull(fmap.get());
	// we have to do these strange contortions because byte[] is not a very
	// good key
	// for a java Map. It only works with equality (you need the exact key
	// object to retrieve
	// the value) I recommend we switch to using ByteBuffer or something
	// similar:
	// http://stackoverflow.com/questions/1058149/using-a-byte-array-as-hashmap-key-java
	Map<byte[], byte[]> map = fmap.get();
	Set<byte[]> mapKeys = map.keySet();
	Iterator<byte[]> iterMap = mapKeys.iterator();
	byte[] firstMapKey = iterMap.next();
	byte[] secondMapKey = iterMap.next();
	assertFalse(iterMap.hasNext());
	verifyHasBothValues(firstMapKey, secondMapKey, "f1".getBytes(),
		"f22".getBytes());
	byte[] firstMapValue = map.get(firstMapKey);
	byte[] secondMapValue = map.get(secondMapKey);
	verifyHasBothValues(firstMapValue, secondMapValue, "v111".getBytes(),
		"v2222".getBytes());

	assertNotNull(fkeys.get());
	Iterator<byte[]> iter = fkeys.get().iterator();
	byte[] firstKey = iter.next();
	byte[] secondKey = iter.next();
	assertFalse(iter.hasNext());
	verifyHasBothValues(firstKey, secondKey, "f1".getBytes(),
		"f22".getBytes());

	assertNotNull(fordered.get());
	assertArrayEquals("v2222".getBytes(), fordered.get().get(0));
	assertArrayEquals("v111".getBytes(), fordered.get().get(1));

	assertNotNull(fvals.get());
	assertEquals(2, fvals.get().size());
	byte[] firstValue = fvals.get().get(0);
	byte[] secondValue = fvals.get().get(1);
	verifyHasBothValues(firstValue, secondValue, "v111".getBytes(),
		"v2222".getBytes());
    }

    private void verifyHasBothValues(byte[] firstKey, byte[] secondKey,
	    byte[] value1, byte[] value2) {
	assertFalse(Arrays.equals(firstKey, secondKey));
	assertTrue(Arrays.equals(firstKey, value1)
		|| Arrays.equals(firstKey, value2));
	assertTrue(Arrays.equals(secondKey, value1)
		|| Arrays.equals(secondKey, value2));
    }

    @Test
    public void pipelineSelect() {
	Pipeline p = jedis.pipelined();
	p.select(1);
	p.sync();
    }

    @Test
    public void pipelineResponseWithoutData() {
	jedis.zadd("zset", 1, "foo");

	Pipeline p = jedis.pipelined();
	Response<Double> score = p.zscore("zset", "bar");
	p.sync();

	assertNull(score.get());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
	jedis.set("string", "foo");

	Pipeline p = jedis.pipelined();
	Response<String> string = p.get("string");
	string.get();
	p.sync();
    }

    @Test
    public void pipelineWithPubSub() {
	Pipeline pipelined = jedis.pipelined();
	Response<Long> p1 = pipelined.publish("foo", "bar");
	Response<Long> p2 = pipelined.publish("foo".getBytes(),
		"bar".getBytes());
	pipelined.sync();
	assertEquals(0, p1.get().longValue());
	assertEquals(0, p2.get().longValue());
    }

    @Test
    public void canRetrieveUnsetKey() {
	Pipeline p = jedis.pipelined();
	Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
	p.sync();
	assertNull(shouldNotExist.get());
    }

    @Test
    public void piplineWithError() {
	Pipeline p = jedis.pipelined();
	p.set("foo", "bar");
	Response<Set<String>> error = p.smembers("foo");
	Response<String> r = p.get("foo");
	p.sync();
	try {
	    error.get();
	    fail();
	} catch (JedisDataException e) {
	    // that is fine we should be here
	}
	assertEquals(r.get(), "bar");
    }

    @Test
    public void multi() {
	Pipeline p = jedis.pipelined();
	p.multi();
	Response<Long> r1 = p.hincrBy("a", "f1", -1);
	Response<Long> r2 = p.hincrBy("a", "f1", -2);
	Response<List<Object>> r3 = p.exec();
	List<Object> result = p.syncAndReturnAll();

	assertEquals(new Long(-1), r1.get());
	assertEquals(new Long(-3), r2.get());

	assertEquals(4, result.size());

	assertEquals("OK", result.get(0));
	assertEquals("QUEUED", result.get(1));
	assertEquals("QUEUED", result.get(2));

	// 4th result is a list with the results from the multi
	@SuppressWarnings("unchecked")
	List<Object> multiResult = (List<Object>) result.get(3);
	assertEquals(new Long(-1), multiResult.get(0));
	assertEquals(new Long(-3), multiResult.get(1));

	assertEquals(new Long(-1), r3.get().get(0));
	assertEquals(new Long(-3), r3.get().get(1));

    }

    @Test
    public void multiWithSync() {
	jedis.set("foo", "314");
	jedis.set("bar", "foo");
	jedis.set("hello", "world");
	Pipeline p = jedis.pipelined();
	Response<String> r1 = p.get("bar");
	p.multi();
	Response<String> r2 = p.get("foo");
	p.exec();
	Response<String> r3 = p.get("hello");
	p.sync();
	
	// before multi
	assertEquals("foo", r1.get());
	// It should be readable whether exec's response was built or not
	assertEquals("314", r2.get());
	// after multi
	assertEquals("world", r3.get());
    }

    @Test
    public void testDiscardInPipeline() {
	Pipeline pipeline = jedis.pipelined();
	pipeline.multi();
	pipeline.set("foo", "bar");
	Response<String> discard = pipeline.discard();
	Response<String> get = pipeline.get("foo");
	pipeline.sync();
	discard.get();
	get.get();
    }

    @Test
    public void testEval() {
	String script = "return 'success!'";

	Pipeline p = jedis.pipelined();
	Response<String> result = p.eval(script);
	p.sync();

	assertEquals("success!", result.get());
    }

    @Test
    public void testEvalKeyAndArg() {
	String key = "test";
	String arg = "3";
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";

	Pipeline p = jedis.pipelined();
	p.set(key, "0");
	Response<String> result0 = p.eval(script, Arrays.asList(key),
		Arrays.asList(arg));
	p.incr(key);
	Response<String> result1 = p.eval(script, Arrays.asList(key),
		Arrays.asList(arg));
	Response<String> result2 = p.get(key);
	p.sync();

	assertNull(result0.get());
	assertNull(result1.get());
	assertEquals("13", result2.get());
    }

    @Test
    public void testEvalsha() {
	String script = "return 'success!'";
	String sha1 = jedis.scriptLoad(script);

	assertTrue(jedis.scriptExists(sha1));

	Pipeline p = jedis.pipelined();
	Response<String> result = p.evalsha(sha1);
	p.sync();

	assertEquals("success!", result.get());
    }

    @Test
    public void testEvalshaKeyAndArg() {
	String key = "test";
	String arg = "3";
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
	String sha1 = jedis.scriptLoad(script);

	assertTrue(jedis.scriptExists(sha1));

	Pipeline p = jedis.pipelined();
	p.set(key, "0");
	Response<String> result0 = p.evalsha(sha1, Arrays.asList(key),
		Arrays.asList(arg));
	p.incr(key);
	Response<String> result1 = p.evalsha(sha1, Arrays.asList(key),
		Arrays.asList(arg));
	Response<String> result2 = p.get(key);
	p.sync();

	assertNull(result0.get());
	assertNull(result1.get());
	assertEquals("13", result2.get());
    }
=======
  @Before
  public void setUp() throws Exception {
    jedis = new Jedis(hnp.getHost(), hnp.getPort(), 500);
    jedis.connect();
    jedis.auth("foobared");
    jedis.flushAll();
  }

  @Test
  public void pipeline() throws UnsupportedEncodingException {
    Pipeline p = jedis.pipelined();
    p.set("foo", "bar");
    p.get("foo");
    List<Object> results = p.syncAndReturnAll();

    assertEquals(2, results.size());
    assertEquals("OK", results.get(0));
    assertEquals("bar", results.get(1));

  }

  @Test
  public void pipelineResponse() {
    jedis.set("string", "foo");
    jedis.lpush("list", "foo");
    jedis.hset("hash", "foo", "bar");
    jedis.zadd("zset", 1, "foo");
    jedis.sadd("set", "foo");
    jedis.setrange("setrange", 0, "0123456789");
    byte[] bytesForSetRange = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    jedis.setrange("setrangebytes".getBytes(), 0, bytesForSetRange);

    Pipeline p = jedis.pipelined();
    Response<String> string = p.get("string");
    Response<String> list = p.lpop("list");
    Response<String> hash = p.hget("hash", "foo");
    Response<Set<String>> zset = p.zrange("zset", 0, -1);
    Response<String> set = p.spop("set");
    Response<Boolean> blist = p.exists("list");
    Response<Double> zincrby = p.zincrby("zset", 1, "foo");
    Response<Long> zcard = p.zcard("zset");
    p.lpush("list", "bar");
    Response<List<String>> lrange = p.lrange("list", 0, -1);
    Response<Map<String, String>> hgetAll = p.hgetAll("hash");
    p.sadd("set", "foo");
    Response<Set<String>> smembers = p.smembers("set");
    Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0, -1);
    Response<String> getrange = p.getrange("setrange", 1, 3);
    Response<byte[]> getrangeBytes = p.getrange("setrangebytes".getBytes(), 6, 8);
    p.sync();

    assertEquals("foo", string.get());
    assertEquals("foo", list.get());
    assertEquals("bar", hash.get());
    assertEquals("foo", zset.get().iterator().next());
    assertEquals("foo", set.get());
    assertEquals(false, blist.get());
    assertEquals(Double.valueOf(2), zincrby.get());
    assertEquals(Long.valueOf(1), zcard.get());
    assertEquals(1, lrange.get().size());
    assertNotNull(hgetAll.get().get("foo"));
    assertEquals(1, smembers.get().size());
    assertEquals(1, zrangeWithScores.get().size());
    assertEquals("123", getrange.get());
    byte[] expectedGetRangeBytes = { 6, 7, 8 };
    assertArrayEquals(expectedGetRangeBytes, getrangeBytes.get());
  }

  @Test
  public void pipelineResponseWithData() {
    jedis.zadd("zset", 1, "foo");

    Pipeline p = jedis.pipelined();
    Response<Double> score = p.zscore("zset", "foo");
    p.sync();

    assertNotNull(score.get());
  }

  @Test
  public void pipelineBinarySafeHashCommands() {
    jedis.hset("key".getBytes(), "f1".getBytes(), "v111".getBytes());
    jedis.hset("key".getBytes(), "f22".getBytes(), "v2222".getBytes());

    Pipeline p = jedis.pipelined();
    Response<Map<byte[], byte[]>> fmap = p.hgetAll("key".getBytes());
    Response<Set<byte[]>> fkeys = p.hkeys("key".getBytes());
    Response<List<byte[]>> fordered = p.hmget("key".getBytes(), "f22".getBytes(), "f1".getBytes());
    Response<List<byte[]>> fvals = p.hvals("key".getBytes());
    p.sync();

    assertNotNull(fmap.get());
    // we have to do these strange contortions because byte[] is not a very
    // good key
    // for a java Map. It only works with equality (you need the exact key
    // object to retrieve
    // the value) I recommend we switch to using ByteBuffer or something
    // similar:
    // http://stackoverflow.com/questions/1058149/using-a-byte-array-as-hashmap-key-java
    Map<byte[], byte[]> map = fmap.get();
    Set<byte[]> mapKeys = map.keySet();
    Iterator<byte[]> iterMap = mapKeys.iterator();
    byte[] firstMapKey = iterMap.next();
    byte[] secondMapKey = iterMap.next();
    assertFalse(iterMap.hasNext());
    verifyHasBothValues(firstMapKey, secondMapKey, "f1".getBytes(), "f22".getBytes());
    byte[] firstMapValue = map.get(firstMapKey);
    byte[] secondMapValue = map.get(secondMapKey);
    verifyHasBothValues(firstMapValue, secondMapValue, "v111".getBytes(), "v2222".getBytes());

    assertNotNull(fkeys.get());
    Iterator<byte[]> iter = fkeys.get().iterator();
    byte[] firstKey = iter.next();
    byte[] secondKey = iter.next();
    assertFalse(iter.hasNext());
    verifyHasBothValues(firstKey, secondKey, "f1".getBytes(), "f22".getBytes());

    assertNotNull(fordered.get());
    assertArrayEquals("v2222".getBytes(), fordered.get().get(0));
    assertArrayEquals("v111".getBytes(), fordered.get().get(1));

    assertNotNull(fvals.get());
    assertEquals(2, fvals.get().size());
    byte[] firstValue = fvals.get().get(0);
    byte[] secondValue = fvals.get().get(1);
    verifyHasBothValues(firstValue, secondValue, "v111".getBytes(), "v2222".getBytes());
  }

  private void verifyHasBothValues(byte[] firstKey, byte[] secondKey, byte[] value1, byte[] value2) {
    assertFalse(Arrays.equals(firstKey, secondKey));
    assertTrue(Arrays.equals(firstKey, value1) || Arrays.equals(firstKey, value2));
    assertTrue(Arrays.equals(secondKey, value1) || Arrays.equals(secondKey, value2));
  }

  @Test
  public void pipelineSelect() {
    Pipeline p = jedis.pipelined();
    p.select(1);
    p.sync();
  }

  @Test
  public void pipelineResponseWithoutData() {
    jedis.zadd("zset", 1, "foo");

    Pipeline p = jedis.pipelined();
    Response<Double> score = p.zscore("zset", "bar");
    p.sync();

    assertNull(score.get());
  }

  @Test(expected = JedisDataException.class)
  public void pipelineResponseWithinPipeline() {
    jedis.set("string", "foo");

    Pipeline p = jedis.pipelined();
    Response<String> string = p.get("string");
    string.get();
    p.sync();
  }

  @Test
  public void pipelineWithPubSub() {
    Pipeline pipelined = jedis.pipelined();
    Response<Long> p1 = pipelined.publish("foo", "bar");
    Response<Long> p2 = pipelined.publish("foo".getBytes(), "bar".getBytes());
    pipelined.sync();
    assertEquals(0, p1.get().longValue());
    assertEquals(0, p2.get().longValue());
  }

  @Test
  public void canRetrieveUnsetKey() {
    Pipeline p = jedis.pipelined();
    Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
    p.sync();
    assertNull(shouldNotExist.get());
  }

  @Test
  public void piplineWithError() {
    Pipeline p = jedis.pipelined();
    p.set("foo", "bar");
    Response<Set<String>> error = p.smembers("foo");
    Response<String> r = p.get("foo");
    p.sync();
    try {
      error.get();
      fail();
    } catch (JedisDataException e) {
      // that is fine we should be here
    }
    assertEquals(r.get(), "bar");
  }

  @Test
  public void multi() {
    Pipeline p = jedis.pipelined();
    p.multi();
    Response<Long> r1 = p.hincrBy("a", "f1", -1);
    Response<Long> r2 = p.hincrBy("a", "f1", -2);
    Response<List<Object>> r3 = p.exec();
    List<Object> result = p.syncAndReturnAll();

    assertEquals(new Long(-1), r1.get());
    assertEquals(new Long(-3), r2.get());

    assertEquals(4, result.size());

    assertEquals("OK", result.get(0));
    assertEquals("QUEUED", result.get(1));
    assertEquals("QUEUED", result.get(2));

    // 4th result is a list with the results from the multi
    @SuppressWarnings("unchecked")
    List<Object> multiResult = (List<Object>) result.get(3);
    assertEquals(new Long(-1), multiResult.get(0));
    assertEquals(new Long(-3), multiResult.get(1));

    assertEquals(new Long(-1), r3.get().get(0));
    assertEquals(new Long(-3), r3.get().get(1));

  }

  @Test
  public void multiWithSync() {
    jedis.set("foo", "314");
    jedis.set("bar", "foo");
    jedis.set("hello", "world");
    Pipeline p = jedis.pipelined();
    Response<String> r1 = p.get("bar");
    p.multi();
    Response<String> r2 = p.get("foo");
    p.exec();
    Response<String> r3 = p.get("hello");
    p.sync();

    // before multi
    assertEquals("foo", r1.get());
    // It should be readable whether exec's response was built or not
    assertEquals("314", r2.get());
    // after multi
    assertEquals("world", r3.get());
  }

  @Test(expected = JedisDataException.class)
  public void pipelineExecShoudThrowJedisDataExceptionWhenNotInMulti() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.exec();
  }

  @Test(expected = JedisDataException.class)
  public void pipelineDiscardShoudThrowJedisDataExceptionWhenNotInMulti() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.discard();
  }

  @Test(expected = JedisDataException.class)
  public void pipelineMultiShoudThrowJedisDataExceptionWhenAlreadyInMulti() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.multi();
    pipeline.set("foo", "3");
    pipeline.multi();
  }

  @Test
  public void testDiscardInPipeline() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.multi();
    pipeline.set("foo", "bar");
    Response<String> discard = pipeline.discard();
    Response<String> get = pipeline.get("foo");
    pipeline.sync();
    discard.get();
    get.get();
  }

  @Test
  public void testEval() {
    String script = "return 'success!'";

    Pipeline p = jedis.pipelined();
    Response<String> result = p.eval(script);
    p.sync();

    assertEquals("success!", result.get());
  }

  @Test
  public void testEvalKeyAndArg() {
    String key = "test";
    String arg = "3";
    String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";

    Pipeline p = jedis.pipelined();
    p.set(key, "0");
    Response<String> result0 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
    p.incr(key);
    Response<String> result1 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
    Response<String> result2 = p.get(key);
    p.sync();

    assertNull(result0.get());
    assertNull(result1.get());
    assertEquals("13", result2.get());
  }

  @Test
  public void testEvalsha() {
    String script = "return 'success!'";
    String sha1 = jedis.scriptLoad(script);

    assertTrue(jedis.scriptExists(sha1));

    Pipeline p = jedis.pipelined();
    Response<String> result = p.evalsha(sha1);
    p.sync();

    assertEquals("success!", result.get());
  }

  @Test
  public void testEvalshaKeyAndArg() {
    String key = "test";
    String arg = "3";
    String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
    String sha1 = jedis.scriptLoad(script);

    assertTrue(jedis.scriptExists(sha1));

    Pipeline p = jedis.pipelined();
    p.set(key, "0");
    Response<String> result0 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
    p.incr(key);
    Response<String> result1 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
    Response<String> result2 = p.get(key);
    p.sync();

    assertNull(result0.get());
    assertNull(result1.get());
    assertEquals("13", result2.get());
  }

  @Test
  public void testPipelinedTransactionResponse() {

    String key1 = "key1";
    String val1 = "val1";

    String key2 = "key2";
    String val2 = "val2";

    String key3 = "key3";
    String field1 = "field1";
    String field2 = "field2";
    String field3 = "field3";
    String field4 = "field4";

    String value1 = "value1";
    String value2 = "value2";
    String value3 = "value3";
    String value4 = "value4";

    Map<String, String> hashMap = new HashMap<String, String>();
    hashMap.put(field1, value1);
    hashMap.put(field2, value2);

    String key4 = "key4";
    Map<String, String> hashMap1 = new HashMap<String, String>();
    hashMap1.put(field3, value3);
    hashMap1.put(field4, value4);

    jedis.set(key1, val1);
    jedis.set(key2, val2);
    jedis.hmset(key3, hashMap);
    jedis.hmset(key4, hashMap1);

    Pipeline pipeline = jedis.pipelined();
    pipeline.multi();

    pipeline.get(key1);
    pipeline.hgetAll(key2);
    pipeline.hgetAll(key3);
    pipeline.get(key4);

    Response<List<Object>> response = pipeline.exec();
    pipeline.sync();

    List<Object> result = response.get();

    assertEquals(4, result.size());

    assertEquals("val1", result.get(0));

    assertTrue(result.get(1) instanceof JedisDataException);

    Map<String, String> hashMapReceived = (Map<String, String>) result.get(2);
    Iterator<String> iterator = hashMapReceived.keySet().iterator();
    String mapKey1 = iterator.next();
    String mapKey2 = iterator.next();
    assertFalse(iterator.hasNext());
    verifyHasBothValues(mapKey1, mapKey2, field1, field2);
    String mapValue1 = hashMapReceived.get(mapKey1);
    String mapValue2 = hashMapReceived.get(mapKey2);
    verifyHasBothValues(mapValue1, mapValue2, value1, value2);

    assertTrue(result.get(3) instanceof JedisDataException);
  }

  @Test
  public void testSyncWithNoCommandQueued() {
    // we need to test with fresh instance of Jedis
    Jedis jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);

    Pipeline pipeline = jedis2.pipelined();
    pipeline.sync();

    jedis2.close();

    jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);

    pipeline = jedis2.pipelined();
    List<Object> resp = pipeline.syncAndReturnAll();
    assertTrue(resp.isEmpty());

    jedis2.close();
  }

  private void verifyHasBothValues(String firstKey, String secondKey, String value1, String value2) {
    assertFalse(firstKey.equals(secondKey));
    assertTrue(firstKey.equals(value1) || firstKey.equals(value2));
    assertTrue(secondKey.equals(value1) || secondKey.equals(value2));
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/main/java/org/junit/experimental/theories/DataPoint.java;<<<<<<< MINE
    String[] value() default {};
||||||| BASE
    String[] value() default {}; 
=======
    String[] value() default {};
    Class<? extends Throwable>[] ignoredExceptions() default {};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/internal/AllMembersSupplierTest.java;<<<<<<< MINE
    
    public static class HasDataPointsArrayField {
||||||| BASE
    public static class HasDataPoints {
=======
    @Rule
    public ExpectedException expected = ExpectedException.none();
    
    public static class HasDataPoints {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/internal/AllMembersSupplierTest.java;<<<<<<< MINE
    public void dataPointsArrayShouldBeRecognizedOnValueTypeNotFieldType() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointsArrayWithMatchingButInaccurateTypes.class.getMethod("theory", Integer.class));
        
        assertEquals(2, assignments.size());
    }
    
    public static class HasDataPointMethodWithOverlyGeneralTypes {
        @DataPoint
        public static Integer object() {
            return 1;
        }

        @Theory
        public void theory(Object param) {
        }
    }

    @Test
    public void dataPointMethodShouldBeRecognizedForOverlyGeneralParameters() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointMethodWithOverlyGeneralTypes.class.getMethod("theory", Object.class));
        
        assertEquals(1, assignments.size());
    }
    
    public static class HasDataPointsWithObjectParameter {
        @DataPoints
        public static Object[] objectField = {1, 2};

        @Theory
        public void theory(Object obj) {
        }
    }

    @Test
    public void dataPointsAnnotationMeansTreatAsArrayOnly() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointsWithObjectParameter.class.getMethod("theory", Object.class));
        
        assertEquals(2, assignments.size());
        for (PotentialAssignment assignment : assignments) {
            assertNotEquals(HasDataPointsWithObjectParameter.objectField, assignment.getValue());
        }
||||||| BASE
    public void dataPointsAnnotationMeansTreatAsArrayOnly()
            throws SecurityException, NoSuchMethodException {
        List<PotentialAssignment> valueSources = new AllMembersSupplier(
                new TestClass(HasDataPoints.class))
                .getValueSources(ParameterSignature.signatures(
                        HasDataPoints.class.getConstructor(Object.class))
                        .get(0));
        assertThat(valueSources.size(), is(2));
=======
    public void dataPointsAnnotationMeansTreatAsArrayOnly() throws Throwable {
        List<PotentialAssignment> valueSources = allMemberValuesFor(
                HasDataPoints.class, Object.class);
        assertThat(valueSources.size(), is(2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;<<<<<<< MINE
    @Test
    public void noTheoryAnnotationMeansAssumeShouldIgnore() {
        Assume.assumeTrue(false);
    }

    @Test
    public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
        Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
        Assert.assertEquals(1, result.getFailureCount());
    }

    /**
     * Simple class that SHOULD fail because no parameters are met.
     */
    public static class TheoryWithNoUnassumedParameters {

        @DataPoint
        public final static boolean FALSE = false;

        @Theory
        public void theoryWithNoUnassumedParameters(boolean value) {
            Assume.assumeTrue(value);
        }
    }
||||||| BASE
	@Test
	public void noTheoryAnnotationMeansAssumeShouldIgnore() {
		Assume.assumeTrue(false);
	}

	@Test
	public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
		JUnitCore junitRunner = new JUnitCore();
		Runner theoryRunner = new Theories(TheoryWithNoUnassumedParameters.class);
		Request request = Request.runner(theoryRunner);
		Result result = junitRunner.run(request);
		Assert.assertEquals(1, result.getFailureCount());
	}

	/**
	 * Simple class that SHOULD fail because no parameters are met.
	 */
	public static class TheoryWithNoUnassumedParameters {
		
		@DataPoint 
		public final static boolean FALSE = false;
		
		@Theory
		public void theoryWithNoUnassumedParameters(boolean value) {
			Assume.assumeTrue(value);
		}
	}
=======
	@Test
	public void noTheoryAnnotationMeansAssumeShouldIgnore() {
		Assume.assumeTrue(false);
	}

	@Test
	public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
		Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
		Assert.assertEquals(1, result.getFailureCount());
	}

	/**
	 * Simple class that SHOULD fail because no parameters are met.
	 */
	public static class TheoryWithNoUnassumedParameters {
		
		@DataPoint 
		public final static boolean FALSE = false;
		
		@Theory
		public void theoryWithNoUnassumedParameters(boolean value) {
			Assume.assumeTrue(value);
		}
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/TheoryTestUtils.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/TheoryTestUtils.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/TheoryTestUtils.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_508d079_7fad9fb/rev_508d079-7fad9fb/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3032c94_f6ff78a/rev_3032c94-f6ff78a/src/main/java/redis/clients/jedis/JedisShardInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_364c6d9_7e24eac/rev_364c6d9-7e24eac/src/test/java/redis/clients/jedis/tests/commands/ObjectCommandsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_364c6d9_7e24eac/rev_364c6d9-7e24eac/src/test/java/redis/clients/jedis/tests/commands/ObjectCommandsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_b09a1e2_ffbca78/rev_b09a1e2-ffbca78/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
public abstract class PipelineBase extends Queable implements BinaryRedisPipeline,
	RedisPipeline {
||||||| BASE
abstract class PipelineBase extends Queable implements BinaryRedisPipeline,
	RedisPipeline {
=======
abstract class PipelineBase extends Queable implements BinaryRedisPipeline, RedisPipeline {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_b09a1e2_ffbca78/rev_b09a1e2-ffbca78/src/main/java/redis/clients/jedis/MultiKeyPipelineBase.java;<<<<<<< MINE
public abstract class MultiKeyPipelineBase extends PipelineBase implements
	BasicRedisPipeline, MultiKeyBinaryRedisPipeline,
	MultiKeyCommandsPipeline, ClusterPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> time() {
	client.time();
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(String destkey, String... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<Long> pfcount(String... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }

    @Override
    public Response<Long> pfcount(final byte[]... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }
||||||| BASE
abstract class MultiKeyPipelineBase extends PipelineBase implements
	BasicRedisPipeline, MultiKeyBinaryRedisPipeline,
	MultiKeyCommandsPipeline, ClusterPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> time() {
	client.time();
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(String destkey, String... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<Long> pfcount(String... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }

    @Override
    public Response<Long> pfcount(final byte[]... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }
=======
abstract class MultiKeyPipelineBase extends PipelineBase implements MultiKeyBinaryRedisPipeline,
    MultiKeyCommandsPipeline, ClusterPipeline, BinaryScriptingCommandsPipeline,
    ScriptingCommandsPipeline {

  protected Client client = null;

  public Response<List<String>> brpop(String... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(int timeout, String... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(String... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> brpop(byte[]... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> brpop(int timeout, byte[]... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> blpop(byte[]... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> blpop(int timeout, byte[]... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> del(String... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[]... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> keys(String pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> keys(byte[] pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> mget(String... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> mget(byte[]... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> mset(String... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> mset(byte[]... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> msetnx(String... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> msetnx(byte[]... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rename(String oldkey, String newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> rename(byte[] oldkey, byte[] newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> renamenx(String oldkey, String newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpoplpush(String srckey, String dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Set<String>> sdiff(String... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sdiff(byte[]... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sdiffstore(String dstkey, String... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sinter(String... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sinter(byte[]... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sinterstore(String dstkey, String... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(String srckey, String dstkey, String member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, SortingParams sortingParameters, String dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, String dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, byte[] dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sunion(String... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sunion(byte[]... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sunionstore(String dstkey, String... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> watch(String... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> watch(byte[]... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zinterstore(String dstkey, String... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(String dstkey, ZParams params, String... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, String... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, ZParams params, String... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> bgrewriteaof() {
    client.bgrewriteaof();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> bgsave() {
    client.bgsave();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> configGet(String pattern) {
    client.configGet(pattern);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> configSet(String parameter, String value) {
    client.configSet(parameter, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> brpoplpush(String source, String destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> configResetStat() {
    client.configResetStat();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> save() {
    client.save();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> lastsave() {
    client.lastsave();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(String channel, String message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> randomKey() {
    client.randomKey();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> randomKeyBinary() {
    client.randomKey();
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> flushDB() {
    client.flushDB();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> flushAll() {
    client.flushAll();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info() {
    client.info();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info(final String section) {
    client.info(section);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> dbSize() {
    client.dbSize();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> shutdown() {
    client.shutdown();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ping() {
    client.ping();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> select(int index) {
    client.select(index);
    Response<String> response = getResponse(BuilderFactory.STRING);
    client.setDb(index);

    return response;
  }

  public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> clusterNodes() {
    client.clusterNodes();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterMeet(final String ip, final int port) {
    client.clusterMeet(ip, port);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterAddSlots(final int... slots) {
    client.clusterAddSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterDelSlots(final int... slots) {
    client.clusterDelSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterInfo() {
    client.clusterInfo();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> clusterGetKeysInSlot(final int slot, final int count) {
    client.clusterGetKeysInSlot(slot, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> clusterSetSlotNode(final int slot, final String nodeId) {
    client.clusterSetSlotNode(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotMigrating(final int slot, final String nodeId) {
    client.clusterSetSlotMigrating(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotImporting(final int slot, final String nodeId) {
    client.clusterSetSlotImporting(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Object> eval(String script) {
    return this.eval(script, 0, new String[0]);
  }

  public Response<Object> eval(String script, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<Object> eval(String script, int keyCount, String... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_RESULT);
  }

  public Response<Object> evalsha(String script) {
    return this.evalsha(script, 0, new String[0]);
  }

  public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<Object> evalsha(String sha1, int keyCount, String... params) {
    getClient(sha1).evalsha(sha1, keyCount, params);
    return getResponse(BuilderFactory.EVAL_RESULT);
  }

  public Response<Object> eval(byte[] script) {
    return this.eval(script, 0);
  }

  public Response<Object> eval(byte[] script, byte[] keyCount, byte[]... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
    byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  public Response<Object> evalsha(byte[] sha1) {
    return this.evalsha(sha1, 0);
  }

  public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
    byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
    getClient(sha1).evalsha(sha1, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  @Override
  public Response<Long> pfcount(String... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(final byte[]... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(String destkey, String... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_d56c729_55d591e/rev_d56c729-55d591e/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
  protected void returnBrokenResource(final Jedis resource) {
||||||| BASE
  public void returnBrokenResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnBrokenResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
   protected void returnResource(final Jedis resource) {
||||||| BASE
  public void returnResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
  protected void returnBrokenResource(final Jedis resource) {
||||||| BASE
  public void returnBrokenResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  public void returnBrokenResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
  protected void returnResource(final Jedis resource) {
||||||| BASE
  public void returnResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  public void returnResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public String set(final String key, final String value, final SetParams params) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
||||||| BASE
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
=======
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import redis.clients.jedis.params.set.SetParams;
import redis.clients.util.Pool;
||||||| BASE
import redis.clients.util.Pool;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/Jedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
    JedisClusterScriptingCommands {
||||||| BASE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 1;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 2000;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public JedisCluster(Set<HostAndPort> nodes) {
    this(nodes, DEFAULT_TIMEOUT);
  }
||||||| BASE
  private int timeout;
  private int maxRedirections;

  private JedisClusterConnectionHandler connectionHandler;
=======
  private int maxRedirections;

  private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
||||||| BASE
  @Override
  public String ping() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.ping();
      }
    }.run(null);
  }

  @Override
  public String quit() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.quit();
      }
    }.run(null);
  }

  @Override
  public String flushDB() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.flushDB();
      }
    }.run(null);
  }

  @Override
  public Long dbSize() {
    return new JedisClusterCommand<Long>(connectionHandler, timeout, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.dbSize();
      }
    }.run(null);
  }

  @Override
  public String select(final int index) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.select(index);
      }
    }.run(null);
  }

  @Override
  public String flushAll() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.flushAll();
      }
    }.run(null);
  }

  @Override
  public String auth(final String password) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.auth(password);
      }
    }.run(null);
  }

  @Override
  public String save() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.save();
      }
    }.run(null);
  }

  @Override
  public String bgsave() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.bgsave();
      }
    }.run(null);
  }

  @Override
  public String bgrewriteaof() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.bgrewriteaof();
      }
    }.run(null);
  }

  @Override
  public Long lastsave() {
    return new JedisClusterCommand<Long>(connectionHandler, timeout, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.lastsave();
      }
    }.run(null);
  }

  @Override
  public String shutdown() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.shutdown();
      }
    }.run(null);
  }

  @Override
  public String info() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.info();
      }
    }.run(null);
  }

  @Override
  public String info(final String section) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.info(section);
      }
    }.run(null);
  }

  @Override
  public String slaveof(final String host, final int port) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.slaveof(host, port);
      }
    }.run(null);
  }

  @Override
  public String slaveofNoOne() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.slaveofNoOne();
      }
    }.run(null);
  }

  @Override
  public Long getDB() {
    return new JedisClusterCommand<Long>(connectionHandler, timeout, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.getDB();
      }
    }.run(null);
  }

  @Override
  public String debug(final DebugParams params) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.debug(params);
      }
    }.run(null);
  }

  @Override
  public String configResetStat() {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.configResetStat();
      }
    }.run(null);
  }

=======
  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String ping() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.ping();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String quit() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.quit();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String flushDB() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.flushDB();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public Long dbSize() {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.dbSize();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String select(final int index) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.select(index);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String flushAll() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.flushAll();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String auth(final String password) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.auth(password);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String save() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.save();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String bgsave() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.bgsave();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String bgrewriteaof() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.bgrewriteaof();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public Long lastsave() {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.lastsave();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String shutdown() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.shutdown();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String info() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.info();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String info(final String section) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.info(section);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String slaveof(final String host, final int port) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.slaveof(host, port);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String slaveofNoOne() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.slaveofNoOne();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public int getDB() {
    return new JedisClusterCommand<Integer>(connectionHandler, maxRedirections) {
      @Override
      public Integer execute(Jedis connection) {
        return connection.getDB();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String debug(final DebugParams params) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.debug(params);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String configResetStat() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.configResetStat();
      }
    }.run(null);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE

    for (String clientInfo : deadClient.clientList().split("\n")) {
      if (clientInfo.contains("DEAD")) {
        // Ugly, but cmon, it's a test.
        String[] hostAndPort = clientInfo.split(" ")[1].split("=")[1].split(":");
        // It would be better if we kill the client by Id as it's safer but jedis doesn't implement
        // the command yet.
        deadClient.clientKill(hostAndPort[0] + ":" + hostAndPort[1]);
      }
    }
||||||| BASE
    
    for (String clientInfo: deadClient.clientList().split("\n")) {
	if (clientInfo.contains("DEAD")) {
	    //Ugly, but cmon, it's a test.
	    String[] hostAndPort = clientInfo.split(" ")[1].split("=")[1].split(":");
	    //It would be better if we kill the client by Id as it's safer but jedis doesn't implement the command yet.
	    deadClient.clientKill(hostAndPort[0]+ ":" +hostAndPort[1]);
	}
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
    assertEquals(true, deadClient.isConnected());
    assertEquals(false, deadClient.getClient().getSocket().isClosed());
    assertEquals(false, deadClient.getClient().isBroken()); // normal - not found

    shardedJedis.disconnect();

    assertEquals(false, deadClient.isConnected());
    assertEquals(true, deadClient.getClient().getSocket().isClosed());
    assertEquals(true, deadClient.getClient().isBroken());

    Jedis jedis2 = it.next();
    assertEquals(false, jedis2.isConnected());
    assertEquals(true, jedis2.getClient().getSocket().isClosed());
    assertEquals(false, jedis2.getClient().isBroken());

||||||| BASE
      assertEquals(true, deadClient.isConnected());
      assertEquals(false, deadClient.getClient().getSocket().isClosed());
      assertEquals(false, deadClient.getClient().isBroken()); // normal - not found

      shardedJedis.disconnect();

      assertEquals(false, deadClient.isConnected());
      assertEquals(true, deadClient.getClient().getSocket().isClosed());
      assertEquals(true, deadClient.getClient().isBroken());
      
      Jedis jedis2 = it.next();
      assertEquals(false, jedis2.isConnected());
      assertEquals(true, jedis2.getClient().getSocket().isClosed());
      assertEquals(false, jedis2.getClient().isBroken());
   
=======
    ClientKillerUtil.killClient(deadClient, "DEAD");

    assertEquals(true, deadClient.isConnected());
    assertEquals(false, deadClient.getClient().getSocket().isClosed());
    assertEquals(false, deadClient.getClient().isBroken()); // normal - not found

    shardedJedis.disconnect();

    assertEquals(false, deadClient.isConnected());
    assertEquals(true, deadClient.getClient().getSocket().isClosed());
    assertEquals(true, deadClient.getClient().isBroken());

    Jedis jedis2 = it.next();
    assertEquals(false, jedis2.isConnected());
    assertEquals(true, jedis2.getClient().getSocket().isClosed());
    assertEquals(false, jedis2.getClient().isBroken());

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}
||||||| BASE
        JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}
=======
    JedisClusterScriptingCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
	    int maxRedirections) {
        this(nodes, timeout, maxRedirections,
                new GenericObjectPoolConfig());
    }

    public JedisCluster(Set<HostAndPort> nodes,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, DEFAULT_TIMEOUT, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	super(jedisClusterNode, timeout, maxRedirections, poolConfig);
    }
    
    @Override
    public String set(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.set(key, value);
	    }
	}.run(key);
    }

    @Override
    public String set(final String key, final String value, final String nxxx,
                      final String expx, final long time) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.set(key, value, nxxx, expx, time);
            }
        }.run(key);
    }

    @Override
    public String get(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.get(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean exists(final String key) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.exists(key);
	    }
	}.run(key);
    }

    @Override
    public Long persist(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.persist(key);
	    }
	}.run(key);
    }

    @Override
    public String type(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.type(key);
	    }
	}.run(key);
    }

    @Override
    public Long expire(final String key, final int seconds) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.expire(key, seconds);
	    }
	}.run(key);
    }

    @Override
    public Long expireAt(final String key, final long unixTime) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.expireAt(key, unixTime);
	    }
	}.run(key);
    }

    @Override
    public Long ttl(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.ttl(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final boolean value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final String value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean getbit(final String key, final long offset) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.getbit(key, offset);
	    }
	}.run(key);
    }

    @Override
    public Long setrange(final String key, final long offset, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setrange(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public String getrange(final String key, final long startOffset,
	    final long endOffset) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getrange(key,
			startOffset, endOffset);
	    }
	}.run(key);
    }

    @Override
    public String getSet(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getSet(key, value);
	    }
	}.run(key);
    }

    @Override
    public Long setnx(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setnx(key, value);
	    }
	}.run(key);
    }

    @Override
    public String setex(final String key, final int seconds, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.setex(key, seconds,
			value);
	    }
	}.run(key);
    }

    @Override
    public Long decrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long decr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decr(key);
	    }
	}.run(key);
    }

    @Override
    public Long incrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long incr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incr(key);
	    }
	}.run(key);
    }

    @Override
    public Long append(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.append(key, value);
	    }
	}.run(key);
    }

    @Override
    public String substr(final String key, final int start, final int end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.substr(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long hset(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.hset(key, field, value);
	    }
	}.run(key);
    }

    @Override
    public String hget(final String key, final String field) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hget(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hsetnx(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hsetnx(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public String hmset(final String key, final Map<String, String> hash) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hmset(key, hash);
	    }
	}.run(key);
    }

    @Override
    public List<String> hmget(final String key, final String... fields) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hmget(key, fields);
	    }
	}.run(key);
    }

    @Override
    public Long hincrBy(final String key, final String field, final long value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hincrBy(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean hexists(final String key, final String field) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.hexists(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hdel(final String key, final String... field) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hdel(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hlen(key);
	    }
	}.run(key);
    }

    @Override
    public Set<String> hkeys(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.hkeys(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> hvals(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hvals(key);
	    }
	}.run(key);
    }

    @Override
    public Map<String, String> hgetAll(final String key) {
	return new JedisClusterCommand<Map<String, String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public Map<String, String> execute(Jedis connection) {
		return connection.hgetAll(key);
	    }
	}.run(key);
    }

    @Override
    public Long rpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long lpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long llen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.llen(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> lrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection
			.lrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String ltrim(final String key, final long start, final long end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ltrim(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String lindex(final String key, final long index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lindex(key, index);
	    }
	}.run(key);
    }

    @Override
    public String lset(final String key, final long index, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.lset(key, index, value);
	    }
	}.run(key);
    }

    @Override
    public Long lrem(final String key, final long count, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.lrem(key, count, value);
	    }
	}.run(key);
    }

    @Override
    public String lpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lpop(key);
	    }
	}.run(key);
    }

    @Override
    public String rpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpop(key);
	    }
	}.run(key);
    }

    @Override
    public Long sadd(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sadd(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> smembers(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.smembers(key);
	    }
	}.run(key);
    }

    @Override
    public Long srem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.srem(key, member);
	    }
	}.run(key);
    }

    @Override
    public String spop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.spop(key);
	    }
	}.run(key);
    }

    @Override
    public Long scard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.scard(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean sismember(final String key, final String member) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.sismember(key, member);
	    }
	}.run(key);
    }

    @Override
    public String srandmember(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.srandmember(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> srandmember(final String key, final int count) {
        return new JedisClusterCommand<List<String>>(connectionHandler, timeout,
            maxRedirections) {
            @Override
            public List<String> execute(Jedis connection) {
            return connection.srandmember(key, count);
            }
        }.run(key);
    }

    @Override
    public Long strlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.strlen(key);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final double score, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zadd(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final Map<String, Double> scoreMembers) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.zadd(key, scoreMembers);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrange(final String key, final long start, final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection
			.zrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zrem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrem(key, member);
	    }
	}.run(key);
    }

    @Override
    public Double zincrby(final String key, final double score,
	    final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zincrby(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Long zrevrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrevrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrange(key, start,
			end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrangeWithScores(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrevrangeWithScores(
			key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zcard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcard(key);
	    }
	}.run(key);
    }

    @Override
    public Double zscore(final String key, final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zscore(key, member);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key,
	    final SortingParams sortingParameters) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key,
			sortingParameters);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final double min, final double max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByRank(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByRank(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final double start,
	    final double end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final String start,
	    final String end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }
    
    @Override
    public Long zlexcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long linsert(final String key, final LIST_POSITION where,
	    final String pivot, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.linsert(key, where,
			pivot, value);
	    }
	}.run(key);
    }

    @Override
    public Long lpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long rpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpushx(key, string);
	    }
	}.run(key);
    }
    
    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, key);
	    }
	}.run(key);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, key);
	    }
	}.run(key);
    }


    @Override
    public List<String> blpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(arg);
	    }
	}.run(arg);
    }

    @Override
    public List<String> brpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(arg);
	    }
	}.run(arg);
    }

    @Override
    public Long del(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(key);
	    }
	}.run(key);
    }

    @Override
    public String echo(final String string) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.echo(string);
	    }
	}.run(null);
    }

    @Override
    public Long move(final String key, final int dbIndex) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.move(key, dbIndex);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key, final long start, final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key, start,
			end);
	    }
	}.run(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final String cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(key);
    }
    
    @Override
    public ScanResult<String> sscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(key);
    }
    
    @Override
    public ScanResult<Tuple> zscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(key);
    }

    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
||||||| BASE
    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
	    int maxRedirections) {
        this(nodes, timeout, maxRedirections,
                new GenericObjectPoolConfig());
    }

    public JedisCluster(Set<HostAndPort> nodes,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, DEFAULT_TIMEOUT, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	super(jedisClusterNode, timeout, maxRedirections, poolConfig);
    }
    
    @Override
    public String set(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.set(key, value);
	    }
	}.run(key);
    }

    @Override
    public String set(final String key, final String value, final String nxxx,
                      final String expx, final long time) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.set(key, value, nxxx, expx, time);
            }
        }.run(key);
    }

    @Override
    public String get(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.get(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean exists(final String key) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.exists(key);
	    }
	}.run(key);
    }

    @Override
    public Long persist(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.persist(key);
	    }
	}.run(key);
    }

    @Override
    public String type(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.type(key);
	    }
	}.run(key);
    }

    @Override
    public Long expire(final String key, final int seconds) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.expire(key, seconds);
	    }
	}.run(key);
    }

    @Override
    public Long expireAt(final String key, final long unixTime) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.expireAt(key, unixTime);
	    }
	}.run(key);
    }

    @Override
    public Long ttl(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.ttl(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final boolean value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final String value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean getbit(final String key, final long offset) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.getbit(key, offset);
	    }
	}.run(key);
    }

    @Override
    public Long setrange(final String key, final long offset, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setrange(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public String getrange(final String key, final long startOffset,
	    final long endOffset) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getrange(key,
			startOffset, endOffset);
	    }
	}.run(key);
    }

    @Override
    public String getSet(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getSet(key, value);
	    }
	}.run(key);
    }

    @Override
    public Long setnx(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setnx(key, value);
	    }
	}.run(key);
    }

    @Override
    public String setex(final String key, final int seconds, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.setex(key, seconds,
			value);
	    }
	}.run(key);
    }

    @Override
    public Long decrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long decr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decr(key);
	    }
	}.run(key);
    }

    @Override
    public Long incrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long incr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incr(key);
	    }
	}.run(key);
    }

    @Override
    public Long append(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.append(key, value);
	    }
	}.run(key);
    }

    @Override
    public String substr(final String key, final int start, final int end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.substr(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long hset(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.hset(key, field, value);
	    }
	}.run(key);
    }

    @Override
    public String hget(final String key, final String field) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hget(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hsetnx(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hsetnx(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public String hmset(final String key, final Map<String, String> hash) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hmset(key, hash);
	    }
	}.run(key);
    }

    @Override
    public List<String> hmget(final String key, final String... fields) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hmget(key, fields);
	    }
	}.run(key);
    }

    @Override
    public Long hincrBy(final String key, final String field, final long value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hincrBy(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean hexists(final String key, final String field) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.hexists(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hdel(final String key, final String... field) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hdel(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hlen(key);
	    }
	}.run(key);
    }

    @Override
    public Set<String> hkeys(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.hkeys(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> hvals(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hvals(key);
	    }
	}.run(key);
    }

    @Override
    public Map<String, String> hgetAll(final String key) {
	return new JedisClusterCommand<Map<String, String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public Map<String, String> execute(Jedis connection) {
		return connection.hgetAll(key);
	    }
	}.run(key);
    }

    @Override
    public Long rpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long lpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long llen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.llen(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> lrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection
			.lrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String ltrim(final String key, final long start, final long end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ltrim(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String lindex(final String key, final long index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lindex(key, index);
	    }
	}.run(key);
    }

    @Override
    public String lset(final String key, final long index, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.lset(key, index, value);
	    }
	}.run(key);
    }

    @Override
    public Long lrem(final String key, final long count, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.lrem(key, count, value);
	    }
	}.run(key);
    }

    @Override
    public String lpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lpop(key);
	    }
	}.run(key);
    }

    @Override
    public String rpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpop(key);
	    }
	}.run(key);
    }

    @Override
    public Long sadd(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sadd(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> smembers(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.smembers(key);
	    }
	}.run(key);
    }

    @Override
    public Long srem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.srem(key, member);
	    }
	}.run(key);
    }

    @Override
    public String spop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.spop(key);
	    }
	}.run(key);
    }

    @Override
    public Long scard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.scard(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean sismember(final String key, final String member) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.sismember(key, member);
	    }
	}.run(key);
    }

    @Override
    public String srandmember(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.srandmember(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> srandmember(final String key, final int count) {
        return new JedisClusterCommand<List<String>>(connectionHandler, timeout,
            maxRedirections) {
            @Override
            public List<String> execute(Jedis connection) {
            return connection.srandmember(key, count);
            }
        }.run(key);
    }

    @Override
    public Long strlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.strlen(key);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final double score, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zadd(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final Map<String, Double> scoreMembers) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.zadd(key, scoreMembers);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrange(final String key, final long start, final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection
			.zrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zrem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrem(key, member);
	    }
	}.run(key);
    }

    @Override
    public Double zincrby(final String key, final double score,
	    final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zincrby(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Long zrevrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrevrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrange(key, start,
			end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrangeWithScores(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrevrangeWithScores(
			key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zcard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcard(key);
	    }
	}.run(key);
    }

    @Override
    public Double zscore(final String key, final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zscore(key, member);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key,
	    final SortingParams sortingParameters) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key,
			sortingParameters);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final double min, final double max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByRank(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByRank(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final double start,
	    final double end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final String start,
	    final String end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }
    
    @Override
    public Long zlexcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long linsert(final String key, final LIST_POSITION where,
	    final String pivot, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.linsert(key, where,
			pivot, value);
	    }
	}.run(key);
    }

    @Override
    public Long lpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long rpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(arg);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(arg);
	    }
	}.run(null);
    }

    @Override
    public Long del(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(key);
	    }
	}.run(key);
    }

    @Override
    public String echo(final String string) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.echo(string);
	    }
	}.run(null);
    }

    @Override
    public Long move(final String key, final int dbIndex) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.move(key, dbIndex);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key, final long start, final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key, start,
			end);
	    }
	}.run(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final String cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<String> sscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<Tuple> zscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }

    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
=======
  public static enum Reset {
    SOFT, HARD
  }

  public JedisCluster(Set<HostAndPort> nodes) {
    this(nodes, DEFAULT_TIMEOUT);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout) {
    this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, int maxRedirections) {
    this(nodes, timeout, maxRedirections, new GenericObjectPoolConfig());
  }

  public JedisCluster(Set<HostAndPort> nodes, final GenericObjectPoolConfig poolConfig) {
    this(nodes, DEFAULT_TIMEOUT, DEFAULT_MAX_REDIRECTIONS, poolConfig);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, final GenericObjectPoolConfig poolConfig) {
    this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, poolConfig);
  }

  public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout, int maxRedirections,
      final GenericObjectPoolConfig poolConfig) {
    super(jedisClusterNode, timeout, maxRedirections, poolConfig);
  }

  public Map<String, JedisPool> getClusterNodes() {
    return connectionHandler.getNodes();
  }

  @Override
  public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler, maxRedirections) {
      @Override
      public Object execute(Jedis connection) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
        return new JedisClusterCommand<String>(connectionHandler,
                timeout, maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.scriptLoad(script);
            }
        }.run(key);
    }

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long del(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> blpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.run(keys.length, keys);

    }
    
    @Override
    public List<String> brpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> mget(final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.run(keys.length - 1, keys);
    }

    @Override
    public String mset(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long msetnx(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public String rename(final String oldkey, final String newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final String oldkey, final String newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public String rpoplpush(final String srckey, final String dstkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Set<String> sdiff(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Set<String> sinter(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sinterstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long smove(final String srckey, final String dstkey,
	    final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Long sort(final String key, final SortingParams sortingParameters,
	    final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Long sort(final String key, final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Set<String> sunion(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sunionstore(final String dstkey, final String... keys) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final String... sets) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String brpoplpush(final String source, final String destination,
	    final int timeout) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.run(2, source, destination);
    }

    @Override
    public Long publish(final String channel, final String message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final JedisPubSub jedisPubSub,
	    final String... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final JedisPubSub jedisPubSub,
	    final String... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final String destKey,
	    final String... srcKeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String pfmerge(final String destkey, final String... sourcekeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public long pfcount(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.run(keys.length, keys);
    }

||||||| BASE
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
        return new JedisClusterCommand<String>(connectionHandler,
                timeout, maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.scriptLoad(script);
            }
        }.run(key);
    }

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
=======
  }

  @Override
  public Set<String> zrevrangeByScore(final String key, final String max, final String min,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByScore(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrangeByScoreWithScores(final String key, final String min, final String max) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrangeByScoreWithScores(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final String max, final String min) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrangeByScoreWithScores(key, min, max, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final double max,
      final double min, final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final String max,
      final String min, final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByRank(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByRank(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByScore(final String key, final double start, final double end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByScore(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByScore(final String key, final String start, final String end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByScore(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zlexcount(final String key, final String min, final String max) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zlexcount(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrangeByLex(final String key, final String min, final String max) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrangeByLex(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrangeByLex(final String key, final String min, final String max,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrangeByLex(key, min, max, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrevrangeByLex(final String key, final String max, final String min) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByLex(key, max, min);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByLex(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByLex(final String key, final String min, final String max) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByLex(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Long linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.linsert(key, where, pivot, value);
      }
    }.run(key);
  }

  @Override
  public Long lpushx(final String key, final String... string) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.lpushx(key, string);
      }
    }.run(key);
  }

  @Override
  public Long rpushx(final String key, final String... string) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.rpushx(key, string);
      }
    }.run(key);
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Override
  @Deprecated
  public List<String> blpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.blpop(arg);
      }
    }.run(arg);
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Override
  @Deprecated
  public List<String> brpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.brpop(arg);
      }
    }.run(arg);
  }

  @Override
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.del(key);
      }
    }.run(key);
  }

  @Override
  public String echo(final String string) {
    // note that it'll be run from arbitary node
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.echo(string);
      }
    }.run(string);
  }

  @Override
  public Long move(final String key, final int dbIndex) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.move(key, dbIndex);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key, start, end);
      }
    }.run(key);
  }

  @Override
  public ScanResult<Entry<String, String>> hscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<Entry<String, String>>>(connectionHandler,
        maxRedirections) {
      @Override
      public ScanResult<Entry<String, String>> execute(Jedis connection) {
        return connection.hscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public ScanResult<String> sscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<String>>(connectionHandler, maxRedirections) {
      @Override
      public ScanResult<String> execute(Jedis connection) {
        return connection.sscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public ScanResult<Tuple> zscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public ScanResult<Tuple> execute(Jedis connection) {
        return connection.zscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public Long pfadd(final String key, final String... elements) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.pfadd(key, elements);
      }
    }.run(key);
  }

  @Override
  public long pfcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.pfcount(key);
      }
    }.run(key);
  }

  @Override
  public List<String> blpop(final int timeout, final String key) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.blpop(timeout, key);
      }
    }.run(key);
  }

  @Override
  public List<String> brpop(final int timeout, final String key) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.brpop(timeout, key);
      }
    }.run(key);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
        
        return runWithRetries(keys[0], this.redirections, false, false);
    }
    
    public T runWithAnyNode() {
	Jedis connection = null;
	try {
	    connection = connectionHandler.getConnection();
	    return execute(connection);
	} catch (JedisConnectionException e) {
	    releaseConnection(connection, true);
	    throw e;
	} finally {
	    releaseConnection(connection, false);
	}
    }
||||||| BASE
        
        return runWithRetries(keys[0], this.redirections, false, false);
    }
=======
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
	MultiKeyBinaryJedisClusterCommands, JedisClusterBinaryScriptingCommands, 
	Closeable {
    
    public static final short HASHSLOTS = 16384;
    protected static final int DEFAULT_TIMEOUT = 1;
    protected static final int DEFAULT_MAX_REDIRECTIONS = 5;

    protected int timeout;
    protected int maxRedirections;

    protected JedisClusterConnectionHandler connectionHandler;
    
    public BinaryJedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, new GenericObjectPoolConfig());
    }

    public BinaryJedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public BinaryJedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
	    int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	this.connectionHandler = new JedisSlotBasedConnectionHandler(
		jedisClusterNode, poolConfig);
	this.timeout = timeout;
	this.maxRedirections = maxRedirections;
    }

    @Override
    public String set(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
        maxRedirections) {
            @Override
            public String execute(Jedis connection) {
            return connection.set(key, value);
            }
        }.runBinary(key);
    }
 
    @Override
    public byte[] get(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.get(key);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean exists(final byte[] key) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.exists(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long persist(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.persist(key);
            }
        }.runBinary(key);
    }

    @Override
    public String type(final byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.type(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long expire(final byte[] key, final int seconds) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expire(key, seconds);
            }
        }.runBinary(key);
    }

    @Override
    public Long expireAt(final byte[] key, final long unixTime) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expireAt(key, unixTime);
            }
        }.runBinary(key);
    }

    @Override
    public Long ttl(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.ttl(key);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean setbit(final byte[] key, final long offset, final boolean value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean setbit(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean getbit(final byte[] key, final long offset) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.getbit(key, offset);
            }
        }.runBinary(key);
    }

    @Override
    public Long setrange(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setrange(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getrange(final byte[] key, final long startOffset, final long endOffset) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getrange(key, startOffset, endOffset);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getSet(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getSet(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long setnx(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setnx(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public String setex(final byte[] key, final int seconds, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.setex(key, seconds, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long decrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Long decr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long incrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Double incrByFloat(final byte[] key, final double value) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) { return connection.incrByFloat(key, value); }
        }.runBinary(key);
    }

    @Override
    public Long incr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long append(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.append(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] substr(final byte[] key, final int start, final int end) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.substr(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long hset(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hset(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] hget(final byte[] key, final byte[] field) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.hget(key, field);
            }
        }.runBinary(key);
    }

    @Override
    public Long hsetnx(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hsetnx(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public String hmset(final byte[] key, final Map<byte[], byte[]> hash) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.hmset(key, hash);
            }
        }.runBinary(key);
    }

    @Override
    public List<byte[]> hmget(final byte[] key, final byte[]... fields) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.hmget(key, fields);
            }
        }.runBinary(key);
    }
||||||| BASE
        JedisClusterBinaryScriptingCommands, Closeable {
    
    public static final short HASHSLOTS = 16384;
    protected static final int DEFAULT_TIMEOUT = 1;
    protected static final int DEFAULT_MAX_REDIRECTIONS = 5;

    protected int timeout;
    protected int maxRedirections;

    protected JedisClusterConnectionHandler connectionHandler;
    
    public BinaryJedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, new GenericObjectPoolConfig());
    }

    public BinaryJedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public BinaryJedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
	    int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	this.connectionHandler = new JedisSlotBasedConnectionHandler(
		jedisClusterNode, poolConfig);
	this.timeout = timeout;
	this.maxRedirections = maxRedirections;
    }

    @Override
    public String set(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
        maxRedirections) {
            @Override
            public String execute(Jedis connection) {
            return connection.set(key, value);
            }
        }.runBinary(key);
    }
 
    @Override
    public byte[] get(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.get(key);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean exists(final byte[] key) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.exists(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long persist(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.persist(key);
            }
        }.runBinary(key);
    }

    @Override
    public String type(final byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.type(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long expire(final byte[] key, final int seconds) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expire(key, seconds);
            }
        }.runBinary(key);
    }

    @Override
    public Long expireAt(final byte[] key, final long unixTime) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expireAt(key, unixTime);
            }
        }.runBinary(key);
    }

    @Override
    public Long ttl(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.ttl(key);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean setbit(final byte[] key, final long offset, final boolean value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean setbit(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean getbit(final byte[] key, final long offset) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.getbit(key, offset);
            }
        }.runBinary(key);
    }

    @Override
    public Long setrange(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setrange(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getrange(final byte[] key, final long startOffset, final long endOffset) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getrange(key, startOffset, endOffset);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getSet(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getSet(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long setnx(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setnx(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public String setex(final byte[] key, final int seconds, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.setex(key, seconds, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long decrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Long decr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long incrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Double incrByFloat(final byte[] key, final double value) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) { return connection.incrByFloat(key, value); }
        }.runBinary(key);
    }

    @Override
    public Long incr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long append(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.append(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] substr(final byte[] key, final int start, final int end) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.substr(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long hset(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hset(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] hget(final byte[] key, final byte[] field) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.hget(key, field);
            }
        }.runBinary(key);
    }

    @Override
    public Long hsetnx(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hsetnx(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public String hmset(final byte[] key, final Map<byte[], byte[]> hash) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.hmset(key, hash);
            }
        }.runBinary(key);
    }

    @Override
    public List<byte[]> hmget(final byte[] key, final byte[]... fields) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.hmget(key, fields);
            }
        }.runBinary(key);
    }
=======
    JedisClusterBinaryScriptingCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
    @Override
    public Long lrem(final byte[] key, final long count, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.lrem(key, count, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] lpop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.lpop(key);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] rpop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.rpop(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long sadd(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.sadd(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> smembers(final byte[] key) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.smembers(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long srem(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.srem(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] spop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.spop(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long scard(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.scard(key);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean sismember(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.sismember(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] srandmember(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.srandmember(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long strlen(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.strlen(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long zadd(final byte[] key, final double score, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zadd(key, score, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zadd(final byte[] key, final Map<byte[], Double> scoreMembers) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zadd(key, scoreMembers);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrange(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrange(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrem(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrem(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Double zincrby(final byte[] key, final double score, final byte[] member) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) {
                return connection.zincrby(key, score, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrank(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrank(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrevrank(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrevrank(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrange(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrevrange(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeWithScores(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<Tuple> execute(Jedis connection) {
                return connection.zrangeWithScores(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<Tuple> execute(Jedis connection) {
                return connection.zrevrangeWithScores(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcard(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcard(key);
            }
        }.runBinary(key);
    }

    @Override
    public Double zscore(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) {
                return connection.zscore(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public List<byte[]> sort(final byte[] key) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.sort(key);
            }
        }.runBinary(key);
    }

    
    @Override
    public List<byte[]> sort(final byte[] key, final SortingParams sortingParameters) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.sort(key, sortingParameters);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcount(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcount(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcount(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrangeByScore(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrangeByScore(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max,min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max, final int offset,
	    final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrangeByScore(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max, final int offset,
	    final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrangeByScore(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
             }
         }.runBinary(key);
    }
	    
    @Override
    public Long zremrangeByRank(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByRank(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long zremrangeByScore(final byte[] key, final double start, final double end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByScore(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long zremrangeByScore(final byte[] key, final byte[] start, final byte[] end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByScore(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long linsert(final byte[] key, final Client.LIST_POSITION where, final byte[] pivot,
	    final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.linsert(key, where, pivot, value);
             }
         }.runBinary(key);
    }

    @Override
    public Long lpushx(final byte[] key, final byte[]... arg) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.lpushx(key, arg);
             }
         }.runBinary(key);
    }

    @Override
    public Long rpushx(final byte[] key, final byte[]... arg) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.rpushx(key, arg);
             }
         }.runBinary(key);
    }

    @Override
    public List<byte[]> blpop(final byte[] arg) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public List<byte[]> execute(Jedis connection) {
             return connection.blpop(arg);
             }
         }.runBinary(arg);
    }

    @Override
    public List<byte[]> brpop(final byte[] arg) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public List<byte[]> execute(Jedis connection) {
             return connection.brpop(arg);
             }
         }.runBinary(arg);
    }

    @Override
    public Long del(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.del(key);
             }
         }.runBinary(key);
    }

    @Override
    public byte[] echo(final byte[] arg) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public byte[] execute(Jedis connection) {
             return connection.echo(arg);
             }
         }.runBinary(null);
    }

    @Override 
    public Long move(final byte[] key, final int dbIndex) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.move(key, dbIndex);
             }
         }.runBinary(null);
    }

    @Override
    public Long bitcount(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.bitcount(key);
             }
         }.runBinary(key);
    }

    @Override
    public Long bitcount(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.bitcount(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long pfadd(final byte[] key, final byte[]... elements) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) { return connection.pfadd(key, elements); }
        }.runBinary(key);
    }

    @Override
    public long pfcount(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) { return connection.pfcount(key); }
        }.runBinary(key);
    }
    
    @Override
    public List<byte[]> srandmember(final byte[] key, final int count) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.srandmember(key, count);
	    }
	}.runBinary(key);
    }

    @Override
    public Long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.runBinary(key);
    }

    @Override
    public Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.runBinary(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
        return connectionHandler.getNodes();
    }
    
    @Override
    public Object eval(final byte[] script, final byte[] keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keyCount, params);
                }
            }.runBinary(Integer.parseInt(SafeEncoder.encode(keyCount)), params);
    }

    @Override
    public Object eval(final byte[] script, final int keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keyCount, params);
                }
            }.runBinary(keyCount, params);
    }

    @Override
    public Object eval(final byte[] script, final List<byte[]> keys, final List<byte[]> args) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keys, args);
                }
            }.runBinary(keys.size(), keys.toArray(new byte[keys.size()][]));
    }

    @Override
    public Object eval(final byte[] script, byte[] key) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script);
                }
            }.runBinary(key);
    }

    @Override
    public Object evalsha(final byte[] script, byte[] key) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(script);
                }
            }.runBinary(key);
    }

    @Override
    public Object evalsha(final byte[] sha1, final List<byte[]> keys, final List<byte[]> args) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(sha1, keys, args);
                }
            }.runBinary(keys.size(), keys.toArray(new byte[keys.size()][]));
    }

    @Override
    public Object evalsha(final byte[] sha1, final int keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(sha1, keyCount, params);
                }
            }.runBinary(keyCount, params);
    }
    
    @Override
    public List<Long> scriptExists(final byte[] key, final byte[][] sha1) {
        return new JedisClusterCommand<List<Long>>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public List<Long> execute(Jedis connection) {
                return connection.scriptExists(sha1);
                }
            }.runBinary(key);
    }
    
    @Override
    public byte[] scriptLoad(final byte[] script, final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public byte[] execute(Jedis connection) {
                return connection.scriptLoad(script);
                }
            }.runBinary(key);
    }
    
    @Override
    public String scriptFlush(final byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public String execute(Jedis connection) {
                return connection.scriptFlush();
                }
            }.runBinary(key);
    }
    
    @Override
    public String scriptKill(byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public String execute(Jedis connection) {
                return connection.scriptKill();
                }
            }.runBinary(key);
    }
    
    @Override
    public Long del(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> mget(final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.runBinary(keys.length - 1, keys);
    }

    @Override
    public String mset(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long msetnx(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public String rename(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public byte[] rpoplpush(final byte[] srckey, final byte[] dstkey) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Set<byte[]> sdiff(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Set<byte[]> sinter(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sinterstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long smove(final byte[] srckey, final byte[] dstkey,
	    final byte[] member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Set<byte[]> sunion(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sunionstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public byte[] brpoplpush(final byte[] source, final byte[] destination,
	    final int timeout) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.runBinary(2, source, destination);
    }

    @Override
    public Long publish(final byte[] channel, final byte[] message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final byte[] destKey,
	    final byte[]... srcKeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long pfcount(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public void close() throws IOException {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}	
    }
||||||| BASE
    @Override
    public Long lrem(final byte[] key, final long count, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.lrem(key, count, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] lpop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.lpop(key);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] rpop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.rpop(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long sadd(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.sadd(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> smembers(final byte[] key) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.smembers(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long srem(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.srem(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] spop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.spop(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long scard(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.scard(key);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean sismember(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.sismember(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] srandmember(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.srandmember(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long strlen(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.strlen(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long zadd(final byte[] key, final double score, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zadd(key, score, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zadd(final byte[] key, final Map<byte[], Double> scoreMembers) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zadd(key, scoreMembers);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrange(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrange(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrem(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrem(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Double zincrby(final byte[] key, final double score, final byte[] member) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) {
                return connection.zincrby(key, score, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrank(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrank(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrevrank(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrevrank(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrange(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrevrange(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeWithScores(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<Tuple> execute(Jedis connection) {
                return connection.zrangeWithScores(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<Tuple> execute(Jedis connection) {
                return connection.zrevrangeWithScores(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcard(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcard(key);
            }
        }.runBinary(key);
    }

    @Override
    public Double zscore(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) {
                return connection.zscore(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public List<byte[]> sort(final byte[] key) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.sort(key);
            }
        }.runBinary(key);
    }

    
    @Override
    public List<byte[]> sort(final byte[] key, final SortingParams sortingParameters) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.sort(key, sortingParameters);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcount(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcount(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcount(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrangeByScore(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrangeByScore(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max,min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max, final int offset,
	    final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrangeByScore(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max, final int offset,
	    final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrangeByScore(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
             }
         }.runBinary(key);
    }
	    
    @Override
    public Long zremrangeByRank(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByRank(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long zremrangeByScore(final byte[] key, final double start, final double end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByScore(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long zremrangeByScore(final byte[] key, final byte[] start, final byte[] end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByScore(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long linsert(final byte[] key, final Client.LIST_POSITION where, final byte[] pivot,
	    final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.linsert(key, where, pivot, value);
             }
         }.runBinary(key);
    }

    @Override
    public Long lpushx(final byte[] key, final byte[]... arg) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.lpushx(key, arg);
             }
         }.runBinary(key);
    }

    @Override
    public Long rpushx(final byte[] key, final byte[]... arg) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.rpushx(key, arg);
             }
         }.runBinary(key);
    }

    @Override
    public List<byte[]> blpop(final byte[] arg) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public List<byte[]> execute(Jedis connection) {
             return connection.blpop(arg);
             }
         }.runBinary(arg);
    }

    @Override
    public List<byte[]> brpop(final byte[] arg) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public List<byte[]> execute(Jedis connection) {
             return connection.brpop(arg);
             }
         }.runBinary(arg);
    }

    @Override
    public Long del(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.del(key);
             }
         }.runBinary(key);
    }

    @Override
    public byte[] echo(final byte[] arg) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public byte[] execute(Jedis connection) {
             return connection.echo(arg);
             }
         }.runBinary(null);
    }

    @Override 
    public Long move(final byte[] key, final int dbIndex) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.move(key, dbIndex);
             }
         }.runBinary(null);
    }

    @Override
    public Long bitcount(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.bitcount(key);
             }
         }.runBinary(key);
    }

    @Override
    public Long bitcount(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.bitcount(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long pfadd(final byte[] key, final byte[]... elements) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) { return connection.pfadd(key, elements); }
        }.runBinary(key);
    }

    @Override
    public long pfcount(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) { return connection.pfcount(key); }
        }.runBinary(key);
    }
    
    @Override
    public List<byte[]> srandmember(final byte[] key, final int count) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.srandmember(key, count);
	    }
	}.runBinary(key);
    }

    @Override
    public Long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.runBinary(key);
    }

    @Override
    public Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.runBinary(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
        return connectionHandler.getNodes();
    }
    
    @Override
    public Object eval(final byte[] script, final byte[] keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keyCount, params);
                }
            }.runBinary(Integer.parseInt(SafeEncoder.encode(keyCount)), params);
    }

    @Override
    public Object eval(final byte[] script, final int keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keyCount, params);
                }
            }.runBinary(keyCount, params);
    }

    @Override
    public Object eval(final byte[] script, final List<byte[]> keys, final List<byte[]> args) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keys, args);
                }
            }.runBinary(keys.size(), keys.toArray(new byte[keys.size()][]));
    }

    @Override
    public Object eval(final byte[] script, byte[] key) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script);
                }
            }.runBinary(key);
    }

    @Override
    public Object evalsha(final byte[] script, byte[] key) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(script);
                }
            }.runBinary(key);
    }

    @Override
    public Object evalsha(final byte[] sha1, final List<byte[]> keys, final List<byte[]> args) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(sha1, keys, args);
                }
            }.runBinary(keys.size(), keys.toArray(new byte[keys.size()][]));
    }

    @Override
    public Object evalsha(final byte[] sha1, final int keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(sha1, keyCount, params);
                }
            }.runBinary(keyCount, params);
    }
    
    @Override
    public List<Long> scriptExists(final byte[] key, final byte[][] sha1) {
        return new JedisClusterCommand<List<Long>>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public List<Long> execute(Jedis connection) {
                return connection.scriptExists(sha1);
                }
            }.runBinary(key);
    }
    
    @Override
    public byte[] scriptLoad(final byte[] script, final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public byte[] execute(Jedis connection) {
                return connection.scriptLoad(script);
                }
            }.runBinary(key);
    }
    
    @Override
    public String scriptFlush(final byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public String execute(Jedis connection) {
                return connection.scriptFlush();
                }
            }.runBinary(key);
    }
    
    @Override
    public String scriptKill(byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public String execute(Jedis connection) {
                return connection.scriptKill();
                }
            }.runBinary(key);
    }

    @Override
    public void close() throws IOException {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}	
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8558487_ca59f9b/rev_8558487-ca59f9b/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
||||||| BASE
   * @deprecated use BinaryJedis.pexpire(byte[], long) or Jedis.pexpire(String,long)
   * Set a timeout on the specified key. After the timeout the key will be automatically deleted by
   * the server. A key with an associated timeout is said to be volatile in Redis terminology.
   * <p>
   * Voltile keys are stored on disk like the other keys, the timeout is persistent too like all the
   * other aspects of the dataset. Saving a dataset containing expires and stopping the server does
   * not stop the flow of time as Redis stores on disk the time when the key will no longer be
   * available as Unix time, and not the remaining milliseconds.
   * <p>
   * Since Redis 2.1.3 you can update the value of the timeout of a key already having an expire
   * set. It is also possible to undo the expire at all turning the key into a normal key using the
   * {@link #persist(byte[]) PERSIST} command.
   * <p>
   * Time complexity: O(1)
   * @see <ahref="http://redis.io/commands/pexpire">PEXPIRE Command</a>
   * @param key
   * @param milliseconds
   * @return Integer reply, specifically: 1: the timeout was set. 0: the timeout was not set since
   *         the key already has an associated timeout (this may happen only in Redis versions <
   *         2.1.3, Redis >= 2.1.3 will happily update the timeout), or the key does not exist.
   */
  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  /**
=======
   * @deprecated use BinaryJedis.pexpire(byte[], long) or Jedis.pexpire(String,long) Set a timeout
   *             on the specified key. After the timeout the key will be automatically deleted by
   *             the server. A key with an associated timeout is said to be volatile in Redis
   *             terminology.
   *             <p>
   *             Voltile keys are stored on disk like the other keys, the timeout is persistent too
   *             like all the other aspects of the dataset. Saving a dataset containing expires and
   *             stopping the server does not stop the flow of time as Redis stores on disk the time
   *             when the key will no longer be available as Unix time, and not the remaining
   *             milliseconds.
   *             <p>
   *             Since Redis 2.1.3 you can update the value of the timeout of a key already having
   *             an expire set. It is also possible to undo the expire at all turning the key into a
   *             normal key using the {@link #persist(byte[]) PERSIST} command.
   *             <p>
   *             Time complexity: O(1)
   * @see <ahref="http://redis.io/commands/pexpire">PEXPIRE Command</a>
   * @param key
   * @param milliseconds
   * @return Integer reply, specifically: 1: the timeout was set. 0: the timeout was not set since
   *         the key already has an associated timeout (this may happen only in Redis versions <
   *         2.1.3, Redis >= 2.1.3 will happily update the timeout), or the key does not exist.
   */
  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8558487_ca59f9b/rev_8558487-ca59f9b/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, timeout, maxRedirections) {
||||||| BASE
  public List<String> blpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, timeout, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.blpop(arg);
      }
    }.run(arg);
  }

  @Override
  public List<String> brpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, timeout, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.brpop(arg);
      }
    }.run(arg);
  }

  @Override
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, timeout, maxRedirections) {
=======
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.del(key);
      }
    }.run(key);
  }

  @Override
  public String echo(final String string) {
    // note that it'll be run from arbitary node
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.echo(string);
      }
    }.run(string);
  }

  @Override
  public Long bitcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8558487_ca59f9b/rev_8558487-ca59f9b/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE
||||||| BASE
  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    Jedis j = getShard(key);
    return j.pexpire(key, milliseconds);
  }
=======

  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    Jedis j = getShard(key);
    return j.pexpire(key, milliseconds);
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/main/java/org/junit/internal/runners/rules/RuleFieldValidator.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
import java.lang.annotation.Annotation;
import java.util.ArrayList;
||||||| BASE
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
    	@Rule
    	public String fieldThatShouldBeMatched = "andromeda";

    	@Rule
    	public boolean fieldThatShouldNotBeMachted;
||||||| BASE
    	@Rule
    	public String fieldThatShouldBeMatched = "andromeda";
    	
    	@Rule
    	public boolean fieldThatShouldNotBeMachted;
=======
        @Rule
        public String fieldC= "andromeda";

        @Rule
        public boolean fieldA;
    	
        @Rule
        public boolean fieldB;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
    	@Ignore
    	@Test
    	public String methodToBeMatched() {
    		return "jupiter";
    	}

    	@Ignore
    	@Test
    	public int methodOfWrongType() {
    		return 0;
||||||| BASE
    	@Ignore
    	@Test
    	public String methodToBeMatched() { 
    		return "jupiter";
    	}
    	
    	@Ignore
    	@Test
    	public int methodOfWrongType() {
    		return 0;
=======
        @Ignore
        @Test
        public int methodC() {
            return 0;
        }

        @Ignore
        @Test
        public String methodA() {
            return "jupiter";
        }
    	
        @Ignore
        @Test
        public int methodB() {
            return 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE

    @Test
    public void annotationToMethods() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        assertThat(methods.size(), is(2));
    }

    @Test
    public void annotationToMethodsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        exception.expect(UnsupportedOperationException.class);
        annotationToMethods.put(Ignore.class, null);
    }

    @Test
    public void annotationToMethodsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        exception.expect(UnsupportedOperationException.class);
        methods.add(null);
    }

    @Test
    public void annotationToFields() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        assertThat(fields.size(), is(2));
    }

    @Test
    public void annotationToFieldsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        exception.expect(UnsupportedOperationException.class);
        annotationToFields.put(Rule.class, null);
    }

    @Test
    public void annotationToFieldsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        exception.expect(UnsupportedOperationException.class);
        fields.add(null);
    }

    public static class MultipleFieldsAnnotated {
        @DataPoint
        public String a = "testing a";

        @Rule
        public boolean b;

        @DataPoint
        public String c = "testing c";

        @Rule
        public boolean d;
    }

    @Test
    public void annotationToFieldsReturnsKeysInADeterministicOrder() {
        TestClass tc = new TestClass(MultipleFieldsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<Class<? extends Annotation>> keys = new ArrayList<Class<? extends Annotation>>();
        for (Class<? extends Annotation> annotation : annotationToFields.keySet()) {
            keys.add(annotation);
        }
        assertThat(keys.get(0), CoreMatchers.<Class<? extends Annotation>>is(DataPoint.class));
        assertThat(keys.get(1), CoreMatchers.<Class<? extends Annotation>>is(Rule.class));
    }
||||||| BASE

    @Test
    public void annotationToMethods() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        assertThat(methods.size(), is(2));
    }

    @Test
    public void annotationToMethodsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        exception.expect(UnsupportedOperationException.class);
        annotationToMethods.put(Ignore.class, null);
    }

    @Test
    public void annotationToMethodsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        exception.expect(UnsupportedOperationException.class);
        methods.add(null);
    }
    
    @Test
    public void annotationToFields() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        assertThat(fields.size(), is(2));
    }

    @Test
    public void annotationToFieldsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        exception.expect(UnsupportedOperationException.class);
        annotationToFields.put(Rule.class, null);
    }

    @Test
    public void annotationToFieldsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        exception.expect(UnsupportedOperationException.class);
        fields.add(null);
    }

    public static class MultipleFieldsAnnotated {
        @DataPoint
        public String a = "testing a";

        @Rule
        public boolean b;

        @DataPoint
        public String c = "testing c";

        @Rule
        public boolean d;
    }

    @Test
    public void annotationToFieldsReturnsKeysInADeterministicOrder() {
        TestClass tc = new TestClass(MultipleFieldsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<Class<? extends Annotation>> keys = new ArrayList<Class<? extends Annotation>>();
        for (Class<? extends Annotation> annotation : annotationToFields.keySet()) {
            keys.add(annotation);
        }
        assertThat(keys.get(0), CoreMatchers.<Class<? extends Annotation>>is(DataPoint.class));
        assertThat(keys.get(1), CoreMatchers.<Class<? extends Annotation>>is(Rule.class));
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f03bc79_eb8b5ee/rev_f03bc79-eb8b5ee/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
        JUnitCoreTest.class,
        FailOnTimeoutTest.class
||||||| BASE
        JUnitCoreTest.class
=======
        FrameworkFieldTest.class,
        FrameworkMethodTest.class,
        JUnitCoreTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_60c1bdf_8851c49/rev_60c1bdf-8851c49/src/main/java/redis/clients/util/Pool.java;<<<<<<< MINE
  protected void returnResourceObject(final T resource) {
||||||| BASE
  public void returnResourceObject(final T resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnResourceObject(final T resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
   * @param nxxx NX|XX, NX -- Only set the key if it does not already exist. XX -- Only set the key
   *          if it already exist.
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of <code>expx</code>
||||||| BASE
   * @param nxxx NX|XX, NX -- Only set the key if it does not already exist. XX -- Only set the key
   *          if it already exist.
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of {@param #expx}
=======
   * @param params
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final long time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
||||||| BASE
  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final long time) {
    checkIsInMulti();
    client.set(key, value, nxxx, expx, time);
=======
  public String set(final byte[] key, final byte[] value, final SetParams params) {
    checkIsInMulti();
    client.set(key, value, params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final int time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
    return client.getStatusCodeReply();
  }

||||||| BASE
  public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
    checkIsInMulti();
    client.set(key, value, nxxx);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final int time) {
    checkIsInMulti();
    client.set(key, value, nxxx, expx, time);
    return client.getStatusCodeReply();
  }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE

  public void readonly() {
    sendCommand(READONLY);
  }
||||||| BASE
=======
  
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisClusterCommands,
    MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
||||||| BASE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 2000;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.jedis.params.set.SetParams;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 2000;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of <code>expx</code>
||||||| BASE
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of {@param #expx}
=======
   *          EX|PX, expire time units: EX = seconds; PX = milliseconds
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
  @Override
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
||||||| BASE
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    checkIsInMulti();
    client.set(key, value, nxxx, expx, time);
=======
  public String set(final String key, final String value, final SetParams params) {
    checkIsInMulti();
    client.set(key, value, params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    set(SafeEncoder.encode(key), SafeEncoder.encode(value), SafeEncoder.encode(nxxx),
      SafeEncoder.encode(expx), time);
||||||| BASE
  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    set(SafeEncoder.encode(key), SafeEncoder.encode(value), SafeEncoder.encode(nxxx),
      SafeEncoder.encode(expx), time);
=======
  public void set(final String key, final String value, final SetParams params) {
    set(SafeEncoder.encode(key), SafeEncoder.encode(value), params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE
  @Override
  public String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time) {
||||||| BASE
  public String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time) {
=======
  public String set(byte[] key, byte[] value, SetParams params) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryJedisClusterCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

public interface BinaryJedisClusterCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Double zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}||||||| BASE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

public interface BinaryJedisClusterCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

/**
 * Common interface for sharded and non-sharded Jedis
 */
public interface JedisCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Long pttl(final String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  String psetex(final String key, final long milliseconds, final String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Double hincrByFloat(final String key, final String field, final double value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, double score, String member, ZAddParams params);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Long zadd(String key, Map<String, Double> scoreMembers, ZAddParams params);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Double zincrby(String key, double score, String member, ZIncrByParams params);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long move(String key, int dbIndex);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  Long bitpos(final String key, final boolean value);

  Long bitpos(final String key, final boolean value, final BitPosParams params);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor,
      final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor, final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor, final ScanParams params);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;

/**
 * Common interface for sharded and non-sharded Jedis
 */
public interface JedisCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Long pttl(final String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  String psetex(final String key, final long milliseconds, final String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Double hincrByFloat(final String key, final String field, final double value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long move(String key, int dbIndex);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  Long bitpos(final String key, final boolean value);

  Long bitpos(final String key, final boolean value, final BitPosParams params);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor,
      final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor, final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor, final ScanParams params);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryRedisPipeline.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.List;
import java.util.Map;
import java.util.Set;

public interface BinaryRedisPipeline {
  Response<Long> append(byte[] key, byte[] value);

  Response<List<byte[]>> blpop(byte[] arg);

  Response<List<byte[]>> brpop(byte[] arg);

  Response<Long> decr(byte[] key);

  Response<Long> decrBy(byte[] key, long integer);

  Response<Long> del(byte[] keys);

  Response<byte[]> echo(byte[] string);

  Response<Boolean> exists(byte[] key);

  Response<Long> expire(byte[] key, int seconds);

  Response<Long> pexpire(byte[] key, long milliseconds);

  Response<Long> expireAt(byte[] key, long unixTime);

  Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp);

  Response<byte[]> get(byte[] key);

  Response<Boolean> getbit(byte[] key, long offset);

  Response<byte[]> getSet(byte[] key, byte[] value);

  Response<byte[]> getrange(byte[] key, long startOffset, long endOffset);

  Response<Long> hdel(byte[] key, byte[]... field);

  Response<Boolean> hexists(byte[] key, byte[] field);

  Response<byte[]> hget(byte[] key, byte[] field);

  Response<Map<byte[], byte[]>> hgetAll(byte[] key);

  Response<Long> hincrBy(byte[] key, byte[] field, long value);

  Response<Set<byte[]>> hkeys(byte[] key);

  Response<Long> hlen(byte[] key);

  Response<List<byte[]>> hmget(byte[] key, byte[]... fields);

  Response<String> hmset(byte[] key, Map<byte[], byte[]> hash);

  Response<Long> hset(byte[] key, byte[] field, byte[] value);

  Response<Long> hsetnx(byte[] key, byte[] field, byte[] value);

  Response<List<byte[]>> hvals(byte[] key);

  Response<Long> incr(byte[] key);

  Response<Long> incrBy(byte[] key, long integer);

  Response<byte[]> lindex(byte[] key, long index);

  Response<Long> linsert(byte[] key, BinaryClient.LIST_POSITION where, byte[] pivot, byte[] value);

  Response<Long> llen(byte[] key);

  Response<byte[]> lpop(byte[] key);

  Response<Long> lpush(byte[] key, byte[]... string);

  Response<Long> lpushx(byte[] key, byte[]... bytes);

  Response<List<byte[]>> lrange(byte[] key, long start, long end);

  Response<Long> lrem(byte[] key, long count, byte[] value);

  Response<String> lset(byte[] key, long index, byte[] value);

  Response<String> ltrim(byte[] key, long start, long end);

  Response<Long> move(byte[] key, int dbIndex);

  Response<Long> persist(byte[] key);

  Response<byte[]> rpop(byte[] key);

  Response<Long> rpush(byte[] key, byte[]... string);

  Response<Long> rpushx(byte[] key, byte[]... string);

  Response<Long> sadd(byte[] key, byte[]... member);

  Response<Long> scard(byte[] key);

  Response<String> set(byte[] key, byte[] value);

  Response<Boolean> setbit(byte[] key, long offset, byte[] value);

  Response<Long> setrange(byte[] key, long offset, byte[] value);

  Response<String> setex(byte[] key, int seconds, byte[] value);

  Response<Long> setnx(byte[] key, byte[] value);

  Response<Long> setrange(String key, long offset, String value);

  Response<Set<byte[]>> smembers(byte[] key);

  Response<Boolean> sismember(byte[] key, byte[] member);

  Response<List<byte[]>> sort(byte[] key);

  Response<List<byte[]>> sort(byte[] key, SortingParams sortingParameters);

  Response<byte[]> spop(byte[] key);

  Response<Set<byte[]>> spop(byte[] key, long count);

  Response<byte[]> srandmember(byte[] key);

  Response<Long> srem(byte[] key, byte[]... member);

  Response<Long> strlen(byte[] key);

  Response<String> substr(byte[] key, int start, int end);

  Response<Long> ttl(byte[] key);

  Response<String> type(byte[] key);

  Response<Long> zadd(byte[] key, double score, byte[] member);

  Response<Long> zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Response<Long> zcard(byte[] key);

  Response<Long> zcount(byte[] key, double min, double max);

  Response<Double> zincrby(byte[] key, double score, byte[] member);

  Response<Double> zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Response<Set<byte[]>> zrange(byte[] key, long start, long end);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max, int offset,
      int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset,
      int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset,
      int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset,
      int count);

  Response<Set<Tuple>> zrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrank(byte[] key, byte[] member);

  Response<Long> zrem(byte[] key, byte[]... member);

  Response<Long> zremrangeByRank(byte[] key, long start, long end);

  Response<Long> zremrangeByScore(byte[] key, double start, double end);

  Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Response<Set<byte[]>> zrevrange(byte[] key, long start, long end);

  Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrevrank(byte[] key, byte[] member);

  Response<Double> zscore(byte[] key, byte[] member);

  Response<Long> zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      int offset, int count);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
      int offset, int count);

  Response<Long> zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Long> bitcount(byte[] key);

  Response<Long> bitcount(byte[] key, long start, long end);

  Response<Long> pfadd(final byte[] key, final byte[]... elements);

  Response<Long> pfcount(final byte[] key);
}||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author guy
 */
public interface BinaryRedisPipeline {
  Response<Long> append(byte[] key, byte[] value);

  Response<List<byte[]>> blpop(byte[] arg);

  Response<List<byte[]>> brpop(byte[] arg);

  Response<Long> decr(byte[] key);

  Response<Long> decrBy(byte[] key, long integer);

  Response<Long> del(byte[] keys);

  Response<byte[]> echo(byte[] string);

  Response<Boolean> exists(byte[] key);

  Response<Long> expire(byte[] key, int seconds);

  Response<Long> pexpire(byte[] key, long milliseconds);

  Response<Long> expireAt(byte[] key, long unixTime);

  Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp);

  Response<byte[]> get(byte[] key);

  Response<Boolean> getbit(byte[] key, long offset);

  Response<byte[]> getSet(byte[] key, byte[] value);

  Response<byte[]> getrange(byte[] key, long startOffset, long endOffset);

  Response<Long> hdel(byte[] key, byte[]... field);

  Response<Boolean> hexists(byte[] key, byte[] field);

  Response<byte[]> hget(byte[] key, byte[] field);

  Response<Map<byte[], byte[]>> hgetAll(byte[] key);

  Response<Long> hincrBy(byte[] key, byte[] field, long value);

  Response<Set<byte[]>> hkeys(byte[] key);

  Response<Long> hlen(byte[] key);

  Response<List<byte[]>> hmget(byte[] key, byte[]... fields);

  Response<String> hmset(byte[] key, Map<byte[], byte[]> hash);

  Response<Long> hset(byte[] key, byte[] field, byte[] value);

  Response<Long> hsetnx(byte[] key, byte[] field, byte[] value);

  Response<List<byte[]>> hvals(byte[] key);

  Response<Long> incr(byte[] key);

  Response<Long> incrBy(byte[] key, long integer);

  Response<byte[]> lindex(byte[] key, long index);

  Response<Long> linsert(byte[] key, BinaryClient.LIST_POSITION where, byte[] pivot, byte[] value);

  Response<Long> llen(byte[] key);

  Response<byte[]> lpop(byte[] key);

  Response<Long> lpush(byte[] key, byte[]... string);

  Response<Long> lpushx(byte[] key, byte[]... bytes);

  Response<List<byte[]>> lrange(byte[] key, long start, long end);

  Response<Long> lrem(byte[] key, long count, byte[] value);

  Response<String> lset(byte[] key, long index, byte[] value);

  Response<String> ltrim(byte[] key, long start, long end);

  Response<Long> move(byte[] key, int dbIndex);

  Response<Long> persist(byte[] key);

  Response<byte[]> rpop(byte[] key);

  Response<Long> rpush(byte[] key, byte[]... string);

  Response<Long> rpushx(byte[] key, byte[]... string);

  Response<Long> sadd(byte[] key, byte[]... member);

  Response<Long> scard(byte[] key);

  Response<String> set(byte[] key, byte[] value);

  Response<Boolean> setbit(byte[] key, long offset, byte[] value);

  Response<Long> setrange(byte[] key, long offset, byte[] value);

  Response<String> setex(byte[] key, int seconds, byte[] value);

  Response<Long> setnx(byte[] key, byte[] value);

  Response<Long> setrange(String key, long offset, String value);

  Response<Set<byte[]>> smembers(byte[] key);

  Response<Boolean> sismember(byte[] key, byte[] member);

  Response<List<byte[]>> sort(byte[] key);

  Response<List<byte[]>> sort(byte[] key, SortingParams sortingParameters);

  Response<byte[]> spop(byte[] key);

  Response<Set<byte[]>> spop(byte[] key, long count);

  Response<byte[]> srandmember(byte[] key);

  Response<Long> srem(byte[] key, byte[]... member);

  Response<Long> strlen(byte[] key);

  Response<String> substr(byte[] key, int start, int end);

  Response<Long> ttl(byte[] key);

  Response<String> type(byte[] key);

  Response<Long> zadd(byte[] key, double score, byte[] member);

  Response<Long> zcard(byte[] key);

  Response<Long> zcount(byte[] key, double min, double max);

  Response<Double> zincrby(byte[] key, double score, byte[] member);

  Response<Set<byte[]>> zrange(byte[] key, long start, long end);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max, int offset,
      int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset,
      int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset,
      int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset,
      int count);

  Response<Set<Tuple>> zrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrank(byte[] key, byte[] member);

  Response<Long> zrem(byte[] key, byte[]... member);

  Response<Long> zremrangeByRank(byte[] key, long start, long end);

  Response<Long> zremrangeByScore(byte[] key, double start, double end);

  Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Response<Set<byte[]>> zrevrange(byte[] key, long start, long end);

  Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrevrank(byte[] key, byte[] member);

  Response<Double> zscore(byte[] key, byte[] member);

  Response<Long> zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      int offset, int count);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
      int offset, int count);

  Response<Long> zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Long> bitcount(byte[] key);

  Response<Long> bitcount(byte[] key, long start, long end);

  Response<Long> pfadd(final byte[] key, final byte[]... elements);

  Response<Long> pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;
||||||| BASE
=======
import redis.clients.jedis.commands.JedisClusterCommands;
import redis.clients.jedis.commands.JedisClusterScriptingCommands;
import redis.clients.jedis.commands.MultiKeyJedisClusterCommands;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisClusterCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.List;
import java.util.Map;
import java.util.Set;

public interface JedisClusterCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, double score, String member, ZAddParams params);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Long zadd(String key, Map<String, Double> scoreMembers, ZAddParams params);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Double zincrby(String key, double score, String member, ZIncrByParams params);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}||||||| BASE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;

import java.util.List;
import java.util.Map;
import java.util.Set;

public interface JedisClusterCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Double zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}||||||| BASE
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, SetParams params);

  public void get(final String key);

  public void exists(final String key);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final double score, final String member,
      final ZAddParams params);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zadd(final String key, final Map<String, Double> scoreMembers, final ZAddParams params);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zincrby(final String key, final double score, final String member,
      final ZIncrByParams params);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}||||||| BASE
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.jedis.params.set.SetParams;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, SetParams params);

  public void get(final String key);

  public void exists(final String key);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryJedisClusterCommands.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryJedisClusterCommands {
  Long del(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryJedisClusterCommands {
  Long del(byte[]... keys);

  Long exists(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyCommandsPipeline.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyCommandsPipeline {
  Response<Long> del(String... keys);

  Response<List<String>> blpop(String... args);

  Response<List<String>> brpop(String... args);

  Response<Set<String>> keys(String pattern);

  Response<List<String>> mget(String... keys);

  Response<String> mset(String... keysvalues);

  Response<Long> msetnx(String... keysvalues);

  Response<String> rename(String oldkey, String newkey);

  Response<Long> renamenx(String oldkey, String newkey);

  Response<String> rpoplpush(String srckey, String dstkey);

  Response<Set<String>> sdiff(String... keys);

  Response<Long> sdiffstore(String dstkey, String... keys);

  Response<Set<String>> sinter(String... keys);

  Response<Long> sinterstore(String dstkey, String... keys);

  Response<Long> smove(String srckey, String dstkey, String member);

  Response<Long> sort(String key, SortingParams sortingParameters, String dstkey);

  Response<Long> sort(String key, String dstkey);

  Response<Set<String>> sunion(String... keys);

  Response<Long> sunionstore(String dstkey, String... keys);

  Response<String> watch(String... keys);

  Response<Long> zinterstore(String dstkey, String... sets);

  Response<Long> zinterstore(String dstkey, ZParams params, String... sets);

  Response<Long> zunionstore(String dstkey, String... sets);

  Response<Long> zunionstore(String dstkey, ZParams params, String... sets);

  Response<String> brpoplpush(String source, String destination, int timeout);

  Response<Long> publish(String channel, String message);

  Response<String> randomKey();

  Response<Long> bitop(BitOP op, final String destKey, String... srcKeys);

  Response<String> pfmerge(final String destkey, final String... sourcekeys);

  Response<Long> pfcount(final String... keys);
}=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyCommandsPipeline {
  Response<Long> del(String... keys);

  Response<Long> exists(String... keys);

  Response<List<String>> blpop(String... args);

  Response<List<String>> brpop(String... args);

  Response<Set<String>> keys(String pattern);

  Response<List<String>> mget(String... keys);

  Response<String> mset(String... keysvalues);

  Response<Long> msetnx(String... keysvalues);

  Response<String> rename(String oldkey, String newkey);

  Response<Long> renamenx(String oldkey, String newkey);

  Response<String> rpoplpush(String srckey, String dstkey);

  Response<Set<String>> sdiff(String... keys);

  Response<Long> sdiffstore(String dstkey, String... keys);

  Response<Set<String>> sinter(String... keys);

  Response<Long> sinterstore(String dstkey, String... keys);

  Response<Long> smove(String srckey, String dstkey, String member);

  Response<Long> sort(String key, SortingParams sortingParameters, String dstkey);

  Response<Long> sort(String key, String dstkey);

  Response<Set<String>> sunion(String... keys);

  Response<Long> sunionstore(String dstkey, String... keys);

  Response<String> watch(String... keys);

  Response<Long> zinterstore(String dstkey, String... sets);

  Response<Long> zinterstore(String dstkey, ZParams params, String... sets);

  Response<Long> zunionstore(String dstkey, String... sets);

  Response<Long> zunionstore(String dstkey, ZParams params, String... sets);

  Response<String> brpoplpush(String source, String destination, int timeout);

  Response<Long> publish(String channel, String message);

  Response<String> randomKey();

  Response<Long> bitop(BitOP op, final String destKey, String... srcKeys);

  Response<String> pfmerge(final String destkey, final String... sourcekeys);

  Response<Long> pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyJedisClusterCommands.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyJedisClusterCommands {
  Long del(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyJedisClusterCommands {
  Long del(String... keys);

  Long exists(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
||||||| BASE
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
  @Override
||||||| BASE
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyCommands.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyCommands {
  Long del(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> blpop(String... args);

  List<String> brpop(String... args);

  Set<String> keys(String pattern);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  String watch(String... keys);

  String unwatch();

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  String randomKey();

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  ScanResult<String> scan(final String cursor);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyCommands {
  Long del(String... keys);

  Long exists(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> blpop(String... args);

  List<String> brpop(String... args);

  Set<String> keys(String pattern);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  String watch(String... keys);

  String unwatch();

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  String randomKey();

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  ScanResult<String> scan(final String cursor);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryCommands.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryCommands {
  Long del(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> blpop(byte[]... args);

  List<byte[]> brpop(byte[]... args);

  Set<byte[]> keys(byte[] pattern);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  String watch(byte[]... keys);

  String unwatch();

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  byte[] randomBinaryKey();

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryCommands {
  Long del(byte[]... keys);

  Long exists(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> blpop(byte[]... args);

  List<byte[]> brpop(byte[]... args);

  Set<byte[]> keys(byte[] pattern);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  String watch(byte[]... keys);

  String unwatch();

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  byte[] randomBinaryKey();

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryRedisPipeline.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyBinaryRedisPipeline {

  Response<Long> del(byte[]... keys);

  Response<List<byte[]>> blpop(byte[]... args);

  Response<List<byte[]>> brpop(byte[]... args);

  Response<Set<byte[]>> keys(byte[] pattern);

  Response<List<byte[]>> mget(byte[]... keys);

  Response<String> mset(byte[]... keysvalues);

  Response<Long> msetnx(byte[]... keysvalues);

  Response<String> rename(byte[] oldkey, byte[] newkey);

  Response<Long> renamenx(byte[] oldkey, byte[] newkey);

  Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey);

  Response<Set<byte[]>> sdiff(byte[]... keys);

  Response<Long> sdiffstore(byte[] dstkey, byte[]... keys);

  Response<Set<byte[]>> sinter(byte[]... keys);

  Response<Long> sinterstore(byte[] dstkey, byte[]... keys);

  Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member);

  Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Response<Long> sort(byte[] key, byte[] dstkey);

  Response<Set<byte[]>> sunion(byte[]... keys);

  Response<Long> sunionstore(byte[] dstkey, byte[]... keys);

  Response<String> watch(byte[]... keys);

  Response<Long> zinterstore(byte[] dstkey, byte[]... sets);

  Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout);

  Response<Long> publish(byte[] channel, byte[] message);

  Response<byte[]> randomKeyBinary();

  Response<Long> bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  Response<String> pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Response<Long> pfcount(final byte[]... keys);
}=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyBinaryRedisPipeline {

  Response<Long> del(byte[]... keys);

  Response<Long> exists(byte[]... keys);

  Response<List<byte[]>> blpop(byte[]... args);

  Response<List<byte[]>> brpop(byte[]... args);

  Response<Set<byte[]>> keys(byte[] pattern);

  Response<List<byte[]>> mget(byte[]... keys);

  Response<String> mset(byte[]... keysvalues);

  Response<Long> msetnx(byte[]... keysvalues);

  Response<String> rename(byte[] oldkey, byte[] newkey);

  Response<Long> renamenx(byte[] oldkey, byte[] newkey);

  Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey);

  Response<Set<byte[]>> sdiff(byte[]... keys);

  Response<Long> sdiffstore(byte[] dstkey, byte[]... keys);

  Response<Set<byte[]>> sinter(byte[]... keys);

  Response<Long> sinterstore(byte[] dstkey, byte[]... keys);

  Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member);

  Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Response<Long> sort(byte[] key, byte[] dstkey);

  Response<Set<byte[]>> sunion(byte[]... keys);

  Response<Long> sunionstore(byte[] dstkey, byte[]... keys);

  Response<String> watch(byte[]... keys);

  Response<Long> zinterstore(byte[] dstkey, byte[]... sets);

  Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout);

  Response<Long> publish(byte[] channel, byte[] message);

  Response<byte[]> randomKeyBinary();

  Response<Long> bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  Response<String> pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Response<Long> pfcount(final byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
||||||| BASE
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
||||||| BASE
=======
  public void exists(final String... keys) {
    final byte[][] bkeys = SafeEncoder.encodeMany(keys);
    exists(bkeys);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time);

  public void get(final String key);

  public void exists(final String key);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}=======
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time);

  public void get(final String key);

  @Deprecated
  public void exists(final String key);

  public void exists(final String... keys);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
||||||| BASE
   * @deprecated use BinaryJedis.pexpire(byte[], long) or Jedis.pexpire(String,long)
   * Set a timeout on the specified key. After the timeout the key will be automatically deleted by
   * the server. A key with an associated timeout is said to be volatile in Redis terminology.
   * <p>
   * Voltile keys are stored on disk like the other keys, the timeout is persistent too like all the
   * other aspects of the dataset. Saving a dataset containing expires and stopping the server does
   * not stop the flow of time as Redis stores on disk the time when the key will no longer be
   * available as Unix time, and not the remaining milliseconds.
   * <p>
   * Since Redis 2.1.3 you can update the value of the timeout of a key already having an expire
   * set. It is also possible to undo the expire at all turning the key into a normal key using the
   * {@link #persist(byte[]) PERSIST} command.
   * <p>
   * Time complexity: O(1)
   * @see <ahref="http://redis.io/commands/pexpire">PEXPIRE Command</a>
   * @param key
   * @param milliseconds
   * @return Integer reply, specifically: 1: the timeout was set. 0: the timeout was not set since
   *         the key already has an associated timeout (this may happen only in Redis versions <
   *         2.1.3, Redis >= 2.1.3 will happily update the timeout), or the key does not exist.
   */
  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  /**
=======
   * Set a timeout on the specified key. After the timeout the key will be automatically deleted by
   * the server. A key with an associated timeout is said to be volatile in Redis terminology.
   * <p>
   * Voltile keys are stored on disk like the other keys, the timeout is persistent too like all the
   * other aspects of the dataset. Saving a dataset containing expires and stopping the server does
   * not stop the flow of time as Redis stores on disk the time when the key will no longer be
   * available as Unix time, and not the remaining milliseconds.
   * <p>
   * Since Redis 2.1.3 you can update the value of the timeout of a key already having an expire
   * set. It is also possible to undo the expire at all turning the key into a normal key using the
   * {@link #persist(byte[]) PERSIST} command.
   * <p>
   * Time complexity: O(1)
   * @see <ahref="http://redis.io/commands/pexpire">PEXPIRE Command</a>
   * @param key
   * @param milliseconds
   * @return Integer reply, specifically: 1: the timeout was set. 0: the timeout was not set since
   *         the key already has an associated timeout (this may happen only in Redis versions <
   *         2.1.3, Redis >= 2.1.3 will happily update the timeout), or the key does not exist.
   */
  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMultiOrPipeline();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  @Override
||||||| BASE
  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
||||||| BASE
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  /**
   * @deprecated String key operation on BinaryCommand. Use byte[] or JedisCommands
   */
  @Deprecated
  Long pexpire(final String key, final long milliseconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> blpop(byte[] arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> brpop(byte[] arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}=======
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> blpop(byte[] arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> brpop(byte[] arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;null
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_fe17537_45f2265/rev_fe17537-45f2265/src/main/java/org/junit/rules/Timeout.java;null
