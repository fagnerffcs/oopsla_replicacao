file;linedbasedConf
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/main/java/org/junit/runner/Result.java;<<<<<<< MINE
		private boolean fIgnoredDuringExecution= false;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/main/java/org/junit/runner/Result.java;<<<<<<< MINE
			if (!fIgnoredDuringExecution)
				fCount++;
			fIgnoredDuringExecution= false;
=======
			fCount++;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/main/java/org/junit/runner/Result.java;<<<<<<< MINE
			fIgnoredDuringExecution= true;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f2ec67e_28fb91a/rev_f2ec67e-28fb91a/src/test/java/org/junit/tests/running/methods/TestMethodTest.java;<<<<<<< MINE
=======
		assertEquals(1, result.getRunCount());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
    public static final byte DOLLAR_BYTE = DOLLAR.getBytes(CHARSET)[0];
    public static final byte ASTERISK_BYTE = ASTERISK.getBytes(CHARSET)[0];
    public static final byte PLUS_BYTE = PLUS.getBytes(CHARSET)[0];
    public static final byte MINUS_BYTE = MINUS.getBytes(CHARSET)[0];
    public static final byte COLON_BYTE = COLON.getBytes(CHARSET)[0];

    public void sendCommand(DataOutputStream os, String name, String... args) {
	    StringBuilder sb = new StringBuilder();
	    sb.append(ASTERISK);
	    sb.append((new Integer(args.length + 1)).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(DOLLAR);
	    sb.append((new Integer(name.length())).toString());
	    sb.append(COMMAND_DELIMITER);
	    sb.append(name);
	    sb.append(COMMAND_DELIMITER);

	    for (String arg : args) {
		int size = arg.getBytes(CHARSET).length;

		sb.append(DOLLAR);
		sb.append((new Integer(size)).toString());
		sb.append(COMMAND_DELIMITER);
		sb.append(arg);
		sb.append(COMMAND_DELIMITER);
	    }

		try {
		    os.write(sb.toString().getBytes(CHARSET));
	    /*
	    os.write(ASTERISK_BYTE);
	    os.write((new Integer(args.length + 1)).toString()
		    .getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(DOLLAR_BYTE);
	    os.write((new Integer(name.length())).toString().getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);
	    os.write(name.getBytes(CHARSET));
	    os.write(COMMAND_DELIMITER_BYTES);

	    for (String arg : args) {
		byte[] barg = arg.getBytes(CHARSET);

		os.write(DOLLAR_BYTE);
		os.write((new Integer(barg.length)).toString()
			.getBytes(CHARSET));
		os.write(COMMAND_DELIMITER_BYTES);
		os.write(barg);
		os.write(COMMAND_DELIMITER_BYTES);
	    }
	    */
	} catch (IOException e) {
	    throw new JedisException(e);
	}
    }

    public void processError(DataInputStream is) {
	String message = readLine(is);
	throw new JedisException(message);
    }

    private String readLine(DataInputStream is) {
	byte b;
	byte c;
	StringBuilder sb = new StringBuilder();

	try {
	    while ((b = is.readByte()) != -1) {
		if (b == '\r') {
		    c = is.readByte();
		    if (c == '\n') {
			break;
		    }
		    sb.append((char) b);
		    sb.append((char) c);
		} else {
		    sb.append((char) b);
		}
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return sb.toString();
    }

    private Object process(DataInputStream is) {
	try {
	    byte b = is.readByte();
	    if (b == MINUS_BYTE) {
		processError(is);
	    } else if (b == ASTERISK_BYTE) {
		return processMultiBulkReply(is);
	    } else if (b == COLON_BYTE) {
		return processInteger(is);
	    } else if (b == DOLLAR_BYTE) {
		return processBulkReply(is);
	    } else if (b == PLUS_BYTE) {
		return processStatusCodeReply(is);
	    } else {
		throw new JedisException("Unknown reply: " + (char) b);
	    }
	} catch (IOException e) {
	    throw new JedisException(e);
	}
	return null;
    }

    private Object processStatusCodeReply(DataInputStream is) {
	String ret = null;
	ret = readLine(is);
	return ret;
    }

    private Object processBulkReply(DataInputStream is) {
	int len = Integer.parseInt(readLine(is));
	if (len == -1) {
	    return null;
	}
	byte[] read = new byte[len];
	int offset = 0;
	try {
		while(offset < len) {
		    offset += is.read(read, offset, (len - offset));
		}
	    // read 2 more bytes for the command delimiter
	    is.read();
	    is.read();
	} catch (IOException e) {
	    throw new JedisException(e);
	}

	return new String(read, CHARSET);
    }

    private Object processInteger(DataInputStream is) {
	int ret = 0;
	String num = readLine(is);
	ret = Integer.parseInt(num);
	return ret;
    }

    private Object processMultiBulkReply(DataInputStream is) {
	int num = Integer.parseInt(readLine(is));
	if (num == -1) {
	    return null;
	}
	List<Object> ret = new ArrayList<Object>();
	for (int i = 0; i < num; i++) {
	    ret.add(process(is));
	}
	return ret;
=======
    public static final byte DOLLAR_BYTE = '$';
    public static final byte ASTERISK_BYTE = '*';
    public static final byte PLUS_BYTE = '+';
    public static final byte MINUS_BYTE = '-';
    public static final byte COLON_BYTE = ':';

    public void sendCommand(RedisOutputStream os, String name, String... args) {
        try {
            os.write(ASTERISK_BYTE);
            os.writeIntCrLf(args.length + 1);
            os.write(DOLLAR_BYTE);
            os.writeIntCrLf(name.length());
            os.writeAsciiCrLf(name);

            for (String str : args) {
                os.write(DOLLAR_BYTE);
                final int size = RedisOutputStream.utf8Length(str);
                os.writeIntCrLf(size);
                if (size == str.length())
                    os.writeAsciiCrLf(str);
                else {
                    os.writeUtf8CrLf(str);
                }
            }
            os.flush();
        } catch (IOException e) {
            throw new JedisException(e);
        }
    }

    private void processError(RedisInputStream is) {
        String message = is.readLine();
        throw new JedisException(message);
    }

    private Object process(RedisInputStream is) {
        try {
            byte b = is.readByte();
            if (b == MINUS_BYTE) {
                processError(is);
            } else if (b == ASTERISK_BYTE) {
                return processMultiBulkReply(is);
            } else if (b == COLON_BYTE) {
                return processInteger(is);
            } else if (b == DOLLAR_BYTE) {
                return processBulkReply(is);
            } else if (b == PLUS_BYTE) {
                return processStatusCodeReply(is);
            } else {
                throw new JedisException("Unknown reply: " + (char) b);
            }
        } catch (IOException e) {
            throw new JedisException(e);
        }
        return null;
    }

    private String processStatusCodeReply(RedisInputStream is) {
        return is.readLine();
    }

    private String processBulkReply(RedisInputStream is) {
        int len = Integer.parseInt(is.readLine());
        if (len == -1) {
            return null;
        }
        byte[] read = new byte[len];
        int offset = 0;
        try {
            while (offset < len) {
                offset += is.read(read, offset, (len - offset));
            }
            // read 2 more bytes for the command delimiter
            is.readByte();
            is.readByte();
        } catch (IOException e) {
            throw new JedisException(e);
        }

        return new String(read, CHARSET);
    }

    private Integer processInteger(RedisInputStream is) {
        String num = is.readLine();
        return Integer.valueOf(num);
    }

    private List<Object> processMultiBulkReply(RedisInputStream is) {
        int num = Integer.parseInt(is.readLine());
        if (num == -1) {
            return null;
        }
        List<Object> ret = new ArrayList<Object>(num);
        for (int i = 0; i < num; i++) {
            ret.add(process(is));
        }
        return ret;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/test/java/redis/clients/jedis/tests/FragmentedByteArrayInputStream.java;<<<<<<< MINE
=======
package redis.clients.jedis.tests;

import java.io.ByteArrayInputStream;

/**
 * Test class the fragment a byte array for testing purpose.
 */
public class FragmentedByteArrayInputStream extends ByteArrayInputStream {
	private int readMethodCallCount = 0;
	public FragmentedByteArrayInputStream(final byte[] buf) {
		super(buf);
	}

	@Override
	public synchronized int read(final byte[] b, final int off, final int len) {
		readMethodCallCount++;
		if (len <= 10) {
			// if the len <= 10, return as usual ..
			return super.read(b, off, len);
		} else {
			// else return the first half ..
			return super.read(b, off, len / 2);
		}
	}
	
	public int getReadMethodCallCount() {
		return readMethodCallCount;
	}

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/test/java/redis/clients/jedis/tests/ProtocolTest.java;<<<<<<< MINE
    public void fragmentedBulkReply() {
    	FragmentedByteArrayInputStream fis = new FragmentedByteArrayInputStream("$30\r\n012345678901234567890123456789\r\n".getBytes());
    	Protocol protocol = new Protocol();
    	String response = (String) protocol.read(new DataInputStream(fis));
    	assertEquals("012345678901234567890123456789", response);
    	assertEquals(3, fis.getReadMethodCallCount());
    }

    
    @Test
=======
    public void fragmentedBulkReply() {
    	FragmentedByteArrayInputStream fis = new FragmentedByteArrayInputStream("$30\r\n012345678901234567890123456789\r\n".getBytes());
    	Protocol protocol = new Protocol();
    	String response = (String) protocol.read(new RedisInputStream(fis));
    	assertEquals("012345678901234567890123456789", response);
//    	assertEquals(3, fis.getReadMethodCallCount());
    }

    
    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	private static final class OldTestClassAdaptingListener implements
=======
	private final class OldTestClassAdaptingListener implements
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
			return Description.createTestDescription(test.getClass(), getName(test));
=======
			return Description.createTestDescription(getEffectiveClass(test), getName(test));
		}

		@SuppressWarnings("unchecked")
		private Class<? extends Test> getEffectiveClass(Test test) {
			// TODO (Feb 23, 2009 11:45:54 PM): Think hard about this.
			if ("warning".equals(getName(test)))
				try {
					return (Class<? extends Test>) Class.forName(fTest.toString());
				} catch (ClassNotFoundException e) {
					return test.getClass();
				}
			return test.getClass();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	public static TestListener createAdaptingListener(final RunNotifier notifier) {
=======
	public TestListener createAdaptingListener(final RunNotifier notifier) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	private static Description makeDescription(Test test) {
=======
	// TODO (Feb 23, 2009 10:57:14 PM): V
	public static Description makeDescription(Test test) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
			for (int i= 0; i < n; i++)
				description.addChild(makeDescription(ts.testAt(i)));
=======
			for (int i= 0; i < n; i++) {
				Description made= makeDescription(ts.testAt(i));
				// TODO (Feb 23, 2009 11:25:23 PM): this is doing Max's work for it.  Max should get rid of these when sorting i
				if (!made.toString().startsWith("warning("))			
					description.addChild(made);
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	private Test getTest() {
=======
	// TODO (Feb 23, 2009 10:57:26 PM): V
	public Test getTest() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private EachTestNotifier makeNotifier(FrameworkMethod method,
=======
	protected EachTestNotifier makeNotifier(FrameworkMethod method,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
	
	private RunNotifier fNotifier;
=======
	// TODO (Feb 23, 2009 10:24:40 PM): V
	public RunNotifier fNotifier;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
		addFirstListener(listener);
=======
		fNotifier.addFirstListener(listener);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
	private void addFirstListener(RunListener listener) {
		fNotifier.addFirstListener(listener);
	}
	

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
	//TODO javadoc
	public static Filter matchDescription(final Description desiredDescription) {
=======
	
	/**
	 * Returns a {@code Filter} that only runs the single method described by
	 * {@code desiredDescription}
	 */
	public static Filter matchMethodDescription(final Description desiredDescription) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
			: null;
=======
			: toString();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/runner/Request.java;<<<<<<< MINE
		return filterWith(Filter.matchDescription(desiredDescription));
=======
		return filterWith(Filter.matchMethodDescription(desiredDescription));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import java.io.FileInputStream;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import java.io.FileOutputStream;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import java.util.Comparator;
import java.util.HashMap;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import java.util.Map;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
// TODO (Nov 18, 2008 1:40:42 PM): Is this doing too much?
public class MaxCore implements Serializable {
	private static final long serialVersionUID= 1L;

	public static MaxCore forFolder(String folder) throws CouldNotReadCoreException {
		if (new File(folder + ".ser").exists())
			return readCore(folder);
		return new MaxCore(folder);
	}

	private static MaxCore readCore(String folder) throws CouldNotReadCoreException {
		// TODO: rule of three
		// TODO: Really?
		ObjectInputStream stream;
		try {
			stream= new ObjectInputStream(new FileInputStream(folder + ".ser"));
		} catch (IOException e) {
			throw new CouldNotReadCoreException(e);
		}
		try {
			return (MaxCore) stream.readObject();
		} catch (Exception e) {
			throw new CouldNotReadCoreException(e); //TODO think about what we can do better here
		} finally {
			try {
				stream.close();
			} catch (IOException e) {
				throw new CouldNotReadCoreException(e);
			}
		}
=======
public class MaxCore {
	public static MaxCore storedLocally(File storedResults) {
		return new MaxCore(storedResults);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public static MaxCore createFresh() {
		return new MaxCore();
	}
=======
	public final MaxHistory fHistory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	protected Map<String, Long> fDurations= new HashMap<String, Long>();
	protected Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();
	private final String fFolder;
	
	private MaxCore(String folder) {
		fFolder= folder;
=======
	public MaxCore(File storedResults) {
		fHistory = MaxHistory.forFolder(storedResults);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private MaxCore() {
		// TODO: ensure fresh
		this("MaxCore");
=======
	public Result run(Class<?> testClass) {
		return run(Request.aClass(testClass));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		core.addListener(new RememberingListener());
=======
		core.addListener(fHistory.listener());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
				save();
=======
				fHistory.save();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public String getFolder() {
		return fFolder;
	}

	public void forget() {
		new File(fFolder).delete();
	}

	private Request sortRequest(Request request) {
=======
	// TODO (Feb 23, 2009 10:14:05 PM): publicized for squeeze
	public Request sortRequest(Request request) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		Collections.sort(leaves, new TestComparator());
=======
		Collections.sort(leaves, fHistory.testComparator());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private Request constructLeafRequest(List<Description> leaves) {
=======
	// TODO (Feb 23, 2009 10:42:05 PM): V
	public Request constructLeafRequest(List<Description> leaves) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private Runner buildRunner(Description each) {
=======
	// TODO (Feb 23, 2009 11:17:01 PM): V
	public Runner buildRunner(Description each) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		return Request.method(type, each.getMethodName()).getRunner();
	}

	private void save() throws FileNotFoundException, IOException {
		ObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(fFolder + ".ser"));
		stream.writeObject(this);
		stream.close();
=======
		String methodName= each.getMethodName();
		if (methodName == null)
			return Request.aClass(type).getRunner();
		return Request.method(type, methodName).getRunner();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE

	private final class RememberingListener extends RunListener {
		private Map<Description, Long> starts= new HashMap<Description, Long>();

		@Override
		public void testStarted(Description description) throws Exception {
			starts.put(description, System.nanoTime()); // Get most accurate possible time
		}

		@Override
		public void testFinished(Description description) throws Exception {
			long end= System.nanoTime();
			long start= starts.get(description);
			putTestDuration(description, end - start);
		}

		@Override
		public void testFailure(Failure failure) throws Exception {
			long end= System.currentTimeMillis(); // This needs to be comparable across tests
			putTestFailureTimestamp(failure.getDescription(), end);
		}
	}

	private class TestComparator implements Comparator<Description> {
		public int compare(Description o1, Description o2) {
			// Always prefer new tests
			if (isNewTest(o1))
				return -1;
			if (isNewTest(o2))
				return 1;
			// Then most recently failed first
			int result= getFailure(o2).compareTo(getFailure(o1)); 
			return result != 0
				? result
				// Then shorter tests first
				: getTestDuration(o1).compareTo(getTestDuration(o2));
		}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		private Long getFailure(Description key) {
			Long result= getFailureTimestamp(key);
			if (result == null) 
				return 0L; // 0 = "never failed (that I know about)"
			return result;
		}
	}
	
	private List<Description> findLeaves(Request request) {
=======
	// TODO (Feb 23, 2009 10:40:23 PM): V
	public List<Description> findLeaves(Request request) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private void findLeaves(Description description, List<Description> results) {
=======
	// TODO (Feb 23, 2009 10:50:48 PM): V
	public void findLeaves(Description description, List<Description> results) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	
	private Long getFailureTimestamp(Description key) {
		return fFailureTimestamps.get(key.toString());
	}

	private void putTestFailureTimestamp(Description key, long end) {
		fFailureTimestamps.put(key.toString(), end);
	}

	private boolean isNewTest(Description key) {
		return ! fDurations.containsKey(key.toString());
	}
	
	private Long getTestDuration(Description key) {
		return fDurations.get(key.toString());
	}
	
	private void putTestDuration(Description description, long duration) {
		fDurations.put(description.toString(), duration);
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======
package org.junit.experimental.max;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

import org.junit.runner.Description;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;

public class MaxHistory implements Serializable {
	private static final long serialVersionUID= 1L;


	public static MaxHistory forFolder(File storedResults) {
		try {
			if (storedResults.exists())
				return readHistory(storedResults);
		} catch (CouldNotReadCoreException e) {
			e.printStackTrace();
			storedResults.delete();
		}
		return new MaxHistory(storedResults);
	}
	
//	public static MaxHistory forFolder(String folder) {
//		File serializedFile= new File(folder + ".ser");
//		try {
//			if (serializedFile.exists())
//				return readHistory(folder);
//		} catch (CouldNotReadCoreException e) {
//			e.printStackTrace();
//			serializedFile.delete();
//		}
//		return new MaxHistory(folder);
//	}

	private static MaxHistory readHistory(File storedResults) throws CouldNotReadCoreException {
		// TODO: rule of three
		// TODO: Really?
		ObjectInputStream stream;
		try {
			stream= new ObjectInputStream(new FileInputStream(storedResults));
		} catch (IOException e) {
			throw new CouldNotReadCoreException(e);
		}
		try {
			return (MaxHistory) stream.readObject();
		} catch (Exception e) {
			throw new CouldNotReadCoreException(e); //TODO think about what we can do better here
		} finally {
			try {
				stream.close();
			} catch (IOException e) {
				throw new CouldNotReadCoreException(e);
			}
		}
	}
	public final Map<String, Long> fDurations= new HashMap<String, Long>();

	public final Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();

	public final File fFolder;

	public MaxHistory(File storedResults) {
		fFolder= storedResults;
	}

	public File getFile() {
		return fFolder;
	}

	public void save() throws IOException {
		ObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(
				fFolder));
		stream.writeObject(this);
		stream.close();
	}

	Long getFailureTimestamp(Description key) {
		return fFailureTimestamps.get(key.toString());
	}

	void putTestFailureTimestamp(Description key, long end) {
		fFailureTimestamps.put(key.toString(), end);
	}

	boolean isNewTest(Description key) {
		return !fDurations.containsKey(key.toString());
	}

	Long getTestDuration(Description key) {
		return fDurations.get(key.toString());
	}

	void putTestDuration(Description description, long duration) {
		fDurations.put(description.toString(), duration);
	}

	private final class RememberingListener extends RunListener {
		private long overallStart= System.currentTimeMillis();

		private Map<Description, Long> starts= new HashMap<Description, Long>();

		@Override
		public void testStarted(Description description) throws Exception {
			starts.put(description, System.nanoTime()); // Get most accurate
														// possible time
		}

		@Override
		public void testFinished(Description description) throws Exception {
			long end= System.nanoTime();
			long start= starts.get(description);
			putTestDuration(description, end - start);
		}

		@Override
		public void testFailure(Failure failure) throws Exception {
			putTestFailureTimestamp(failure.getDescription(), overallStart);
		}
	}

	private class TestComparator implements Comparator<Description> {
		public int compare(Description o1, Description o2) {
			// Always prefer new tests
			if (isNewTest(o1))
				return -1;
			if (isNewTest(o2))
				return 1;
			// Then most recently failed first
			int result= getFailure(o2).compareTo(getFailure(o1)); 
			return result != 0
				? result
				// Then shorter tests first
				: getTestDuration(o1).compareTo(getTestDuration(o2));
		}
	
		private Long getFailure(Description key) {
			Long result= getFailureTimestamp(key);
			if (result == null) 
				return 0L; // 0 = "never failed (that I know about)"
			return result;
		}
	}


	public RememberingListener listener() {
		return new RememberingListener();
	}

	// TODO (Feb 23, 2009 10:41:36 PM): V
	public Comparator<Description> testComparator() {
		return new TestComparator();
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
=======
package org.junit.experimental;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.junit.runner.Computer;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.Suite;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;

public class ParallelComputer extends Computer {
	private final boolean fClasses;
	private final boolean fMethods;

	public ParallelComputer(boolean classes, boolean methods) {
		fClasses= classes;
		fMethods= methods;
	}

	public static Computer classes() {
		return new ParallelComputer(true, false);
	}
	
//TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
		}
		private ExecutorService fService= Executors.newCachedThreadPool();
		private List<Future<Object>> fResults= new ArrayList<Future<Object>>();
	
		@Override
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fResults.add(fService.submit(callable));
		}
		
		protected void superRunChild(Runner runner, RunNotifier notifier) {
			super.runChild(runner, notifier);
		}
		
		@Override
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fResults)
				try {
					each.get(2000, TimeUnit.MILLISECONDS);
				} catch (Exception e) {
					e.printStackTrace();
				} 
		}
	}

	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		private ExecutorService fService= Executors.newCachedThreadPool();
		private List<Future<Object>> fResults= new ArrayList<Future<Object>>();
	
		@Override
		protected void runChild(final FrameworkMethod method, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(method, notifier);
					return null;
				}
			};
			fResults.add(fService.submit(callable));
		}
		
		protected void superRunChild(FrameworkMethod method, RunNotifier notifier) {
			super.runChild(method, notifier);
		}
		
		@Override
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fResults)
				try {
					each.get(2000, TimeUnit.MILLISECONDS); // TODO(parallel) what should this really be?
				} catch (Exception e) {
					e.printStackTrace();
				} 
		}
	}

	@Override
	public Suite getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes) throws InitializationError {
		return fClasses
			? new ParallelSuite(builder, classes)
			: super.getSuite(builder, classes);
	}
	
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		return fMethods
			? new ParallelRunner(testClass)
			: super.getRunner(builder, testClass);
	}

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;<<<<<<< MINE
=======
import org.junit.experimental.ParallelComputer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
=======
import org.junit.experimental.ParallelComputer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
	@Test/*(timeout=1500)*/ public void testsRunInParallel() {
=======
	@Test public void testsRunInParallel() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
		Result result= JUnitCore.runClasses(ParallelComputer.methods(), Example.class);
=======
		Result result= JUnitCore.runClasses(ParallelComputer.methods(),
				Example.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
		assertThat(end - start, greaterThanOrEquals(1000));
=======
		assertThat(end - start, betweenInclusive(1000, 1500));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
	private Matcher<Long> greaterThanOrEquals(final long l) {
=======
	private Matcher<Long> betweenInclusive(final long min, final long max) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
				return item >= l;
=======
				return item >= min && item <= max;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
				description.appendText("greater than or equal" + l);
=======
				description.appendText("between " + min + " and " + max);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;<<<<<<< MINE
=======
import java.io.File;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;<<<<<<< MINE
=======
	private File fMaxFile;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;<<<<<<< MINE
		fMax= MaxCore.createFresh();
=======
		fMaxFile= new File("MaxCore.ser");
		if (fMaxFile.exists())
			fMaxFile.delete();
		fMax= MaxCore.storedLocally(fMaxFile);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/JUnit38SortingTest.java;<<<<<<< MINE
		fMax.forget();
=======
		fMaxFile.delete();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.is;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
import static org.junit.Assert.assertThat;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
import static org.junit.matchers.JUnitMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
import java.io.File;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
import org.junit.experimental.max.CouldNotReadCoreException;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
import org.junit.runner.Runner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
	private File fMaxFile;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		fMax= MaxCore.createFresh();
=======
		fMaxFile= new File("MaxCore.ser");
		if (fMaxFile.exists())
			fMaxFile.delete();
		fMax= MaxCore.storedLocally(fMaxFile);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		fMax.forget();
=======
		fMaxFile.delete();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
			fail();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
			fail();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======

	}

	@Test
	public void rememberOldRuns() {
		fMax.run(TwoUnEqualTests.class);

		MaxCore reincarnation= MaxCore.storedLocally(fMaxFile);
		List<Failure> failures= reincarnation.run(TwoUnEqualTests.class)
				.getFailures();
		assertEquals("fast", failures.get(0).getDescription().getMethodName());
		assertEquals("slow", failures.get(1).getDescription().getMethodName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
	public void remember() throws CouldNotReadCoreException {
		Request request= Request.aClass(TwoUnEqualTests.class);
		fMax.run(request);
		MaxCore reincarnation= MaxCore.forFolder(fMax.getFolder());
		try {
			Description thing= reincarnation.sortedLeavesForTest(request).get(1);
			assertEquals(Description.createTestDescription(TwoUnEqualTests.class, "slow"), thing);
		} finally {
			reincarnation.forget();
		}
	}

	@Test
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
	
	@Test public void saffSqueezeExample() throws Exception {
		final Description method= Description.createTestDescription(TwoOldTests.class, "testOne");
		Filter filter= Filter.matchDescription(method);
=======

	@Test
	public void saffSqueezeExample() throws Exception {
		final Description method= Description.createTestDescription(
				TwoOldTests.class, "testOne");
		Filter filter= Filter.matchMethodDescription(method);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		// TODO (Nov 18, 2008 4:42:43 PM): DUP above
		Class<AllTests> testClass= AllTests.class;
		assertFilterLeavesTestUnscathed(testClass);
=======
		assertFilterLeavesTestUnscathed(AllTests.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
	private static class MalformedJUnit38Test {
		private MalformedJUnit38Test() {
		}

		public void testSucceeds() {
		}
	}

	@Test
	public void maxShouldSkipMalformedJUnit38Classes() {
		Request request= Request.aClass(MalformedJUnit38Test.class);
		fMax.run(request);
	}

	public static class MalformedJUnit38TestMethod extends TestCase {
		@SuppressWarnings("unused")
		private void testNothing() {
		}
	}

	String fMessage= null;

	@Test
	public void correctErrorFromMalformedTest() {
		Request request= Request.aClass(MalformedJUnit38TestMethod.class);
		JUnitCore core= new JUnitCore();
		Request sorted= fMax.sortRequest(request);
		Runner runner= sorted.getRunner();
		Result result= core.run(runner);
		Failure failure= result.getFailures().get(0);

		assertThat(failure.toString(),
				containsString("MalformedJUnit38TestMethod"));
		assertThat(failure.toString(), containsString("testNothing"));
		assertThat(failure.toString(), containsString("isn't public"));
	}

	public static class HalfMalformedJUnit38TestMethod extends TestCase {
		public void testSomething() {
		}

		@SuppressWarnings("unused")
		private void testNothing() {
		}
	}

	@Test
	public void halfMalformed() {
		assertThat(JUnitCore.runClasses(HalfMalformedJUnit38TestMethod.class)
				.getFailureCount(), is(1));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.max;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import junit.framework.TestCase;
import org.junit.Test;
import org.junit.experimental.max.MaxHistory;
import org.junit.internal.builders.JUnit3Builder;
import org.junit.runner.Computer;
import org.junit.runner.Description;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunListener;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;

public class MaxComputerTest {
	private static class MaxComputer extends Computer {
		// TODO (Mar 2, 2009 11:21:28 PM): configure somehow
		MaxHistory fMax= new MaxHistory(new File("MaxCore.max"));

		@Override
		protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
				throws Throwable {
			Runner junit3Runner= new JUnit3Builder().runnerForClass(testClass);
			if (junit3Runner != null)
				return junit3Runner;
			return new MaxRunner(testClass, fMax);
		}
	}

	private static class MaxRunner extends BlockJUnit4ClassRunner {
		private final MaxHistory fMax;

		// TODO (Mar 2, 2009 10:59:15 PM): this grows without bound.
		private List<FrameworkMethod> methods= new ArrayList<FrameworkMethod>();

		public MaxRunner(Class<?> klass, MaxHistory max)
				throws InitializationError {
			super(klass);
			fMax= max;
		}

		@Override
		protected void runChild(FrameworkMethod method, RunNotifier notifier) {
			methods.add(method);
		}

		@Override
		public void run(RunNotifier notifier) {
			notifier.addListener(fMax.listener());
			super.run(notifier);
			sortMethods();
			for (FrameworkMethod each : methods) {
				super.runChild(each, notifier);
			}
		}

		private void sortMethods() {
			Collections.sort(methods, new Comparator<FrameworkMethod>() {
				public int compare(FrameworkMethod o1, FrameworkMethod o2) {
					return fMax.testComparator().compare(describe(o1),
							describe(o2));
				}

				private Description describe(FrameworkMethod o1) {
					return Description.createTestDescription(o1.getMethod()
							.getDeclaringClass(), o1.getName());
				}
			});
		}
	}

	public static class TwoTests {
		@Test
		public void succeed() {
		}

		@Test
		public void dontSucceed() {
			fail();
		}
	}

	@Test
	public void twoTestsNotRunComeBackInRandomOrder() {
		Result result= new JUnitCore().run(new MaxComputer(), TwoTests.class);
		assertEquals(2, result.getRunCount());
		assertEquals(1, result.getFailureCount());
		assertEquals("dontSucceed", result.getFailures().get(0)
				.getDescription().getMethodName());
	}

	@Test
	public void failedTestFirstOnSecondRun() {
		MaxComputer computer= new MaxComputer();
		new JUnitCore().run(computer, TwoTests.class);
		JUnitCore core= new JUnitCore();
		final List<Description> testOrder= new ArrayList<Description>();
		core.addListener(new RunListener() {
			@Override
			public void testStarted(Description description) throws Exception {
				testOrder.add(description);
			}
		});
		core.run(computer, TwoTests.class);
		assertEquals("dontSucceed", testOrder.get(0).getMethodName());
		assertEquals(2, testOrder.size());
	}
	
	public static class TwoOldTests extends TestCase {
		public void testSucceed() {
		}

		public void testDontSucceed() {
			fail();
		}
	}

	@Test
	public void junit3TestsAreRunOnce() throws Exception {
		Result result= new JUnitCore().run(new MaxComputer(), TwoOldTests.class);
		assertEquals(2, result.getRunCount());
		assertEquals(1, result.getFailureCount());
		assertEquals("testDontSucceed", result.getFailures().get(0)
				.getDescription().getMethodName());
	}

	// Description succeed= Description.createTestDescription(TwoTests.class,
	// "succeed");
	// Description dontSucceed= Description.createTestDescription(
	// TwoTests.class, "dontSucceed");
	// assertTrue(things.contains(succeed));
	// assertTrue(things.contains(dontSucceed));
	// assertEquals(2, things.size());
	// }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/junit3compatibility/OldTestClassAdaptingListenerTest.java;<<<<<<< MINE
		TestListener adaptingListener= JUnit38ClassRunner
				.createAdaptingListener(notifier);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/junit3compatibility/OldTestClassAdaptingListenerTest.java;<<<<<<< MINE
=======
		TestListener adaptingListener= new JUnit38ClassRunner(testCase)
				.createAdaptingListener(notifier);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
import org.junit.tests.experimental.max.MaxComputerTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	JUnit38SortingTest.class
=======
	JUnit38SortingTest.class,
	MaxComputerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jeromq/revisions/rev_422e861_d89fa27/rev_422e861-d89fa27/src/test/java/org/jeromq/TestZLoop.java;<<<<<<< MINE
        loop.pollerEnd(poll_input);
        ctx.destroy();
        //  @end
        printf ("OK\n");
    }
    
    @Test(timeout = 1000)
    public void testZLoopEndReactorFromTimer() {
        printf (" * zloop end reactor from timer: ");
        int rc = 0;
        //  @selftest
        ZContext ctx = new ZContext ();
        assert (ctx != null);
        
        Socket output = ctx.createSocket(ZMQ.PAIR);
        assert (output != null);
        output.bind("inproc://zloop.test");
        Socket input = ctx.createSocket(ZMQ.PAIR);
        assert (input != null);
        input.connect( "inproc://zloop.test");

        ZLoop loop = ZLoop.instance();
        assert (loop != null);
        loop.verbose (true);
        
        ZLoop.IZLoopHandler s_timer_event = new ZLoop.IZLoopHandler() {

            @Override
            public int handle(ZLoop loop, PollItem item, Object arg) {
                ((Socket)arg).send("PING", 0);
                return 0;
            }
        };
        
        ZLoop.IZLoopHandler s_socket_event = new ZLoop.IZLoopHandler() {

            @Override
            public int handle(ZLoop loop, PollItem item, Object arg) {
                //  After 10 msecs, fire an event that ends the reactor
            	ZLoop.IZLoopHandler s_shutdown_event = new ZLoop.IZLoopHandler() {
                    @Override
                    public int handle(ZLoop loop, PollItem item, Object arg) {
                    	//  Just end the reactor
                        return -1;
                    }
                };
                loop.timer(10, 1, s_shutdown_event, s_shutdown_event);
                return 0;
            }
        };

        //  Fire event that sends a ping message to output
        loop.timer (0, 1, s_timer_event, output);
        
        //  When we get the ping message, end the reactor
        PollItem poll_input = new PollItem( input, ZMQ.POLLIN );
        rc = loop.poller (poll_input, s_socket_event, null);
        assert (rc == 0);
        loop.start ();

        loop.pollerEnd(poll_input);
=======
        loop.pollerEnd(poll_input);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jeromq/revisions/rev_422e861_d89fa27/rev_422e861-d89fa27/src/test/java/org/jeromq/TestZLoop.java;<<<<<<< MINE
        System.out.println(s);
=======
        System.out.print(s);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_e4ee2c0_f454880/rev_e4ee2c0-f454880/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	private static String host = "localhost";
	private static int port = Protocol.DEFAULT_PORT;
	
	static {
		final String envHost = System.getProperty("redis-host");
		final String envPort = System.getProperty("redis-port");
		if (null != envHost && 0 < envHost.length()) {
			host = envHost;
		}
		if (null != envPort && 0 < envPort.length()) {
			try {
				port = Integer.parseInt(envPort);
			} catch (final NumberFormatException e) {}
		}
		
		System.out.println("Redis host to be used : " + host + ":" + port);
	}
	
	@Test
	public void checkConnections() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port, 2000);
		pool.setResourcesNumber(10);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "bar");
		assertEquals("bar", jedis.get("foo"));
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test
	public void checkConnectionWithDefaultPort() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(10);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "bar");
		assertEquals("bar", jedis.get("foo"));
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test
	public void checkJedisIsReusedWhenReturned() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "0");
		pool.returnResource(jedis);

		jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.incr("foo");
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test
	public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
			IOException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.quit();
		pool.returnBrokenResource(jedis);

		jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.incr("foo");
		pool.returnResource(jedis);
		pool.destroy();
	}

	@Test(expected = TimeoutException.class)
	public void checkPoolOverflow() throws TimeoutException {
		JedisPool pool = new JedisPool(host, port);
		pool.setResourcesNumber(1);
		pool.init();

		Jedis jedis = pool.getResource(200);
		jedis.auth("foobared");
		jedis.set("foo", "0");

		Jedis newJedis = pool.getResource(200);
		newJedis.auth("foobared");
		newJedis.incr("foo");
	}
=======
    @Test
    public void checkConnections() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(10);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkConnectionWithDefaultPort() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(10);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkJedisIsReusedWhenReturned() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "0");
	pool.returnResource(jedis);

	jedis = pool.getResource(200);
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test
    public void checkPoolRepairedWhenJedisIsBroken() throws TimeoutException,
	    IOException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.quit();
	pool.returnBrokenResource(jedis);

	jedis = pool.getResource(200);
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
    }

    @Test(expected = TimeoutException.class)
    public void checkPoolOverflow() throws TimeoutException {
	JedisPool pool = new JedisPool("localhost", Protocol.DEFAULT_PORT,
		2000, "foobared");
	pool.setResourcesNumber(1);
	pool.init();

	Jedis jedis = pool.getResource(200);
	jedis.set("foo", "0");

	Jedis newJedis = pool.getResource(200);
	newJedis.incr("foo");
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.5";
=======
		return "4.6-RC1";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
					Assert.assertEquals((Double)expected, (Double)actual, fDelta);
=======
					if (expected instanceof Double)
						Assert.assertEquals((Double)expected, (Double)actual, fDelta);
					else
						Assert.assertEquals((Float)expected, (Float)actual, fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/org/junit/Assert.java;<<<<<<< MINE
=======
	 * Asserts that two double arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown with the given message.
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expecteds
	 *            double array with expected values.
	 * @param actuals
	 *            double array with actual values
	 */
	public static void assertArrayEquals(String message, float[] expecteds,
			float[] actuals, float delta) throws ArrayComparisonFailure {
		new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);
	}

	// TODO (Mar 10, 2009 10:52:18 AM): fix javadoc
	/**
	 * Asserts that two double arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown.
	 * 
	 * @param expecteds
	 *            double array with expected values.
	 * @param actuals
	 *            double array with actual values
	 */
	public static void assertArrayEquals(float[] expecteds, float[] actuals, float delta) {
		assertArrayEquals(null, expecteds, actuals, delta);
	}

	/**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
	public static MaxCore forFolder(String fileName) {
		return storedLocally(new File(fileName));
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
		// TODO: add floats
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
=======
		// TODO (Mar 10, 2009 10:47:34 AM): Import
		Assert.assertArrayEquals(new float[] {1.0f}, new float[] {1.0f}, 1.0f);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
		// TODO: add floats
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e980c59_1bb1eaf/rev_e980c59-1bb1eaf/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
=======
	public void oneDimensionalFloatArraysAreNotEqual() {
		assertArrayEquals(new float[] {1.0f}, new float[] {2.5f}, 1.0f);
	}

	@Test(expected=AssertionError.class)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ef92925_469dcc7/rev_ef92925-469dcc7/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.6-RC1";
=======
		return "4.6";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
    public JedisPool(ShardInfo shardInfo) {
=======
    public JedisPool(JedisShardInfo shardInfo) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
public class ShardedJedis extends Sharded<Jedis> {
    public ShardedJedis(List<ShardInfo> shards) {
=======
public class ShardedJedis extends Sharded<Jedis,JedisShardInfo> {
    public ShardedJedis(List<JedisShardInfo> shards) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public ShardedJedis(List<ShardInfo> shards, Hashing algo) {
=======
    public ShardedJedis(List<JedisShardInfo> shards, Hashing algo) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
	for (Jedis jedis : getAllShards()) {
	    jedis.disconnect();
=======
	for (JedisShardInfo jedis : getAllShards()) {
	    jedis.getResource().disconnect();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    protected Jedis create(ShardInfo shard) {
=======
    protected Jedis create(JedisShardInfo shard) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Jedis(ShardInfo shardInfo) {
=======
    public Jedis(JedisShardInfo shardInfo) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/JedisShardInfo.java;<<<<<<< MINE
=======
/*
 * Copyright 2009-2010 MBTE Sweden AB.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package redis.clients.jedis;

import redis.clients.util.ShardInfo;
import redis.clients.util.Sharded;

public class JedisShardInfo extends ShardInfo<Jedis> {
    @Override
    public String toString() {
        return "JedisShardInfo [host=" + host + ", port=" + port + ", weight="
                + getWeight() + "]";
    }

    private int timeout;
    private String host;
    private int port;
    private String password = null;

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }

    public JedisShardInfo(String host) {
        this(host, Protocol.DEFAULT_PORT);
    }

    public JedisShardInfo(String host, int port) {
        this(host, port, 2000);
    }

    public JedisShardInfo(String host, int port, int timeout) {
        this(host, port, timeout, Sharded.DEFAULT_WEIGHT);
    }

    public JedisShardInfo(String host, int port, int timeout, int weight) {
        super(weight);
        this.host = host;
        this.port = port;
        this.timeout = timeout;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String auth) {
        this.password = auth;
    }

    public int getTimeout() {
        return timeout;
    }

    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    @Override
    public Jedis createResource() {
        return new Jedis(this);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
import java.io.IOException;
=======
import redis.clients.util.RedisInputStream;
import redis.clients.util.RedisOutputStream;

import java.io.*;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
import redis.clients.util.RedisInputStream;
import redis.clients.util.RedisOutputStream;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
	try {
	    connect();
	} catch (UnknownHostException e) {
	    throw new JedisException("Could not connect to redis-server", e);
	} catch (IOException e) {
	    throw new JedisException("Could not connect to redis-server", e);
	}
=======
		try {
			connect();
		} catch (UnknownHostException e) {
			throw new JedisException("Could not connect to redis-server", e);
		} catch (IOException e) {
			throw new JedisException("Could not connect to redis-server", e);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
    public Integer getIntegerReply() {
=======
    public int getIntegerReply() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
	return (Integer) protocol.read(inputStream);
=======
	return ((Integer) protocol.read(inputStream)).intValue();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
import java.util.HashMap;
=======
import java.util.Collections;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
import java.util.Map;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
public abstract class Sharded<T> {
=======
public class Sharded<R, S extends ShardInfo<R>> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    private TreeMap<Long, ShardInfo> nodes;
    private int totalWeight;
    private Map<ShardInfo, T> resources;
    private Hashing algo = Hashing.MD5;
=======
    private TreeMap<Long, S> nodes;
    private final Hashing algo;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    public Sharded(List<ShardInfo> shards) {
	initialize(shards);
=======
    public Sharded(List<S> shards) {
        this(shards, Hashing.MURMUR_HASH); // MD5 is really not good as we works with 64-bits not 128
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    public Sharded(List<ShardInfo> shards, Hashing algo) {
	initialize(shards);
=======
    public Sharded(List<S> shards, Hashing algo) {
        this.algo = algo;
        initialize(shards);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    private void initialize(List<ShardInfo> shards) {
	nodes = new TreeMap<Long, ShardInfo>();
	resources = new HashMap<ShardInfo, T>();
=======
    private void initialize(List<S> shards) {
        nodes = new TreeMap<Long, S>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	totalWeight = 0;
=======
        int totalWeight = 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	for (ShardInfo shard : shards) {
	    totalWeight += shard.getWeight();
	}
=======
        for (ShardInfo shard : shards) {
            totalWeight += shard.getWeight();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	MessageDigest md5;
	try {
	    md5 = MessageDigest.getInstance("MD5");
	} catch (NoSuchAlgorithmException e) {
	    throw new IllegalStateException("++++ no md5 algorythm found");
	}
=======
        long oneForthOfStep = (1L << 62) / totalWeight; // 62 vs 64 to normalize math in Long
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
	for (ShardInfo shard : shards) {
	    double factor = Math
		    .floor(((double) (40 * shards.size() * DEFAULT_WEIGHT))
			    / (double) totalWeight);

	    for (long j = 0; j < factor; j++) {
		byte[] d = md5.digest((shard.toString() + "-" + j).getBytes());
		for (int h = 0; h < 4; h++) {
		    Long k = ((long) (d[3 + h * 4] & 0xFF) << 24)
			    | ((long) (d[2 + h * 4] & 0xFF) << 16)
			    | ((long) (d[1 + h * 4] & 0xFF) << 8)
			    | ((long) (d[0 + h * 4] & 0xFF));
		    nodes.put(k, shard);
		}
	    }
	    resources.put(shard, create(shard));
	}
=======
        long floor = Long.MIN_VALUE;
        for (int i = 0; i != shards.size(); ++i) {
            final S shardInfo = shards.get(i);
            shardInfo.initResource();
            nodes.put(floor, shardInfo);
            floor += 4 * oneForthOfStep * shardInfo.getWeight(); // *4 to compensate 62 vs 64
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    public ShardInfo getShardInfo(String key) {
	long hv = calculateHash(key);

	return nodes.get(findPointFor(hv));
=======
    public R getShard(String key) {
        return nodes.floorEntry(algo.hash(key)).getValue().getResource();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    private Long calculateHash(String key) {
	return algo.hash(key);
=======
    public S getShardInfo(String key) {
        return nodes.floorEntry(algo.hash(key)).getValue();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
    private Long findPointFor(Long hashK) {
	Long k = nodes.ceilingKey(hashK);

	if (k == null) {
	    k = nodes.firstKey();
	}

	return k;
    }

    public T getShard(String key) {
	ShardInfo shard = getShardInfo(key);
	return resources.get(shard);
    }

    protected abstract T create(ShardInfo shard);

    public Collection<T> getAllShards() {
	return resources.values();
=======
    public Collection<S> getAllShards() {
        return Collections.unmodifiableCollection(nodes.values());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
import redis.clients.jedis.Protocol;
=======
public abstract class ShardInfo<T> {
    private T resource;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
public class ShardInfo {
    @Override
    public String toString() {
	return "ShardInfo [host=" + host + ", port=" + port + ", weight="
		+ weight + "]";
    }

    private String host;
    private int port;
    private int timeout;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    private String password = null;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public String getHost() {
	return host;
=======
    public ShardInfo() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public int getPort() {
	return port;
=======
    public ShardInfo(int weight) {
        this.weight = weight;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public int getTimeout() {
	return timeout;
    }

    public ShardInfo(String host) {
	this(host, Protocol.DEFAULT_PORT);
=======
    public int getWeight() {
        return this.weight;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    public ShardInfo(String host, int port) {
	this(host, port, 2000);
=======
    public T getResource() {
        return resource;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    @Override
    public int hashCode() {
	final int prime = 31;
	int result = 1;
	result = prime * result + ((host == null) ? 0 : host.hashCode());
	result = prime * result + port;
	result = prime * result + timeout;
	result = prime * result + weight;
	return result;
=======
    public void initResource () {
        resource = createResource();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
    @Override
    public boolean equals(Object obj) {
	if (this == obj)
	    return true;
	if (obj == null)
	    return false;
	if (getClass() != obj.getClass())
	    return false;
	ShardInfo other = (ShardInfo) obj;
	if (host == null) {
	    if (other.host != null)
		return false;
	} else if (!host.equals(other.host))
	    return false;
	if (port != other.port)
	    return false;
	if (timeout != other.timeout)
	    return false;
	if (weight != other.weight)
	    return false;
	return true;
    }

    public ShardInfo(String host, int port, int timeout) {
	this(host, port, timeout, Sharded.DEFAULT_WEIGHT);
    }

    public ShardInfo(String host, int port, int timeout, int weight) {
	this.host = host;
	this.port = port;
	this.timeout = timeout;
	this.weight = weight;
    }

    public String getPassword() {
	return password;
    }

    public void setPassword(String auth) {
	this.password = auth;
    }

    public void setTimeout(int timeout) {
	this.timeout = timeout;
    }

    public int getWeight() {
	return this.weight;
    }
=======
    protected abstract T createResource();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
=======
import redis.clients.jedis.JedisShardInfo;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	List<ShardInfo> shards = new ArrayList<ShardInfo>();
	shards.add(new ShardInfo(redis1.host, redis1.port));
	shards.add(new ShardInfo(redis2.host, redis2.port));
=======
	List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
	shards.add(new JedisShardInfo(redis1.host, redis1.port));
	shards.add(new JedisShardInfo(redis2.host, redis2.port));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	List<ShardInfo> shards = new ArrayList<ShardInfo>();
	ShardInfo si = new ShardInfo(redis1.host, redis1.port);
=======
	List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
	JedisShardInfo si = new JedisShardInfo(redis1.host, redis1.port);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	si = new ShardInfo(redis2.host, redis2.port);
=======
	si = new JedisShardInfo(redis2.host, redis2.port);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	ShardInfo s1 = jedis.getShardInfo("a");
=======
	JedisShardInfo s1 = jedis.getShardInfo("a");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	ShardInfo s2 = jedis.getShardInfo("b");
=======
	JedisShardInfo s2 = jedis.getShardInfo("b");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	List<ShardInfo> shards = new ArrayList<ShardInfo>();
	ShardInfo si = new ShardInfo(redis1.host, redis1.port);
=======
	List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
	JedisShardInfo si = new JedisShardInfo(redis1.host, redis1.port);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	si = new ShardInfo(redis2.host, redis2.port);
=======
	si = new JedisShardInfo(redis2.host, redis2.port);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	ShardInfo s1 = jedis.getShardInfo("a");
=======
	JedisShardInfo s1 = jedis.getShardInfo("a");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
	ShardInfo s2 = jedis.getShardInfo("b");
=======
	JedisShardInfo s2 = jedis.getShardInfo("b");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/JedisTest.java;<<<<<<< MINE
=======
import redis.clients.jedis.JedisShardInfo;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/test/java/redis/clients/jedis/tests/JedisTest.java;<<<<<<< MINE
	ShardInfo shardInfo = new ShardInfo("localhost", Protocol.DEFAULT_PORT);
=======
	JedisShardInfo shardInfo = new JedisShardInfo("localhost", Protocol.DEFAULT_PORT);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
=======
	private boolean fFinished= false;

	private Throwable fThrown= null;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
		ExecutorService service= Executors.newSingleThreadExecutor();
		Callable<Object> callable= new Callable<Object>() {
			public Object call() throws Exception {
=======
		Thread thread= new Thread() {
			@Override
			public void run() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
=======
					fFinished= true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
					throw new ExecutionException(e);
=======
					fThrown= e;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
				return null;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/main/java/org/junit/internal/runners/statements/FailOnTimeout.java;<<<<<<< MINE
		Future<Object> result= service.submit(callable);
		service.shutdown();
		try {
			boolean terminated= service.awaitTermination(fTimeout,
					TimeUnit.MILLISECONDS);
			if (!terminated)
				service.shutdownNow();
			result.get(0, TimeUnit.MILLISECONDS); // throws the exception if one occurred during the invocation
		} catch (TimeoutException e) {
			throw new Exception(String.format(
					"test timed out after %d milliseconds", fTimeout));
		} catch (ExecutionException e) {
			throw unwrap(e);
		}
	}

	private Throwable unwrap(Throwable e) {
		if (e instanceof ExecutionException)
			return unwrap(e.getCause());
		return e;
=======
		thread.start();
		thread.join(fTimeout);
		if (fFinished)
			return;
		if (fThrown != null)
			throw fThrown;
		Exception exception= new Exception(String.format(
				"test timed out after %d milliseconds", fTimeout));
		exception.setStackTrace(thread.getStackTrace());
		throw exception;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;<<<<<<< MINE
=======
import static org.junit.matchers.JUnitMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;<<<<<<< MINE
	@Ignore("We would like this behavior to work but it may not be possible")
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_1708730_912e94c/rev_1708730-912e94c/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;<<<<<<< MINE
		assertTrue(writer.toString().contains("infiniteLoop")); // Make sure we have the stalled frame on the stack somewhere
=======
		assertThat(buffer.toString(), containsString("infiniteLoop")); // Make sure we have the stalled frame on the stack somewhere
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis implements JedisCommands {
    private Client client = null;
    private String password = null;

    public Jedis(String host) {
        client = new Client(host);
=======
public class Jedis extends BinaryJedis implements JedisCommands {
    public Jedis(final String host) {
        super(host);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Jedis(JedisShardInfo shardInfo) {
        client = new Client(shardInfo.getHost(), shardInfo.getPort());
        client.setTimeout(shardInfo.getTimeout());
        this.password = shardInfo.getPassword();
    }

    public String ping() {
        runChecks();
        client.ping();
        return client.getStatusCodeReply();
=======
    public Jedis(final JedisShardInfo shardInfo) {
    	super(shardInfo);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Ask the server to silently close the connection.
     */
    public void quit() {
        runChecks();
        client.quit();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Delete all the keys of the currently selected DB. This command never
     * fails.
     * 
     * @return Status code reply
     */
    public String flushDB() {
        runChecks();
        client.flushDB();
        return client.getStatusCodeReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Return the number of keys in the currently selected database.
     * 
     * @return Integer reply
     */
    public Integer dbSize() {
        runChecks();
        client.dbSize();
        return client.getIntegerReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Select the DB with having the specified zero-based numeric index. For
     * default every new client connection is automatically selected to DB 0.
     * 
     * @param index
     * @return Status code reply
     */
    public String select(int index) {
        runChecks();
        client.select(index);
        return client.getStatusCodeReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
     * Delete all the keys of all the existing databases, not just the currently
     * selected one. This command never fails.
     * 
     * @return Status code reply
     */
    public String flushAll() {
        runChecks();
        client.flushAll();
        return client.getStatusCodeReply();
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Transaction multi() {
        client.multi();
        client.getStatusCodeReply();
        return new Transaction(client);
    }

    public List<Object> multi(TransactionBlock jedisTransaction) {
        List<Object> results = null;
        try {
            jedisTransaction.setClient(client);
            multi();
            jedisTransaction.execute();
            results = jedisTransaction.exec();
        } catch (Exception ex) {
            client.discard();
        }
        return results;
    }

    private void runChecks() {
        if (client.isInMulti()) {
            throw new JedisException(
                    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
        }
        try {
            this.connect();
        } catch (UnknownHostException e) {
            throw new JedisException(e);
        } catch (IOException e) {
            throw new JedisException(e);
        }
    }

    public void connect() throws UnknownHostException, IOException {
        if (!client.isConnected()) {
            client.connect();
            if (this.password != null) {
                this.auth(this.password);
            }
        }
    }

    public void disconnect() throws IOException {
        client.disconnect();
    }

    public String watch(String key) {
=======
    public String watch(final String key) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(String password) {
        runChecks();
        client.auth(password);
        return client.getStatusCodeReply();
    }

    public List<Object> pipelined(JedisPipeline jedisPipeline) {
        jedisPipeline.setClient(client);
        jedisPipeline.execute();
        return client.getAll();
    }

    public void subscribe(JedisPubSub jedisPubSub, String... channels) {
        client.setTimeoutInfinite();
        jedisPubSub.proceed(client, channels);
        client.rollbackTimeout();
    }

    public Integer publish(String channel, String message) {
        client.publish(channel, message);
        return client.getIntegerReply();
    }

    public void psubscribe(JedisPubSub jedisPubSub, String... patterns) {
        client.setTimeoutInfinite();
        jedisPubSub.proceedWithPatterns(client, patterns);
        client.rollbackTimeout();
    }

    public Integer zcount(String key, double min, double max) {
        runChecks();
=======
    public Integer zcount(final String key, final double min, final double max) {
        checkIsInMulti();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
    protected Connection sendCommand(String name, String... args) {
        protocol.sendCommand(outputStream, name, args);
=======
    protected Connection sendCommand(final Command cmd, final String... args) {
    	final byte[][] bargs = new byte[args.length][];
    	for(int i=0; i < args.length; i++) {
    		bargs[i] = args[i].getBytes(Protocol.UTF8);
    	}
    	return sendCommand(cmd, bargs);
    }

    protected Connection sendCommand(final Command cmd, final byte[]... args) {
        try {
            connect();
        } catch (UnknownHostException e) {
            throw new JedisException("Could not connect to redis-server", e);
        } catch (IOException e) {
            throw new JedisException("Could not connect to redis-server", e);
        }
        protocol.sendCommand(outputStream, cmd, args);
        pipelinedCommands++;
        return this;
    }

    protected Connection sendCommand(final Command cmd) {
        try {
            connect();
        } catch (UnknownHostException e) {
            throw new JedisException("Could not connect to redis-server", e);
        } catch (IOException e) {
            throw new JedisException("Could not connect to redis-server", e);
        }
        protocol.sendCommand(outputStream, cmd, new byte[0][]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.6";
=======
		return "4.7-SNAPSHOT-20090428-1600";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/AfterClass.java;<<<<<<< MINE
 *    DatabaseConnection database;
=======
 *    private static DatabaseConnection database;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import java.lang.reflect.Field;

import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

public class Interceptors extends BlockJUnit4ClassRunner {
	public Interceptors(Class<?> klass) throws InitializationError {
		super(klass);
	}

	@Override
	protected Statement withAfters(FrameworkMethod method, Object target,
			Statement statement) {
		// TODO Auto-generated method stub
		// TODO (Apr 28, 2009 10:55:21 PM): parameter clump?
		return super.withAfters(method, target, intercept(statement, target, method));
	}

	private Statement intercept(Statement statement, Object target, FrameworkMethod method) {
		Class<?> javaClass= getTestClass().getJavaClass();
		Field[] fields= javaClass.getFields();
		Statement result= statement;
		for (Field each : fields) {
			if (each.getAnnotation(Interceptor.class) != null) {
				try {
					StatementInterceptor interceptor= (StatementInterceptor) each
							.get(target);
					result= interceptor.intercept(result, method);
				} catch (IllegalAccessException e) {
					throw new RuntimeException(
							"How did getFields return a field we couldn't access?");
				}
			}
		}
		return result;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/Interceptor.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface Interceptor {

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/StatementInterceptor.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public interface StatementInterceptor {
	Statement intercept(Statement base, FrameworkMethod method);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class TestWatchman implements StatementInterceptor {
	public Statement intercept(final Statement base,
			final FrameworkMethod method) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				try {
					base.evaluate();
					succeeded(method);
				} catch (Throwable t) {
					failed(t, method);
					throw t;
				}
			}
		};
	}

	public void succeeded(FrameworkMethod method) {
		return;
	}

	// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
	// FrameworkMethod too powerful?
	public void failed(Throwable e, FrameworkMethod method) {
		return;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/experimental/InterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental;

import static org.junit.Assert.*;
import static org.junit.matchers.JUnitMatchers.containsString;

import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	@RunWith(Interceptors.class)
	public static class ExampleTest {
		@Interceptor
		public StatementInterceptor example= new StatementInterceptor() {
			// TODO (Apr 28, 2009 10:31:18 PM): much better error if
			// @Interceptor
			// annotates a non-public field.
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAnEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	@RunWith(Interceptors.class)
	public static class MultipleInterceptorTest {
		private static class Incrementor implements StatementInterceptor {
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Interceptor
		public StatementInterceptor interceptor1= new Incrementor();

		@Interceptor
		public StatementInterceptor interceptor2= new Incrementor();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	@RunWith(Interceptors.class)
	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	@RunWith(Interceptors.class)
	public static class OnFailureTest {
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
			// FrameworkMethod too powerful?
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	@RunWith(Interceptors.class)
	public static class WatchmanTest {
		private static String watchedLog;

		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
import org.junit.tests.experimental.InterceptorTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	MaxComputerTest.class
=======
	MaxComputerTest.class,
	InterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/running/classes/SuiteTest.java;<<<<<<< MINE
=======
	}	
	
	public static class InheritsAll extends All {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/running/classes/SuiteTest.java;<<<<<<< MINE
=======
	@Test public void ensureInheritedTestIsRun() {
		JUnitCore core= new JUnitCore();
		Result result= core.run(InheritsAll.class);
		assertEquals(2, result.getRunCount());
		assertEquals(1, result.getFailureCount());
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_11f0abd_8b507d7/rev_11f0abd-8b507d7/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Transaction.java;<<<<<<< MINE
    public String setbit(String key, long offset, boolean value) {
=======
    public void setbit(String key, long offset, String value) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Transaction.java;<<<<<<< MINE
        return client.getStatusCodeReply() == "1";
    }

    public long setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
        return client.getIntegerReply();
    }

    public String getrange(String key, long startOffset, long endOffset) {
        client.getrange(key, startOffset, endOffset);
        return client.getBulkReply();
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_333a9bc_e7e4c4c/rev_333a9bc-e7e4c4c/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        while (pipelinedCommands > 0) {
=======
        while (pipelinedCommands > except) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.7-SNAPSHOT-20090428-1600";
=======
		return "4.7-SNAPSHOT-20090507-1339";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/ExactComparisonCriteria.java;<<<<<<< MINE
=======
package org.junit.internal;

import org.junit.Assert;

// TODO (Apr 29, 2009 4:17:49 PM): where should this live?
public class ExactComparisonCriteria extends ComparisonCriteria {
	@Override
	protected void assertElementsEqual(Object expected, Object actual) {
		Assert.assertEquals(expected, actual);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
=======
package org.junit.internal;

import java.lang.reflect.Array;

import org.junit.Assert;

public abstract class ComparisonCriteria {
	// TODO (Sep 8, 2008 4:36:12 PM): check structure
	
	/**
	 * Asserts that two arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown with the given message. If
	 * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,
	 * they are considered equal.
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expecteds
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            expected values.
	 * @param actuals
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            actual values
	 * @param criteria TODO
	 */
	public void arrayEquals(String message, Object expecteds,
			Object actuals) throws ArrayComparisonFailure {
		// TODO: DUP above
		// TODO (Sep 8, 2008 4:32:50 PM): Test that this fails sometimes
		// TODO (Sep 8, 2008 4:33:04 PM): Update javadoc
		
		if (expecteds == actuals)
			return;
		String header= message == null ? "" : message + ": ";
		
		int expectedsLength= Assert.assertArraysAreSameLength(expecteds, actuals,
				header);

		for (int i= 0; i < expectedsLength; i++) {
			Object expected= Array.get(expecteds, i);
			Object actual= Array.get(actuals, i);
			
			if (Assert.isArray(expected) && Assert.isArray(actual)) {
				try {
					arrayEquals(message, expected, actual);
				} catch (ArrayComparisonFailure e) {
					e.addDimension(i);
					throw e;
				}
			} else
				try {
					assertElementsEqual(expected, actual);
				} catch (AssertionError e) {
					throw new ArrayComparisonFailure(header, e, i);
				}
		}
	}

	protected abstract void assertElementsEqual(Object expected, Object actual);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
/**
 * 
 */
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
import java.lang.reflect.Array;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
public class InexactComparisonCriteria {
=======
public class InexactComparisonCriteria extends ComparisonCriteria {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
	// TODO (Sep 8, 2008 4:36:12 PM): check structure
	
	/**
	 * Asserts that two object arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown with the given message. If
	 * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,
	 * they are considered equal.
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expecteds
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            expected values.
	 * @param actuals
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            actual values
	 * @param criteria TODO
	 */
	public void internalArrayEquals(String message, Object expecteds,
			Object actuals) throws ArrayComparisonFailure {
		// TODO: DUP above
		// TODO (Sep 8, 2008 4:32:50 PM): Test that this fails sometimes
		// TODO (Sep 8, 2008 4:33:04 PM): Update javadoc
		
		if (expecteds == actuals)
			return;
		String header= message == null ? "" : message + ": ";
		
		int expectedsLength= Assert.assertArraysAreSameLength(expecteds, actuals,
				header);

		for (int i= 0; i < expectedsLength; i++) {
			Object expected= Array.get(expecteds, i);
			Object actual= Array.get(actuals, i);
			
			if (Assert.isArray(expected) && Assert.isArray(actual)) {
				try {
					internalArrayEquals(message, expected, actual);
				} catch (ArrayComparisonFailure e) {
					e.addDimension(i);
					throw e;
				}
			} else
				try {
					if (expected instanceof Double)
						Assert.assertEquals((Double)expected, (Double)actual, fDelta);
					else
						Assert.assertEquals((Float)expected, (Float)actual, fDelta);
				} catch (AssertionError e) {
					throw new ArrayComparisonFailure(header, e, i);
				}
		}
=======
	// TODO (Apr 29, 2009 4:43:46 PM): Look for missing JavaDoc
	@Override
	protected void assertElementsEqual(Object expected, Object actual) {
		if (expected instanceof Double)
			Assert.assertEquals((Double)expected, (Double)actual, fDelta);
		else
			Assert.assertEquals((Float)expected, (Float)actual, fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
=======
import org.junit.internal.ExactComparisonCriteria;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
		new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);
=======
		new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two double arrays are equal. If they are not, an
=======
	 * Asserts that two float arrays are equal. If they are not, an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with expected values.
=======
	 *            float array with expected values.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with actual values
=======
	 *            float array with actual values
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
		new InexactComparisonCriteria(delta).internalArrayEquals(message, expecteds, actuals);
=======
		new InexactComparisonCriteria(delta).arrayEquals(message, expecteds, actuals);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	// TODO (Mar 10, 2009 10:52:18 AM): fix javadoc
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two double arrays are equal. If they are not, an
=======
	 * Asserts that two float arrays are equal. If they are not, an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with expected values.
=======
	 *            float array with expected values.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *            double array with actual values
=======
	 *            float array with actual values
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/Assert.java;<<<<<<< MINE
		if (expecteds == actuals)
			return;
		String header= message == null ? "" : message + ": ";
		int expectedsLength= assertArraysAreSameLength(expecteds, actuals,
				header);

		for (int i= 0; i < expectedsLength; i++) {
			Object expected= Array.get(expecteds, i);
			Object actual= Array.get(actuals, i);
			// TODO (Nov 6, 2008 12:58:55 PM): Is this a DUP?
			if (isArray(expected) && isArray(actual)) {
				try {
					internalArrayEquals(message, expected, actual);
				} catch (ArrayComparisonFailure e) {
					e.addDimension(i);
					throw e;
				}
			} else
				try {
					assertEquals(expected, actual);
				} catch (AssertionError e) {
					throw new ArrayComparisonFailure(header, e, i);
				}
		}
	}
	
=======
		new ExactComparisonCriteria().arrayEquals(message, expecteds, actuals);
	}	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import java.util.concurrent.TimeUnit;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}

	private static <T> Runner parallelize(ParentRunner<T> runner)
			throws InitializationError {
		return new ParallelParentRunner<T>(runner);
	}

	private static class ParallelParentRunner<T> extends ParentRunner<T> {
		private final ParentRunner<T> fDelegate;

		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

		private final ExecutorService fService= Executors.newCachedThreadPool();

		public ParallelParentRunner(ParentRunner<T> delegate)
				throws InitializationError {
			super(delegate.getTestClass().getJavaClass());
			fDelegate= delegate;
=======
	
	// TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE

=======
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public Description describeChild(T child) {
			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
			return fDelegate.internalDescribeChild(child);
=======
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fCollator.process(callable);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public List<T> getChildren() {
			return fDelegate.internalGetChildren();
=======
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fCollator.results)
				try {
					each.get();
				} catch (Exception e) {
					e.printStackTrace();
				} 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
=======
	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
			}));
=======
			};
			fCollator.process(callable);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
					each.get(2000, TimeUnit.MILLISECONDS); // TODO(parallel) what should this really be?
=======
					each.get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		@SuppressWarnings("unused")
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
	
	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows delegation without breaking subclasses
	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public List<T> internalGetChildren() {
		return getChildren();
	}

	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public Description internalDescribeChild(T child) {
		return describeChild(child);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
	/**
	 * Interim interface during 4.7 development.  _Very_ likely to go away.
	 */
	public void internalRunChild(T child, RunNotifier notifier) {
		runChild(child, notifier);
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	protected final TestClass getTestClass() {
=======
	public final TestClass getTestClass() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runner/Computer.java;<<<<<<< MINE
	public Suite getSuite(final RunnerBuilder builder,
=======
	public Runner getSuite(final RunnerBuilder builder,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runner/Request.java;<<<<<<< MINE
import org.junit.runners.Suite;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/runner/Request.java;<<<<<<< MINE
			Suite suite= computer.getSuite(builder, classes);
=======
			Runner suite= computer.getSuite(builder, classes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
	protected Statement withAfters(FrameworkMethod method, Object target,
=======
	protected Statement withBefores(FrameworkMethod method, Object target,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
		// TODO Auto-generated method stub
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
		return super.withAfters(method, target, intercept(statement, target, method));
=======
		return super.withBefores(method, target, intercept(statement, target, method));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Timeout.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.internal.runners.statements.FailOnTimeout;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class Timeout implements StatementInterceptor {
	private final int fMillis;

	public Timeout(int millis) {
		fMillis= millis;
	}

	public Statement intercept(Statement base, FrameworkMethod method) {
		return new FailOnTimeout(base, fMillis);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
=======
				starting(method);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
=======
				} finally {
					finished(method);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE

	public void starting(FrameworkMethod method) throws Exception {
	}

	public void finished(FrameworkMethod method) {
	}
=======

	public void starting(FrameworkMethod method) {
	}

	public void finished(FrameworkMethod method) {
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
=======
import org.junit.runner.Description;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
=======
import org.junit.runners.ParentRunner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.model.FrameworkMethod;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	
	// TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
=======

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}

	private static <T> Runner parallelize(ParentRunner<T> runner)
			throws InitializationError {
		return new ParallelParentRunner<T>(runner);
	}

	private static class ParallelParentRunner<T> extends ParentRunner<T> {
		private final ParentRunner<T> fDelegate;

		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

		private final ExecutorService fService= Executors.newCachedThreadPool();

		public ParallelParentRunner(ParentRunner<T> delegate)
				throws InitializationError {
			super(delegate.getTestClass().getJavaClass());
			fDelegate= delegate;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fCollator.process(callable);
=======
		public Description describeChild(T child) {
			// TODO (May 4, 2009 4:34:05 PM): How to do this for real?
			return fDelegate.internalDescribeChild(child);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		
		protected void superRunChild(Runner runner, RunNotifier notifier) {
			super.runChild(runner, notifier);
		}
		
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fCollator.results)
				try {
					each.get();
				} catch (Exception e) {
					e.printStackTrace();
				} 
=======
		public List<T> getChildren() {
			return fDelegate.internalGetChildren();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		protected void runChild(final FrameworkMethod method, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
=======
		public void runChild(final T child, final RunNotifier notifier) {
			fResults.add(fService.submit(new Callable<Object>() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
					superRunChild(method, notifier);
=======
					fDelegate.internalRunChild(child, notifier);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
			};
			fCollator.process(callable);
=======
			}));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		
		protected void superRunChild(FrameworkMethod method, RunNotifier notifier) {
			super.runChild(method, notifier);
		}
		
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
			for (Future<Object> each : fCollator.results)
=======
			for (Future<Object> each : fResults)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
				} 
=======
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	public Suite getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes) throws InitializationError {
		return fClasses
			? new ParallelSuite(builder, classes)
			: super.getSuite(builder, classes);
=======
	public Runner getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes)
			throws InitializationError {
		Suite suite= (Suite) super.getSuite(builder, classes);
		return fClasses ? parallelize(suite) : suite;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		return fMethods
			? new ParallelRunner(testClass)
			: super.getRunner(builder, testClass);
	}

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}
	
	private static class ParallelCollator {
		private final List<Future<Object>> results = new ArrayList<Future<Object>>();
		private final ExecutorService service = Executors.newCachedThreadPool();

		public void process(Callable<Object> callable) {
			this.results.add(service.submit(callable));
		}
=======
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/InterceptorTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.is;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/InterceptorTest.java;<<<<<<< MINE
=======
import org.junit.After;
import org.junit.Before;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/InterceptorTest.java;<<<<<<< MINE
=======

	@RunWith(Interceptors.class)
	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;<<<<<<< MINE
		protected void runChild(FrameworkMethod method, RunNotifier notifier) {
=======
		public void runChild(FrameworkMethod method, RunNotifier notifier) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;<<<<<<< MINE

	// Description succeed= Description.createTestDescription(TwoTests.class,
	// "succeed");
	// Description dontSucceed= Description.createTestDescription(
	// TwoTests.class, "dontSucceed");
	// assertTrue(things.contains(succeed));
	// assertTrue(things.contains(dontSucceed));
	// assertEquals(2, things.size());
	// }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.containsString;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;

public class TimeoutInterceptorTest {
	@RunWith(Interceptors.class)
	public static class HasGlobalTimeout {
		public static String log;
		
		@Interceptor public StatementInterceptor globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
import org.junit.tests.experimental.TimeoutInterceptorTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	InterceptorTest.class
=======
	InterceptorTest.class,
	TimeoutInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
/**
 * 
 */
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
	public void starting(FrameworkMethod method) {
=======
	public void starting(FrameworkMethod method) throws Exception {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/test/java/org/junit/tests/experimental/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
import org.junit.Ignore;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_dafc0ed_79b869e/rev_dafc0ed-79b869e/src/test/java/org/junit/tests/experimental/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
	// TODO (May 6, 2009 11:30:19 AM): Make a separate build that makes gump happy
	@Ignore("For gump, for now")
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private RunnerInterceptor fRunnerInterceptor= new RunnerInterceptor() {	
		public void runChild(Runnable childStatement) {
			childStatement.run();
		}
	
		public void finished() {
			// do nothing
		}
	};

=======
	private Decorator fDecorator= new Decorator() {
		public void runAll(SafeStatement statement) {
			statement.execute();
		}

		public void runChild(SafeStatement statement) {
			statement.execute();
		}
	};

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		
=======

	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows
	// delegation without breaking subclasses
	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public List<T> internalGetChildren() {
		return getChildren();
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public Description internalDescribeChild(T child) {
		return describeChild(child);
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public void internalRunChild(T child, RunNotifier notifier) {
		runChild(child, notifier);
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

	public void setRunnerInterceptor(RunnerInterceptor runnerInterceptor) {
		this.fRunnerInterceptor = runnerInterceptor;
	}
=======

	// TODO (May 11, 2009 2:53:54 PM): complex
	public void installDecorator(Decorator decorator) {
		this.fDecorator= decorator;
	}

	// TODO (May 11, 2009 4:19:18 PM): move?
	public boolean isSuite() {
		return false;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runner.Description;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;
import org.junit.runners.model.RunnerInterceptor;
=======
import org.junit.tests.SafeStatement;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	private static <T> Runner parallelize(ParentRunner<T> runner) {
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runChild(final Runnable childStatement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						childStatement.run();
						return null;
					}
				}));
			}

			public void finished() {
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
		});
		return runner;
	}

=======
	private static void parallelize(Runner runner) {
		((ParentRunner<?>) runner).installDecorator(new ParentRunner.Decorator() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runAll(SafeStatement statement) {
				statement.execute();
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}

			}

			public void runChild(final SafeStatement statement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						statement.execute();
						return null;
					}
				}));
			}
		});
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
=======
	private boolean shouldParallelize(Runner runner) {
		if (runner instanceof ParentRunner) {
			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
			if (fClasses && parentRunner.isSuite())
				return true;
			if (fMethods && !parentRunner.isSuite())
				return true;
		}
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	ParallelMethodTest.class
=======
	ParallelMethodTest.class,
	ParentRunnerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
package org.junit.tests;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerInterceptor;

public class ParentRunnerTest {
	public static String log= "";

	public static class FruitTest {
		@Test
		public void apple() {
			log+= "apple ";
		}

		@Test
		public void banana() {
			log+= "banana ";
		}
	}

	@Test
	public void useChildHarvester() throws InitializationError {
		log= "";
		ParentRunner<?> runner= new BlockJUnit4ClassRunner(FruitTest.class);
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			public void runChild(Runnable childStatement) {
				log+= "before ";
				childStatement.run();
				log+= "after ";
			}

			public void finished() {
				log+= "afterAll ";
			}
		});

		runner.run(new RunNotifier());
		assertEquals("before apple after before banana after afterAll ", log);
	}
}=======
package org.junit.tests;

import static org.junit.Assert.assertEquals;

import java.util.Comparator;

import org.junit.Test;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Sorter;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.FrameworkMethod;

// TODO (May 11, 2009 2:42:38 PM): move package

public class ParentRunnerTest {
	private static StringBuffer log= new StringBuffer();

	public static class FruitTests {
		@Test
		public void apple() {
			log.append("apple ");
		}

		@Test
		public void banana() {
			log.append("banana ");
		}

		@Test
		public void pear() {
			log.append("pear ");
		}
	}

	@Test
	public void installDecorator() throws Throwable {
		log.setLength(0);
		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
				true).runnerForClass(FruitTests.class);
		// TODO (May 11, 2009 2:58:11 PM): DUP?
		runner.sort(new Sorter(new Comparator<Description>() {
			public int compare(Description o1, Description o2) {
				return o1.toString().compareTo(o2.toString());
			}
		}));
		runner.installDecorator(new ParentRunner.Decorator() {
			public void runChild(SafeStatement statement) {
				log.append("before ");
				statement.execute();
				log.append("after ");
			}

			public void runAll(SafeStatement statement) {
				log.append("beforeAll ");
				statement.execute();
				log.append("afterAll ");
			}
		});

		runner.run(new RunNotifier());
		assertEquals(
				"beforeAll before apple after before banana after before pear after afterAll ",
				log.toString());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private RunnerInterceptor fRunnerInterceptor= new RunnerInterceptor() {	
		public void runChild(Runnable childStatement) {
			childStatement.run();
		}
	
		public void finished() {
			// do nothing
		}
	};

=======
	private Decorator fDecorator= new Decorator() {
		public void runAll(SafeStatement statement) {
			statement.execute();
		}

		public void runChild(SafeStatement statement) {
			statement.execute();
		}
	};

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		
=======

	// TODO (May 4, 2009 4:34:28 PM): This can't be right, but it allows
	// delegation without breaking subclasses
	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public List<T> internalGetChildren() {
		return getChildren();
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public Description internalDescribeChild(T child) {
		return describeChild(child);
	}

	/**
	 * Interim interface during 4.7 development. _Very_ likely to go away.
	 */
	public void internalRunChild(T child, RunNotifier notifier) {
		runChild(child, notifier);
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

	public void setRunnerInterceptor(RunnerInterceptor runnerInterceptor) {
		this.fRunnerInterceptor = runnerInterceptor;
	}
=======

	// TODO (May 11, 2009 2:53:54 PM): complex
	public void installDecorator(Decorator decorator) {
		this.fDecorator= decorator;
	}

	// TODO (May 11, 2009 4:19:18 PM): move?
	public boolean isSuite() {
		return false;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runner.Description;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.Suite;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;
import org.junit.runners.model.RunnerInterceptor;
=======
import org.junit.tests.SafeStatement;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	private static <T> Runner parallelize(ParentRunner<T> runner) {
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runChild(final Runnable childStatement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						childStatement.run();
						return null;
					}
				}));
			}

			public void finished() {
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
		});
		return runner;
	}

=======
	private static void parallelize(Runner runner) {
		((ParentRunner<?>) runner).installDecorator(new ParentRunner.Decorator() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runAll(SafeStatement statement) {
				statement.execute();
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}

			}

			public void runChild(final SafeStatement statement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						statement.execute();
						return null;
					}
				}));
			}
		});
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
		return fMethods ? parallelize(runner) : runner;
=======
	private boolean shouldParallelize(Runner runner) {
		if (runner instanceof ParentRunner) {
			ParentRunner<?> parentRunner= (ParentRunner<?>) runner;
			if (fClasses && parentRunner.isSuite())
				return true;
			if (fMethods && !parentRunner.isSuite())
				return true;
		}
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
import org.junit.tests.experimental.parallel.ParallelClassTest;
import org.junit.tests.experimental.parallel.ParallelMethodTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	TimeoutInterceptorTest.class
=======
	TimeoutInterceptorTest.class,
	ParallelClassTest.class,
	ParallelMethodTest.class,
	ParentRunnerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
package org.junit.tests;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerInterceptor;

public class ParentRunnerTest {
	public static String log= "";

	public static class FruitTest {
		@Test
		public void apple() {
			log+= "apple ";
		}

		@Test
		public void banana() {
			log+= "banana ";
		}
	}

	@Test
	public void useChildHarvester() throws InitializationError {
		log= "";
		ParentRunner<?> runner= new BlockJUnit4ClassRunner(FruitTest.class);
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			public void runChild(Runnable childStatement) {
				log+= "before ";
				childStatement.run();
				log+= "after ";
			}

			public void finished() {
				log+= "afterAll ";
			}
		});

		runner.run(new RunNotifier());
		assertEquals("before apple after before banana after afterAll ", log);
	}
}=======
package org.junit.tests;

import static org.junit.Assert.assertEquals;

import java.util.Comparator;

import org.junit.Test;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Sorter;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.FrameworkMethod;

// TODO (May 11, 2009 2:42:38 PM): move package

public class ParentRunnerTest {
	private static StringBuffer log= new StringBuffer();

	public static class FruitTests {
		@Test
		public void apple() {
			log.append("apple ");
		}

		@Test
		public void banana() {
			log.append("banana ");
		}

		@Test
		public void pear() {
			log.append("pear ");
		}
	}

	@Test
	public void installDecorator() throws Throwable {
		log.setLength(0);
		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
				true).runnerForClass(FruitTests.class);
		// TODO (May 11, 2009 2:58:11 PM): DUP?
		runner.sort(new Sorter(new Comparator<Description>() {
			public int compare(Description o1, Description o2) {
				return o1.toString().compareTo(o2.toString());
			}
		}));
		runner.installDecorator(new ParentRunner.Decorator() {
			public void runChild(SafeStatement statement) {
				log.append("before ");
				statement.execute();
				log.append("after ");
			}

			public void runAll(SafeStatement statement) {
				log.append("beforeAll ");
				statement.execute();
				log.append("afterAll ");
			}
		});

		runner.run(new RunNotifier());
		assertEquals(
				"beforeAll before apple after before banana after before pear after afterAll ",
				log.toString());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8aa25eb_58aa95c/rev_8aa25eb-58aa95c/src/main/java/redis/clients/jedis/Pipeline.java;<<<<<<< MINE
    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
=======
    //--
    public void zrevrangeByScore(String key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(byte[] key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, String max, String min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScore(byte[] key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(byte[] key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(byte[] key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrangeWithScores(String key, int start, int end) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8aa25eb_58aa95c/rev_8aa25eb-58aa95c/src/main/java/redis/clients/jedis/PipelineBlock.java;<<<<<<< MINE
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

import java.util.Map;

public abstract class PipelineBlock implements Commands {
    private Client client;

    public void setClient(Client client) {
        this.client = client;
    }

    public void append(String key, String value) {
        client.append(key, value);
    }

    public void blpop(String[] args) {
        client.blpop(args);
    }

    public void brpop(String[] args) {
        client.brpop(args);
    }

    public void decr(String key) {
        client.decr(key);
    }

    public void decrBy(String key, long integer) {
        client.decrBy(key, integer);
    }

    public void del(String... keys) {
        client.del(keys);
    }

    public void echo(String string) {
        client.echo(string);
    }

    public void exists(String key) {
        client.exists(key);
    }

    public void expire(String key, int seconds) {
        client.expire(key, seconds);
    }

    public void expireAt(String key, long unixTime) {
        client.expireAt(key, unixTime);
    }

    public void get(String key) {
        client.get(key);
    }

    public void getbit(String key, long offset) {
        client.getbit(key, offset);
    }

    public void getrange(String key, long startOffset, long endOffset) {
        client.getrange(key, startOffset, endOffset);
    }

    public void getSet(String key, String value) {
        client.getSet(key, value);
    }

    public void hdel(String key, String field) {
        client.hdel(key, field);
    }

    public void hexists(String key, String field) {
        client.hexists(key, field);
    }

    public void hget(String key, String field) {
        client.hget(key, field);
    }

    public void hgetAll(String key) {
        client.hgetAll(key);
    }

    public void hincrBy(String key, String field, long value) {
        client.hincrBy(key, field, value);
    }

    public void hkeys(String key) {
        client.hkeys(key);
    }

    public void hlen(String key) {
        client.hlen(key);
    }

    public void hmget(String key, String... fields) {
        client.hmget(key, fields);
    }

    public void hmset(String key, Map<String, String> hash) {
        client.hmset(key, hash);
    }

    public void hset(String key, String field, String value) {
        client.hset(key, field, value);
    }

    public void hsetnx(String key, String field, String value) {
        client.hsetnx(key, field, value);
    }

    public void hvals(String key) {
        client.hvals(key);
    }

    public void incr(String key) {
        client.incr(key);
    }

    public void incrBy(String key, long integer) {
        client.incrBy(key, integer);
    }

    public void keys(String pattern) {
        client.keys(pattern);
    }

    public void lindex(String key, int index) {
        client.lindex(key, index);
    }

    public void linsert(String key, LIST_POSITION where, String pivot,
            String value) {
        client.linsert(key, where, pivot, value);
    }

    public void llen(String key) {
        client.llen(key);
    }

    public void lpop(String key) {
        client.lpop(key);
    }

    public void lpush(String key, String string) {
        client.lpush(key, string);
    }

    public void lpushx(String key, String string) {
        client.lpushx(key, string);
    }

    public void lrange(String key, int start, int end) {
        client.lrange(key, start, end);
    }

    public void lrem(String key, int count, String value) {
        client.lrem(key, count, value);
    }

    public void lset(String key, int index, String value) {
        client.lset(key, index, value);
    }

    public void ltrim(String key, int start, int end) {
        client.ltrim(key, start, end);
    }

    public void mget(String... keys) {
        client.mget(keys);
    }

    public void move(String key, int dbIndex) {
        client.move(key, dbIndex);
    }

    public void mset(String... keysvalues) {
        client.mset(keysvalues);
    }

    public void msetnx(String... keysvalues) {
        client.msetnx(keysvalues);
    }

    public void persist(String key) {
        client.persist(key);
    }

    public void rename(String oldkey, String newkey) {
        client.rename(oldkey, newkey);
    }

    public void renamenx(String oldkey, String newkey) {
        client.renamenx(oldkey, newkey);
    }

    public void rpop(String key) {
        client.rpop(key);
    }

    public void rpoplpush(String srckey, String dstkey) {
        client.rpoplpush(srckey, dstkey);
    }

    public void rpush(String key, String string) {
        client.rpush(key, string);
    }

    public void rpushx(String key, String string) {
        client.rpushx(key, string);
    }

    public void sadd(String key, String member) {
        client.sadd(key, member);
    }

    public void scard(String key) {
        client.scard(key);
    }

    public void sdiff(String... keys) {
        client.sdiff(keys);
    }

    public void sdiffstore(String dstkey, String... keys) {
        client.sdiffstore(dstkey, keys);
    }

    public void set(String key, String value) {
        client.set(key, value);
    }

    public void setbit(String key, long offset, boolean value) {
        client.setbit(key, offset, value);
    }

    public void setex(String key, int seconds, String value) {
        client.setex(key, seconds, value);
    }

    public void setnx(String key, String value) {
        client.setnx(key, value);
    }

    public void setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
    }

    public void sinter(String... keys) {
        client.sinter(keys);
    }

    public void sinterstore(String dstkey, String... keys) {
        client.sinterstore(dstkey, keys);
    }

    public void sismember(String key, String member) {
        client.sismember(key, member);
    }

    public void smembers(String key) {
        client.smembers(key);
    }

    public void smove(String srckey, String dstkey, String member) {
        client.smove(srckey, dstkey, member);
    }

    public void sort(String key) {
        client.sort(key);
    }

    public void sort(String key, SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
    }

    public void sort(String key, SortingParams sortingParameters, String dstkey) {
        client.sort(key, sortingParameters, dstkey);
    }

    public void sort(String key, String dstkey) {
        client.sort(key, dstkey);
    }

    public void spop(String key) {
        client.spop(key);
    }

    public void srandmember(String key) {
        client.srandmember(key);
    }

    public void srem(String key, String member) {
        client.srem(key, member);
    }

    public void strlen(String key) {
        client.strlen(key);
    }

    public void substr(String key, int start, int end) {
        client.substr(key, start, end);
    }

    public void sunion(String... keys) {
        client.sunion(keys);
    }

    public void sunionstore(String dstkey, String... keys) {
        client.sunionstore(dstkey, keys);
    }

    public void ttl(String key) {
        client.ttl(key);
    }

    public void type(String key) {
        client.type(key);
    }

    public void watch(String... keys) {
        client.watch(keys);
    }

    public void zadd(String key, double score, String member) {
        client.zadd(key, score, member);
    }

    public void zcard(String key) {
        client.zcard(key);
    }

    public void zcount(String key, double min, double max) {
        client.zcount(key, min, max);
    }

    public void zincrby(String key, double score, String member) {
        client.zincrby(key, score, member);
    }

    public void zinterstore(String dstkey, String... sets) {
        client.zinterstore(dstkey, sets);
    }

    public void zinterstore(String dstkey, ZParams params, String... sets) {
        client.zinterstore(dstkey, params, sets);
    }

    public void zrange(String key, int start, int end) {
        client.zrange(key, start, end);
    }

    public void zrangeByScore(String key, double min, double max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, String min, String max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, double min, double max, int offset,
            int count) {
        client.zrangeByScore(key, min, max, offset, count);
    }

    public void zrangeByScoreWithScores(String key, double min, double max) {
        client.zrangeByScoreWithScores(key, min, max);
    }

    public void zrangeByScoreWithScores(String key, double min, double max,
            int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
    }

    public void zrevrangeByScore(String key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, String max, String min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrangeWithScores(String key, int start, int end) {
        client.zrangeWithScores(key, start, end);
    }

    public void zrank(String key, String member) {
        client.zrank(key, member);
    }

    public void zrem(String key, String member) {
        client.zrem(key, member);
    }

    public void zremrangeByRank(String key, int start, int end) {
        client.zremrangeByRank(key, start, end);
    }

    public void zremrangeByScore(String key, double start, double end) {
        client.zremrangeByScore(key, start, end);
    }

    public void zrevrange(String key, int start, int end) {
        client.zrevrange(key, start, end);
    }

    public void zrevrangeWithScores(String key, int start, int end) {
        client.zrevrangeWithScores(key, start, end);
    }

    public void zrevrank(String key, String member) {
        client.zrevrank(key, member);
    }

    public void zscore(String key, String member) {
        client.zscore(key, member);
    }

    public void zunionstore(String dstkey, String... sets) {
        client.zunionstore(dstkey, sets);
    }

    public void zunionstore(String dstkey, ZParams params, String... sets) {
        client.zunionstore(dstkey, params, sets);
    }

    public void bgrewriteaof() {
        client.bgrewriteaof();
    }

    public void bgsave() {
        client.bgsave();
    }

    public void configGet(String pattern) {
        client.configGet(pattern);
    }

    public void configSet(String parameter, String value) {
        client.configSet(parameter, value);
    }

    public void brpoplpush(String source, String destination, int timeout) {
        client.brpoplpush(source, destination, timeout);
    }

    public void configResetStat() {
        client.configResetStat();
    }

    public void save() {
        client.save();
    }

    public void lastsave() {
        client.lastsave();
    }

    public void discard() {
        client.discard();
    }

    public void exec() {
        client.exec();
    }

    public void multi() {
        client.multi();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		statement= new RunBefores(statement, befores, null);
		return statement;
=======
		return befores.isEmpty() ? statement :
			new RunBefores(statement, befores, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		statement= new RunAfters(statement, afters, null);
		return statement;
=======
		return afters.isEmpty() ? statement : 
			new RunAfters(statement, afters, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		return new RunBefores(statement, befores, target);
=======
		return befores.isEmpty() ? statement : 
			new RunBefores(statement, befores, target);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
		// TODO (May 11, 2009 11:28:21 PM):
		// withBefores/withAfters/withBeforeClass/withAfterClass is a lot of
		// duplication.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		return new RunAfters(statement, afters, target);
=======
		return afters.isEmpty() ? statement :
			new RunAfters(statement, afters, target);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/experimental/interceptor/TestName.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;

public class TestName extends TestWatchman {
	private String fName;

	@Override
	public void starting(FrameworkMethod method) throws Exception {
		fName = method.getName();
	}
	
	public String getMethodName() {
		return fName;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.matchers.JUnitMatchers.containsString;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	@RunWith(Interceptors.class)
	public static class ExampleTest {
		@Interceptor
		public StatementInterceptor example= new StatementInterceptor() {
			// TODO (Apr 28, 2009 10:31:18 PM): much better error if
			// @Interceptor
			// annotates a non-public field.
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAndEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	@RunWith(Interceptors.class)
	public static class MultipleInterceptorTest {
		private static class Incrementor implements StatementInterceptor {
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Interceptor
		public StatementInterceptor interceptor1= new Incrementor();

		@Interceptor
		public StatementInterceptor interceptor2= new Incrementor();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	@RunWith(Interceptors.class)
	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	@RunWith(Interceptors.class)
	public static class OnFailureTest {
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
			// FrameworkMethod too powerful?
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	@RunWith(Interceptors.class)
	public static class WatchmanTest {
		private static String watchedLog;

		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}

	@RunWith(Interceptors.class)
	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.containsString;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;

public class TimeoutInterceptorTest {
	@RunWith(Interceptors.class)
	public static class HasGlobalTimeout {
		public static String log;
		
		@Interceptor public StatementInterceptor globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	// TODO (May 6, 2009 11:30:19 AM): Make a separate build that makes gump happy
	@Ignore("For gump, for now")
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.TestName;
import org.junit.runner.RunWith;

@RunWith(Interceptors.class)
public class NameInterceptorTest {
	@Interceptor public TestName name = new TestName();
	
	@Test public void testA() {
		assertEquals("testA", name.getMethodName());
	}
	
	@Test public void testB() {
		assertEquals("testB", name.getMethodName());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
import org.junit.tests.experimental.InterceptorTest;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
import org.junit.tests.experimental.TimeoutInterceptorTest;
=======
import org.junit.tests.experimental.interceptor.InterceptorTest;
import org.junit.tests.experimental.interceptor.NameInterceptorTest;
import org.junit.tests.experimental.interceptor.TimeoutInterceptorTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	ParentRunnerTest.class
=======
	ParentRunnerTest.class,
	NameInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMember.java;<<<<<<< MINE
=======
package org.junit.runners.model;

import java.lang.annotation.Annotation;

public interface FrameworkMember<T extends FrameworkMember<T>> {
	/**
	 * Returns the annotations on this method
	 */
	public Annotation[] getAnnotations();

	public boolean isShadowedBy(T otherMember);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
public class FrameworkMethod {
	private final Method fMethod;
=======
public class FrameworkMethod implements FrameworkMember<FrameworkMethod> {
	final Method fMethod;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
	boolean isShadowedBy(List<FrameworkMethod> results) {
		for (FrameworkMethod each : results)
			if (isShadowedBy(each))
				return true;
		return false;
	}

	private boolean isShadowedBy(FrameworkMethod each) {
		if (!each.getName().equals(getName()))
=======
	public boolean isShadowedBy(FrameworkMethod other) {
		if (!other.getName().equals(getName()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
		if (each.getParameterTypes().length != getParameterTypes().length)
=======
		if (other.getParameterTypes().length != getParameterTypes().length)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
		for (int i= 0; i < each.getParameterTypes().length; i++)
			if (!each.getParameterTypes()[i].equals(getParameterTypes()[i]))
=======
		for (int i= 0; i < other.getParameterTypes().length; i++)
			if (!other.getParameterTypes()[i].equals(getParameterTypes()[i]))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
=======
import java.lang.reflect.Field;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
=======
	private Map<Class<?>, List<FrameworkField>> fFieldsForAnnotations= new HashMap<Class<?>, List<FrameworkField>>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		for (Class<?> eachClass : getSuperClasses(fClass))
=======
		for (Class<?> eachClass : getSuperClasses(fClass)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
				addToAnnotationLists(new FrameworkMethod(eachMethod));
=======
				addToAnnotationLists(new FrameworkMethod(eachMethod), fMethodsForAnnotations);
			for (Field eachField : eachClass.getDeclaredFields())
				addToAnnotationLists(new FrameworkField(eachField), fFieldsForAnnotations);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	private void addToAnnotationLists(FrameworkMethod testMethod) {
		for (Annotation each : computeAnnotations(testMethod))
			addToAnnotationList(each.annotationType(), testMethod);
	}

	/**
	 * Returns all of the annotations on {@code testMethod}
	 */
	protected Annotation[] computeAnnotations(FrameworkMethod testMethod) {
		return testMethod.getAnnotations();
=======
	// TODO (May 25, 2009 9:46:48 PM): move to FrameworkMember
	private <T extends FrameworkMember<T>> void addToAnnotationLists(T member, Map<Class<?>, List<T>> map) {
		for (Annotation each : member.getAnnotations()) {
			Class<? extends Annotation> type= each.annotationType();
			ensureKey(map, type);
			List<T> members= map.get(type);
			if (isShadowedBy(member, members))
				return;
			if (runsTopToBottom(type))
				members.add(0, member);
			else
				members.add(member);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	private void addToAnnotationList(Class<? extends Annotation> annotation,
			FrameworkMethod testMethod) {
		List<FrameworkMethod> methods= getAnnotatedMethods(annotation);
		if (testMethod.isShadowedBy(methods))
			return;
		if (runsTopToBottom(annotation))
			methods.add(0, testMethod);
		else
			methods.add(testMethod);
=======
	private <T extends FrameworkMember<T>> boolean isShadowedBy(T member, List<T> members) {
		for (T each : members)
			if (member.isShadowedBy(each))
				return true;
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	private void ensureKey(Class<? extends Annotation> annotation) {
		if (!fMethodsForAnnotations.containsKey(annotation))
			fMethodsForAnnotations.put(annotation,
					new ArrayList<FrameworkMethod>());
=======
	private <T> void ensureKey(Map<Class<?>, List<T>> map, Class<?> annotation) {
		if (!map.containsKey(annotation))
			map.put(annotation, new ArrayList<T>());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		ensureKey(annotationClass);
=======
		// TODO (May 25, 2009 10:02:46 PM): DUP
		ensureKey(fMethodsForAnnotations, annotationClass);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
=======
	public List<FrameworkField> getAnnotatedFields(Class<? extends Annotation> annotationClass) {
		// TODO (May 25, 2009 10:02:46 PM): DUP
		ensureKey(fFieldsForAnnotations, annotationClass);
		return fFieldsForAnnotations.get(annotationClass);
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
=======
package org.junit.runners.model;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;

public class FrameworkField implements FrameworkMember<FrameworkField> {
	private final Field fField;

	public FrameworkField(Field field) {
		fField= field;
	}

	public Annotation[] getAnnotations() {
		return fField.getAnnotations();
	}

	// TODO (May 25, 2009 9:45:43 PM): faking it
	public boolean isShadowedBy(FrameworkField otherMember) {
		// TODO Auto-generated method stub
		return false;
	}

	public Field getField() {
		return fField;
	}

	public Object get(Object target) throws IllegalArgumentException, IllegalAccessException {
		return fField.get(target);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.StatementInterceptor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
import org.junit.runners.model.FrameworkField;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
		validateFields(errors);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	
	private void validateConstructor(List<Throwable> errors) {
=======

	protected void validateConstructor(List<Throwable> errors) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
		// TODO (May 26, 2009 10:48:26 PM): don't override this
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	
	protected void validateFields(List<Throwable> errors) {
		for (FrameworkField each : interceptorFields())
			validateInterceptorField(each.getField(), errors);
	}

	private void validateInterceptorField(Field field, List<Throwable> errors) {
		if (!StatementInterceptor.class.isAssignableFrom(field.getType()))
			errors.add(new Exception("Field " + field.getName()
					+ " must implement StatementInterceptor"));
		if (!Modifier.isPublic(field.getModifiers()))
			errors.add(new Exception("Field " + field.getName()
					+ " must be public"));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
		statement= withInterceptors(method, test, statement);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	
	protected Statement withInterceptors(FrameworkMethod method, Object test,
			Statement statement) {
		// TODO (May 26, 2009 11:16:13 PM): outsource to a class?
		Statement result= statement;
		for (FrameworkField each : interceptorFields())
			try {
				StatementInterceptor interceptor= (StatementInterceptor) each
						.get(test);
				result= interceptor.intercept(result, method);
			} catch (IllegalAccessException e) {
				throw new RuntimeException(
						"How did getFields return a field we couldn't access?");
			}
		return result;
	}

	private List<FrameworkField> interceptorFields() {
		return getTestClass().getAnnotatedFields(Interceptor.class);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
import java.lang.reflect.Field;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
import org.junit.runners.model.FrameworkMethod;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
import org.junit.runners.model.Statement;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE

	@Override
	protected Statement withBefores(FrameworkMethod method, Object target,
			Statement statement) {
		// TODO (Apr 28, 2009 10:55:21 PM): parameter clump?
		return super.withBefores(method, target, intercept(statement, target, method));
	}

	private Statement intercept(Statement statement, Object target, FrameworkMethod method) {
		Class<?> javaClass= getTestClass().getJavaClass();
		Field[] fields= javaClass.getFields();
		Statement result= statement;
		for (Field each : fields) {
			if (each.getAnnotation(Interceptor.class) != null) {
				try {
					StatementInterceptor interceptor= (StatementInterceptor) each
							.get(target);
					result= interceptor.intercept(result, method);
				} catch (IllegalAccessException e) {
					throw new RuntimeException(
							"How did getFields return a field we couldn't access?");
				}
			}
		}
		return result;
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestName.java;<<<<<<< MINE
	public void starting(FrameworkMethod method) throws Exception {
=======
	public void starting(FrameworkMethod method) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class ExpectedException implements StatementInterceptor {
	private Class<? extends Throwable> fType;
	private String fMessage;

	public Statement intercept(Statement base, FrameworkMethod method) {
		return new ExpectedExceptionStatement(base);
	}

	public void expect(Class<? extends Throwable> type) {
		fType= type;
	}

	public void expectMessage(String message) {
		fMessage= message;
	}

	private boolean noExpectedException() {
		return fType == null && fMessage == null;
	}
	
	public class ExpectedExceptionStatement extends Statement {

		private final Statement fNext;

		public ExpectedExceptionStatement(Statement base) {
			fNext= base;
		}

		@Override
		public void evaluate() throws Throwable {
			boolean complete = false;
			try {
				fNext.evaluate();
				complete = true;
			} catch (Throwable e) {
				if (noExpectedException())
					throw e;
				// TODO (May 26, 2009 11:46:31 PM): isInstance?
				if (fType != null && !fType.isAssignableFrom(e.getClass())) {
					String message= "Unexpected exception, expected<"
								+ fType.getName() + "> but was<"
								+ e.getClass().getName() + ">";
					throw new Exception(message, e);
				}
				if (fMessage != null && !getMessage(e).contains(fMessage)) {
					String message= "Unexpected exception message, expected<"
								+ fMessage + "> but was<"
								+ getMessage(e) + ">";
					throw new Exception(message, e);
				}
			}
			// TODO (May 26, 2009 11:54:22 PM): do I need complete
			if (complete && !noExpectedException()) {
				if (fType != null)
					throw new AssertionError("Expected exception: "
							+ fType.getName());
				else if (fMessage != null)
					throw new AssertionError("Expected exception with message: "
							+ fMessage);
				else
					throw new RuntimeException("How'd we get here?");
			}
		}

		private String getMessage(Throwable e) {
			return e.getMessage() == null ? "" : e.getMessage();
		}
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
=======
	
	// TODO (May 25, 2009 9:44:36 PM): Fix max and Theories
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
	public void starting(FrameworkMethod method) throws Exception {
=======
	public void starting(FrameworkMethod method) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
import org.junit.runners.Suite;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	private static <T> Runner parallelize(ParentRunner<T> runner) {
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

			private final ExecutorService fService= Executors
					.newCachedThreadPool();

			public void runChild(final Runnable childStatement) {
				fResults.add(fService.submit(new Callable<Object>() {
					public Object call() throws Exception {
						childStatement.run();
						return null;
					}
				}));
			}

			public void finished() {
				for (Future<Object> each : fResults)
					try {
						each.get();
					} catch (Exception e) {
						e.printStackTrace();
					}
			}
		});
=======
	private static <T> Runner parallelize(Runner runner) {
		if (runner instanceof ParentRunner<?>) {
			((ParentRunner<?>) runner).setRunnerInterceptor(new RunnerInterceptor() {
				private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

				private final ExecutorService fService= Executors
						.newCachedThreadPool();

				public void runChild(final Runnable childStatement) {
					fResults.add(fService.submit(new Callable<Object>() {
						public Object call() throws Exception {
							childStatement.run();
							return null;
						}
					}));
				}

				public void finished() {
					for (Future<Object> each : fResults)
						try {
							each.get();
						} catch (Exception e) {
							e.printStackTrace();
						}
				}
			});
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		Suite suite= (Suite) super.getSuite(builder, classes);
=======
		Runner suite= super.getSuite(builder, classes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
		// TODO (May 4, 2009 4:09:16 PM): no guarantees here
		BlockJUnit4ClassRunner runner= (BlockJUnit4ClassRunner) super
				.getRunner(builder, testClass);
=======
		Runner runner= super.getRunner(builder, testClass);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
		assertThat(end - start, betweenInclusive(1000, 1500));
=======
		assertThat(end - start, betweenInclusive(1000, 1900));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
		@SuppressWarnings("unused")
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
import org.junit.experimental.interceptor.Interceptors;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
import org.junit.experimental.interceptor.TestName;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
import org.junit.runner.RunWith;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
	@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
			// TODO (Apr 28, 2009 10:31:18 PM): much better error if
			// @Interceptor
			// annotates a non-public field.
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
	@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
	@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
	@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
			// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
			// FrameworkMethod too powerful?
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
	@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
	@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
	
	public static class WrongTypedField {
		@Interceptor public int x = 5;
		@Test public void foo() {}
	}
	
	@Test public void validateWrongTypedField() {
		assertThat(testResult(WrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}
	
	public static class SonOfWrongTypedField extends WrongTypedField {
		
	}

	@Test public void validateWrongTypedFieldInSuperclass() {
		assertThat(testResult(SonOfWrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}

	public static class PrivateInterceptor {
		@SuppressWarnings("unused")
		@Interceptor private StatementInterceptor interceptor = new TestName();
		@Test public void foo() {}
	}
	
	@Test public void validatePrivateInterceptor() {
		assertThat(testResult(PrivateInterceptor.class), 
				hasSingleFailureContaining("must be public"));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExpectedException;
import org.junit.experimental.interceptor.Interceptor;

public class ExpectedExceptionInterceptorTest {
	public static class HasExpectedException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Unexpected exception, expected<java.lang.NullPointerException> but was<java.lang.IllegalArgumentException>"));
	}

	public static class HasWrongMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class),
				hasSingleFailureContaining("Unexpected exception message, expected<expectedMessage> but was<actualMessage>"));
	}

	public static class WronglyExpectsException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected exception: java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected exception with message: anything!"));
	}

	public static class ExpectsSubstring {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(
				testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("Unexpected exception message, expected<anything!> but was<>"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
import org.junit.experimental.interceptor.Interceptors;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
import org.junit.runner.RunWith;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
	@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
import org.junit.experimental.interceptor.Interceptors;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
import org.junit.runner.RunWith;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
@RunWith(Interceptors.class)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
import org.junit.tests.experimental.interceptor.ExpectedExceptionInterceptorTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	NameInterceptorTest.class
=======
	NameInterceptorTest.class,
	ExpectedExceptionInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
import static org.junit.Assert.assertEquals;

import java.lang.annotation.Annotation;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
import org.junit.runners.model.FrameworkMethod;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
	
	private static int fComputations;
	// Profiling a JUnit 4.4 suite shows that getAnnotatedMethods accounts for at least 13% of running time
	// (all running time, including user test code!)
	@Test
	public void annotationsAreCached() {
		TestClass testClass= new TestClass(ManyMethods.class) {			
			@Override
			protected Annotation[] computeAnnotations(FrameworkMethod testMethod) {
				fComputations++;
				return super.computeAnnotations(testMethod);
			}
		};
		testClass.getAnnotatedMethods(Test.class);
		fComputations= 0;
		testClass.getAnnotatedMethods(Test.class);
		assertEquals(0, fComputations);
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.7-SNAPSHOT-20090511-2347";
=======
		return "4.7-SNAPSHOT-20090527-0039";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/SubstringMatcher.java;<<<<<<< MINE
=======
/**
 * @deprectated Use org.hamcrest.core.SubstringMatcher directly
 */
@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;<<<<<<< MINE
=======
import org.hamcrest.CoreMatchers;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;<<<<<<< MINE
 * Tests if the argument is a string that contains a substring.
=======
 * @deprectated Use org.hamcrest.core.StringContains directly
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;<<<<<<< MINE
=======
@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/StringContains.java;<<<<<<< MINE
        return new StringContains(substring);
=======
        return CoreMatchers.containsString(substring);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/IsCollectionContaining.java;<<<<<<< MINE
import static org.hamcrest.core.AllOf.allOf;
import static org.hamcrest.core.IsEqual.equalTo;

import java.util.ArrayList;
import java.util.Collection;

import org.hamcrest.Description;
import org.hamcrest.Factory;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/IsCollectionContaining.java;<<<<<<< MINE
public class IsCollectionContaining<T> extends TypeSafeMatcher<Iterable<T>> {
    private final Matcher<? extends T> elementMatcher;

    public IsCollectionContaining(Matcher<? extends T> elementMatcher) {
        this.elementMatcher = elementMatcher;
    }

    @Override
	public boolean matchesSafely(Iterable<T> collection) {
        for (T item : collection) {
            if (elementMatcher.matches(item)){
                return true;
            }
        }
        return false;
    }

    public void describeTo(Description description) {
        description
        	.appendText("a collection containing ")
        	.appendDescriptionOf(elementMatcher);
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItem(Matcher<? extends T> elementMatcher) {
        return new IsCollectionContaining<T>(elementMatcher);
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItem(T element) {
        return hasItem(equalTo(element));
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItems(Matcher<? extends T>... elementMatchers) {
        Collection<Matcher<? extends Iterable<T>>> all
                = new ArrayList<Matcher<? extends Iterable<T>>>(elementMatchers.length);
        for (Matcher<? extends T> elementMatcher : elementMatchers) {
            all.add(hasItem(elementMatcher));
        }
        return allOf(all);
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItems(T... elements) {
        Collection<Matcher<? extends Iterable<T>>> all
                = new ArrayList<Matcher<? extends Iterable<T>>>(elements.length);
        for (T element : elements) {
            all.add(hasItem(element));
        }
        return allOf(all);
    }

=======
/**
 * @deprecated use org.hamcrest.core.IsCollectionContaining directly
 */
@Deprecated 
public class IsCollectionContaining<T> extends org.hamcrest.core.IsCollectionContaining<T> {
	// Client code should just use static factories, so this should be OK
	private IsCollectionContaining(Matcher<? super T> elementMatcher) {
		super(elementMatcher);
		// TODO Auto-generated constructor stub
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/CombinableMatcher.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.anyOf;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/CombinableMatcher.java;<<<<<<< MINE
public class CombinableMatcher<T> extends BaseMatcher<T> {

	private final Matcher<? extends T> fMatcher;

	public CombinableMatcher(Matcher<? extends T> matcher) {
		fMatcher= matcher;
	}

	public boolean matches(Object item) {
		return fMatcher.matches(item);
	}

	public void describeTo(Description description) {
		description.appendDescriptionOf(fMatcher);
	}
	
	@SuppressWarnings("unchecked")
	public CombinableMatcher<T> and(Matcher<? extends T> matcher) {
		return new CombinableMatcher<T>(allOf(matcher, fMatcher));
	}

	@SuppressWarnings("unchecked")
	public CombinableMatcher<T> or(Matcher<? extends T> matcher) {
		return new CombinableMatcher<T>(anyOf(matcher, fMatcher));
=======
/**
 * @deprectated Use org.hamcrest.core.CombinableMatcher directly
 */
@Deprecated
public class CombinableMatcher<T> extends org.hamcrest.core.CombinableMatcher<T> {
	// should only be using static factories
	private CombinableMatcher(Matcher<? super T> matcher) {
		super(matcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/TypeSafeMatcher.java;<<<<<<< MINE
=======
/**
 * @deprectated Use org.hamcrest.TypeSafeMatcher
 */
@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.not;
import static org.junit.internal.matchers.IsCollectionContaining.hasItem;
import org.hamcrest.BaseMatcher;
import org.hamcrest.Description;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;<<<<<<< MINE
=======
import org.hamcrest.core.Every;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;<<<<<<< MINE
=======

/**
 * @deprecated use org.hamcrest.core.Every
 */
@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/Each.java;<<<<<<< MINE
		final Matcher<Iterable<T>> allItemsAre = not(hasItem(not(individual)));
		
		return new BaseMatcher<Iterable<T>>() {
			public boolean matches(Object item) {
				return allItemsAre.matches(item);
			}
			
			public void describeTo(Description description) {
				description.appendText("each ");
				individual.describeTo(description);
			}
		};
=======
		return Every.everyItem(individual);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
import org.hamcrest.CoreMatchers;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
import org.junit.internal.matchers.CombinableMatcher;
import org.junit.internal.matchers.Each;
import org.junit.internal.matchers.IsCollectionContaining;
import org.junit.internal.matchers.StringContains;
=======
import org.hamcrest.core.CombinableMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
 * @deprecated as of JUnit 4.7, all of these matchers are found in the org.hamcrest.CoreMatchers
 *             class instead.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	// TODO (May 27, 2009 11:46:27 AM): deprecate all?
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated Use org.hamcrest.CoreMatchers.hasItem
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> org.hamcrest.Matcher<java.lang.Iterable<T>> hasItem(T element) {
		return IsCollectionContaining.hasItem(element);
=======
	@Deprecated
	public static <T> Matcher<Iterable<? super T>> hasItem(T element) {
		return CoreMatchers.hasItem(element);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated Use org.hamcrest.CoreMatchers.hasItem
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> org.hamcrest.Matcher<java.lang.Iterable<T>> hasItem(org.hamcrest.Matcher<? extends T> elementMatcher) {
		return IsCollectionContaining.hasItem(elementMatcher);
=======
	@Deprecated
    public static <T> Matcher<Iterable<? super T>> hasItem(Matcher<? super T> elementMatcher) {
		return CoreMatchers.hasItem(elementMatcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated Use org.hamcrest.CoreMatchers.hasItems
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return IsCollectionContaining.hasItems(elements);
=======
		return CoreMatchers.hasItems(elements);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated Use org.hamcrest.CoreMatchers.hasItems
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> org.hamcrest.Matcher<java.lang.Iterable<T>> hasItems(org.hamcrest.Matcher<? extends T>... elementMatchers) {
		return IsCollectionContaining.hasItems(elementMatchers);
=======
	@Deprecated
	public static <T> Matcher<Iterable<T>> hasItems(Matcher<? super T>... elementMatchers) {
		return CoreMatchers.hasItems(elementMatchers);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated use CoreMatchers.everyItem directly
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return Each.each(elementMatcher);
=======
		return CoreMatchers.everyItem(elementMatcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated Use org.hamcrest.CoreMatchers.containsString
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return StringContains.containsString(substring);
=======
		return CoreMatchers.containsString(substring);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated Use org.hamcrest.CoreMatchers.both
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> CombinableMatcher<T> both(Matcher<T> matcher) {
		return new CombinableMatcher<T>(matcher);
=======
	@Deprecated
	public static <T> CombinableMatcher<T> both(Matcher<? super T> matcher) {
		return CoreMatchers.both(matcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
	 * @deprecated Use org.hamcrest.CoreMatchers.either
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> CombinableMatcher<T> either(Matcher<T> matcher) {
		return new CombinableMatcher<T>(matcher);
=======
	@Deprecated
	public static <T> CombinableMatcher<T> either(Matcher<? super T> matcher) {
		return CoreMatchers.either(matcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/experimental/results/ResultMatchers.java;<<<<<<< MINE
import org.junit.internal.matchers.TypeSafeMatcher;
=======
import org.hamcrest.TypeSafeMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/Assume.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.everyItem;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/Assume.java;<<<<<<< MINE
import org.junit.internal.matchers.Each;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/Assume.java;<<<<<<< MINE
		assumeThat(asList(objects), Each.each(notNullValue()));
=======
		assumeThat(asList(objects), everyItem(notNullValue()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.either;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
import static org.junit.matchers.JUnitMatchers.either;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
	public static Matcher<Integer> IS_3= is(3);
=======
	public static Matcher<? super Integer> IS_3= is(3);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
	public static Matcher<Integer> IS_4= is(4);
=======
	public static Matcher<? super Integer> IS_4= is(4);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;<<<<<<< MINE
=======
import org.hamcrest.TypeSafeMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;<<<<<<< MINE
import org.junit.internal.matchers.TypeSafeMatcher;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
=======
import org.hamcrest.TypeSafeMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/parallel/ParallelMethodTest.java;<<<<<<< MINE
import org.junit.internal.matchers.TypeSafeMatcher;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionViolatedExceptionTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionViolatedExceptionTest.java;<<<<<<< MINE
import static org.junit.internal.matchers.StringContains.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/PrintableResultTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/PrintableResultTest.java;<<<<<<< MINE
import static org.junit.internal.matchers.StringContains.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/PrintableResultTest.java;<<<<<<< MINE
	@SuppressWarnings("unchecked")
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/ResultMatchersTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/ResultMatchersTest.java;<<<<<<< MINE
import static org.junit.internal.matchers.StringContains.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/results/ResultMatchersTest.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/AssumptionTest.java;<<<<<<< MINE
import static org.junit.internal.matchers.StringContains.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WhenNoParametersMatch.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WhenNoParametersMatch.java;<<<<<<< MINE
import static org.junit.internal.matchers.StringContains.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithOnlyTestAnnotations.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithOnlyTestAnnotations.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.both;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.both;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.everyItem;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java;<<<<<<< MINE
import static org.junit.internal.matchers.Each.each;
import static org.junit.internal.matchers.StringContains.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/runner/WithDataPointMethod.java;<<<<<<< MINE
		return each(nullValue);
=======
		return everyItem(nullValue);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterSignatureTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.hasItem;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterSignatureTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.hasItem;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterizedAssertionErrorTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/theories/ParameterizedAssertionErrorTest.java;<<<<<<< MINE
import static org.junit.internal.matchers.StringContains.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/junit3compatibility/AllTestsTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/junit3compatibility/AllTestsTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
import org.junit.tests.assertion.EachTest;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	EachTest.class,
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/methods/TimeoutTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;<<<<<<< MINE
import static org.junit.matchers.JUnitMatchers.containsString;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.equalTo;

import java.util.ArrayList;
import java.util.List;

=======
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.is;

import java.util.ArrayList;
import java.util.List;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
 * @deprecated as of JUnit 4.7, all of these matchers are found in the org.hamcrest.CoreMatchers
 *             class instead.
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
@Deprecated
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return CoreMatchers.hasItem(element);
=======
		return CoreMatchers.<T>hasItem(element);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
		return CoreMatchers.hasItem(elementMatcher);
=======
		return CoreMatchers.<T>hasItem(elementMatcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	public static <T> Matcher<Iterable<T>> everyItem(final Matcher<T> elementMatcher) {
=======
	public static <T> Matcher<Iterable<T>> each(final Matcher<T> elementMatcher) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	 * @deprecated Use org.hamcrest.CoreMatchers.both
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	@Deprecated
	public static <T> CombinableMatcher<T> both(Matcher<? super T> matcher) {
=======
	public static <T> CombinableMatcher<T> both(Matcher<T> matcher) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	 *   assertThat(string, both(containsString("a")).and(containsString("b")));
=======
	 *   assertThat(string, either(containsString("a")).or(containsString("b")));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	 * @deprecated Use org.hamcrest.CoreMatchers.either
=======
	 * 
	 * If you want to say either(is(3)).or(is(4)), and are prevented,
	 * please see isOneOf(...) below.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	@Deprecated
	public static <T> CombinableMatcher<T> either(Matcher<? super T> matcher) {
=======
	public static <T> CombinableMatcher<T> either(Matcher<T> matcher) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
	}
	
	/**
	 * This is sugar for the situation where you want to specify
	 * a finite list of concrete objects that can match.
	 * For example:
	 * <pre>
	 *   assertThat(string, isOneOf("a", "b", "c"));
	 *   // is equivalent to
	 *   assertThat(string, anyOf(is("a"), is("b"), is("c")))
	 * </pre>
	 */
	public static <T> Matcher<T> isOneOf(T... objects) {
		List<Matcher<? super T>> matchers = new ArrayList<Matcher<? super T>>();
		for (T each : objects) {
			matchers.add(equalTo(each));
		}
		return anyOf(matchers);
	}
	
	/**
	 * Loosens type parameter, in order to use a Matcher 
	 * in a place where Java doesn't want to type-check:
	 *
	 * Goofy example:
	 * <pre>
	 *   assertThat(3, matches(containsString("a")));
	 * </pre>
	 * 
	 * Real example:
	 * <pre>
	 *   assertThat(3, either(matches(is(String.class))).or(
	 *		                  matches(is(Integer.class))));
	 * </pre>
	 */
	@SuppressWarnings("unchecked")
	public static <T> Matcher<T> matches(Matcher<?> matcher) {
		return (Matcher<T>)matcher;
	}
=======
	}
	
	/**
	 * This is sugar for the situation where 
	 * For example:
	 * <pre>
	 *   assertThat(string, eitherIs("a").or(is("b")));
	 * </pre>
	 */
	public static <T> Matcher<T> isOneOf(T... objects) {
		List<Matcher<? super T>> matchers = new ArrayList<Matcher<? super T>>();
		for (T each : objects) {
			matchers.add(is(each));
		}
		return anyOf(matchers);
	}
	
	/**
	 * Loosens type parameter, in order to use a Matcher 
	 * in a place where Java doesn't want to typecheck:
	 *
	 * Goofy example:
	 * <pre>
	 *   assertThat(3, matches(containsString("a")));
	 * </pre>
	 * 
	 * Real example:
	 * <pre>
	 *   assertThat(3, either(matches(is(String.class))).or(
	 *		                  matches(is(Integer.class))));
     *
	 * </pre>
	 */
	@SuppressWarnings("unchecked")
	public static <T> Matcher<T> matches(Matcher<?> matcher) {
		return (Matcher<T>)matcher;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.is;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
=======
import static org.junit.matchers.JUnitMatchers.matches;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
        String expectedMessage = "identifier\nExpected: \"expected\"\n     got: \"actual\"\n";
=======
        String expectedMessage = "identifier\nExpected: \"expected\"\n     but: was \"actual\"";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
=======
    
    @Test public void assertThatIncludesAdvancedMismatch() {
        String expectedMessage = "identifier\nExpected: is an instance of java.lang.Integer\n     but: \"actual\" is a java.lang.String";
        
        try {
            assertThat("identifier", "actual", matches(is(Integer.class)));
        } catch (AssertionError e) {
            assertEquals(expectedMessage, e.getMessage());
        }
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
        String expectedMessage = "\nExpected: \"expected\"\n     got: \"actual\"\n";
=======
        String expectedMessage = "\nExpected: \"expected\"\n     but: was \"actual\"";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
	}


=======
	}	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.both;
=======
import static org.hamcrest.CoreMatchers.any;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.either;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.sameInstance;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
=======
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.either;
import static org.junit.matchers.JUnitMatchers.isOneOf;
import static org.junit.matchers.JUnitMatchers.matches;

import java.util.Arrays;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
		assertThat(3, both(is(Integer.class)).and(is(3)));
=======
		assertThat(3, both(any(Integer.class)).and(is(3)));
		assertThat("ab", both(containsString("a")).and(containsString("b")));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
		assertThat(3, either(is(3)).or(is(4)));
=======
		assertThat(3, either(sameInstance(3)).or(sameInstance(4)));
		assertThat(3, either(matches(is(String.class))).or(
				matches(is(Integer.class))));
		assertThat("a", either(sameInstance("a")).or(sameInstance("b")));
	}

	@SuppressWarnings("unchecked")
	@Test
	public void isOneOfPasses() {
		assertThat(3, isOneOf(3, 4));
		assertThat(Arrays.asList("a"), isOneOf(Arrays.asList("a"), Arrays
				.asList("b")));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/assertion/BothTest.java;<<<<<<< MINE
	
	@Test public void subclassesAreOkInSecondPositionOnly() {
		assertThat(3, both(is(Integer.class)).and(is(3)));
=======

	@Test
	public void superclassesAreOkInSecondPositionOnly() {
		assertThat("a", both(containsString("a")).and(is(String.class)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.both;
=======
import static org.junit.matchers.JUnitMatchers.both;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.both;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/test/java/org/junit/tests/running/methods/AnnotationTest.java;<<<<<<< MINE
=======
import static org.junit.matchers.JUnitMatchers.both;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.matches;
import org.hamcrest.FeatureMatcher;
import org.hamcrest.Matcher;
import org.hamcrest.StringDescription;
import org.junit.Assert;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
	private Class<? extends Throwable> fType;
	private String fMessage;
=======
	private Matcher<?> fMatcher= null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
	public void expect(Matcher<?> matcher) {
		if (fMatcher == null)
			fMatcher = matcher;
		else
			fMatcher = both(fMatcher).and(matches(matcher));
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
		fType= type;
=======
		expect(instanceOf(type));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
	public void expectMessage(String message) {
		fMessage= message;
=======
	public void expectMessage(String substring) {
		expectMessage(containsString(substring));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
	private boolean noExpectedException() {
		return fType == null && fMessage == null;
=======
	public void expectMessage(Matcher<String> matcher) {
		expect(hasMessage(matcher));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
	
	public class ExpectedExceptionStatement extends Statement {
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
	private class ExpectedExceptionStatement extends Statement {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
			boolean complete = false;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
				complete = true;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
				if (noExpectedException())
=======
				if (fMatcher == null)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
				// TODO (May 26, 2009 11:46:31 PM): isInstance?
				if (fType != null && !fType.isAssignableFrom(e.getClass())) {
					String message= "Unexpected exception, expected<"
								+ fType.getName() + "> but was<"
								+ e.getClass().getName() + ">";
					throw new Exception(message, e);
				}
				if (fMessage != null && !getMessage(e).contains(fMessage)) {
					String message= "Unexpected exception message, expected<"
								+ fMessage + "> but was<"
								+ getMessage(e) + ">";
					throw new Exception(message, e);
				}
			}
			// TODO (May 26, 2009 11:54:22 PM): do I need complete
			if (complete && !noExpectedException()) {
				if (fType != null)
					throw new AssertionError("Expected exception: "
							+ fType.getName());
				else if (fMessage != null)
					throw new AssertionError("Expected exception with message: "
							+ fMessage);
				else
					throw new RuntimeException("How'd we get here?");
=======
				Assert.assertThat(e, matches(fMatcher));
				return;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
			if (fMatcher != null)
				throw new AssertionError("Expected test to throw "
						+ StringDescription.toString(fMatcher));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
		private String getMessage(Throwable e) {
			return e.getMessage() == null ? "" : e.getMessage();
		}
=======
	private Matcher<Throwable> hasMessage(Matcher<String> matcher) {
		return new FeatureMatcher<Throwable, String>(matcher,
				"exception with message", "getMessage()") {
			@Override
			protected String featureValueOf(Throwable actual) {
				return actual.getMessage();
			}
		};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.startsWith;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Unexpected exception, expected<java.lang.NullPointerException> but was<java.lang.IllegalArgumentException>"));
=======
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Unexpected exception message, expected<expectedMessage> but was<actualMessage>"));
=======
				hasSingleFailureContaining("\"expectedMessage\"\n     but: getMessage() was \"actualMessage\""));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Expected exception: java.lang.NullPointerException"));
=======
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
				hasSingleFailureContaining("Expected exception with message: anything!"));
=======
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
		assertThat(
				testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("Unexpected exception message, expected<anything!> but was<>"));
=======
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("but: getMessage() was null"));
	}

	public static class ExpectsMessageMatcher {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.7-SNAPSHOT-20090601-1258";
=======
		return "4.7-SNAPSHOT-20090604-0055";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/matchers/IsCollectionContaining.java;<<<<<<< MINE
		// TODO Auto-generated constructor stub
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/model/MultipleFailureException.java;<<<<<<< MINE
=======

	public static void assertEmpty(List<Throwable> errors) throws Throwable {
		if (errors.isEmpty())
			return;
		if (errors.size() == 1)
			throw errors.get(0);
		throw new MultipleFailureException(errors);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
//			// TODO (Feb 23, 2009 11:45:54 PM): Think hard about this. Didn't think hard enough. Throwing away information doesn't help error recovery.
//			if ("warning".equals(getName(test)))
//				try {
//					return (Class<? extends Test>) Class.forName(fTest.toString());
//				} catch (ClassNotFoundException e) {
//					return test.getClass();
//				}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:57:14 PM): V
	public static Description makeDescription(Test test) {
=======
	private static Description makeDescription(Test test) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
				// TODO (Feb 23, 2009 11:25:23 PM): this is doing Max's work for it.  Max should get rid of these when sorting i
				if (!made.toString().startsWith("warning("))			
					description.addChild(made);
=======
				description.addChild(made);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:57:26 PM): V
	public Test getTest() {
=======
	private Test getTest() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
		List<Throwable> fErrors = new ArrayList<Throwable>();
		fErrors.clear();
=======
		List<Throwable> errors = new ArrayList<Throwable>();
		errors.clear();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
			fErrors.add(e);
=======
			errors.add(e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
					fErrors.add(e);
=======
					errors.add(e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/runners/statements/RunAfters.java;<<<<<<< MINE
		if (fErrors.isEmpty())
			return;
		if (fErrors.size() == 1)
			throw fErrors.get(0);
		throw new MultipleFailureException(fErrors);
=======
		MultipleFailureException.assertEmpty(errors);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ExactComparisonCriteria.java;<<<<<<< MINE
// TODO (Apr 29, 2009 4:17:49 PM): where should this live?
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
=======
/**
 * Defines criteria for finding two items "equal enough". Concrete subclasses
 * may demand exact equality, or, for example, equality within a given delta.
 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	 * Asserts that two arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown with the given message. If
	 * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,
	 * they are considered equal.
=======
	 * Asserts that two arrays are equal, according to the criteria defined by
	 * the concrete subclass. If they are not, an {@link AssertionError} is
	 * thrown with the given message. If <code>expecteds</code> and
	 * <code>actuals</code> are <code>null</code>, they are considered equal.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
=======
	 *            the identifying message for the {@link AssertionError} (
	 *            <code>null</code> okay)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	 * @param criteria TODO
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
	public void arrayEquals(String message, Object expecteds,
			Object actuals) throws ArrayComparisonFailure {
		// TODO: DUP above
		// TODO (Sep 8, 2008 4:32:50 PM): Test that this fails sometimes
		// TODO (Sep 8, 2008 4:33:04 PM): Update javadoc
		
=======
	public void arrayEquals(String message, Object expecteds, Object actuals)
			throws ArrayComparisonFailure {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
		
		int expectedsLength= Assert.assertArraysAreSameLength(expecteds, actuals,
				header);
=======

		int expectedsLength= Assert.assertArraysAreSameLength(expecteds,
				actuals, header);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
			
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;<<<<<<< MINE
=======
import java.util.List;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;<<<<<<< MINE
public interface FrameworkMember<T extends FrameworkMember<T>> {
=======
abstract class FrameworkMember<T extends FrameworkMember<T>> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;<<<<<<< MINE
	public Annotation[] getAnnotations();
=======
	abstract Annotation[] getAnnotations();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;<<<<<<< MINE
	public boolean isShadowedBy(T otherMember);
=======
	abstract boolean isShadowedBy(T otherMember);

	boolean isShadowedBy(List<T> members) {
		for (T each : members)
			if (isShadowedBy(each))
				return true;
		return false;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
public class FrameworkMethod implements FrameworkMember<FrameworkMethod> {
=======
public class FrameworkMethod extends FrameworkMember<FrameworkMethod> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
=======
	@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
=======
	@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	// TODO (May 25, 2009 9:46:48 PM): move to FrameworkMember
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
			ensureKey(map, type);
			List<T> members= map.get(type);
			if (isShadowedBy(member, members))
=======
			List<T> members= getAnnotatedMembers(map, type);
			if (member.isShadowedBy(members))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
	private <T extends FrameworkMember<T>> boolean isShadowedBy(T member, List<T> members) {
		for (T each : members)
			if (member.isShadowedBy(each))
				return true;
		return false;
	}

	private <T> void ensureKey(Map<Class<?>, List<T>> map, Class<?> annotation) {
		if (!map.containsKey(annotation))
			map.put(annotation, new ArrayList<T>());
	}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		// TODO (May 25, 2009 10:02:46 PM): DUP
		ensureKey(fMethodsForAnnotations, annotationClass);
		return fMethodsForAnnotations.get(annotationClass);
=======
		return getAnnotatedMembers(fMethodsForAnnotations, annotationClass);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
=======
	/**
	 * Returns, efficiently, all the non-overridden fields in this class and
	 * its superclasses that are annotated with {@code annotationClass}.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/TestClass.java;<<<<<<< MINE
		// TODO (May 25, 2009 10:02:46 PM): DUP
		ensureKey(fFieldsForAnnotations, annotationClass);
		return fFieldsForAnnotations.get(annotationClass);
=======
		return getAnnotatedMembers(fFieldsForAnnotations, annotationClass);
	}

	private <T> List<T> getAnnotatedMembers(Map<Class<?>, List<T>> map,
			Class<? extends Annotation> type) {
		if (!map.containsKey(type))
			map.put(type, new ArrayList<T>());
		return map.get(type);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;

/**
 * Represents a field on a test class (currently used only for Rules in
 * {@link BlockJUnit4ClassRunner}, but custom runners can make other uses)
 */
public class FrameworkField extends FrameworkMember<FrameworkField> {
=======
import org.junit.runners.BlockJUnit4ClassRunner;

/**
 * Represents a field on a test class (currently used only for Interceptors in
 * {@link BlockJUnit4ClassRunner}, but custom runners can make other uses)
 */
public class FrameworkField extends FrameworkMember<FrameworkField> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
=======
	@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
	// TODO (May 25, 2009 9:45:43 PM): faking it
=======
	@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
		// TODO Auto-generated method stub
		return false;
=======
		return otherMember.getField().getName().equals(getField().getName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
import java.util.ArrayList;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE

=======
	
	/**
	 * Adds to {@code errors} if the test class has more than one constructor,
	 * or if the constructor takes parameters.  Override if a subclass requires
	 * different validation rules.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private void validateOnlyOneConstructor(List<Throwable> errors) {
=======
	/**
	 * Adds to {@code errors} if the test class has more than one constructor
	 * (do not override)
	 */
	protected void validateOnlyOneConstructor(List<Throwable> errors) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	 * (do not override)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		// TODO (May 26, 2009 10:48:26 PM): don't override this
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private void validateRuleField(Field field, List<Throwable> errors) {
		if (!MethodRule.class.isAssignableFrom(field.getType()))
=======
	private void validateInterceptorField(Field field, List<Throwable> errors) {
		if (!MethodRule.class.isAssignableFrom(field.getType()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		statement= withInterceptors(method, test, statement);
=======
		statement= withRules(method, test, statement);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		List<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(
				Before.class);
=======
		List<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(Before.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	
	protected Statement withInterceptors(FrameworkMethod method, Object test,
			Statement statement) {
		// TODO (May 26, 2009 11:16:13 PM): outsource to a class?
		Statement result= statement;
		for (FrameworkField each : interceptorFields())
			try {
				StatementInterceptor interceptor= (StatementInterceptor) each
						.get(test);
				result= interceptor.intercept(result, method);
			} catch (IllegalAccessException e) {
				throw new RuntimeException(
						"How did getFields return a field we couldn't access?");
			}
		return result;
	}

	private List<FrameworkField> interceptorFields() {
		return getTestClass().getAnnotatedFields(Interceptor.class);
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	 * 
	 * @deprecated Will be private soon: use Rules instead
=======
	 * 
	 * @deprecated Will be private soon: use Interceptors instead
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	@Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		// TODO (May 11, 2009 11:28:21 PM):
		// withBefores/withAfters/withBeforeClass/withAfterClass is a lot of
		// duplication.
		List<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(
				After.class);
=======
		List<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(After.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
	
	private Statement withRules(FrameworkMethod method, Object target,
			Statement statement) {
		Statement result= statement;
		for (MethodRule each : rules(target))
			result= each.apply(result, method, target);
		return result;
	}
	
	/**
	 * @return the MethodRules that can transform the block
	 * that runs each method in the tested class.
	 */
	protected List<MethodRule> rules(Object test) {
		List<MethodRule> results= new ArrayList<MethodRule>();
		for (FrameworkField each : ruleFields())
			results.add(createRule(test, each));
		return results;
	}

	private List<FrameworkField> ruleFields() {
		return getTestClass().getAnnotatedFields(Rule.class);
	}

	private MethodRule createRule(Object test,
			FrameworkField each) {
		try {
			return (MethodRule) each.get(test);
		} catch (IllegalAccessException e) {
			throw new RuntimeException(
					"How did getFields return a field we couldn't access?");
		}
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:24:40 PM): V
	public RunNotifier fNotifier;
=======
	private RunNotifier fNotifier;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
	 * @param computer TODO
=======
	 * @param computer Helps construct Runners from classes
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
		// TODO(parallel) too many Executioner creations
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
	 * @param computer TODO
=======
	 * @param computer Helps construct Runners from classes
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	// TODO javadoc
=======
	/**
	 * @return If this describes a method invocation, 
	 * the class of the test instance.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	//TODO javadoc
=======
	/**
	 * @return If this describes a method invocation, 
	 * the name of the class of the test instance
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
		Matcher matcher= Pattern.compile("(.*)\\((.*)\\)").matcher(toString());
=======
		Matcher matcher= methodStringMatcher();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
=======
	
	/**
	 * @return If this describes a method invocation, 
	 * the name of the method (or null if not)
	 */
	public String getMethodName() {
		return parseMethod();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
		Matcher matcher= Pattern.compile("(.*)\\((.*)\\)").matcher(toString());
=======
		Matcher matcher= methodStringMatcher();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	
	// TODO javadoc
	public String getMethodName() {
		return parseMethod();
=======

	private Matcher methodStringMatcher() {
		return Pattern.compile("(.*)\\((.*)\\)").matcher(toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runner/Request.java;<<<<<<< MINE
	 * @param computer TODO
=======
	 * @param computer Helps construct Runners from classes
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;<<<<<<< MINE
=======
import org.junit.runner.Computer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;<<<<<<< MINE
		return new PrintableResult(type);
=======
		return testResult(type, new Computer());
	}
	
	public static PrintableResult testResult(Class<?> type, Computer computer) {
		return new PrintableResult(type, computer);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/PrintableResult.java;<<<<<<< MINE
	public PrintableResult(Class<?> type) {
		this(JUnitCore.runClasses(type));
=======
	public PrintableResult(Class<?> type, Computer computer) {
		this(JUnitCore.runClasses(computer, type));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/FailureList.java;<<<<<<< MINE
public class FailureList {
=======
class FailureList {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/CouldNotReadCoreException.java;<<<<<<< MINE
=======
/**
 * Thrown when Max cannot read the MaxCore serialization
 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/CouldNotReadCoreException.java;<<<<<<< MINE
=======
	/**
	 * Constructs
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import java.io.FileNotFoundException;
import java.io.IOException;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
import junit.framework.TestSuite;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
import org.junit.internal.runners.JUnit38ClassRunner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
/**
 * A replacement for JUnitCore, which keeps track of runtime and failure history, and reorders tests
 * to maximize the chances that a failing test occurs early in the test run.
 * 
 * The rules for sorting are:
 * <ol>
 * <li> Never-run tests first, in arbitrary order
 * <li> Group remaining tests by the date at which they most recently failed.
 * <li> Sort groups such that the most recent failure date is first, and never-failing tests are at the end.
 * <li> Within a group, run the fastest tests first. 
 * </ol>
 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public static MaxCore forFolder(String fileName) {
		return storedLocally(new File(fileName));
=======
	private static final String MALFORMED_JUNIT_3_TEST_CLASS_PREFIX= "malformed JUnit 3 test class: ";
	
	/**
	 * Create a new MaxCore from a serialized file stored at storedResults
	 * @deprecated use storedLocally()
	 */
	@Deprecated
	public static MaxCore forFolder(String folderName) {
		return storedLocally(new File(folderName));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
	/**
	 * Create a new MaxCore from a serialized file stored at storedResults
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public final MaxHistory fHistory;
=======
	private final MaxHistory fHistory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	public MaxCore(File storedResults) {
=======
	private MaxCore(File storedResults) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
	/**
	 * Run all the tests in <code>class</code>.
	 * @return a {@link Result} describing the details of the test run and the failed tests.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
	/**
	 * Run all the tests contained in <code>request</code>.
	 * @param request the request describing tests
	 * @return a {@link Result} describing the details of the test run and the failed tests.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
	/**
	 * Run all the tests contained in <code>request</code>.
	 * 
	 * This variant should be used if {@code core} has attached listeners that this
	 * run should notify.
	 * 
	 * @param request the request describing tests
	 * @param core a JUnitCore to delegate to.
	 * @return a {@link Result} describing the details of the test run and the failed tests.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		try { 
			return core.run(sortRequest(request).getRunner());
		} finally {
			try {
				fHistory.save();
			} catch (FileNotFoundException e) {
				// TODO
				e.printStackTrace();
			} catch (IOException e) {
				// TODO
				e.printStackTrace();
			}
		}
=======
		return core.run(sortRequest(request).getRunner());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:14:05 PM): publicized for squeeze
=======
	/**
	 * @param request
	 * @return a new Request, which contains all of the same tests, but in a new order.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:42:05 PM): V
	public Request constructLeafRequest(List<Description> leaves) {
=======
	private Request constructLeafRequest(List<Description> leaves) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 11:17:01 PM): V
	public Runner buildRunner(Description each) {
=======
	private Runner buildRunner(Description each) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			try {
				// TODO (Nov 18, 2008 2:18:28 PM): move to Suite
				return new Suite(null, new Class<?>[0]);
			} catch (InitializationError e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
=======
			return Suite.emptySuite();
		if (each.toString().startsWith(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX))
			// This is cheating, because it runs the whole class 
			// to get the warning for this method, but we can't do better, 
			// because JUnit 3.8's
			// thrown away which method the warning is for.
			return new JUnit38ClassRunner(new TestSuite(getMalformedTestClass(each)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			// TODO (Nov 18, 2008 2:04:09 PM): add a check if building a runner is possible
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
	private Class<?> getMalformedTestClass(Description each) {
		try {
			return Class.forName(each.toString().replace(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX, ""));
		} catch (ClassNotFoundException e) {
			return null;
		}
	}

	/**
	 * @param request a request to run
	 * @return a list of method-level tests to run, sorted in the order
	 * specified in the class comment.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:40:23 PM): V
	public List<Description> findLeaves(Request request) {
=======
	private List<Description> findLeaves(Request request) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		findLeaves(request.getRunner().getDescription(), results);
=======
		findLeaves(null, request.getRunner().getDescription(), results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:50:48 PM): V
	public void findLeaves(Description description, List<Description> results) {
=======
	private void findLeaves(Description parent, Description description, List<Description> results) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			results.add(description);
=======
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
			else
				results.add(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
				findLeaves(each, results);
=======
				findLeaves(description, each, results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
import java.io.FileNotFoundException;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======
import org.junit.runner.Result;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======
/**
 * Stores a subset of the history of each test:
 * <ul>
 * <li>Last failure timestamp
 * <li>Duration of last execution
 * </ul>
 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	/**
	 * Loads a {@link MaxHistory} from {@code file}, or generates a new one that
	 * will be saved to {@code file}.
	 */
	public static MaxHistory forFolder(File file) {
		if (file.exists())
			try {
				return readHistory(file);
			} catch (CouldNotReadCoreException e) {
				e.printStackTrace();
				file.delete();
			}
		return new MaxHistory(file);
	}
=======
	/**
	 * Loads a {@link MaxHistory} from {@code file}, or generates a new one that
	 * will be saved to {@code file}.
	 */
	public static MaxHistory forFolder(File file) {
		// TODO: temp!
		if (file.getPath() == null)
			throw new NullPointerException();
		if (file.exists())
			try {
				return readHistory(file);
			} catch (CouldNotReadCoreException e) {
				e.printStackTrace();
				file.delete();
			}
		return new MaxHistory(file);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public static MaxHistory forFolder(File storedResults) {
		try {
			if (storedResults.exists())
				return readHistory(storedResults);
		} catch (CouldNotReadCoreException e) {
			e.printStackTrace();
			storedResults.delete();
		}
		return new MaxHistory(storedResults);
	}
	
	private static MaxHistory readHistory(File storedResults) throws CouldNotReadCoreException {
		// TODO: rule of three
		// TODO: Really?
		ObjectInputStream stream;
		FileInputStream file= null;
		try {
			file= new FileInputStream(storedResults);
		} catch (FileNotFoundException e) {
			throw new CouldNotReadCoreException(e);
		}
=======
	private static MaxHistory readHistory(File storedResults)
			throws CouldNotReadCoreException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======
			FileInputStream file= new FileInputStream(storedResults);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
				stream= new ObjectInputStream(file);
			} catch (IOException e) {
				throw new CouldNotReadCoreException(e);
			}
			try {
				return (MaxHistory) stream.readObject();
			} catch (Exception e) {
				throw new CouldNotReadCoreException(e); //TODO think about what we can do better here
			} finally {
=======
				ObjectInputStream stream= new ObjectInputStream(file);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======
					return (MaxHistory) stream.readObject();
				} finally {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
				} catch (IOException e) {
					throw new CouldNotReadCoreException(e);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
			}
		} finally {
			try {
=======
			} finally {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
			} catch (IOException e) {
				// TODO can't imagine what's gone wrong here, but who cares?
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======
		} catch (Exception e) {
			throw new CouldNotReadCoreException(e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public final Map<String, Long> fDurations= new HashMap<String, Long>();
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public final Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();
=======
	private final Map<String, Long> fDurations= new HashMap<String, Long>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public final File fFolder;
=======
	private final Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public MaxHistory(File storedResults) {
		fFolder= storedResults;
	}
=======
	private final File fHistoryStore;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public File getFile() {
		return fFolder;
=======
	private MaxHistory(File storedResults) {
		fHistoryStore= storedResults;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	public void save() throws IOException {
=======
	private void save() throws IOException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
				fFolder));
=======
				fHistoryStore));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
														// possible time
=======
			// possible time
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======

		@Override
		public void testRunFinished(Result result) throws Exception {
			save();
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
			int result= getFailure(o2).compareTo(getFailure(o1)); 
			return result != 0
				? result
				// Then shorter tests first
				: getTestDuration(o1).compareTo(getTestDuration(o2));
=======
			int result= getFailure(o2).compareTo(getFailure(o1));
			return result != 0 ? result
			// Then shorter tests first
					: getTestDuration(o1).compareTo(getTestDuration(o2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
			if (result == null) 
=======
			if (result == null)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE

	public RememberingListener listener() {
=======
	/**
	 * @return a listener that will update this history based on the test
	 *         results reported.
	 */
	public RunListener listener() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
	// TODO (Feb 23, 2009 10:41:36 PM): V
=======
	/**
	 * @return a comparator that ranks tests based on the JUnit Max sorting
	 *         rules, as described in the {@link MaxCore} class comment.
	 */
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
	protected void validateZeroArgConstructor(List<Throwable> errors) {
		// constructor can have args
=======
	protected void validateConstructor(List<Throwable> errors) {
		validateOnlyOneConstructor(errors);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TestName.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;

/**
 * The TestName Rule makes the current test name available inside test methods:
 * 
 * <pre>
 * public class TestNameTest {
 * 	&#064;Rule
 * 	public TestName name= new TestName();
 * 
 * 	&#064;Test
 * 	public void testA() {
 * 		assertEquals(&quot;testA&quot;, name.getMethodName());
 * 	}
 * 
 * 	&#064;Test
 * 	public void testB() {
 * 		assertEquals(&quot;testB&quot;, name.getMethodName());
 * 	}
 * }
 * </pre>
 */
public class TestName extends TestWatchman {
	private String fName;

	@Override
	public void starting(FrameworkMethod method) {
		fName= method.getName();
	}

	public String getMethodName() {
		return fName;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/ExternalResource.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * A base class for Rules (like TemporaryFolder) that set up an external
 * resource before a test (a file, socket, server, database connection, etc.),
 * and guarantee to tear it down afterward:
 * 
 * <pre>
 * public static class UsesExternalResource {
 * 	Server myServer= new Server();
 * 
 * 	&#064;Rule
 * 	public ExternalResource resource= new ExternalResource() {
 * 		&#064;Override
 * 		protected void before() throws Throwable {
 * 			myServer.connect();
 * 		};
 * 
 * 		&#064;Override
 * 		protected void after() {
 * 			myServer.disconnect();
 * 		};
 * 	};
 * 
 * 	&#064;Test
 * 	public void testFoo() {
 * 		new Client().run(myServer);
 * 	}
 * }
 * </pre>
 */
public abstract class ExternalResource implements MethodRule {
	public final Statement apply(final Statement base,
			FrameworkMethod method, Object target) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				before();
				try {
					base.evaluate();
				} finally {
					after();
				}
			}
		};
	}

	/**
	 * Override to set up your specific external resource.
	 * @throws if setup fails (which will disable {@code after}
	 */
	protected void before() throws Throwable {
		// do nothing
	}

	/**
	 * Override to tear down your specific external resource.
	 * @throws if setup fails (which will disable {@code after}
	 */
	protected void after() {
		// do nothing
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.matches;
import org.hamcrest.FeatureMatcher;
import org.hamcrest.Matcher;
import org.hamcrest.StringDescription;
import org.junit.Assert;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * The ExpectedException Rule allows in-test specification of expected exception
 * types and messages:
 * 
 * <pre>
 * // These tests all pass.
 * public static class HasExpectedException {
 * 	&#064;Rule
 * 	public ExpectedException thrown= new ExpectedException();
 * 
 * 	&#064;Test
 * 	public void throwsNothing() {
 *    // no exception expected, none thrown: passes.
 * 	}
 * 
 * 	&#064;Test
 * 	public void throwsNullPointerException() {
 * 		thrown.expect(NullPointerException.class);
 * 		throw new NullPointerException();
 * 	}
 * 
 * 	&#064;Test
 * 	public void throwsNullPointerExceptionWithMessage() {
 * 		thrown.expect(NullPointerException.class);
 * 		thrown.expectMessage(&quot;happened?&quot;);
 * 		thrown.expectMessage(startsWith(&quot;What&quot;));
 * 		throw new NullPointerException(&quot;What happened?&quot;);
 * 	}
 * }
 * </pre>
 */
public class ExpectedException implements MethodRule {
	public static ExpectedException none() {
		return new ExpectedException();
	}

	private Matcher<?> fMatcher= null;

	private ExpectedException() {
		
	}
	
	public Statement apply(Statement base, FrameworkMethod method, Object target) {
		return new ExpectedExceptionStatement(base);
	}

	/**
	 * Adds {@code matcher} to the list of requirements for any thrown exception.
	 */
	public void expect(Matcher<?> matcher) {
		if (fMatcher == null)
			fMatcher= matcher;
		else
			fMatcher= both(fMatcher).and(matches(matcher));
	}

	/**
	 * Adds to the list of requirements for any thrown exception that it
	 * should be an instance of {@code type}
	 */
	public void expect(Class<? extends Throwable> type) {
		expect(instanceOf(type));
	}

	/**
	 * Adds to the list of requirements for any thrown exception that it
	 * should <em>contain</em> string {@code substring}
	 */
	public void expectMessage(String substring) {
		expectMessage(containsString(substring));
	}

	/**
	 * Adds {@code matcher} to the list of requirements for the message 
	 * returned from any thrown exception.
	 */
	public void expectMessage(Matcher<String> matcher) {
		expect(hasMessage(matcher));
	}

	private class ExpectedExceptionStatement extends Statement {
		private final Statement fNext;

		public ExpectedExceptionStatement(Statement base) {
			fNext= base;
		}

		@Override
		public void evaluate() throws Throwable {
			try {
				fNext.evaluate();
			} catch (Throwable e) {
				if (fMatcher == null)
					throw e;
				Assert.assertThat(e, matches(fMatcher));
				return;
			}
			if (fMatcher != null)
				throw new AssertionError("Expected test to throw "
						+ StringDescription.toString(fMatcher));
		}
	}

	private Matcher<Throwable> hasMessage(Matcher<String> matcher) {
		return new FeatureMatcher<Throwable, String>(matcher,
				"exception with message", "getMessage()") {
			@Override
			protected String featureValueOf(Throwable actual) {
				return actual.getMessage();
			}
		};
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/Timeout.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.internal.runners.statements.FailOnTimeout;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * The Timeout Rule applies the same timeout to all test methods in a class:
 * 
 * <pre>
 * public static class HasGlobalTimeout {
 * 	public static String log;
 * 
 * 	&#064;Rule
 * 	public MethodRule globalTimeout= new Timeout(20);
 * 
 * 	&#064;Test
 * 	public void testInfiniteLoop1() {
 * 		log+= &quot;ran1&quot;;
 * 		for (;;) {
 * 		}
 * 	}
 * 
 * 	&#064;Test
 * 	public void testInfiniteLoop2() {
 * 		log+= &quot;ran2&quot;;
 * 		for (;;) {
 * 		}
 * 	}
 * }
 * </pre>
 */
public class Timeout implements MethodRule {
	private final int fMillis;

	public Timeout(int millis) {
		fMillis= millis;
	}

	public Statement apply(Statement base, FrameworkMethod method, Object target) {
		return new FailOnTimeout(base, fMillis);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * TestWatchman is a base class for Rules that take note of the testing
 * action, without modifying it. For example, this class will keep a log of each
 * passing and failing test:
 * 
 * <pre>
 * public static class WatchmanTest {
 * 	private static String watchedLog;
 * 
 * 	&#064;Rule
 * 	public MethodRule watchman= new TestWatchman() {
 * 		&#064;Override
 * 		public void failed(Throwable e, FrameworkMethod method) {
 * 			watchedLog+= method.getName() + &quot; &quot; + e.getClass().getSimpleName()
 * 					+ &quot;\n&quot;;
 * 		}
 * 
 * 		&#064;Override
 * 		public void succeeded(FrameworkMethod method) {
 * 			watchedLog+= method.getName() + &quot; &quot; + &quot;success!\n&quot;;
 * 		}
 * 	};
 * 
 * 	&#064;Test
 * 	public void fails() {
 * 		fail();
 * 	}
 * 
 * 	&#064;Test
 * 	public void succeeds() {
 * 	}
 * }
 * </pre>
 */
public class TestWatchman implements MethodRule {
	public Statement apply(final Statement base, final FrameworkMethod method,
			Object target) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				starting(method);
				try {
					base.evaluate();
					succeeded(method);
				} catch (Throwable t) {
					failed(t, method);
					throw t;
				} finally {
					finished(method);
				}
			}
		};
	}

	/**
	 * Invoked when a test method succeeds
	 * 
	 * @param method
	 */
	public void succeeded(FrameworkMethod method) {
	}

	/**
	 * Invoked when a test method fails
	 * 
	 * @param e 
	 * @param method
	 */
	public void failed(Throwable e, FrameworkMethod method) {
	}

	/**
	 * Invoked when a test method is about to start
	 * 
	 * @param method  
	 */
	public void starting(FrameworkMethod method) {
	}


	/**
	 * Invoked when a test method finishes (whether passing or failing)
	 * 
	 * @param method  
	 */
	public void finished(FrameworkMethod method) {
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TemporaryFolder.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import java.io.File;
import java.io.IOException;

/**
 * The TemporaryFolder Rule allows creation of files and folders that are
 * guaranteed to be deleted when the test method finishes (whether it passes or
 * fails):
 * 
 * <pre>
 * public static class HasTempFolder {
 * 	&#064;Rule
 * 	public TemporaryFolder folder= new TemporaryFolder();
 * 
 * 	&#064;Test
 * 	public void testUsingTempFolder() throws IOException {
 * 		File createdFile= folder.newFile(&quot;myfile.txt&quot;);
 * 		File createdFolder= folder.newFolder(&quot;subfolder&quot;);
 * 		// ...
 * 	}
 * }
 * </pre>
 */
public class TemporaryFolder extends ExternalResource {
	private File folder;

	@Override
	protected void before() throws Throwable {
		create();
	}

	@Override
	protected void after() {
		delete();
	}

	// testing purposes only
	public void create() throws IOException {
		folder= File.createTempFile("junit", "");
		folder.delete();
		folder.mkdir();
	}

	public File newFile(String fileName) throws IOException {
		File file= new File(folder, fileName);
		file.createNewFile();
		return file;
	}

	public File newFolder(String folderName) {
		File file= new File(folder, folderName);
		file.mkdir();
		return file;
	}

	public File getRoot() {
		return folder;
	}

	public void delete() {
		recursiveDelete(folder);
	}

	private void recursiveDelete(File file) {
		File[] files= file.listFiles();
		if (files != null)
			for (File each : files)
				recursiveDelete(each);
		file.delete();
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
import java.io.Serializable;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
import java.util.Map;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
		// TODO (Mar 10, 2009 10:47:34 AM): Import
		Assert.assertArrayEquals(new float[] {1.0f}, new float[] {1.0f}, 1.0f);
=======
		assertArrayEquals(new float[] {1.0f}, new float[] {1.0f}, 1.0f);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/parallel/ParallelClassTest.java;<<<<<<< MINE
	// TODO(parallel) we need to push parallel execution down through suites (i.e. run a Suite with a parallel executioner and you get parallel execution)
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
		// TODO (Nov 18, 2008 2:03:06 PM): flaky?
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
	

	@Test
	public void correctErrorFromHalfMalformedTest() {
		Request request= Request.aClass(HalfMalformedJUnit38TestMethod.class);
		JUnitCore core= new JUnitCore();
		Request sorted= fMax.sortRequest(request);
		Runner runner= sorted.getRunner();
		Result result= core.run(runner);
		Failure failure= result.getFailures().get(0);
		assertThat(failure.toString(), containsString("MalformedJUnit38TestMethod"));
		assertThat(failure.toString(), containsString("testNothing"));
		assertThat(failure.toString(), containsString("isn't public"));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
import org.junit.experimental.interceptor.TestName;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	public static class ExampleTest {
		@Rule
		public MethodRule example= new MethodRule() {
			public Statement apply(final Statement base,
					FrameworkMethod method, Object target) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAndEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	public static class MultipleInterceptorTest {
		private static class Increment implements MethodRule {
			public Statement apply(final Statement base,
					FrameworkMethod method, Object target) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Rule
		public MethodRule incrementor1= new Increment();

		@Rule
		public MethodRule incrementor2= new Increment();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	public static class OnFailureTest {
		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	public static class WatchmanTest {
		private static String watchedLog;

		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}

	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
	
	public static class WrongTypedField {
		@Rule public int x = 5;
		@Test public void foo() {}
	}
	
	@Test public void validateWrongTypedField() {
		assertThat(testResult(WrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}
	
	public static class SonOfWrongTypedField extends WrongTypedField {
		
	}

	@Test public void validateWrongTypedFieldInSuperclass() {
		assertThat(testResult(SonOfWrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}

	public static class PrivateInterceptor {
		@SuppressWarnings("unused")
		@Rule private MethodRule interceptor = new TestName();
		@Test public void foo() {}
	}
	
	@Test public void validatePrivateInterceptor() {
		assertThat(testResult(PrivateInterceptor.class), 
				hasSingleFailureContaining("must be public"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/TempFolderInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;

import java.io.File;
import java.io.IOException;

import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.TemporaryFolder;

public class TempFolderInterceptorTest {
	private static File createdFile;

	public static class HasTempFolder {
		@Rule
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFile("myfile.txt");
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void tempFolderIsDeleted() {
		assertThat(testResult(HasTempFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	public static class CreatesSubFolder {
		@Rule
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFolder("subfolder");
			new File(createdFile, "a.txt").createNewFile();
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void subFolderIsDeleted() {
		assertThat(testResult(CreatesSubFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	@Test
	public void recursiveDeleteFolderWithOneElement() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		File file= folder.newFile("a");
		folder.delete();
		assertFalse(file.exists());
		assertFalse(folder.getRoot().exists());
	}

	@Test
	public void recursiveDeleteFolderWithZeroElements() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		folder.delete();
		assertFalse(folder.getRoot().exists());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExpectedException;
import org.junit.experimental.interceptor.Rule;

public class ExpectedExceptionInterceptorTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class),
				hasSingleFailureContaining("\"expectedMessage\"\n     but: getMessage() was \"actualMessage\""));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("but: getMessage() was null"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/ExternalResourceInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExternalResource;
import org.junit.experimental.interceptor.Rule;

public class ExternalResourceInterceptorTest {
	private static String callSequence;
	
	public static class UsesExternalResource {
		@Rule public ExternalResource resource = new ExternalResource() {
			@Override
			protected void before() throws Throwable {
				callSequence += "before ";
			};
			
			@Override
			protected void after() {
				callSequence += "after ";
			};
		};
		
		@Test public void testFoo() {
			callSequence += "test ";
		}
	}

	@Test public void externalResourceGeneratesCorrectSequence() {
		callSequence= "";
		assertThat(testResult(UsesExternalResource.class), isSuccessful());
		assertEquals("before test after ", callSequence);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;

public class TimeoutInterceptorTest {
	public static class HasGlobalTimeout {
		public static String log;
		
		@Rule public MethodRule globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	@Ignore("For gump, for now")
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.TestName;

public class NameInterceptorTest {
	@Rule public TestName name = new TestName();
	
	@Test public void testA() {
		assertEquals("testA", name.getMethodName());
	}
	
	@Test public void testB() {
		assertEquals("testB", name.getMethodName());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
import org.junit.tests.experimental.interceptor.ExpectedExceptionInterceptorTest;
import org.junit.tests.experimental.interceptor.ExternalResourceInterceptorTest;
import org.junit.tests.experimental.interceptor.InterceptorTest;
import org.junit.tests.experimental.interceptor.NameInterceptorTest;
import org.junit.tests.experimental.interceptor.TempFolderInterceptorTest;
import org.junit.tests.experimental.interceptor.TimeoutInterceptorTest;
import org.junit.tests.experimental.interceptor.VerifierInterceptorTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
import org.junit.tests.experimental.max.MaxComputerTest;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	RulesTest.class,
	TimeoutRuleTest.class,
=======
	InterceptorTest.class,
	TimeoutInterceptorTest.class,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	NameRulesTest.class,
	ExpectedExceptionRuleTest.class,
	TempFolderRuleTest.class,
	ExternalResourceRuleTest.class,
	VerifierRuleTest.class
=======
	NameInterceptorTest.class,
	ExpectedExceptionInterceptorTest.class,
	TempFolderInterceptorTest.class,
	ExternalResourceInterceptorTest.class,
	VerifierInterceptorTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
import org.junit.rules.MethodRule;
=======
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
		public TwoConstructors() {}
		public TwoConstructors(int x) {}
=======
		public TwoConstructors() {
		}

		public TwoConstructors(int x) {
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
	
	@Test(expected=IllegalArgumentException.class) public void complainIfMultipleConstructors() {
=======

	@Test(expected= IllegalArgumentException.class)
	public void complainIfMultipleConstructors() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
		@Test public void a() {}
		@Before public void b() {}
		@Ignore @Test public void c() {}
		@Ignore @After public void d() {}
		public void e() {}
		@BeforeClass public void f() {}
		public void g() {}
		@AfterClass public void h() {}
		@Test public void i() {}
		@Test public void j() {}
=======
		@Test
		public void a() {
		}

		@Before
		public void b() {
		}

		@Ignore
		@Test
		public void c() {
		}

		@Ignore
		@After
		public void d() {
		}

		public void e() {
		}

		@BeforeClass
		public void f() {
		}

		public void g() {
		}

		@AfterClass
		public void h() {
		}

		@Test
		public void i() {
		}

		@Test
		public void j() {
		}
	}

	public static class SuperclassWithField {
		@Rule
		public MethodRule x;
	}

	public static class SubclassWithField extends SuperclassWithField {
		@Rule
		public MethodRule x;
	}

	@Test
	public void fieldsOnSubclassesShadowSuperclasses() {
		assertThat(new TestClass(SubclassWithField.class).getAnnotatedFields(
				Rule.class).size(), is(1));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/junit/framework/Assert.java;<<<<<<< MINE
	 * Asserts that an object is null.
=======
	 * Asserts that an object is null. If it isn't an {@link AssertionError} is
	 * thrown.
	 * Message contains: Expected: <null> but was: object
	 * 
	 * @param object
	 *            Object to check or <code>null</code>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/junit/framework/Assert.java;<<<<<<< MINE
		assertNull(null, object);
=======
		String message = "Expected: <null> but was: " + object.toString();
		assertNull(message, object);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/runners/model/InitializationError.java;<<<<<<< MINE
=======
	public InitializationError(Throwable error) {
		this(Arrays.asList(error));
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/runners/model/InitializationError.java;<<<<<<< MINE
		this(Arrays.<Throwable>asList(new Exception(string)));
=======
		this(new Exception(string));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/CategoryType.java;<<<<<<< MINE
=======
package org.junit.experimental.categories;

/**
 * Super-interface for all interface classes that are used to represent
 * categories.  Representing categories as types allows compile-time
 * checking of typos in category names, preventing accidental test
 * exclusion.
 */
public interface CategoryType {

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/CategoryClass.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.categories;

public interface CategoryClass {

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/Category.java;<<<<<<< MINE
=======
package org.junit.experimental.categories;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * Marks a test class or test method as belonging to one or more categories of tests.
 * The value is an array of interface classes that extend the {@link CategoryType}
 * superinterface.
 * 
 * This annotation is only interpreted by the Categories runner (at present).
 * 
 * For example:
<pre>
	public interface FastTests extends CategoryType {}
	public interface SlowTests extends CategoryType {}

	public static class A {
		@Test
		public void a() {
			fail();
		}

		@Category(SlowTests.class)
		@Test
		public void b() {
		}
	}

	@Category({SlowTests.class, FastTests.class})
	public static class B {
		@Test
		public void c() {

		}
	}
</pre>
 * 
 * For more usage, see code example on {@link Categories}.
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface Category {
	Class<? extends CategoryType>[] value();
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
=======
import org.junit.runner.Plan;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	
	// TODO: rename var
	public Test asTest(Plan plan) {
		if (plan.isSuite())
			return createTest(plan);
		else
			return asSingleTest(plan.getDescription());
	}

	private Test asSingleTest(Description description) {
		if (!containsKey(description))
			put(description, createSingleTest(description));
		return get(description);
=======

	public List<Test> asTestList(Plan plan) {
		Description description= plan.getDescription();
		if (description.isTest())
			return Arrays.asList(asTestCase(description));
		else {
			List<Test> returnThis= new ArrayList<Test>();
			for (Plan child : plan.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	Test createTest(Plan plan) {
		Description description= plan.getDescription();
		if (plan.isTest())
			return createSingleTest(description);
		else {
			TestSuite suite = new TestSuite(description.getDisplayName());
			for (Plan child : plan.getChildren())
				suite.addTest(asTest(child));
			return suite;
		}
=======
	public Test asTest(Plan plan) {
		Description description= plan.getDescription();
		if (description.isSuite())
			return asTestSuite(plan);
		else
			return asTestCase(description);
	}

	private Test asTestSuite(Plan plan) {
		return createTestSuite(plan);
	}

	private Test createTestSuite(Plan plan) {
		TestSuite suite= new TestSuite(plan.getDescription().getDisplayName());
		for (Plan child : plan.getChildren())
			suite.addTest(asTest(child));
		return suite;
	}
	
	private Test asTestCase(Description description) {
		if (!containsKey(description))
			put(description, createTestCase(description));
		return get(description);
	}

	private Test createTestCase(Description description) {
		return new JUnit4TestCaseFacade(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE

	public List<Test> asTestList(Plan plan) {
		if (plan.isTest())
			return Arrays.asList(asTest(plan));
		else {
			List<Test> returnThis = new ArrayList<Test>();
			for (Plan child : plan.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
		}
	}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();
=======
		fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		return fCache.asTestList(getDescription());
=======
		return fCache.asTestList(fRunner.getPlan());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		Description description= fRunner.getDescription();		
		return removeIgnored(description);
=======
		return fRunner.getDescription();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
	private Description removeIgnored(Description description) {
		if (isIgnored(description))
			return Description.EMPTY;
		Description result = description.childlessCopy();
		for (Description each : description.getChildren()) {
			Description child= removeIgnored(each);
			if (! child.isEmpty())
				result.addChild(child);
		}
		return result;
=======
	private Filter removeIgnored() {
		return new Filter() {			
			@Override
			public boolean shouldRun(Description description) {
				return !isIgnored(description);
			}
			
			@Override
			public String describe() {
				return "not ignored";
			}
		};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
import java.util.Iterator;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private Filter fFilter= null;
=======
	private List<T> fCachedChildren= null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: unpublic!
	public RunnerScheduler fScheduler= new RunnerScheduler() {
=======
	private RunnerScheduler fScheduler= new RunnerScheduler() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * @throws InitializationError 
=======
	 * 
	 * @throws InitializationError
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).
	 * Default implementation adds an error for each method annotated with
	 * {@code @BeforeClass} or {@code @AfterClass} that is not
	 * {@code public static void} with no arguments.
=======
	 * Adds to {@code errors} a throwable for each problem noted with the test
	 * class (available from {@link #getTestClass()}). Default implementation
	 * adds an error for each method annotated with {@code @BeforeClass} or
	 * {@code @AfterClass} that is not {@code public static void} with no
	 * arguments.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,
			boolean isStatic, List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(annotation);
=======
	protected void validatePublicVoidNoArgMethods(
			Class<? extends Annotation> annotation, boolean isStatic,
			List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(
				annotation);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	/** 
	 * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. 
	 * Here is an outline of the implementation:
=======
	/**
	 * Constructs a {@code Statement} to run all of the tests in the test class.
	 * Override to add pre-/post-processing. Here is an outline of the
	 * implementation:
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before the previous step; if any throws an
=======
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned
	 * by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this
	 * class and superclasses before the previous step; if any throws an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before any of the previous steps; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
=======
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this
	 * class and superclasses before any of the previous steps; all AfterClass
	 * methods are always executed: exceptions thrown by previous steps are
	 * combined, if necessary, with exceptions from AfterClass methods into a
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
	 * 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before executing {@code statement}; if any throws an
	 * Exception, stop execution and pass the exception on.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; if any throws an Exception, stop execution and pass the exception on.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> befores= fTestClass
=======
		List<FrameworkMethod> befores= getTestClass()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		return befores.isEmpty() ? statement :
			new RunBefores(statement, befores, null);
=======
		return befores.isEmpty() ? statement : new RunBefores(statement,
				befores, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before executing {@code statement}; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
	 * {@link MultipleFailureException}.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; all AfterClass methods are always executed: exceptions thrown by
	 * previous steps are combined, if necessary, with exceptions from
	 * AfterClass methods into a {@link MultipleFailureException}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> afters= fTestClass
=======
		List<FrameworkMethod> afters= getTestClass()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		return afters.isEmpty() ? statement : 
			new RunAfters(statement, afters, null);
=======
		return afters.isEmpty() ? statement : new RunAfters(statement, afters,
				null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: public?
	public void runChildren(final RunNotifier notifier) {
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
=======
	private void runChildren(final RunNotifier notifier) {
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (T child : getFilteredChildren())
=======
		for (T child : getCachedChildren())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		fFilter= filter;
=======
		for (Iterator<T> iter= getCachedChildren().iterator(); iter.hasNext();) {
			T each= iter.next();
			if (!filter.shouldRun(describeChild(each)))
				iter.remove();
			else
				try {
					filter.apply(each);
				} catch (NoTestsRemainException e) {
					iter.remove();
				}
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (T each : getChildren())
			if (shouldRun(each))
				return;
		throw new NoTestsRemainException();
=======
		if (getCachedChildren().isEmpty())
			throw new NoTestsRemainException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		fSorter= sorter;
=======
		Collections.sort(getCachedChildren(), comparator(sorter));
		for (T each : getCachedChildren()) {
			sorter.apply(each);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: public?
	public List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
=======
	private List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private Comparator<? super T> comparator() {
=======
	private Comparator<? super T> comparator(final Sorter sorter) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
				return fSorter.compare(describeChild(o1), describeChild(o2));
=======
				return sorter.compare(describeChild(o1), describeChild(o2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Sets a scheduler that determines the order and parallelization
	 * of children.  Highly experimental feature that may change.
=======
	 * Sets a scheduler that determines the order and parallelization of
	 * children. Highly experimental feature that may change.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		this.fScheduler = scheduler;
=======
		this.fScheduler= scheduler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runner/Plan.java;<<<<<<< MINE
package org.junit.runner;

import java.util.ArrayList;
import java.util.List;

public abstract class Plan {
	public abstract Description getDescription();
	public abstract List<Plan> getChildren();

	public static Plan fromDescription(final Description description) {
		return new Plan() {
			@Override
			public Description getDescription() {
				return description;
			}
			
			@Override
			public List<Plan> getChildren() {
				List<Description> childrenDescs= description.getChildrenInternal();
				ArrayList<Plan> children= new ArrayList<Plan>();
				for (Description each : childrenDescs)
					children.add(Plan.fromDescription(each));
				return children;
			}
		};
	}
	
	public boolean isSuite() {
		return getChildren().size() > 0;
	}
	
	public boolean isTest() {
		return !isSuite();
	}
}=======
package org.junit.runner;

import java.util.ArrayList;
import java.util.List;

public class Plan {
	private final Description fDescription;

	private Plan(Description description) {
		fDescription= description;
	}

	public Description getDescription() {
		return fDescription;
	}

	public List<Plan> getChildren() {
		ArrayList<Plan> results= new ArrayList<Plan>();
		ArrayList<Description> children= fDescription.getChildren();
		for (Description each : children)
			results.add(Plan.fromDescription(each));
		return results;
	}

	static Plan fromDescription(Description description) {
		return new Plan(description);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runner/Runner.java;<<<<<<< MINE

	public Plan getPlan() {
		return Plan.fromDescription(getDescription());
	}
=======
	
	public Plan getPlan() {
		return Plan.fromDescription(getDescription());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
=======
import org.junit.runner.Plan;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		findLeaves(null, request.getRunner().getDescription(), results);
=======
		findLeaves(null, request.getRunner().getPlan(), results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private void findLeaves(Plan parent, Plan plan, List<Description> results) {
		if (plan.getChildren().isEmpty())
			if (plan.getDescription().toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent.getDescription()));
=======
	private void findLeaves(Description parent, Plan plan, List<Description> results) {
		Description description = plan.getDescription();
		if (plan.getChildren().isEmpty())
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			for (Plan each : plan.getChildren())
				findLeaves(plan, each, results);
=======
			for (Plan each : plan.getChildren())
				findLeaves(description, each, results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
	
	@Test public void failIfEverythingIsIgnoredOut() {
=======

	// when executing as JUnit 3, ignored tests are stripped out before execution
	@Test
	public void descriptionAndRunNotificationsAreConsistent() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		assertEquals(1, result.getFailureCount());
=======

		Runner runner= Request.aClass(CompatibilityTest.class).getRunner();
		Description description= runner.getDescription();
		assertEquals(1, description.getChildren().size());
		assertEquals("initializationError", description.getChildren().get(0)
				.getMethodName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	static public Test createTest(Class<? extends TestCase> theClass, String name) {
		Constructor<? extends TestCase> constructor;
=======
	static public Test createTest(Class<?> theClass, String name) {
		Constructor<?> constructor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	public static Constructor<? extends TestCase> getTestConstructor(Class<? extends TestCase> theClass) throws NoSuchMethodException {
=======
	public static Constructor<?> getTestConstructor(Class<?> theClass) throws NoSuchMethodException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	 public TestSuite(final Class<? extends TestCase> theClass) {
=======
	public TestSuite(final Class<?> theClass) {
		addTestsFromTestCase(theClass);
	}

	private void addTestsFromTestCase(final Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
			addTest(new TestSuite(each.asSubclass(TestCase.class)));
=======
			addTest(testCaseForClass(each));
	}

	private Test testCaseForClass(Class<?> each) {
		if (TestCase.class.isAssignableFrom(each))
			return new TestSuite(each.asSubclass(TestCase.class));
		else
			return warning(each.getCanonicalName() + " does not extend TestCase");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	private void addTestMethod(Method m, List<String> names, Class<? extends TestCase> theClass) {
=======
	private void addTestMethod(Method m, List<String> names, Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/ThreeTestCases.java;<<<<<<< MINE
=======
package junit.tests.framework;

/**
 * Test class used in SuiteTest
 */
import junit.framework.TestCase;

public class ThreeTestCases extends TestCase {
	public void testCase() {
	}
	public void testCase2() {
	}
	public void testCase3thisTimeItsPersonal() {
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
=======
import java.util.Collections;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
=======
		suite.addTest(new SuiteTest("testOneTestCaseEclipseSeesSameStructureAs381"));		
		suite.addTest(new SuiteTest("testNoTestCaseClass"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
// This test case is obsolete, since the compiler will catch this error in 1.5
//	public void testNoTestCaseClass() {
//		Test t= new TestSuite(NoTestCaseClass.class);
//		t.run(fResult);
//		assertEquals(1, fResult.runCount());  // warning test
//		assertTrue(! fResult.wasSuccessful());
//	}
=======
	public void testNoTestCaseClass() {
		Test t= new TestSuite(NoTestCaseClass.class);
		t.run(fResult);
		assertEquals(1, fResult.runCount());  // warning test
		assertTrue(! fResult.wasSuccessful());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
		Test t= new TestSuite(OneTestCase.class);
=======
		TestSuite t= new TestSuite(OneTestCase.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
=======
	public void testOneTestCaseEclipseSeesSameStructureAs381() {
		TestSuite t= new TestSuite(ThreeTestCases 	.class);
		assertEquals(3, Collections.list(t.tests()).size());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	private static final long serialVersionUID= 1L;

	private static final JUnit4TestAdapterCache fInstance= new JUnit4TestAdapterCache();
=======
	private static final long serialVersionUID = 1L;
	private static final JUnit4TestAdapterCache fInstance = new JUnit4TestAdapterCache();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
=======
	
	public Test asTest(Description description) {
		if (description.isSuite())
			return createTest(description);
		else {
			if (!containsKey(description))
				put(description, createTest(description));
			return get(description);
		}
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	public List<Test> asTestList(Plan plan) {
		Description description= plan.getDescription();
=======
	Test createTest(Description description) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			return Arrays.asList(asTestCase(description));
=======
			return new JUnit4TestCaseFacade(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			List<Test> returnThis= new ArrayList<Test>();
			for (Plan child : plan.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
=======
			TestSuite suite = new TestSuite(description.getDisplayName());
			for (Description child : description.getChildren())
				suite.addTest(asTest(child));
			return suite;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
	public Test asTest(Plan plan) {
		Description description= plan.getDescription();
		if (description.isSuite())
			return asTestSuite(plan);
		else
			return asTestCase(description);
	}

	private Test asTestSuite(Plan plan) {
		return createTestSuite(plan);
	}

	private Test createTestSuite(Plan plan) {
		TestSuite suite= new TestSuite(plan.getDescription().getDisplayName());
		for (Plan child : plan.getChildren())
			suite.addTest(asTest(child));
		return suite;
	}
	
	private Test asTestCase(Description description) {
		if (!containsKey(description))
			put(description, createTestCase(description));
		return get(description);
	}

	private Test createTestCase(Description description) {
		return new JUnit4TestCaseFacade(description);
	}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
		RunNotifier notifier= new RunNotifier();
=======
		RunNotifier notifier = new RunNotifier();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
				result.addError(asTestCase(failure.getDescription()), failure
						.getException());
=======
				result.addError(asTest(failure.getDescription()), failure.getException());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			public void testFinished(Description description) throws Exception {
				result.endTest(asTestCase(description));
=======
			public void testFinished(Description description)
					throws Exception {
				result.endTest(asTest(description));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
			public void testStarted(Description description) throws Exception {
				result.startTest(asTestCase(description));
=======
			public void testStarted(Description description)
					throws Exception {
				result.startTest(asTest(description));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapterCache.java;<<<<<<< MINE
=======

	public List<Test> asTestList(Description description) {
		if (description.isTest())
			return Arrays.asList(asTest(description));
		else {
			List<Test> returnThis = new ArrayList<Test>();
			for (Description child : description.getChildren()) {
				returnThis.add(asTest(child));
			}
			return returnThis;
		}
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
	private final Runner fRunner;
=======
	private Runner fRunner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
	private final JUnit4TestAdapterCache fCache;
=======
	private JUnit4TestAdapterCache fCache;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		fRunner = Request.classWithoutSuiteMethod(newTestClass).filterWith(removeIgnored()).getRunner();
=======
		fRunner = Request.classWithoutSuiteMethod(newTestClass).getRunner();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		return fCache.asTestList(fRunner.getPlan());
=======
		return fCache.asTestList(getDescription());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
		return fRunner.getDescription();
=======
		Description description= fRunner.getDescription();		
		return removeIgnored(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/JUnit4TestAdapter.java;<<<<<<< MINE
	private Filter removeIgnored() {
		return new Filter() {			
			@Override
			public boolean shouldRun(Description description) {
				return !isIgnored(description);
			}
			
			@Override
			public String describe() {
				return "not ignored";
			}
		};
=======
	private Description removeIgnored(Description description) {
		if (isIgnored(description))
			return Description.EMPTY;
		Description result = description.childlessCopy();
		for (Description each : description.getChildren()) {
			Description child= removeIgnored(each);
			if (! child.isEmpty())
				result.addChild(child);
		}
		return result;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	static public Test createTest(Class<? extends TestCase> theClass, String name) {
		Constructor<? extends TestCase> constructor;
=======
	static public Test createTest(Class<?> theClass, String name) {
		Constructor<?> constructor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	public static Constructor<? extends TestCase> getTestConstructor(Class<? extends TestCase> theClass) throws NoSuchMethodException {
=======
	public static Constructor<?> getTestConstructor(Class<?> theClass) throws NoSuchMethodException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	 public TestSuite(final Class<? extends TestCase> theClass) {
=======
	public TestSuite(final Class<?> theClass) {
		addTestsFromTestCase(theClass);
	}

	private void addTestsFromTestCase(final Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
			addTest(new TestSuite(each.asSubclass(TestCase.class)));
=======
			addTest(testCaseForClass(each));
	}

	private Test testCaseForClass(Class<?> each) {
		if (TestCase.class.isAssignableFrom(each))
			return new TestSuite(each.asSubclass(TestCase.class));
		else
			return warning(each.getCanonicalName() + " does not extend TestCase");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/framework/TestSuite.java;<<<<<<< MINE
	private void addTestMethod(Method m, List<String> names, Class<? extends TestCase> theClass) {
=======
	private void addTestMethod(Method m, List<String> names, Class<?> theClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/junit/runner/Version.java;<<<<<<< MINE
		return "4.8.1";
=======
		return "4.8.2";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/rules/ExternalResource.java;<<<<<<< MINE
	 * 
	 * TODO: can assume here.
	 * 
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/rules/ExternalResource.java;<<<<<<< MINE
=======
	 * @throws if setup fails (which will disable {@code after}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
import java.util.Iterator;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	// TODO: does it has to be lazy?
	private Description fDescription= null;
=======
	private Filter fFilter= null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private List<T> fCachedChildren= null;
=======
	private Sorter fSorter= Sorter.NULL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private RunnerScheduler fScheduler= new RunnerScheduler() {
=======
	private RunnerScheduler fScheduler= new RunnerScheduler() {	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * 
	 * @throws InitializationError
=======
	 * @throws InitializationError 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Adds to {@code errors} a throwable for each problem noted with the test
	 * class (available from {@link #getTestClass()}). Default implementation
	 * adds an error for each method annotated with {@code @BeforeClass} or
	 * {@code @AfterClass} that is not {@code public static void} with no
	 * arguments.
=======
	 * Adds to {@code errors} a throwable for each problem noted with the test class (available from {@link #getTestClass()}).
	 * Default implementation adds an error for each method annotated with
	 * {@code @BeforeClass} or {@code @AfterClass} that is not
	 * {@code public static void} with no arguments.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	protected void validatePublicVoidNoArgMethods(
			Class<? extends Annotation> annotation, boolean isStatic,
			List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(
				annotation);
=======
	protected void validatePublicVoidNoArgMethods(Class<? extends Annotation> annotation,
			boolean isStatic, List<Throwable> errors) {
		List<FrameworkMethod> methods= getTestClass().getAnnotatedMethods(annotation);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	/**
	 * Constructs a {@code Statement} to run all of the tests in the test class.
	 * Override to add pre-/post-processing. Here is an outline of the
	 * implementation:
=======
	/** 
	 * Constructs a {@code Statement} to run all of the tests in the test class. Override to add pre-/post-processing. 
	 * Here is an outline of the implementation:
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned
	 * by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this
	 * class and superclasses before the previous step; if any throws an
=======
	 * <li>Call {@link #runChild(Object, RunNotifier)} on each object returned by {@link #getChildren()} (subject to any imposed filter and sort).</li>
	 * <li>ALWAYS run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before the previous step; if any throws an
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this
	 * class and superclasses before any of the previous steps; all AfterClass
	 * methods are always executed: exceptions thrown by previous steps are
	 * combined, if necessary, with exceptions from AfterClass methods into a
=======
	 * <li>ALWAYS run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before any of the previous steps; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * 
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; if any throws an Exception, stop execution and pass the exception on.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @BeforeClass} methods on this class
	 * and superclasses before executing {@code statement}; if any throws an
	 * Exception, stop execution and pass the exception on.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(
				BeforeClass.class);
		return befores.isEmpty() ? statement : new RunBefores(statement,
				befores, null);
=======
		List<FrameworkMethod> befores= fTestClass
				.getAnnotatedMethods(BeforeClass.class);
		return befores.isEmpty() ? statement :
			new RunBefores(statement, befores, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass}
	 * methods on this class and superclasses before executing {@code statement}
	 * ; all AfterClass methods are always executed: exceptions thrown by
	 * previous steps are combined, if necessary, with exceptions from
	 * AfterClass methods into a {@link MultipleFailureException}.
=======
	 * Returns a {@link Statement}: run all non-overridden {@code @AfterClass} methods on this class
	 * and superclasses before executing {@code statement}; all AfterClass methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from AfterClass methods into a
	 * {@link MultipleFailureException}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		List<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(
				AfterClass.class);
		return afters.isEmpty() ? statement : new RunAfters(statement, afters,
				null);
=======
		List<FrameworkMethod> afters= fTestClass
				.getAnnotatedMethods(AfterClass.class);
		return afters.isEmpty() ? statement : 
			new RunAfters(statement, afters, null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (final T each : getCachedChildren())
			fScheduler.schedule(new Runnable() {
=======
		for (final T each : getFilteredChildren())
			fScheduler.schedule(new Runnable() {			
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		if (fDescription == null) {
			// TODO: extract createDescription?
			fDescription= Description.createSuiteDescription(getName(), fTestClass.getAnnotations());
			for (T child : getCachedChildren())
				fDescription.addChild(describeChild(child));
		}
		return fDescription;
=======
		Description description= Description.createSuiteDescription(getName(),
				fTestClass.getAnnotations());
		for (T child : getFilteredChildren())
			description.addChild(describeChild(child));
		return description;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		for (Iterator<T> iter= getCachedChildren().iterator(); iter.hasNext();) {
			T each= iter.next();
			if (!filter.shouldRun(describeChild(each)))
				iter.remove();
			else
				try {
					filter.apply(each);
				} catch (NoTestsRemainException e) {
					iter.remove();
				}
		}
=======
		fFilter= filter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		fDescription = null;
		
		if (getCachedChildren().isEmpty())
			throw new NoTestsRemainException();
=======
		for (T each : getChildren())
			if (shouldRun(each))
				return;
		throw new NoTestsRemainException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		Collections.sort(getCachedChildren(), comparator(sorter));
		for (T each : getCachedChildren()) {
			sorter.apply(each);
		}
=======
		fSorter= sorter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private List<T> getCachedChildren() {
		if (fCachedChildren == null)
			fCachedChildren= getChildren();
		return fCachedChildren;
=======
	private List<T> getFilteredChildren() {
		ArrayList<T> filtered= new ArrayList<T>();
		for (T each : getChildren())
			if (shouldRun(each))
				try {
					filterChild(each);
					sortChild(each);
					filtered.add(each);
				} catch (NoTestsRemainException e) {
					// don't add it
				}
		Collections.sort(filtered, comparator());
		return filtered;
	}

	private void sortChild(T child) {
		fSorter.apply(child);
	}

	private void filterChild(T child) throws NoTestsRemainException {
		if (fFilter != null)
			fFilter.apply(child);
	}

	private boolean shouldRun(T each) {
		return fFilter == null || fFilter.shouldRun(describeChild(each));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	private Comparator<? super T> comparator(final Sorter sorter) {
=======
	private Comparator<? super T> comparator() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
				return sorter.compare(describeChild(o1), describeChild(o2));
=======
				return fSorter.compare(describeChild(o1), describeChild(o2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
	 * Sets a scheduler that determines the order and parallelization of
	 * children. Highly experimental feature that may change.
=======
	 * Sets a scheduler that determines the order and parallelization
	 * of children.  Highly experimental feature that may change.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
		this.fScheduler= scheduler;
=======
		this.fScheduler = scheduler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		Description description= Description.createTestDescription(
				getTestClass().getJavaClass(), testName(method), method
						.getAnnotations());
		description.setParent(getDescription());
		return description;
=======
		return Description.createTestDescription(getTestClass().getJavaClass(),
				testName(method), method.getAnnotations());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/JUnitCore.java;<<<<<<< MINE
			fNotifier.fireTestRunStarted(runner.getPlan());
=======
			fNotifier.fireTestRunStarted(runner.getDescription());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
 * The canonical case of filtering is when you want to run a single test method
 * in a class. Rather than introduce runner API just for that one case, JUnit
 * provides a general filtering mechanism.
 * 
 * If you want to filter the tests to be run, extend <code>Filter</code> and
 * apply an instance of your filter to the {@link org.junit.runner.Request}
 * before running it (see {@link org.junit.runner.JUnitCore#run(Request)}.
 * 
 * Alternatively, apply a <code>Filter</code> to a
 * {@link org.junit.runner.Runner} before running tests (for example, in
 * conjunction with {@link org.junit.runner.RunWith}.
=======
 * The canonical case of filtering is when you want to run a single test method in a class. Rather
 * than introduce runner API just for that one case, JUnit provides a general filtering mechanism.
 * If you want to filter the tests to be run, extend <code>Filter</code> and apply an instance of
 * your filter to the {@link org.junit.runner.Request} before running it (see 
 * {@link org.junit.runner.JUnitCore#run(Request)}. Alternatively, apply a <code>Filter</code> to 
 * a {@link org.junit.runner.Runner} before running tests (for example, in conjunction with 
 * {@link org.junit.runner.RunWith}.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
				// TODO: DUP!
				return description.isSuite() || desiredDescription.equals(description);
=======
				if (description.isTest())
					return desiredDescription.equals(description);
				
				// explicitly check if any children want to run
				for (Description each : description.getChildren())
					if (shouldRun(each))
						return true;
				return false;					
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
	 * Indicates how to prune the tree of tests. The meaning of the boolean
	 * returned depends on whether {@code description} describes a leaf in the
	 * test tree ({@code Description.isTest} is true), or a suite ({@code
	 * Description.isSuite} is true).
	 * 
	 * If {@code description} is a leaf, then {@code shouldRun} returns false
	 * iff the test represented should not be run.
	 * 
	 * If {@code description} is a suite, then {@code shouldRun} may return
	 * false if it is cheap to determine that no leaf recursively included by
	 * this suite should be run. However, {@code shouldRun} may return true for
	 * a suite, and yet return false for every member of that suite, in which
	 * case the suite should throw {@link NoTestsRemainException} from the
	 * {@code filter} method.
	 *
	 * I apologize for any inconvenience caused by this specification. 
	 * 
	 * @param description
	 *            the description of the test to be run
	 * @return <code>true</code> if the test should be run.
	 * @author saff
=======
	 * @param description the description of the test to be run
	 * @return <code>true</code> if the test should be run
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
	 * 
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/manipulation/Filter.java;<<<<<<< MINE
	 * Invoke with a {@link org.junit.runner.Runner} to cause all tests it
	 * intends to run to first be checked with the filter. Only those that pass
	 * the filter will be run.
	 * 
	 * @param child
	 *            the runner to be filtered by the receiver
	 * @throws NoTestsRemainException
	 *             if the receiver removes all tests
=======
	 * Invoke with a {@link org.junit.runner.Runner} to cause all tests it intends to run
	 * to first be checked with the filter. Only those that pass the filter will be run.
	 * @param child the runner to be filtered by the receiver
	 * @throws NoTestsRemainException if the receiver removes all tests
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
import java.util.List;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
 * TODO: Make really clear how this has changed.
 * 
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	// This is vestigial
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE

	private final String fDisplayName;	
=======
	private final String fDisplayName;
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	private Description fParent = null;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
		// TODO: deprecate this, too
		fChildren.add(description);
		// description.setParent(this);
	}

	public void setParent(Description parent) {
		fParent = parent;
=======
		getChildren().add(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	 * @deprecated Description should not be used for walking the test tree.
	 * Instead, call {@code Runner.getPlan} to get a {@code Plan}, and use
	 * {@code Plan.getChildren}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE
	@Deprecated public ArrayList<Description> getChildren() {
=======
	public ArrayList<Description> getChildren() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Description.java;<<<<<<< MINE

	List<Description> getChildrenInternal() {
		return fChildren;
	}

	public Description getParentDescription() {
		return fParent;
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;<<<<<<< MINE
	 * @deprecated override {@link RunListener#testRunStarted(Plan)} instead.
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;<<<<<<< MINE
	@Deprecated
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunListener.java;<<<<<<< MINE

	/**
	 * Called before any tests have been run.
	 * @param plan describes the tests to be run
	 */
	public void testRunStarted(Plan plan) throws Exception {
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunNotifier.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunNotifier.java;<<<<<<< MINE
	public void fireTestRunStarted(final Plan plan) {
		new SafeNotifier() {
			@SuppressWarnings("deprecation")
			@Override
			protected void notifyListener(RunListener each) throws Exception {
				each.testRunStarted(plan);
				each.testRunStarted(plan.getDescription());
			};
		}.run();
	}
	
	/**
	 * Do not invoke.  Really, don't!
	 * @deprecated Call {@link RunNotifier#fireTestRunStarted(Plan)} if you must.
	 *             But don't.
	 */
	@Deprecated
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/notification/RunNotifier.java;<<<<<<< MINE
	
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Runner.java;<<<<<<< MINE
	private Description fParent = null;
	
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/runner/Runner.java;<<<<<<< MINE
	
	public Plan getPlan() {
		return Plan.fromDescription(getDescription());
	}
	
	public void setParent(Description parent) {
		fParent= parent;
	}
	
	protected Description getParent() {
		return fParent;
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
		findLeaves(null, request.getRunner().getPlan(), results);
=======
		findLeaves(null, request.getRunner().getDescription(), results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
	private void findLeaves(Plan parent, Plan plan, List<Description> results) {
		if (plan.getChildren().isEmpty())
			if (plan.getDescription().toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent.getDescription()));
=======
	private void findLeaves(Description parent, Description description, List<Description> results) {
		if (description.getChildren().isEmpty())
			if (description.toString().equals("warning(junit.framework.TestSuite$1)"))
				results.add(Description.createSuiteDescription(MALFORMED_JUNIT_3_TEST_CLASS_PREFIX + parent));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
				results.add(plan.getDescription());
=======
				results.add(description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
			for (Plan each : plan.getChildren())
				findLeaves(plan, each, results);
=======
			for (Description each : description.getChildren())
				findLeaves(description, each, results);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/PotentialAssignment.java;<<<<<<< MINE
	public static PotentialAssignment forValue(final Object value) {
		return forValue(value.toString(), value);
	}
	
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
=======
import org.junit.runners.model.TestClass;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
		return new TheoryAnchor(method);
=======
		return new TheoryAnchor(method, getTestClass());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
	// TODO: this should be static
	public class TheoryAnchor extends Statement {
=======
	public static class TheoryAnchor extends Statement {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
=======
        private TestClass fTestClass;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
		public TheoryAnchor(FrameworkMethod method) {
=======
		public TheoryAnchor(FrameworkMethod method, TestClass testClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
=======
            fTestClass= testClass;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
=======
        private TestClass getTestClass() {
            return fTestClass;
        }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/ThreeTestCases.java;<<<<<<< MINE
=======
package junit.tests.framework;

/**
 * Test class used in SuiteTest
 */
import junit.framework.TestCase;

public class ThreeTestCases extends TestCase {
	public void testCase() {
	}
	public void testCase2() {
	}
	public void testCase3thisTimeItsPersonal() {
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
=======
import java.util.Collections;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
=======
		suite.addTest(new SuiteTest("testOneTestCaseEclipseSeesSameStructureAs381"));		
		suite.addTest(new SuiteTest("testNoTestCaseClass"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
// This test case is obsolete, since the compiler will catch this error in 1.5
//	public void testNoTestCaseClass() {
//		Test t= new TestSuite(NoTestCaseClass.class);
//		t.run(fResult);
//		assertEquals(1, fResult.runCount());  // warning test
//		assertTrue(! fResult.wasSuccessful());
//	}
=======
	public void testNoTestCaseClass() {
		Test t= new TestSuite(NoTestCaseClass.class);
		t.run(fResult);
		assertEquals(1, fResult.runCount());  // warning test
		assertTrue(! fResult.wasSuccessful());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
		Test t= new TestSuite(OneTestCase.class);
=======
		TestSuite t= new TestSuite(OneTestCase.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/SuiteTest.java;<<<<<<< MINE
=======
	public void testOneTestCaseEclipseSeesSameStructureAs381() {
		TestSuite t= new TestSuite(ThreeTestCases 	.class);
		assertEquals(3, Collections.list(t.tests()).size());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java;<<<<<<< MINE
		Plan plan = runner.getPlan();
		assertEquals(1, plan.getChildren().size());
=======
		Description description = runner.getDescription();
		assertEquals(1, description.getChildren().size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/manipulation/SingleMethodTest.java;<<<<<<< MINE
		int testCount= Request.method(HasSuiteMethod.class, "a").getRunner().testCount();
=======
		int testCount= Request.method(HasSuiteMethod.class, "a").getRunner().getDescription().testCount();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
	public void testCountsMatchUp() {
		JUnitCore core= new JUnitCore();
		Request filtered= Request.aClass(AllTests.class).filterWith(
				new Filter() {
					@Override
					public boolean shouldRun(Description description) {
						return !description.toString().contains("Max");
					}

					@Override
					public String describe() {
						return "Avoid infinite recursion";
					}
				});
		int maxCount= fMax.run(filtered, core).getRunCount();
		int coreCount= core.run(filtered).getRunCount();
		assertEquals(coreCount, maxCount);
	}

	@Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;<<<<<<< MINE
		assertThat(new Theories(HasATheory.class).getPlan().getChildren()
				.size(), is(1));
=======
		assertThat(new Theories(HasATheory.class).getDescription()
				.getChildren().size(), is(1));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/runner/UnsuccessfulWithDataPointFields.java;<<<<<<< MINE
		assertThat(testResult(TheoriesMustBePublic.class),
=======
		assertThat(
				testResult(TheoriesMustBePublic.class),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;<<<<<<< MINE
=======
import org.junit.runners.model.TestClass;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;<<<<<<< MINE
		return new StubbedTheoryAnchor(method);
=======
		return new StubbedTheoryAnchor(method, getTestClass());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;<<<<<<< MINE
	public class StubbedTheoryAnchor extends TheoryAnchor {
		public StubbedTheoryAnchor(FrameworkMethod method) {
			super(method);
=======
	public static class StubbedTheoryAnchor extends TheoryAnchor {
		public StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass) {
			super(method, testClass);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE
import org.junit.Ignore;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	public static class Category1 {
	}

	public static class Category2 {
	}

=======
	
	public static class Category1 {}
	public static class Category2 {}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE
		@Test
		public void noCategory() {
		}

		@Category(Category1.class)
		@Test
		public void justCategory1() {
		}

		@Category(Category2.class)
		@Test
		public void justCategory2() {
		}

		@Category( { Category1.class, Category2.class })
		@Test
		public void both() {
		}

		@Category( { Category2.class, Category1.class })
		@Test
		public void bothReversed() {
		}
=======
		@Test public void noCategory() {}
		@Category(Category1.class) @Test public void justCategory1() {}
		@Category(Category2.class) @Test public void justCategory2() {}
		@Category({Category1.class, Category2.class}) @Test public void both() {}
		@Category({Category2.class, Category1.class}) @Test public void bothReversed() {}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE
		@Category( { FastTests.class, SlowTests.class })
=======
		@Category({FastTests.class, SlowTests.class})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	@Test
	public void runMethodWithTwoCategories() {
=======
	
	@Test public void runMethodWithTwoCategories() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	@Test
	public void subclassesOfIncludedCategoriesAreRun() {
=======
	
	@Test public void subclassesOfIncludedCategoriesAreRun() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE
		@Category(ClassAsCategory.class)
		@Test
		public void a() {
		}
=======
		@Category(ClassAsCategory.class) @Test public void a() {}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	@Test
	public void classesCanBeCategories() {
=======
	
	@Test public void classesCanBeCategories() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE
	
	public static class LeafClass {
		@Test public void a() {}
	}
	
	@RunWith(Suite.class)
	@Category(String.class)
	@SuiteClasses({LeafClass.class})
	public static class CategorizedSuite {
	}
	
	@RunWith(Categories.class)
	@IncludeCategory(String.class)
	@SuiteClasses({CategorizedSuite.class})
	public static class ParentSuite {
	}
	
	@Ignore @Test public void categoriesOnSuiteTrickleDown() {
		assertThat(testResult(ParentSuite.class), isSuccessful());
		Result result= new JUnitCore().run(ParentSuite.class);
		assertEquals(1, result.getRunCount());
		assertEquals(0, result.getFailureCount());
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
=======
import org.junit.runner.Description;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
import org.junit.runner.Runner;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void makeSureSuiteIsCalled() {
=======
	
	@Test public void makeSureSuiteIsCalled() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		@Test
		public void sample() {
=======
		@Test public void sample() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void makeSureSuiteWorksWithJUnit4Classes() {
=======
	
	@Test public void makeSureSuiteWorksWithJUnit4Classes() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		@Ignore
		@Test
=======
		@Ignore	@Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

		Runner runner= Request.aClass(CompatibilityTest.class).getRunner();
		Plan plan= runner.getPlan();
		assertEquals(1, plan.getChildren().size());
		assertEquals("initializationError", plan.getChildren().get(0).getDescription()
				.getMethodName());
=======
		
		Description description= Request.aClass(CompatibilityTest.class).getRunner().getDescription();
		assertEquals(0, description.getChildren().size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE
		@Test
		public void sample() {
=======
		@Test public void sample() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void suiteIsUsedWithJUnit4Classes() {
=======
	
	@Test public void suiteIsUsedWithJUnit4Classes() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

		@Test
		public void sample() {
=======
		
		@Test public void sample() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

		@Ignore
		@Test
		public void ignore() {
=======
		
		@Ignore @Test public void ignore() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/junit3compatibility/SuiteMethodTest.java;<<<<<<< MINE

	@Test
	public void makeSureSuiteNotUsedWithJUnit4Classes2() {
=======
	
	@Test public void makeSureSuiteNotUsedWithJUnit4Classes2() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;<<<<<<< MINE
=======
import org.junit.runner.Description;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/running/classes/ParameterizedTestTest.java;<<<<<<< MINE
		Plan plan= runner.getPlan();
		assertEquals("[0]", plan.getChildren().get(0).getDescription().getDisplayName());
=======
		Description description= runner.getDescription();
		assertEquals("[0]", description.getChildren().get(0).getDisplayName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/listening/TestListenerTest.java;<<<<<<< MINE
import static org.junit.Assert.assertTrue;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/listening/TestListenerTest.java;<<<<<<< MINE
import org.junit.runner.Plan;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/listening/TestListenerTest.java;<<<<<<< MINE
	

	@Test public void callPlanVersionOfTestRunStarted() {
		JUnitCore core= new JUnitCore();
		
		final boolean[] wasCalled= new boolean[1];
		wasCalled[0]= false;
		core.addListener(new RunListener() {
			@Override
			public void testRunStarted(Plan plan) throws Exception {
				wasCalled[0]= true;
			}
		});
		core.run(OneTest.class);
		assertTrue(wasCalled[0]);
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
import static org.junit.Assert.assertNotNull;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
import org.junit.runner.Description;
import org.junit.runner.Request;
import org.junit.runner.RunWith;
import org.junit.runner.manipulation.Filter;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
import org.junit.runners.Suite;
import org.junit.runners.Suite.SuiteClasses;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
	
	@RunWith(Suite.class)
	@SuiteClasses({FruitTest.class})
	public static class FruitSuite {
		
	}
	
	@Test public void saneBehaviorWhenNoTestsShouldRun() {
		Filter nothing= new Filter() {			
			@Override
			public boolean shouldRun(Description description) {
				return false;
			}
			
			@Override
			public String describe() {
				return "nothing";
			}
		};
		assertNotNull(Request.aClass(FruitSuite.class).filterWith(nothing).getRunner());
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_63f40a8_ab51452/rev_63f40a8-ab51452/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	
	/**
	 * @return the MethodRules that can transform the block
	 * that runs each method in the tested class.
	 */
	protected List<MethodRule> rules(Object test) {
		List<MethodRule> results= new ArrayList<MethodRule>();
		for (FrameworkField each : ruleFields()) {
			if (MethodRule.class.isAssignableFrom(each.getType())) {
				results.add(createRule(test, each));
			}
		}
		return results;
	}

	private MethodRule createRule(Object test,
			FrameworkField each) {
		try {
			return (MethodRule) each.get(test);
		} catch (IllegalAccessException e) {
			throw new RuntimeException(
					"How did getFields return a field we couldn't access?");
		}
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/rules/ClassRule.java;<<<<<<< MINE
=======
/**
 * Created Oct 19, 2009
 */
package org.junit.rules;

import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;

/**
 * A ClassRule is the class-level analogue to a
 * {@link org.junit.rules.MethodRule}.
 * 
 * @author Alistair A. Israel
 */
public interface ClassRule {

	/**
	 * Modifies the class-running {@link Statement} to implement an additional,
	 * class-level test-running rule.
	 * 
	 * @param base
	 *            The {@link Statement} to be modified
	 * @param method
	 *            The {@link TestClass} to be run
	 * @return a new statement, which may be the same as {@code base}, a wrapper
	 *         around {@code base}, or a completely new Statement.
	 */
	Statement apply(Statement base, TestClass testClass);

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
import org.junit.Rule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
import org.junit.rules.ClassRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
import org.junit.runners.model.FrameworkField;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
		statement= withClassRules(statement);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
=======
	 * Returns a {@link Statement}: apply all static {@link ClassRule} fields
	 * annotated with {@link Rule}.
	 *
	 * @param statement
	 *            the base statement
	 * @return a WithClassRules statement if any class-level {@link Rule}s are
	 *         found, or the base statement
	 */
	private Statement withClassRules(Statement statement) {
		final List<ClassRule> classRules= classRules();
		if (classRules.isEmpty()) {
			return statement;
		}
		Statement next = statement;
		for (final ClassRule classRule : classRules) {
			next = classRule.apply(next, fTestClass);
		}
		return next;
	}

	/**
	 * @return the {@code ClassRule}s that can transform the block that runs
	 *         each method in the tested class.
	 */
	protected List<ClassRule> classRules() {
		final List<ClassRule> results= new ArrayList<ClassRule>();
		for (FrameworkField field : ruleFields()) {
			if (ClassRule.class.isAssignableFrom(field.getType())) {
				results.add(getClassRule(field));
			}
		}
		return results;
	}

	private ClassRule getClassRule(final FrameworkField field) {
		try {
			return (ClassRule) field.get(null);
		} catch (IllegalAccessException e) {
			throw new RuntimeException(
					"How did getAnnotatedFields return a field we couldn't access?");
		}
	}

	/**
	 * @return list of {@link FrameworkField}s annotated with {@link Rule}
	 */
	protected List<FrameworkField> ruleFields() {
		return fTestClass.getAnnotatedFields(Rule.class);
	}

	/**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/ParentRunner.java;<<<<<<< MINE
			fScheduler.schedule(new Runnable() {			
=======
 			fScheduler.schedule(new Runnable() {			
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
=======
	 * @return the underlying Java Field type
	 * @see java.lang.reflect.Field#getType()
	 */
	public Class<?> getType() {
		return fField.getType();
	}

	/**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
import org.junit.rules.ClassRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		if (!MethodRule.class.isAssignableFrom(field.getType()))
			errors.add(new Exception("Field " + field.getName()
					+ " must implement MethodRule"));
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
=======
		if (!MethodRule.class.isAssignableFrom(field.getType())) {
			if (ClassRule.class.isAssignableFrom(field.getType())) {
				if (!Modifier.isStatic(field.getModifiers())) {
					errors.add(new Exception("Field " + field.getName()
							+ " must be static"));
				}
			} else {
				errors.add(new Exception("Field " + field.getName()
						+ " must implement MethodRule or ClassRule"));
			}
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
		for (FrameworkField each : ruleFields())
			results.add(createRule(test, each));
=======
		for (FrameworkField each : ruleFields()) {
			if (MethodRule.class.isAssignableFrom(each.getType())) {
				results.add(createRule(test, each));
			}
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	private List<FrameworkField> ruleFields() {
		return getTestClass().getAnnotatedFields(Rule.class);
	}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/test/java/org/junit/tests/experimental/rules/ClassRulesTest.java;<<<<<<< MINE
=======
/**
 * Created Oct 19, 2009
 */
package org.junit.tests.experimental.rules;

import static org.junit.Assert.assertFalse;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ClassRule;
import org.junit.runner.JUnitCore;
import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;

/**
 * Tests to exercise class-level rules.
 */
public class ClassRulesTest {

	private static int runCount;

	public static class ExampleTestWithClassRule {

		@Rule
		public static ClassRule classRule= new ClassRule() {

			public Statement apply(final Statement base,
					final TestClass testClass) {
				return new Statement() {

					@Override
					public void evaluate() throws Throwable {
						++runCount;
						base.evaluate();
					}
				};
			}
		};

		@Test
		public void firstTest() {
			assertFalse("ClassRule was not applied!", runCount == 0);
			assertFalse("ClassRule was applied more than once!", runCount > 1);
		}

		@Test
		public void secondTest() {
			assertFalse("ClassRule was not applied!", runCount == 0);
			assertFalse("ClassRule was applied more than once!", runCount > 1);
		}
	}

	@Test
	public void ruleIsAppliedOnce() {
		runCount= 0;
		JUnitCore.runClasses(ExampleTestWithClassRule.class);
		assertFalse("ClassRule was not applied!", runCount == 0);
		assertFalse("ClassRule was applied more than once!", runCount > 1);
	}

	public static class SubclassOfTestWithClassRule extends
			ExampleTestWithClassRule {

	}

	@Test
	public void ruleIsIntroducedAndEvaluatedOnSubclass() {
		runCount= 0;
		JUnitCore.runClasses(SubclassOfTestWithClassRule.class);
		assertFalse("ClassRule was not applied!", runCount == 0);
		assertFalse("ClassRule was applied more than once!", runCount > 1);
	}

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
import org.junit.tests.experimental.rules.ClassRulesTest;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
=======
	ClassRulesTest.class,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_5f25ca3_bed58a5/rev_5f25ca3-bed58a5/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
 * ways.  {@link org.junit.Rule} annotates method-level 
 * {@link TestRule}s, and {@link org.junit.ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
=======
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See the Javadoc for those annotations
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f27f809_d97f30a/rev_f27f809-d97f30a/src/test/java/redis/clients/jedis/tests/SharedJedisPipelineTest.java;<<<<<<< MINE
=======
package redis.clients.jedis.tests;

import org.junit.Before;
import org.junit.Test;
import redis.clients.jedis.*;
import redis.clients.jedis.exceptions.JedisDataException;

import java.io.UnsupportedEncodingException;
import java.util.*;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();

        JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.host, redis1.port);
        JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.host, redis2.port);
        shardInfo1.setPassword("foobared");
        shardInfo2.setPassword("foobared");
        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(shardInfo1);
        shards.add(shardInfo2);
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));
    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(new Double(2), zincrby.get());
        assertEquals(new Long(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_0781e97_7f6173a/rev_0781e97-7f6173a/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
 * ways.  {@link org.junit.Rule} annotates method-level 
 * {@link TestRule}s, and {@link org.junit.ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
=======
 * ways.  {@link Rule} annotates method-level {@link TestRule}s, and {@link ClassRule} 
 * annotates class-level {@link TestRule}s.  See javadoc for those annotations
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_cb1b19b_04f6038/rev_cb1b19b-04f6038/src/test/java/redis/clients/jedis/tests/SharedJedisPipelineTest.java;<<<<<<< MINE
=======
package redis.clients.jedis.tests;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import org.junit.Before;
import org.junit.Test;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.Response;
import redis.clients.jedis.ShardedJedis;
import redis.clients.jedis.ShardedJedisPipeline;
import redis.clients.jedis.Tuple;
import redis.clients.jedis.exceptions.JedisDataException;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.flushAll();
        jedis.disconnect();

        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(new JedisShardInfo(redis1.host, redis1.port));
        shards.add(new JedisShardInfo(redis2.host, redis2.port));
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(Double.valueOf(2), zincrby.get());
        assertEquals(Long.valueOf(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e857122_9d8bb06/rev_e857122-9d8bb06/src/main/java/org/junit/rules/TestRule.java;<<<<<<< MINE
	protected abstract Statement apply(Statement base, Description description);
=======
	Statement apply(Statement base, Description description);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e857122_9d8bb06/rev_e857122-9d8bb06/src/main/java/org/junit/rules/TestWatcher.java;<<<<<<< MINE
public abstract class TestWatcher extends TestRule {
	@Override
	protected Statement apply(final Statement base, final Description description) {
=======
public class TestWatcher implements TestRule {
	public Statement apply(final Statement base, final Description description) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e857122_9d8bb06/rev_e857122-9d8bb06/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
import org.junit.rules.RunRules;
=======
import org.junit.rules.MethodRule;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_fb723db_72ca494/rev_fb723db-72ca494/src/main/java/redis/clients/jedis/Response.java;<<<<<<< MINE
        	if (data instanceof JedisDataException){
        		throw new JedisDataException((JedisDataException)data);
=======
        	if(data != null ){
	        	if (data instanceof JedisDataException){
	        		throw new JedisDataException((JedisDataException)data);
	        	}
	            response = builder.build(data);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_fb723db_72ca494/rev_fb723db-72ca494/src/main/java/redis/clients/jedis/Response.java;<<<<<<< MINE
            response = builder.build(data);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_fb723db_72ca494/rev_fb723db-72ca494/src/test/java/redis/clients/jedis/tests/PipeliningTest.java;<<<<<<< MINE
=======
    
    @Test
    public void pipelineResponseWithData() {
        jedis.zadd("zset", 1, "foo");
        
        Pipeline p = jedis.pipelined();
        Response<Double> score = p.zscore("zset", "foo");
        p.sync();

        assertNotNull(score.get());    
    }
    
    @Test
    public void pipelineResponseWithoutData() {
        jedis.zadd("zset", 1, "foo");
        
        Pipeline p = jedis.pipelined();
        Response<Double> score = p.zscore("zset", "bar");
        p.sync();

        assertNull(score.get());
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_708ed37_9d8bb06/rev_708ed37-9d8bb06/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
import org.junit.internal.AssumptionViolatedException;
import org.junit.internal.runners.model.EachTestNotifier;
=======
import org.junit.internal.runners.model.MultipleFailureException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
    
    /**
     * Evaluates scripts using the Lua interpreter built into Redis starting from version 2.6.0.
     * <p>
     * 
     * @return Script result
     */
	public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	    client.setTimeoutInfinite();
        client.eval(script, toByteArray(keys.size()), getParams(keys, args));
        return client.getOne();
	}
	private byte[][] getParams(List<byte[]> keys, List<byte[]> args){
    	int keyCount = keys.size();
    	byte[][] params = new byte[keyCount + args.size()][];
    	
    	for(int i=0;i<keyCount;i++)
    		params[i] = keys.get(i);
    	
    	for(int i=0;i<keys.size();i++)
    		params[keyCount + i] = args.get(i);
    	
    	return params;
    }
	public Object eval(byte[] script, byte[] keyCount, byte[][] params) {
	    client.setTimeoutInfinite();
        client.eval(script, keyCount, params);
        return client.getOne();
	}
	
	public byte[] scriptFlush(){
    	client.scriptFlush();
    	return client.getBinaryBulkReply();
    }
	
    public List<Long> scriptExists(byte[]... sha1){
		client.scriptExists(sha1);
		return client.getIntegerMultiBulkReply();
    }
    
    public byte[] scriptLoad(byte[] script){
    	client.scriptLoad(script);
    	return client.getBinaryBulkReply();
    }
    
    public byte[] scriptKill(){
    	client.scriptKill();
    	return client.getBinaryBulkReply();
    }
=======
    
	public byte[] slowlogReset() {
		client.slowlogReset();
		return client.getBinaryBulkReply();
	}
	
	public long slowlogLen() {
		client.slowlogLen();
		return client.getIntegerReply();
	}
	
	public List<byte[]> slowlogGetBinary() {
		client.slowlogGet();
		return client.getBinaryMultiBulkReply();
	}
	
	public List<byte[]> slowlogGetBinary(long entries) {
		client.slowlogGet(entries);
		return client.getBinaryMultiBulkReply();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    
    private void sendEvalCommand(Command command, byte[] script, byte[] keyCount, byte[][] params){
    	
    	final byte[][] allArgs = new byte[params.length + 2][];
    	
    	allArgs[0] = script;
    	allArgs[1] = keyCount;
    	
    	for(int i=0;i<params.length; i++)
    		allArgs[i+2] = params[i];
    	
    	sendCommand(command, allArgs );
    }
    
    public void eval(byte[] script, byte[] keyCount, byte[][] params){
    	sendEvalCommand(EVAL, script, keyCount, params );
    }
    
    public void evalsha(byte[] sha1, byte[] keyCount, byte[][] params){
    	sendEvalCommand(EVALSHA, sha1, keyCount, params);
    }
    
    public void scriptFlush(){
    	sendCommand(SCRIPT, Keyword.FLUSH.raw);
    }
    
    public void scriptExists(byte[]... sha1){
    	byte[][] args = new byte[sha1.length + 1][];
    	args[0] = Keyword.EXISTS.raw;
    	for(int i=0;i<sha1.length; i++)
    		args[i+1] = sha1[i];
    	
    	sendCommand(SCRIPT, args);
    }
    
    public void scriptLoad(byte[] script){
    	sendCommand(SCRIPT, Keyword.LOAD.raw, script);
    }
    
    public void scriptKill(){
    	sendCommand(SCRIPT, Keyword.KILL.raw);
    }
=======

	public void slowlogGet() {
		sendCommand(SLOWLOG, Keyword.GET.raw);
	}
	
	public void slowlogGet(long entries) {
		sendCommand(SLOWLOG, Keyword.GET.raw, toByteArray(entries));
	}
	
	public void slowlogReset() {
		sendCommand(SLOWLOG, RESET.raw);
	}
	
	public void slowlogLen() {
		sendCommand(SLOWLOG, LEN.raw);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import redis.clients.util.SafeEncoder;
=======
import redis.clients.util.Slowlog;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    }

    public Object eval(String script, int keyCount, String... params) {
    	client.setTimeoutInfinite();
        client.eval(script, keyCount, params);
        
        return getEvalResult();
    }
	
    private String[] getParams(List<String> keys, List<String> args){
    	int keyCount = keys.size();
		int argCount = args.size();
    	
    	String[] params = new String[keyCount + args.size()];
    	
    	for(int i=0;i<keyCount;i++)
    		params[i] = keys.get(i);
    	
    	for(int i=0;i<argCount;i++)
    		params[keyCount + i] = args.get(i);
    	
    	return params;
    }
    
    public Object eval(String script, List<String> keys, List<String> args) {
    	return eval(script, keys.size(), getParams(keys, args));
	}

	public Object eval(String script) {
		return eval(script,0);		
	}

	public Object evalsha(String script) {
		return evalsha(script,0);		
	}
    
    private Object getEvalResult(){
    	Object result = client.getOne();
        
        if(result instanceof byte[])
        	return SafeEncoder.encode((byte[])result);
        
        if(result instanceof List<?>) {
        	List<?> list = (List<?>)result;
        	List<String> listResult = new ArrayList<String>(list.size());
        	for(Object bin: list)
        		listResult.add(SafeEncoder.encode((byte[])bin));
        	
        	return listResult;
        }
        
        return result;
    }
    
    public Object evalsha(String sha1, List<String> keys, List<String> args) {
    	return evalsha(sha1, keys.size(), getParams(keys, args));
    }
    
	public Object evalsha(String sha1, int keyCount, String... params) {
		checkIsInMulti();
        client.evalsha(sha1, keyCount, params);
        
        return getEvalResult();
    }
	
	public Boolean scriptExists(String sha1){
		String[] a = new String[1];
		a[0] = sha1;
		return scriptExists(a).get(0);
    }

	public List<Boolean> scriptExists(String... sha1){
		client.scriptExists(sha1);
		List<Long> result = client.getIntegerMultiBulkReply();
		List<Boolean> exists = new ArrayList<Boolean>();
		
		for(Long value : result)
			exists.add(value == 1);
		
		return exists;
    }
	
    public String scriptLoad(String script){
    	client.scriptLoad(script);
    	return client.getBulkReply();
    }
=======
    }
    
    public List<Slowlog> slowlogGet() {
		client.slowlogGet();
		return Slowlog.from(client.getObjectMultiBulkReply());
	}
	
	public List<Slowlog> slowlogGet(long entries) {
		client.slowlogGet(entries);
		return Slowlog.from(client.getObjectMultiBulkReply());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT;
=======
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, SLOWLOG;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_618bbec_c765bc3/rev_618bbec-c765bc3/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, FLUSH, EXISTS, LOAD, KILL;
=======
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LEN, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, RESET;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/JedisCommands.java;<<<<<<< MINE
    Long rpush(String key, String string);
=======
    Long rpush(String key, String... string);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/JedisCommands.java;<<<<<<< MINE
    Long lpush(String key, String string);
=======
    Long lpush(String key, String... string);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
    Long rpush(byte[] key, byte[] string);
=======
    Long rpush(byte[] key, byte[]... string);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
    Long lpush(byte[] key, byte[] string);
=======
    Long lpush(byte[] key, byte[]... string);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3da2f2d_dd88c51/rev_3da2f2d-dd88c51/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE

    private byte[][] getByteParams(String... params){
    	byte[][] p = new byte[params.length][];
		for(int i=0;i<params.length;i++)
			p[i] = SafeEncoder.encode(params[i]);
		
		return p;
    }
    
    public void eval(String script, int keyCount, String... params) {
		eval(SafeEncoder.encode(script),toByteArray(keyCount), getByteParams(params));		
	}

	public void evalsha(String sha1, int keyCount, String... params) {
		evalsha(SafeEncoder.encode(sha1),toByteArray(keyCount), getByteParams(params));				
	}
	
	public void scriptExists(String... sha1){
		final byte[][] bsha1 = new byte[sha1.length][];
        for (int i = 0; i < bsha1.length; i++) {
        	bsha1[i] = SafeEncoder.encode(sha1[i]);
        }
		scriptExists(bsha1);
    }
	
    public void scriptLoad(String script){
    	scriptLoad(SafeEncoder.encode(script));
    }
=======

	public void zadd(String key, Map<Double, String> scoreMembers) {
		HashMap<Double,byte[]> binaryScoreMembers = new HashMap<Double,byte[]>();
		
		for(Map.Entry<Double,String> entry : scoreMembers.entrySet()){
			binaryScoreMembers.put(entry.getKey(), SafeEncoder.encode(entry.getValue()));
		}
	    
		zaddBinary(SafeEncoder.encode(key), binaryScoreMembers);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	client.configSet(parameter, value);
	return client.getStatusCodeReply();
    }

    public Object eval(String script, int keyCount, String... params) {
	client.setTimeoutInfinite();
	client.eval(script, keyCount, params);

	return getEvalResult();
    }

    private String[] getParams(List<String> keys, List<String> args) {
	int keyCount = keys.size();
	int argCount = args.size();

	String[] params = new String[keyCount + args.size()];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return params;
    }

    public Object eval(String script, List<String> keys, List<String> args) {
	return eval(script, keys.size(), getParams(keys, args));
    }

    public Object eval(String script) {
	return eval(script, 0);
    }

    public Object evalsha(String script) {
	return evalsha(script, 0);
    }

    private Object getEvalResult() {
	Object result = client.getOne();

	if (result instanceof byte[])
	    return SafeEncoder.encode((byte[]) result);

	if (result instanceof List<?>) {
	    List<?> list = (List<?>) result;
	    List<String> listResult = new ArrayList<String>(list.size());
	    for (Object bin : list)
		listResult.add(SafeEncoder.encode((byte[]) bin));

	    return listResult;
	}

	return result;
    }

    public Object evalsha(String sha1, List<String> keys, List<String> args) {
	return evalsha(sha1, keys.size(), getParams(keys, args));
    }

    public Object evalsha(String sha1, int keyCount, String... params) {
	checkIsInMulti();
	client.evalsha(sha1, keyCount, params);

	return getEvalResult();
    }

    public Boolean scriptExists(String sha1) {
	String[] a = new String[1];
	a[0] = sha1;
	return scriptExists(a).get(0);
    }

    public List<Boolean> scriptExists(String... sha1) {
	client.scriptExists(sha1);
	List<Long> result = client.getIntegerMultiBulkReply();
	List<Boolean> exists = new ArrayList<Boolean>();

	for (Long value : result)
	    exists.add(value == 1);

	return exists;
    }

    public String scriptLoad(String script) {
	client.scriptLoad(script);
	return client.getBulkReply();
    }

    public List<Slowlog> slowlogGet() {
	client.slowlogGet();
	return Slowlog.from(client.getObjectMultiBulkReply());
    }

    public List<Slowlog> slowlogGet(long entries) {
	client.slowlogGet(entries);
	return Slowlog.from(client.getObjectMultiBulkReply());
    }
=======
        client.configSet(parameter, value);
        return client.getStatusCodeReply();
    }

	public Long objectRefcount(String string) {
		client.objectRefcount(string);
		return client.getIntegerReply();
	}
	
	public String objectEncoding(String string) {
		client.objectEncoding(string);
		return client.getBulkReply();
	}

	public Long objectIdletime(String string) {
		client.objectIdletime(string);
		return client.getIntegerReply();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
    
=======
    
    Long objectRefcount(byte[] key);
	
	Long objectIdletime(byte[] key);
	
	byte[] objectEncoding(byte[] key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG;
=======
        PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, OBJECT;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0550321_d102ccf/rev_0550321-d102ccf/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, RESET, FLUSH, EXISTS, LOAD, KILL, LEN;
	public final byte[] raw;
=======
        AGGREGATE, ALPHA, ASC, BY, DESC, GET, LIMIT, MESSAGE, NO, NOSORT, PMESSAGE, PSUBSCRIBE, PUNSUBSCRIBE, OK, ONE, QUEUED, SET, STORE, SUBSCRIBE, UNSUBSCRIBE, WEIGHTS, WITHSCORES, RESETSTAT, REFCOUNT, ENCODING, IDLETIME;
        public final byte[] raw;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_42f19c7_ded776f/rev_42f19c7-ded776f/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE

    Long objectRefcount(byte[] key);

    Long objectIdletime(byte[] key);

    byte[] objectEncoding(byte[] key);
=======

    Long lpushx(byte[] key, byte[] string);    

    Long rpushx(byte[] key, byte[] string); 
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<String> zrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrange(key, start, end);
=======
    public Set<String> zrange(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrange(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<String> zrevrange(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrange(key, start, end);
=======
    public Set<String> zrevrange(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrevrange(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<Tuple> zrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrangeWithScores(key, start, end);
=======
    public Set<Tuple> zrangeWithScores(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrangeWithScores(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Set<Tuple> zrevrangeWithScores(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zrevrangeWithScores(key, start, end);
=======
    public Set<Tuple> zrevrangeWithScores(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zrevrangeWithScores(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    public Long zremrangeByRank(String key, int start, int end) {
	Jedis j = getShard(key);
	return j.zremrangeByRank(key, start, end);
=======
    public Long zremrangeByRank(String key, long start, long end) {
        Jedis j = getShard(key);
        return j.zremrangeByRank(key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrange(final byte[] key, final int start, final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
=======
    public void zrange(final byte[] key, final long start, final long end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrange(final byte[] key, final int start, final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
=======
    public void zrevrange(final byte[] key, final long start, final long end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
=======
    public void zrangeWithScores(final byte[] key, final long start,
            final long end) {
        sendCommand(ZRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeWithScores(final byte[] key, final int start,
	    final int end) {
	sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
		WITHSCORES.raw);
=======
    public void zrevrangeWithScores(final byte[] key, final long start,
            final long end) {
        sendCommand(ZREVRANGE, key, toByteArray(start), toByteArray(end),
                WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zremrangeByRank(final byte[] key, final int start, final int end) {
	sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
=======
    public void zremrangeByRank(final byte[] key, final long start, final long end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<String> zrange(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
=======
    public Set<String> zrange(final String key, final long start, final long end) {
        checkIsInMulti();
        client.zrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<String> zrevrange(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrange(key, start, end);
	final List<String> members = client.getMultiBulkReply();
	return new LinkedHashSet<String>(members);
=======
    public Set<String> zrevrange(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrevrange(key, start, end);
        final List<String> members = client.getMultiBulkReply();
        return new LinkedHashSet<String>(members);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<Tuple> zrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
=======
    public Set<Tuple> zrangeWithScores(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Set<Tuple> zrevrangeWithScores(final String key, final int start,
	    final int end) {
	checkIsInMulti();
	client.zrevrangeWithScores(key, start, end);
	Set<Tuple> set = getTupledSet();
	return set;
=======
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
            final long end) {
        checkIsInMulti();
        client.zrevrangeWithScores(key, start, end);
        Set<Tuple> set = getTupledSet();
        return set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public Long zremrangeByRank(final String key, final int start, final int end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
=======
    public Long zremrangeByRank(final String key, final long start, final long end) {
        checkIsInMulti();
        client.zremrangeByRank(key, start, end);
        return client.getIntegerReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrange(final String key, final int start, final int end) {
	zrange(SafeEncoder.encode(key), start, end);
=======
    public void zrange(final String key, final long start, final long end) {
        zrange(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrevrange(final String key, final int start, final int end) {
	zrevrange(SafeEncoder.encode(key), start, end);
=======
    public void zrevrange(final String key, final long start, final long end) {
        zrevrange(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrangeWithScores(final String key, final int start,
	    final int end) {
	zrangeWithScores(SafeEncoder.encode(key), start, end);
=======
    public void zrangeWithScores(final String key, final long start,
            final long end) {
        zrangeWithScores(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zrevrangeWithScores(final String key, final int start,
	    final int end) {
	zrevrangeWithScores(SafeEncoder.encode(key), start, end);
=======
    public void zrevrangeWithScores(final String key, final long start,
            final long end) {
        zrevrangeWithScores(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    public void zremrangeByRank(final String key, final int start, final int end) {
	zremrangeByRank(SafeEncoder.encode(key), start, end);
=======
    public void zremrangeByRank(final String key, final long start, final long end) {
        zremrangeByRank(SafeEncoder.encode(key), start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
    public void zadd(final String key, final Map<Double, String> scoreMembers);

    public void zrange(final String key, final int start, final int end);
=======
    public void zrange(final String key, final long start, final long end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
    public void zrangeWithScores(final String key, final int start,
	    final int end);
=======
    public void zrangeWithScores(final String key, final long start,
            final long end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_457cccc_088f84b/rev_457cccc-088f84b/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
    public void zrevrangeWithScores(final String key, final int start,
	    final int end);
=======
    public void zrevrangeWithScores(final String key, final long start,
            final long end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1a96769_4570329/rev_1a96769-4570329/src/main/java/redis/clients/jedis/JedisCommands.java;<<<<<<< MINE

    List<String> blpop(String arg);

    List<String> brpop(String arg);

    Long del(String key);

    String echo(String string);

    Long move(String key, int dbIndex);
=======

    Long bitcount(final String key);

    Long bitcount(final String key, long start, long end);

    Long bitop(BitOP op, final String destKey, String... srcKeys);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE

    public void bitcount(byte[] key) {
        sendCommand(BITCOUNT, key);
    }

    public void bitcount(byte[] key, long start, long end) {
        sendCommand(BITCOUNT, key, toByteArray(start), toByteArray(end));
    }

    public void bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
        Keyword kw = Keyword.AND;
        int len = srcKeys.length;
        switch (op) {
            case AND:
                kw = Keyword.AND;
                break;
            case OR:
                kw = Keyword.OR;
                break;
            case XOR:
                kw = Keyword.XOR;
                break;
            case NOT:
                kw = Keyword.NOT;
                len = Math.min(1, len);
                break;
        }

        byte[][] bargs = new byte[len + 2][];
        bargs[0] = kw.raw;
        bargs[1] = destKey;
        for (int i = 0; i < len; ++i) {
            bargs[i + 2] = srcKeys[i];
        }

        sendCommand(BITOP, bargs);
    }
=======

    public void sentinel(final byte[]... args) {
  sendCommand(SENTINEL, args);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    public Long bitcount(final String key) {
        client.bitcount(key);
        return client.getIntegerReply();
    }

    public Long bitcount(final String key, long start, long end) {
        client.bitcount(key, start, end);
        return client.getIntegerReply();
    }

    public Long bitop(BitOP op, final String destKey, String... srcKeys) {
        client.bitop(op, destKey, srcKeys);
        return client.getIntegerReply();
    }
=======

  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel masters
   * 1)  1) "name"
   *     2) "mymaster"
   *     3) "ip"
   *     4) "127.0.0.1"
   *     5) "port"
   *     6) "6379"
   *     7) "runid"
   *     8) "93d4d4e6e9c06d0eea36e27f31924ac26576081d"
   *     9) "flags"
   *    10) "master"
   *    11) "pending-commands"
   *    12) "0"
   *    13) "last-ok-ping-reply"
   *    14) "423"
   *    15) "last-ping-reply"
   *    16) "423"
   *    17) "info-refresh"
   *    18) "6107"
   *    19) "num-slaves"
   *    20) "1"
   *    21) "num-other-sentinels"
   *    22) "2"
   *    23) "quorum"
   *    24) "2"
   *
   * </pre>
   *
   * @return
   */
  public List<Map<String, String>> sentinelMasters() {
    client.sentinel(Protocol.SENTINEL_MASTERS);
    final List<Object> reply = client.getObjectMultiBulkReply();

    final List<Map<String,String>> masters = new ArrayList<Map<String,String>>();
    for (Object obj : reply) {
      masters.add(BuilderFactory.STRING_MAP.build((List) obj));
    }
    return masters;
  }

  
  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel get-master-addr-by-name mymaster
   * 1) "127.0.0.1"
   * 2) "6379"
   * </pre>
   * 
   * @param masterName
   * @return two elements list of strings : host and port.
   */
  public List<String> sentinelGetMasterAddrByName(String masterName) {
    client.sentinel(Protocol.SENTINEL_GET_MASTER_ADDR_BY_NAME, masterName);
    final List<Object> reply = client.getObjectMultiBulkReply();
    return BuilderFactory.STRING_LIST.build(reply);
  }

  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel reset mymaster
   * (integer) 1
   * </pre>
   * 
   * @param pattern
   * @return
   */
  public Long sentinelReset(String pattern) {
    client.sentinel(Protocol.SENTINEL_RESET, pattern);
    return client.getIntegerReply();
  }

  /**
   * <pre>
   * redis 127.0.0.1:26381> sentinel slaves mymaster
   * 1)  1) "name"
   *     2) "127.0.0.1:6380"
   *     3) "ip"
   *     4) "127.0.0.1"
   *     5) "port"
   *     6) "6380"
   *     7) "runid"
   *     8) "d7f6c0ca7572df9d2f33713df0dbf8c72da7c039"
   *     9) "flags"
   *    10) "slave"
   *    11) "pending-commands"
   *    12) "0"
   *    13) "last-ok-ping-reply"
   *    14) "47"
   *    15) "last-ping-reply"
   *    16) "47"
   *    17) "info-refresh"
   *    18) "657"
   *    19) "master-link-down-time"
   *    20) "0"
   *    21) "master-link-status"
   *    22) "ok"
   *    23) "master-host"
   *    24) "localhost"
   *    25) "master-port"
   *    26) "6379"
   *    27) "slave-priority"
   *    28) "100"
   * </pre>
   * 
   * @param masterName
   * @return
   */
  public List<Map<String, String>> sentinelSlaves(String masterName) {
    client.sentinel(Protocol.SENTINEL_SLAVES, masterName);
    final List<Object> reply = client.getObjectMultiBulkReply();

    final List<Map<String,String>> slaves = new ArrayList<Map<String,String>>();
    for (Object obj : reply) {
      slaves.add(BuilderFactory.STRING_MAP.build((List) obj));
    }
    return slaves;
  }
  
  /**
   * <pre>
   * redis 127.0.0.1:26381> SENTINEL is-master-down-by-addr 127.0.0.1 1
   * 1) (integer) 0
   * 2) "?"
   * redis 127.0.0.1:26381> SENTINEL is-master-down-by-addr 127.0.0.1 6379
   * 1) (integer) 0
   * 2) "aaef11fbb2712346a386078c7f9834e72ed51e96"
   * </pre>
   * @return Long followed by the String (runid)
   */
  public List<? extends Object> sentinelIsMasterDownByAddr(String host, int port) {
    client.sentinel(Protocol.SENTINEL_IS_MASTER_DOWN_BY_ADDR, host, port);
    final List<Object> reply = client.getObjectMultiBulkReply();
    return Arrays.asList(BuilderFactory.LONG.build(reply.get(0)), BuilderFactory.STRING.build(reply.get(1)));
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE

    public void bitcount(final String key) {
        bitcount(SafeEncoder.encode(key));
    }

    public void bitcount(final String key, long start, long end) {
        bitcount(SafeEncoder.encode(key), start, end);
    }

    public void bitop(BitOP op, final String destKey, String... srcKeys) {
        bitop(op, SafeEncoder.encode(destKey), getByteParams(srcKeys));
    }
=======


  public void sentinel(final String... args) {
    final byte[][] arg = new byte[args.length][];
    for (int i = 0; i < arg.length; i++) {
      arg[i] = SafeEncoder.encode(args[i]);
    }
    sentinel(arg);
  }

  public void sentinel(final String cmd, String arg1, int arg2) {
    sentinel(SafeEncoder.encode(cmd), SafeEncoder.encode(arg1), toByteArray(arg2));
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_406d52b_69b5291/rev_406d52b-69b5291/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *             <code>assertEquals(double expected, double actual, double epsilon)</code>
=======
	 *             <code>assertEquals(double expected, double actual, double delta)</code>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 *             <code>assertEquals(String message, double expected, double actual, double epsilon)</code>
=======
	 *             <code>assertEquals(String message, double expected, double actual, double delta)</code>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c396cff_95f6c41/rev_c396cff-95f6c41/src/main/java/org/junit/ClassRule.java;<<<<<<< MINE
 * 	&#064;Rule
=======
 * 	&#064;ClassRule
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_610f7d4_69f5340/rev_610f7d4-69f5340/src/main/java/redis/clients/jedis/Pipeline.java;<<<<<<< MINE
    public Response<Long> append(String key, String value) {
        client.append(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(byte[] key, byte[] value) {
        client.append(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> blpop(String... args) {
        client.blpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(byte[]... args) {
        client.blpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(String... args) {
        client.brpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(byte[]... args) {
        client.brpop(args);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> decr(String key) {
        client.decr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(byte[] key) {
        client.decr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(String key, long integer) {
        client.decrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(byte[] key, long integer) {
        client.decrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(String... keys) {
        client.del(keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
        client.del(keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> echo(String string) {
        client.echo(string);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> echo(byte[] string) {
        client.echo(string);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> exists(String key) {
        client.exists(key);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> exists(byte[] key) {
        client.exists(key);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
        client.expire(key, seconds);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expire(byte[] key, int seconds) {
        client.expire(key, seconds);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
        client.expireAt(key, unixTime);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(byte[] key, long unixTime) {
        client.expireAt(key, unixTime);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> get(String key) {
        client.get(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> get(byte[] key) {
        client.get(key);
        return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> getbit(String key, long offset) {
        client.getbit(key, offset);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> getrange(String key, long startOffset,
            long endOffset) {
        client.getrange(key, startOffset, endOffset);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> getSet(String key, String value) {
        client.getSet(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> getSet(byte[] key, byte[] value) {
        client.getSet(key, value);
        return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> hdel(String key, String field) {
        client.hdel(key, field);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(byte[] key, byte[] field) {
        client.hdel(key, field);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> hexists(String key, String field) {
        client.hexists(key, field);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> hexists(byte[] key, byte[] field) {
        client.hexists(key, field);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> hget(String key, String field) {
        client.hget(key, field);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hget(byte[] key, byte[] field) {
        client.hget(key, field);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Map<String, String>> hgetAll(String key) {
        client.hgetAll(key);
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Map<String, String>> hgetAll(byte[] key) {
        client.hgetAll(key);
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Long> hincrBy(String key, String field, long value) {
        client.hincrBy(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
        client.hincrBy(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> hincrByFloat(String key, String field, double value) {
        client.hincrByFloat(key, field, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> hincrByFloat(byte[] key, byte[] field, double value) {
        client.hincrByFloat(key, field, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Set<String>> hkeys(String key) {
        client.hkeys(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> hkeys(byte[] key) {
        client.hkeys(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> hlen(String key) {
        client.hlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(byte[] key) {
        client.hlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hmget(String key, String... fields) {
        client.hmget(key, fields);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> hmget(byte[] key, byte[]... fields) {
        client.hmget(key, fields);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
        client.hmset(key, hash);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
        client.hmset(key, hash);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
        client.hset(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
        client.hset(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
        client.hsetnx(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
        client.hsetnx(key, field, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hvals(String key) {
        client.hvals(key);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> hvals(byte[] key) {
        client.hvals(key);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> incr(String key) {
        client.incr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incr(byte[] key) {
        client.incr(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, long integer) {
        client.incrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(byte[] key, long integer) {
        client.incrBy(key, integer);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> incrByFloat(String key, double value) {
        client.incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double value) {
        client.incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Set<String>> keys(String pattern) {
        client.keys(pattern);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> keys(byte[] pattern) {
        client.keys(pattern);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<String> lindex(String key, int index) {
        client.lindex(key, index);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lindex(byte[] key, int index) {
        client.lindex(key, index);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> linsert(String key, LIST_POSITION where,
            String pivot, String value) {
        client.linsert(key, where, pivot, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(byte[] key, LIST_POSITION where,
            byte[] pivot, byte[] value) {
        client.linsert(key, where, pivot, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
        client.llen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(byte[] key) {
        client.llen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
        client.lpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lpop(byte[] key) {
        client.lpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lpush(String key, String string) {
        client.lpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(byte[] key, byte[] string) {
        client.lpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(String key, String string) {
        client.lpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(byte[] key, byte[] bytes) {
        client.lpushx(key, bytes);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, long start, long end) {
        client.lrange(key, start, end);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> lrange(byte[] key, long start, long end) {
        client.lrange(key, start, end);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> lrem(String key, long count, String value) {
        client.lrem(key, count, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lrem(byte[] key, long count, byte[] value) {
        client.lrem(key, count, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lset(String key, long index, String value) {
        client.lset(key, index, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(byte[] key, long index, byte[] value) {
        client.lset(key, index, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(String key, long start, long end) {
        client.ltrim(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(byte[] key, long start, long end) {
        client.ltrim(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> mget(String... keys) {
        client.mget(keys);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> mget(byte[]... keys) {
        client.mget(keys);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> move(String key, int dbIndex) {
        client.move(key, dbIndex);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> move(byte[] key, int dbIndex) {
        client.move(key, dbIndex);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> mset(String... keysvalues) {
        client.mset(keysvalues);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
        client.mset(keysvalues);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
        client.msetnx(keysvalues);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
        client.msetnx(keysvalues);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(String key) {
        client.persist(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(byte[] key) {
        client.persist(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
        client.rename(oldkey, newkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
        client.rename(oldkey, newkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
        client.renamenx(oldkey, newkey);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
        client.renamenx(oldkey, newkey);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpop(String key) {
        client.rpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpop(byte[] key) {
        client.rpop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
        client.rpoplpush(srckey, dstkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpoplpush(byte[] srckey, byte[] dstkey) {
        client.rpoplpush(srckey, dstkey);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> rpush(String key, String string) {
        client.rpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpush(byte[] key, byte[] string) {
        client.rpush(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(String key, String string) {
        client.rpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(byte[] key, byte[] string) {
        client.rpushx(key, string);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(String key, String member) {
        client.sadd(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(byte[] key, byte[] member) {
        client.sadd(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(String key) {
        client.scard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(byte[] key) {
        client.scard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sdiff(String... keys) {
        client.sdiff(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sdiff(byte[]... keys) {
        client.sdiff(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
        client.sdiffstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
        client.sdiffstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> set(String key, String value) {
        client.set(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value) {
        client.set(key, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
        client.setbit(key, offset, value);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> setex(String key, int seconds, String value) {
        client.setex(key, seconds, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> setex(byte[] key, int seconds, byte[] value) {
        client.setex(key, seconds, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
        client.setnx(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setnx(byte[] key, byte[] value) {
        client.setnx(key, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
        client.sinter(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sinter(byte[]... keys) {
        client.sinter(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
        client.sinterstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
        client.sinterstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
        client.sismember(key, member);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> sismember(byte[] key, byte[] member) {
        client.sismember(key, member);
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Set<String>> smembers(String key) {
        client.smembers(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> smembers(byte[] key) {
        client.smembers(key);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
        client.smove(srckey, dstkey, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
        client.smove(srckey, dstkey, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key) {
        client.sort(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key) {
        client.sort(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> sort(String key,
            SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key,
            SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(String key,
            SortingParams sortingParameters, String dstkey) {
        client.sort(key, sortingParameters, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key,
            SortingParams sortingParameters, byte[] dstkey) {
        client.sort(key, sortingParameters, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(String key, String dstkey) {
        client.sort(key, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> sort(byte[] key, byte[] dstkey) {
        client.sort(key, dstkey);
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> spop(String key) {
        client.spop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> spop(byte[] key) {
        client.spop(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> srandmember(String key) {
        client.srandmember(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> srandmember(byte[] key) {
        client.srandmember(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> srem(String key, String member) {
        client.srem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> srem(byte[] key, byte[] member) {
        client.srem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(String key) {
        client.strlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(byte[] key) {
        client.strlen(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
        client.substr(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> substr(byte[] key, int start, int end) {
        client.substr(key, start, end);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Set<String>> sunion(String... keys) {
        client.sunion(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> sunion(byte[]... keys) {
        client.sunion(keys);
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
        client.sunionstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
        client.sunionstore(dstkey, keys);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(String key) {
        client.ttl(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(byte[] key) {
        client.ttl(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> type(String key) {
        client.type(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> type(byte[] key) {
        client.type(key);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(String... keys) {
        client.watch(keys);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
        client.watch(keys);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
        client.zadd(key, score, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(byte[] key, double score, byte[] member) {
        client.zadd(key, score, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(String key) {
        client.zcard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(byte[] key) {
        client.zcard(key);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, double min, double max) {
        client.zcount(key, min, max);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(byte[] key, double min, double max) {
        client.zcount(key, toByteArray(min), toByteArray(max));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
        client.zincrby(key, score, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zincrby(byte[] key, double score, byte[] member) {
        client.zincrby(key, score, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
        client.zinterstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
        client.zinterstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
            String... sets) {
        client.zinterstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
            byte[]... sets) {
        client.zinterstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrange(String key, int start, int end) {
        client.zrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrange(byte[] key, int start, int end) {
        client.zrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
            double max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, double min,
            double max) {
        return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }
    
    public Response<Set<String>> zrangeByScore(String key, String min,
            String max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, byte[] min,
            byte[] max) {
        client.zrangeByScore(key, min, max);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
            double max, int offset, int count) {
        client.zrangeByScore(key, min, max, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(byte[] key, double min,
            double max, int offset, int count) {
        return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
    }
    
    public Response<Set<String>> zrangeByScore(byte[] key, byte[] min,
    		byte[] max, int offset, int count) {
        client.zrangeByScore(key, min, max, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
            double max) {
        client.zrangeByScoreWithScores(key, min, max);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
            double max) {
        return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }
    
    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
    		byte[] max) {
        client.zrangeByScoreWithScores(key, min, max);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
            double max, int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
            double max, int offset, int count) {
        client.zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
    		byte[] max, int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
            double min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, double max,
            double min) {
        client.zrevrangeByScore(key, toByteArray(max), toByteArray(min));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
            String min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, byte[] max,
            byte[] min) {
        client.zrevrangeByScore(key, max, min);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
            double min, int offset, int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(byte[] key, double max,
            double min, int offset, int count) {
        client.zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }
    
    public Response<Set<String>> zrevrangeByScore(byte[] key, byte[] max,
    		byte[] min, int offset, int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
            double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
            double max, double min) {
        client.zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
    		byte[] max, byte[] min) {
        client.zrevrangeByScoreWithScores(key, max, min);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
            double max, double min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
            double max, double min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }
    
    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
    		byte[] max, byte[] min, int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
        client.zrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(byte[] key, int start, int end) {
        client.zrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrank(String key, String member) {
        client.zrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrank(byte[] key, byte[] member) {
        client.zrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(String key, String member) {
        client.zrem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(byte[] key, byte[] member) {
        client.zrem(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(String key, int start, int end) {
        client.zremrangeByRank(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(byte[] key, int start, int end) {
        client.zremrangeByRank(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
        client.zremrangeByScore(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
        client.zremrangeByScore(key, toByteArray(start), toByteArray(end));
        return getResponse(BuilderFactory.LONG);
    }
    
    public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
        client.zremrangeByScore(key, start, end);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, int start, int end) {
        client.zrevrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrange(byte[] key, int start, int end) {
        client.zrevrange(key, start, end);
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, int start,
            int end) {
        client.zrevrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, int start,
            int end) {
        client.zrevrangeWithScores(key, start, end);
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrevrank(String key, String member) {
        client.zrevrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(byte[] key, byte[] member) {
        client.zrevrank(key, member);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
        client.zscore(key, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zscore(byte[] key, byte[] member) {
        client.zscore(key, member);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
        client.zunionstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
        client.zunionstore(dstkey, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
            String... sets) {
        client.zunionstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
            byte[]... sets) {
        client.zunionstore(dstkey, params, sets);
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
        client.bgrewriteaof();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
        client.bgsave();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
        client.configGet(pattern);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
        client.configSet(parameter, value);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
            int timeout) {
        client.brpoplpush(source, destination, timeout);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(byte[] source, byte[] destination,
            int timeout) {
        client.brpoplpush(source, destination, timeout);
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configResetStat() {
        client.configResetStat();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
        client.save();
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
        client.lastsave();
        return getResponse(BuilderFactory.LONG);
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_610f7d4_69f5340/rev_610f7d4-69f5340/src/main/java/redis/clients/jedis/ShardedJedisPipeline.java;<<<<<<< MINE
    public Response<String> set(String key, String value) {
        Client c = getClient(key);
        c.set(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> get(String key) {
        Client c = getClient(key);
        c.get(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> del(String key) {
        Client c = getClient(key);
        c.del(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> exists(String key) {
        Client c = getClient(key);
        c.exists(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> type(String key) {
        Client c = getClient(key);
        c.type(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
        Client c = getClient(key);
        c.expire(key, seconds);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
        Client c = getClient(key);
        c.expireAt(key, unixTime);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(String key) {
        Client c = getClient(key);
        c.ttl(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> getSet(String key, String value) {
        Client c = getClient(key);
        c.getSet(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
        Client c = getClient(key);
        c.setnx(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setex(String key, int seconds, String value) {
        Client c = getClient(key);
        c.setex(key, seconds, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);        
    }

    public Response<Long> decrBy(String key, long integer) {
        Client c = getClient(key);
        c.decrBy(key, integer);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(String key) {
        Client c = getClient(key);
        c.decr(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, int integer) {
        Client c = getClient(key);
        c.incrBy(key, integer);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> incrByFloat(String key, double value) {
        Client c = getClient(key);
        c.incrByFloat(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> incr(String key) {
        Client c = getClient(key);
        c.incr(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(String key, String value) {
        Client c = getClient(key);
        c.append(key, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
        Client c = getClient(key);
        c.substr(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
        Client c = getClient(key);
        c.hset(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> hget(String key, String field) {
        Client c = getClient(key);
        c.hget(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
        Client c = getClient(key);
        c.hsetnx(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
        Client c = getClient(key);
        c.hmset(key, hash);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> hmget(String key, String... fields) {
        Client c = getClient(key);
        c.hmget(key, fields);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> hincrBy(String key, String field, int value) {
        Client c = getClient(key);
        c.hincrBy(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> hincrByFloat(String key, String field, double value) {
        Client c = getClient(key);
        c.hincrByFloat(key, field, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Boolean> hexists(String key, String field) {
        Client c = getClient(key);
        c.hexists(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> hdel(String key, String field) {
        Client c = getClient(key);
        c.hdel(key, field);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(String key) {
        Client c = getClient(key);
        c.hlen(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> hkeys(String key) {
        Client c = getClient(key);
        c.hkeys(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<String>> hvals(String key) {
        Client c = getClient(key);
        c.hvals(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Map<String, String>> hgetAll(String key) {
        Client c = getClient(key);
        c.hgetAll(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Long> rpush(String key, String string) {
        Client c = getClient(key);
        c.rpush(key, string);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(String key, String string) {
        Client c = getClient(key);
        c.lpush(key, string);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
        Client c = getClient(key);
        c.llen(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, int start, int end) {
        Client c = getClient(key);
        c.lrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> ltrim(String key, int start, int end) {
        Client c = getClient(key);
        c.ltrim(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lindex(String key, int index) {
        Client c = getClient(key);
        c.lindex(key, index);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(String key, int index, String value) {
        Client c = getClient(key);
        c.lset(key, index, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lrem(String key, int count, String value) {
        Client c = getClient(key);
        c.lrem(key, count, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
        Client c = getClient(key);
        c.lpop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rpop(String key) {
        Client c = getClient(key);
        c.rpop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> sadd(String key, String member) {
        Client c = getClient(key);
        c.sadd(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> smembers(String key) {
        Client c = getClient(key);
        c.smembers(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Long> srem(String key, String member) {
        Client c = getClient(key);
        c.srem(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<String> spop(String key) {
        Client c = getClient(key);
        c.spop(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> scard(String key) {
        Client c = getClient(key);
        c.scard(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
        Client c = getClient(key);
        c.sismember(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> srandmember(String key) {
        Client c = getClient(key);
        c.srandmember(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
        Client c = getClient(key);
        c.zadd(key, score, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrange(String key, int start, int end) {
        Client c = getClient(key);
        c.zrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Long> zrem(String key, String member) {
        Client c = getClient(key);
        c.zrem(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
        Client c = getClient(key);
        c.zincrby(key, score, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> zrank(String key, String member) {
        Client c = getClient(key);
        c.zrank(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(String key, String member) {
        Client c = getClient(key);
        c.zrevrank(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, int start, int end) {
        Client c = getClient(key);
        c.zrevrange(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, int start, int end) {
        Client c = getClient(key);
        c.zrangeWithScores(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, int start, int end) {
        Client c = getClient(key);
        c.zrevrangeWithScores(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zcard(String key) {
        Client c = getClient(key);
        c.zcard(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
        Client c = getClient(key);
        c.zscore(key, member);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> sort(String key) {
        Client c = getClient(key);
        c.sort(key);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<List<String>> sort(String key, SortingParams sortingParameters) {
        Client c = getClient(key);
        c.sort(key, sortingParameters);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> zcount(String key, double min, double max) {
        Client c = getClient(key);
        c.zcount(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrangeByScore(String key, double min, double max) {
        Client c = getClient(key);
        c.zrangeByScore(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min, double max,
                                               int offset, int count) {
        Client c = getClient(key);
        c.zrangeByScore(key, min, max, offset, count);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max) {
        Client c = getClient(key);
        c.zrangeByScoreWithScores(key, min, max);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max,
            int offset, int count) {
        Client c = getClient(key);
        c.zrangeByScoreWithScores(key, min, max, offset, count);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zremrangeByRank(String key, int start, int end) {
        Client c = getClient(key);
        c.zremrangeByRank(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
        Client c = getClient(key);
        c.zremrangeByScore(key, start, end);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(String key, LIST_POSITION where, String pivot,
                                  String value) {
        Client c = getClient(key);
        c.linsert(key, where, pivot, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> getbit(String key, long offset) {
        Client c = getClient(key);
        c.getbit(key, offset);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
        Client c = getClient(key);
        c.setbit(key, offset, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> setrange(String key, long offset, String value) {
        Client c = getClient(key);
        c.setrange(key, offset, value);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);

    }

    public Response<Long> getrange(String key, long startOffset, long endOffset) {
        Client c = getClient(key);
        c.getrange(key, startOffset, endOffset);
        results.add(new FutureResult(c));
        return getResponse(BuilderFactory.LONG);
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_610f7d4_69f5340/rev_610f7d4-69f5340/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCRBYFLOAT, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HINCRBYFLOAT, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zcount(final byte[] key, final double min, final double max) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZCOUNT, key, byteArrayMin, byteArrayMax);
    }

    public void zcount(final byte[] key, final byte min[], final byte max[]) {
        sendCommand(ZCOUNT, key, min, max);
    }

    public void zcount(final byte[] key, final String min, final String max) {
        sendCommand(ZCOUNT, key, min.getBytes(), max.getBytes());
=======
    public void zcount(final byte[] key, final byte[] min, final byte[] max) {
	sendCommand(ZCOUNT, key, min, max);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScore(final byte[] key, final double min,
            final double max) {
=======
    public void zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max) {
	sendCommand(ZRANGEBYSCORE, key, min, max);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax);
=======
    public void zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScore(final byte[] key, final String max,
            final String min) {
        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes());
    }

    public void zrangeByScore(final byte[] key, final double min,
            final double max, final int offset, int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrangeByScore(final byte[] key, final byte min[],
            final byte max[], final int offset, int count) {

        sendCommand(ZRANGEBYSCORE, key, min, max,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrangeByScore(final byte[] key, final String min,
            final String max, final int offset, int count) {

        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
=======
    public void zrangeByScoreWithScores(final byte[] key, final byte[] min,
	    final byte[] max) {
	sendCommand(ZRANGEBYSCORE, key, min, max, WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScore(final byte[] key, final double max,
            final double min, final int offset, int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

     public void zrevrangeByScore(final byte[] key, final byte max[],
            final byte min[], final int offset, int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                LIMIT.raw, toByteArray(offset), toByteArray(count));
    }

    public void zrevrangeByScore(final byte[] key, final String max,
            final String min, final int offset, int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count));
=======
    public void zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
	    final byte[] min) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min, WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final byte min[],
            final byte max[]) {

        sendCommand(ZRANGEBYSCORE, key, min, max,
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final String min,
            final String max) {

        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                WITHSCORES.raw);
=======
    public void zrangeByScoreWithScores(final byte[] key, final byte[] min,
	    final byte[] max, final int offset, final int count) {
	sendCommand(ZRANGEBYSCORE, key, min, max, LIMIT.raw,
		toByteArray(offset), toByteArray(count), WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final byte max[],
            final byte min[]) {
        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final String max,
            final String min) {
        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                WITHSCORES.raw);
=======
    public void zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
	    final byte[] min, final int offset, final int count) {
	sendCommand(ZREVRANGEBYSCORE, key, max, min, LIMIT.raw,
		toByteArray(offset), toByteArray(count), WITHSCORES.raw);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrangeByScoreWithScores(final byte[] key, final double min,
            final double max, final int offset, final int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZRANGEBYSCORE, key, byteArrayMin, byteArrayMax,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final byte min[],
            final byte max[], final int offset, final int count) {
        sendCommand(ZRANGEBYSCORE, key, min, max,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrangeByScoreWithScores(final byte[] key, final String min,
            final String max, final int offset, final int count) {
        sendCommand(ZRANGEBYSCORE, key, min.getBytes(), max.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
=======
    public void zremrangeByRank(final byte[] key, final long start,
	    final long end) {
	sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_88e662e_155aff0/rev_88e662e-155aff0/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    public void zrevrangeByScoreWithScores(final byte[] key, final double max,
            final double min, final int offset, final int count) {

        byte byteArrayMin[] = (min == Double.NEGATIVE_INFINITY) ? "-inf".getBytes() : toByteArray(min);
        byte byteArrayMax[] = (max == Double.POSITIVE_INFINITY) ? "+inf".getBytes() : toByteArray(max);

        sendCommand(ZREVRANGEBYSCORE, key, byteArrayMax, byteArrayMin,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final byte max[],
            final byte min[], final int offset, final int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max, min,
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zrevrangeByScoreWithScores(final byte[] key, final String max,
            final String min, final int offset, final int count) {

        sendCommand(ZREVRANGEBYSCORE, key, max.getBytes(), min.getBytes(),
                LIMIT.raw, toByteArray(offset), toByteArray(count),
                WITHSCORES.raw);
    }

    public void zremrangeByRank(final byte[] key, final int start, final int end) {
        sendCommand(ZREMRANGEBYRANK, key, toByteArray(start), toByteArray(end));
    }

    public void zremrangeByScore(final byte[] key, final double start,
            final double end) {
        sendCommand(ZREMRANGEBYSCORE, key, toByteArray(start), toByteArray(end));
=======
    public void zremrangeByScore(final byte[] key, final byte[] start,
	    final byte[] end) {
	sendCommand(ZREMRANGEBYSCORE, key, start, end);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest.java;<<<<<<< MINE
    protected static HostAndPort master = HostAndPortUtil.getRedisServers()
	    .get(2);
    protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
	    .get(3);
    protected static HostAndPort slave2 = HostAndPortUtil.getRedisServers()
	    .get(4);
    protected static HostAndPort sentinel1 = HostAndPortUtil
	    .getSentinelServers().get(1);
    protected static HostAndPort sentinel2 = HostAndPortUtil
	    .getSentinelServers().get(2);

    protected static Jedis masterJedis;
    protected static Jedis slaveJedis1;
    protected static Jedis slaveJedis2;

    protected static int slaveCount = 0;

    protected Set<String> sentinels = new HashSet<String>();

    @Before
    public void setUp() throws Exception {

	// set up master and slaves
	masterJedis = new Jedis(master.host, master.port);
	masterJedis.auth("foobared");
	masterJedis.slaveofNoOne();

	slaveJedis1 = new Jedis(slave1.host, slave1.port);
	slaveJedis1.auth("foobared");
	slaveJedis1.slaveof(master.host, master.port);
	slaveCount++;

	slaveJedis2 = new Jedis(slave2.host, slave2.port);
	slaveJedis2.auth("foobared");
	slaveJedis2.slaveof(master.host, master.port);
	slaveCount++;

	sentinels.add(sentinel1.toString());
	sentinels.add(sentinel2.toString());

	// FIXME: The following allows the master/slave relationship to
	// be established, and let sentinels know about this relationship.
	// We can do this more elegantly.
	Thread.sleep(10000);
    }

    @Test
    public void ensureSafeTwiceFailover() throws InterruptedException {
	JedisSentinelPool pool = new JedisSentinelPool("mymaster", sentinels,
		new GenericObjectPoolConfig(), 1000, "foobared", 2);

	// perform failover
	doSegFaultMaster(pool);

	// perform failover once again
	doSegFaultMaster(pool);

	// you can test failover as much as possible
	// but you need to prepare additional slave per failover
    }

    private void doSegFaultMaster(JedisSentinelPool pool)
	    throws InterruptedException {
	// jedis connection should be master
	Jedis jedis = pool.getResource();
	assertEquals("PONG", jedis.ping());

	try {
	    jedis.debug(DebugParams.SEGFAULT());
	} catch (Exception e) {
	}

	// wait for the sentinel to promote a master
	// FIXME: we can query the sentinel and sleep
	// right until the master is promoted
	Thread.sleep(35000);

	jedis = pool.getResource();
	assertEquals("PONG", jedis.ping());
	assertEquals("foobared", jedis.configGet("requirepass").get(1));
	assertEquals(2, jedis.getDB().intValue());
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/benchmark/PoolBenchmark.java;<<<<<<< MINE
	final JedisPool pool = new JedisPool(new GenericObjectPoolConfig(),
		hnp.host, hnp.port, 2000, "foobared");
	List<Thread> tds = new ArrayList<Thread>();

	final AtomicInteger ind = new AtomicInteger();
	for (int i = 0; i < 50; i++) {
	    Thread hj = new Thread(new Runnable() {
		public void run() {
		    for (int i = 0; (i = ind.getAndIncrement()) < TOTAL_OPERATIONS;) {
			try {
			    Jedis j = pool.getResource();
			    final String key = "foo" + i;
			    j.set(key, key);
			    j.get(key);
			    pool.returnResource(j);
			} catch (Exception e) {
			    e.printStackTrace();
			}
		    }
		}
	    });
	    tds.add(hj);
	    hj.start();
	}
=======
        final JedisPool pool = new JedisPool(new Config(), hnp.getHost(), hnp.getPort(),
                2000, "foobared");
        List<Thread> tds = new ArrayList<Thread>();

        final AtomicInteger ind = new AtomicInteger();
        for (int i = 0; i < 50; i++) {
            Thread hj = new Thread(new Runnable() {
                public void run() {
                    for (int i = 0; (i = ind.getAndIncrement()) < TOTAL_OPERATIONS;) {
                        try {
                            Jedis j = pool.getResource();
                            final String key = "foo" + i;
                            j.set(key, key);
                            j.get(key);
                            pool.returnResource(j);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            });
            tds.add(hj);
            hj.start();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
=======
import redis.clients.jedis.BinaryJedis;
import redis.clients.jedis.HostAndPort;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "0");
	pool.returnResource(jedis);

	jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
=======
    	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");
        pool.returnResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.quit();
	pool.returnBrokenResource(jedis);

	jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.incr("foo");
	pool.returnResource(jedis);
	pool.destroy();
=======
    	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.quit();
        pool.returnBrokenResource(jedis);

        jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.incr("foo");
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisPool pool = new JedisPool(config, hnp.host, hnp.port);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "0");

	Jedis newJedis = pool.getResource();
	newJedis.auth("foobared");
	newJedis.incr("foo");
=======
        Config config = new Config();
        config.maxActive = 1;
        config.whenExhaustedAction = GenericObjectPool.WHEN_EXHAUSTED_FAIL;
        JedisPool pool = new JedisPool(config, hnp.getHost(), hnp.getPort());
        Jedis jedis = pool.getResource();
        jedis.auth("foobared");
        jedis.set("foo", "0");

        Jedis newJedis = pool.getResource();
        newJedis.auth("foobared");
        newJedis.incr("foo");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
	JedisPool pool0 = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared");
	Jedis jedis0 = pool0.getResource();
	jedis0.set("foo", "bar");
	assertEquals("bar", jedis0.get("foo"));
	pool0.returnResource(jedis0);
	pool0.destroy();

	JedisPool pool1 = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared", 1);
	Jedis jedis1 = pool1.getResource();
	assertNull(jedis1.get("foo"));
	pool1.returnResource(jedis1);
	pool1.destroy();
=======
        JedisPool pool0 = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000, "foobared");
        Jedis jedis0 = pool0.getResource();
        jedis0.set("foo", "bar");
        assertEquals( "bar", jedis0.get("foo") );
        pool0.returnResource(jedis0);
        pool0.destroy();

        JedisPool pool1 = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000, "foobared", 1);
        Jedis jedis1 = pool1.getResource();
        assertNull( jedis1.get("foo") );
        pool1.returnResource(jedis0);
        pool1.destroy();
    }

    @Test
    public void returnBinary() {
        JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
        		hnp.getPort(), 2000);
        BinaryJedis jedis = pool.getResource();
        pool.returnResource(jedis);
        pool.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
    @Test
    public void selectDatabaseOnActivation() {
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.host,
		hnp.port, 2000, "foobared");

	Jedis jedis0 = pool.getResource();
	assertEquals(0L, jedis0.getDB().longValue());

	jedis0.select(1);
	assertEquals(1L, jedis0.getDB().longValue());

	pool.returnResource(jedis0);

	Jedis jedis1 = pool.getResource();
	assertTrue("Jedis instance was not reused", jedis1 == jedis0);
	assertEquals(0L, jedis1.getDB().longValue());

	pool.returnResource(jedis1);
	pool.destroy();
    }
=======
	@Test
	public void selectDatabaseOnActivation() {
		JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(), 
				hnp.getPort(), 2000, "foobared");

		Jedis jedis0 = pool.getResource();
		assertEquals(0L, jedis0.getDB().longValue());
		
		jedis0.select(1);
		assertEquals(1L, jedis0.getDB().longValue());

		pool.returnResource(jedis0);

		Jedis jedis1 = pool.getResource();
		assertTrue("Jedis instance was not reused", jedis1	== jedis0);
		assertEquals(0L, jedis1.getDB().longValue());

		pool.returnResource(jedis1);
		pool.destroy();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/ShardedJedisPipelineTest.java;<<<<<<< MINE
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil
	    .getRedisServers().get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil
	    .getRedisServers().get(1);
=======
    private static HostAndPort redis1 = HostAndPortUtil
            .getRedisServers().get(0);
    private static HostAndPort redis2 = HostAndPortUtil
            .getRedisServers().get(1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/ShardedJedisPipelineTest.java;<<<<<<< MINE
	Jedis jedis = new Jedis(redis1.host, redis1.port);
	jedis.auth("foobared");
	jedis.flushAll();
	jedis.disconnect();
	jedis = new Jedis(redis2.host, redis2.port);
	jedis.auth("foobared");
	jedis.flushAll();
	jedis.disconnect();

	JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.host, redis1.port);
	JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.host, redis2.port);
	shardInfo1.setPassword("foobared");
	shardInfo2.setPassword("foobared");
	List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
	shards.add(shardInfo1);
	shards.add(shardInfo2);
	this.jedis = new ShardedJedis(shards);
=======
        Jedis jedis = new Jedis(redis1.getHost(), redis1.getPort());
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.getHost(), redis2.getPort());
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();

        JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.getHost(), redis1.getPort());
        JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.getHost(), redis2.getPort());
        shardInfo1.setPassword("foobared");
        shardInfo2.setPassword("foobared");
        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(shardInfo1);
        shards.add(shardInfo2);
        this.jedis = new ShardedJedis(shards);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_bbb8677_7e1a1a7/rev_bbb8677-7e1a1a7/src/test/java/redis/clients/jedis/tests/JedisSentinelTest.java;<<<<<<< MINE
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

=======
import java.util.ArrayList;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    
    public void scan(int cursor, final ScanParams params) {
	final List<byte[]> args = new ArrayList<byte[]>();
	args.add(toByteArray(cursor));
	args.addAll(params.getParams());
	sendCommand(SCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void hscan(final byte[] key, int cursor, final ScanParams params) {
 	final List<byte[]> args = new ArrayList<byte[]>();
 	args.add(key);
 	args.add(toByteArray(cursor));
 	args.addAll(params.getParams());
 	sendCommand(HSCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void sscan(final byte[] key, int cursor, final ScanParams params) {
 	final List<byte[]> args = new ArrayList<byte[]>();
 	args.add(key);
 	args.add(toByteArray(cursor));
 	args.addAll(params.getParams());
 	sendCommand(SSCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void zscan(final byte[] key, int cursor, final ScanParams params) {
 	final List<byte[]> args = new ArrayList<byte[]>();
 	args.add(key);
 	args.add(toByteArray(cursor));
 	args.addAll(params.getParams());
 	sendCommand(ZSCAN, args.toArray(new byte[args.size()][]));
    }
    
    public void waitReplicas(int replicas, long timeout) {
	sendCommand(WAIT, toByteArray(replicas), toByteArray(timeout));
    }
=======
    
    public void cluster(final byte[]... args) {
    	sendCommand(CLUSTER, args);
    }
    public void asking() {
    	sendCommand(Command.ASKING);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, BasicCommands {
=======
import java.net.URI;
import java.util.*;

public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, ClusterCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    public ScanResult<String> scan(int cursor) {
	return scan(cursor, new ScanParams());
    }
    
    public ScanResult<String> scan(int cursor, final ScanParams params) {
	checkIsInMulti();
	client.scan(cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }
    
    public ScanResult<Map.Entry<String, String>> hscan(final String key, int cursor) {
	return hscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Map.Entry<String, String>> hscan(final String key, int cursor, final ScanParams params) {
	checkIsInMulti();
	client.hscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<Map.Entry<String, String>> results = new ArrayList<Map.Entry<String, String>>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while(iterator.hasNext()) {
	    results.add(new AbstractMap.SimpleEntry<String, String>(SafeEncoder.encode(iterator.next()), SafeEncoder.encode(iterator.next())));
	}
	return new ScanResult<Map.Entry<String, String>>(newcursor, results);
    }
    
    public ScanResult<String> sscan(final String key, int cursor) {
	return sscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<String> sscan(final String key, int cursor, final ScanParams params) {
	checkIsInMulti();
	client.sscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }
    
    public ScanResult<Tuple> zscan(final String key, int cursor) {
	return zscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Tuple> zscan(final String key, int cursor, final ScanParams params) {
	checkIsInMulti();
	client.zscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[])result.get(0)));
	List<Tuple> results = new ArrayList<Tuple>();
	List<byte[]> rawResults = (List<byte[]>)result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while(iterator.hasNext()) {
	    results.add(new Tuple(SafeEncoder.encode(iterator.next()), Double.valueOf(SafeEncoder.encode(iterator.next()))));
	}
	return new ScanResult<Tuple>(newcursor, results);
    }
=======

    public String clusterNodes() {
    	checkIsInMulti();
    	client.clusterNodes();
    	return client.getBulkReply();
    }
    
    public String clusterMeet(final String ip, final int port) {
    	checkIsInMulti();
    	client.clusterMeet(ip, port);
    	return client.getStatusCodeReply();
    }
    
    public String clusterAddSlots(final int ...slots) {
    	checkIsInMulti();
    	client.clusterAddSlots(slots);
    	return client.getStatusCodeReply();
    }
    
    public String clusterDelSlots(final int ...slots) {
    	checkIsInMulti();
    	client.clusterDelSlots(slots);
    	return client.getStatusCodeReply();
    }
    
    public String clusterInfo() {
    	checkIsInMulti();
    	client.clusterInfo();
    	return client.getStatusCodeReply();
    }
    
    public List<String> clusterGetKeysInSlot(final int slot, final int count) {
    	checkIsInMulti();
    	client.clusterGetKeysInSlot(slot, count);
    	return client.getMultiBulkReply();
    }
    
    public String clusterSetSlotNode(final int slot, final String nodeId) {
    	checkIsInMulti();
    	client.clusterSetSlotNode(slot, nodeId);
    	return client.getStatusCodeReply();
    }
    
    public String clusterSetSlotMigrating(final int slot, final String nodeId) {
    	checkIsInMulti();
    	client.clusterSetSlotMigrating(slot, nodeId);
    	return client.getStatusCodeReply();
    }
    
    public String clusterSetSlotImporting(final int slot, final String nodeId) {
    	checkIsInMulti();
    	client.clusterSetSlotImporting(slot, nodeId);
    	return client.getStatusCodeReply();
    }

	public String asking() {
		checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    
    public void hscan(final String key, int cursor, final ScanParams params) {
 	hscan(SafeEncoder.encode(key), cursor, params);
    }
    
    public void sscan(final String key, int cursor, final ScanParams params) {
 	sscan(SafeEncoder.encode(key), cursor, params);
    }
    
    public void zscan(final String key, int cursor, final ScanParams params) {
 	zscan(SafeEncoder.encode(key), cursor, params);
    }
=======

    public void cluster(final String subcommand, final int... args) {
	final byte[][] arg = new byte[args.length+1][];
	for (int i = 1; i < arg.length; i++) {
	    arg[i] = toByteArray(args[i-1]);
	}
	arg[0] = SafeEncoder.encode(subcommand);
	cluster(arg);
    }

    public void cluster(final String subcommand, final String... args) {
	final byte[][] arg = new byte[args.length+1][];
	for (int i = 1; i < arg.length; i++) {
	    arg[i] = SafeEncoder.encode(args[i-1]);
	}
	arg[0] = SafeEncoder.encode(subcommand);
	cluster(arg);
    }
    
    public void cluster(final String subcommand) {
	final byte[][] arg = new byte[1][];
	arg[0] = SafeEncoder.encode(subcommand);
	cluster(arg);
    }
    
    public void clusterNodes() {
	cluster(Protocol.CLUSTER_NODES);
    }
    
    public void clusterMeet(final String ip, final int port) {
	cluster(Protocol.CLUSTER_MEET, ip, String.valueOf(port));
    }
    
    public void clusterAddSlots(final int ...slots) {
	cluster(Protocol.CLUSTER_ADDSLOTS, slots);
    }
    
    public void clusterDelSlots(final int ...slots) {
	cluster(Protocol.CLUSTER_DELSLOTS, slots);
    }
    
    public void clusterInfo() {
	cluster(Protocol.CLUSTER_INFO);
    }
    
    public void clusterGetKeysInSlot(final int slot, final int count) {
    	final int[] args = new int[]{ slot, count };
    	cluster(Protocol.CLUSTER_GETKEYSINSLOT, args);
    }
    
    public void clusterSetSlotNode(final int slot, final String nodeId) {
	cluster(Protocol.CLUSTER_SETSLOT, String.valueOf(slot), Protocol.CLUSTER_SETSLOT_NODE, nodeId);
    }
    
    public void clusterSetSlotMigrating(final int slot, final String nodeId) {
	cluster(Protocol.CLUSTER_SETSLOT, String.valueOf(slot), Protocol.CLUSTER_SETSLOT_MIGRATING, nodeId);
    }
    
    public void clusterSetSlotImporting(final int slot, final String nodeId) {
	cluster(Protocol.CLUSTER_SETSLOT, String.valueOf(slot), Protocol.CLUSTER_SETSLOT_IMPORTING, nodeId);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT;
=======
	DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, CLUSTER, ASKING;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2cd3988_9995466/rev_2cd3988-9995466/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
				Assert.assertThat(e, fMatcher);
=======
				try {
					Assert.assertThat(e, fMatcher);
				} catch (AssertionError ae) {
					// add e as cause to have a complete error message in the
					// results
					ae.initCause(e);
					throw ae;
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2cd3988_9995466/rev_2cd3988-9995466/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
				Assert.assertThat(e, fMatcher);
=======
				try {
					Assert.assertThat(e, fMatcher);
				} catch (AssertionError ae) {
					// add e as cause to have a complete error message in the
					// results
					ae.initCause(e);
					throw ae;
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d7c5823_f11c162/rev_d7c5823-f11c162/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
	flush();
	pipelinedCommands--;
	return (List<Object>) Protocol.read(inputStream);
=======
        flush();
        pipelinedCommands--;
        return getRawObjectMultiBulkReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import java.net.URI;
import java.util.*;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    public String asking() {
	checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
    }

    public List<String> pubSubChannels(String pattern) {
	checkIsInMulti();
	client.pubSubChannels(pattern);
	return client.getMultiBulkReply();
    }

    public Long pubSubNumPat() {
	checkIsInMulti();
	client.pubSubNumPat();
	return client.getIntegerReply();
    }

    public Map<String, Long> pubSubNumSub(String... channels) {
	checkIsInMulti();
  	client.pubSubNumSub(channels);
  	return BuilderFactory.STRING_LONG_MAP
  		.build(client.getBinaryMultiBulkReply());
    }
=======
    public String asking() {
	checkIsInMulti();
	client.asking();
	return client.getStatusCodeReply();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
import redis.clients.util.SafeEncoder;
=======
import static redis.clients.jedis.Protocol.toByteArray;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
import static redis.clients.jedis.Protocol.toByteArray;
import static redis.clients.jedis.Protocol.Command.HSCAN;
=======
import redis.clients.util.SafeEncoder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/test/java/redis/clients/jedis/tests/commands/PublishSubscribeCommandsTest.java;<<<<<<< MINE
import org.junit.Ignore;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_319a241_8fef62e/rev_319a241-8fef62e/src/test/java/redis/clients/jedis/tests/commands/PublishSubscribeCommandsTest.java;<<<<<<< MINE
import redis.clients.jedis.exceptions.JedisDataException;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8fef62e_10c131b/rev_8fef62e-10c131b/src/test/java/redis/clients/jedis/tests/commands/TransactionCommandsTest.java;<<<<<<< MINE

    @Test
    public void testResetStateWhenInMulti() {
	jedis.auth("foobared");

	Transaction t = jedis.multi();
	t.set("foooo", "barrr");

	jedis.resetState();
	assertEquals(null, jedis.get("foooo"));
    }

    @Test
    public void testResetStateWhenInMultiWithinPipeline() {
	jedis.auth("foobared");

	Pipeline p = jedis.pipelined();
	p.multi();
	p.set("foooo", "barrr");

	jedis.resetState();
	assertEquals(null, jedis.get("foooo"));
    }

    @Test
    public void testResetStateWhenInWatch() {
	jedis.watch("mykey", "somekey");

	// state reset : unwatch
	jedis.resetState();

	Transaction t = jedis.multi();

	nj.connect();
	nj.auth("foobared");
	nj.set("mykey", "bar");
	nj.disconnect();

	t.set("mykey", "foo");
	List<Object> resp = t.exec();
	assertNotNull(resp);
	assertEquals(1, resp.size());
	assertEquals("foo", jedis.get("mykey"));
    }
=======
    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_68356eb_2d04a38/rev_68356eb-2d04a38/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import java.net.URI;
import java.util.*;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_68356eb_2d04a38/rev_68356eb-2d04a38/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands {
=======
public class Jedis extends BinaryJedis implements JedisCommands,
	MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands,
	BasicCommands, ClusterCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_68356eb_2d04a38/rev_68356eb-2d04a38/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	public String asking() {
		checkIsInMulti();
    	client.asking();
    	return client.getStatusCodeReply();
	}

=======
    public Map<String, String> pubsubNumSub(String... channels) {
	checkIsInMulti();
  	client.pubsubNumSub(channels);
  	return BuilderFactory.STRING_MAP
  		.build(client.getBinaryMultiBulkReply());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
	return evalResult(client.getOne());
    }

    private Object evalResult(Object result) {
=======
	Object result = client.getOne();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.hasItem;
=======
import org.junit.Test;

import redis.clients.jedis.BinaryJedis;
import redis.clients.jedis.exceptions.JedisDataException;
import redis.clients.util.SafeEncoder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    @Test
    public void scriptEvalReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }
=======
    @Test
    public void scriptEvalReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	List<String> results = (List<String>) jedis.eval(script, 2, "key1",
		"key2", "1", "2");
	assertEquals(results.get(0), "key1");
	assertEquals(results.get(1), "key2");
	assertEquals(results.get(2), "1");
	assertEquals(results.get(3), "2");
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    @Test
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }
=======
    @Test
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1",
		"key2", "1", "2");
	assertEquals(results.get(0), "key1");
	assertEquals(results.get(1), "key2");
	assertEquals(results.get(2), "1");
	assertEquals(results.get(3), "2");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4fb85d0_51a4bf9/rev_4fb85d0-51a4bf9/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    private <T> CombinableMatcher<List<T>> listWithItem(T expected) {
	return both(CoreMatchers.<List<T>>instanceOf(List.class)).and(hasItem(equalTo(expected)));
    }
=======
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
	public double fDelta;
=======
	public Object fDelta;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
=======
	
	public InexactComparisonCriteria(float delta){
		fDelta = delta;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
			Assert.assertEquals((Double)expected, (Double)actual, fDelta);
=======
			Assert.assertEquals((Double)expected, (Double)actual, (Double)fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
			Assert.assertEquals((Float)expected, (Float)actual, fDelta);
=======
			Assert.assertEquals((Float)expected, (Float)actual, (Float)fDelta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two doubles or floats are equal to within a positive delta.
=======
	 * Asserts that two doubles are equal to within a positive delta.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;<<<<<<< MINE
=======
	
	/**
	 * Asserts that two floats are equal to within a positive delta.
	 * If they are not, an {@link AssertionError} is thrown with the given
	 * message. If the expected value is infinity then the delta value is
	 * ignored. NaNs are considered equal:
	 * <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expected
	 *            expected value
	 * @param actual
	 *            the value to check against <code>expected</code>
	 * @param delta
	 *            the maximum delta between <code>expected</code> and
	 *            <code>actual</code> for which both numbers are still
	 *            considered equal.
	 */
	static public void assertEquals(String message, float expected,
			float actual, float delta) {
		if (Float.compare(expected, actual) == 0)
		{
			return;
		}
		if (!(Math.abs(expected - actual) <= delta))
		{
			failNotEquals(message, new Float(expected), new Float(actual));
		}
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	 * Asserts that two doubles or floats are equal to within a positive delta.
=======
	 * Asserts that two doubles are equal to within a positive delta.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/main/java/org/junit/Assert.java;<<<<<<< MINE
=======
	
	/**
	 * Asserts that two floats are equal to within a positive delta.
	 * If they are not, an {@link AssertionError} is thrown. If the expected
	 * value is infinity then the delta value is ignored. NaNs are considered
	 * equal: <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes
	 * 
	 * @param expected
	 *            expected value
	 * @param actual
	 *            the value to check against <code>expected</code>
	 * @param delta
	 *            the maximum delta between <code>expected</code> and
	 *            <code>actual</code> for which both numbers are still
	 *            considered equal.
	 */
	
	static public void assertEquals(float expected, float actual, float delta) {
		assertEquals(null, expected, actual, delta);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c7f5669_9f30584/rev_c7f5669-9f30584/src/test/java/org/junit/tests/assertion/AssertionTest.java;<<<<<<< MINE
=======
	@Test
	 public void floatsNotDoublesInArrays()
	{
		float delta = 4.444f;
		float[] f1 = new float[] {1.111f};
		float[] f2 = new float[] {5.555f};
		Assert.assertArrayEquals(f1, f2, delta);
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c2bdb1a_34d2943/rev_c2bdb1a-34d2943/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
=======
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c2bdb1a_34d2943/rev_c2bdb1a-34d2943/src/main/java/org/junit/rules/ExpectedException.java;<<<<<<< MINE
import org.hamcrest.TypeSafeMatcher;
import org.junit.Assert;
=======
import org.junit.internal.AssumptionViolatedException;
import org.junit.internal.matchers.TypeSafeMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c2bdb1a_34d2943/rev_c2bdb1a-34d2943/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6b943e5_34d2943/rev_6b943e5-34d2943/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import org.hamcrest.CoreMatchers;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}

        @Test
        public void throwsIllegalArgumentExceptionWithCause() {
            NullPointerException expectedCause = new NullPointerException("expected cause");

            thrown.expect(IllegalArgumentException.class);
            thrown.expectMessage("Ack!");
            thrown.expectCause(is(expectedCause));

            throw new IllegalArgumentException("Ack!", expectedCause);
        }

        @Test
        public void throwsIllegalArgumentExceptionWithCauseExplicitlyNull() {
            thrown.expect(IllegalArgumentException.class);
            thrown.expectMessage("Ack!");
            thrown.expectCause(CoreMatchers.<Throwable>nullValue());

            throw new IllegalArgumentException("Ack!");
        }
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}

	public static class HasWrongCause {
        public static final NullPointerException EXPECTED_CAUSE = new NullPointerException("expected cause");

        @Rule
		public ExpectedException thrown= ExpectedException.none();

        @Test
		public void throwWithCause() {
            thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
            thrown.expectCause(is(EXPECTED_CAUSE));

			throw new IllegalArgumentException("Ack!", new NullPointerException("an unexpected cause"));
		}
	}

	@Test
	public void failsWithWrongCause() {
		assertThat(testResult(HasWrongCause.class),
            hasSingleFailureContaining(HasWrongCause.EXPECTED_CAUSE.toString()));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_db76522_e7bc4f5/rev_db76522-e7bc4f5/src/main/java/redis/clients/jedis/JedisSlotBasedConnectionHandler.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

=======
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_db76522_e7bc4f5/rev_db76522-e7bc4f5/src/main/java/redis/clients/jedis/JedisSlotBasedConnectionHandler.java;<<<<<<< MINE
    private Jedis currentConnection;

    public JedisSlotBasedConnectionHandler(Set<HostAndPort> nodes,
        final GenericObjectPoolConfig poolConfig) {
	super(nodes, poolConfig);
=======
    public JedisSlotBasedConnectionHandler(Set<HostAndPort> nodes) {
	super(nodes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e381886_3f6e3ef/rev_e381886-3f6e3ef/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.failureIs;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.causedBy;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}
	
	@Test
	public void expectedExceptionClauseExists() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				failureIs(causedBy(instanceOf(IllegalArgumentException.class))));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e381886_3f6e3ef/rev_e381886-3f6e3ef/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
	BlockJUnit4ClassRunnerTest.class,
	CauseMatcherTest.class
=======
	BlockJUnit4ClassRunnerTest.class,
	MethodSorterTest.class,
	TestedOnSupplierTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_c2cf79c_ac53759/rev_c2cf79c-ac53759/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
    
    public void pfadd(final byte[] key, final byte[]... elements) {
   	sendCommand(PFADD, joinParameters(key, elements));
    }
    
    public void pfcount(final byte[] key) {
   	sendCommand(PFCOUNT, key);
    }
    public void pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
   	sendCommand(PFMERGE, joinParameters(destkey, sourcekeys));
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_c2cf79c_ac53759/rev_c2cf79c-ac53759/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    public Long pfadd(final String key, final String... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    public long pfcount(final String key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    public String pfmerge(final String destkey, final String... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_c2cf79c_ac53759/rev_c2cf79c-ac53759/src/test/java/redis/clients/jedis/tests/commands/HyperLogLogCommandsTest.java;<<<<<<< MINE
package redis.clients.jedis.tests.commands;

import org.junit.Test;

import redis.clients.util.SafeEncoder;

public class HyperLogLogCommandsTest extends JedisCommandTestBase {


    @Test
    public void pfadd() {
	long status = jedis.pfadd("foo", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("foo", "a");
	assertEquals(0, status);
    }
    
    @Test
    public void pfaddBinary() {
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bBar2 = SafeEncoder.encode("bar2");
	
	long status = jedis.pfadd(bFoo, bBar, bBar2);
	assertEquals(1, status);
	
	status = jedis.pfadd(bFoo, bBar, bBar2);
	assertEquals(0, status);
    }
    
    @Test
    public void pfcount() {
	long status = jedis.pfadd("hll", "foo", "bar", "zap");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll", "zap", "zap", "zap");
	assertEquals(0, status);
	
	status = jedis.pfadd("hll", "foo", "bar");
	assertEquals(0, status);
	
	status = jedis.pfcount("hll");
	assertEquals(3, status);
    }
    
    @Test
    public void pfcountBinary() {
	byte[] bHll = SafeEncoder.encode("hll");
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bZap = SafeEncoder.encode("zap");
	
	long status = jedis.pfadd(bHll, bFoo, bBar, bZap);
	assertEquals(1, status);
	
	status = jedis.pfadd(bHll, bZap, bZap, bZap);
	assertEquals(0, status);
	
	status = jedis.pfadd(bHll, bFoo, bBar);
	assertEquals(0, status);
	
	status = jedis.pfcount(bHll);
	assertEquals(3, status);
    }
    
    @Test
    public void pfmerge() {
	long status = jedis.pfadd("hll1", "foo", "bar", "zap", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll2", "a", "b", "c", "foo");
	assertEquals(1, status);
	
	String mergeStatus = jedis.pfmerge("hll3", "hll1", "hll2");
	assertEquals("OK", mergeStatus);
	
	status = jedis.pfcount("hll3");
	assertEquals(6, status);
    }
    
    @Test
    public void pfmergeBinary() {
	byte[] bHll1 = SafeEncoder.encode("hll1");
	byte[] bHll2 = SafeEncoder.encode("hll2");
	byte[] bHll3 = SafeEncoder.encode("hll3");
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bZap = SafeEncoder.encode("zap");
	byte[] bA = SafeEncoder.encode("a");
	byte[] bB = SafeEncoder.encode("b");
	byte[] bC = SafeEncoder.encode("c");
	
	long status = jedis.pfadd(bHll1, bFoo, bBar, bZap, bA);
	assertEquals(1, status);
	
	status = jedis.pfadd(bHll2, bA, bB, bC, bFoo);
	assertEquals(1, status);
	
	String mergeStatus = jedis.pfmerge(bHll3, bHll1, bHll2);
	assertEquals("OK", mergeStatus);
	
	status = jedis.pfcount("hll3");
	assertEquals(6, status);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_72e10d3_d4755d0/rev_72e10d3-d4755d0/src/main/java/org/junit/Assert.java;<<<<<<< MINE
	
	/**
	 * Asserts that two floats are equal to within a positive delta.
	 * If they are not, an {@link AssertionError} is thrown with the given
	 * message. If the expected value is infinity then the delta value is
	 * ignored. NaNs are considered equal:
	 * <code>assertEquals(Float.NaN, Float.NaN, *)</code> passes
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expected
	 *            expected value
	 * @param actual
	 *            the value to check against <code>expected</code>
	 * @param delta
	 *            the maximum delta between <code>expected</code> and
	 *            <code>actual</code> for which both numbers are still
	 *            considered equal.
	 */
	static public void assertEquals(String message, float expected,
			float actual, float delta) {
		if (Float.compare(expected, actual) == 0)
			return;
		if (!(Math.abs(expected - actual) <= delta))
			failNotEquals(message, new Float(expected), new Float(actual));
	}
=======
	
	static private boolean doubleIsDifferent(double d1, double d2, double delta) {
		if (Double.compare(d1, d2) == 0)
			return false;
		if ((Math.abs(d1 - d2) <= delta))
			return false;
		
		return true;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_167a782_81c8308/rev_167a782-81c8308/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
    public T runBinary(byte[] key) {
        if (key == null) {
            throw new JedisClusterException(
                "No way to dispatch this command to Redis Cluster.");
        }

        return runWithRetries(key, this.redirections, false, false);
    }
    
    public T runScript(String... keys) {
=======
    public T run(int keyCount, String... keys) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
import org.hamcrest.core.CombinableMatcher;
=======
import org.junit.internal.matchers.CombinableMatcher;
import org.junit.internal.matchers.Each;
import org.junit.internal.matchers.IsCollectionContaining;
import org.junit.internal.matchers.StringContains;
import org.junit.internal.matchers.CauseMatcher;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.startsWith;
=======
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.hamcrest.CoreMatchers.is;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java;<<<<<<< MINE
=======
import org.hamcrest.CoreMatchers;
import org.hamcrest.Description;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java;<<<<<<< MINE
=======

	public static class ThrowExceptionWithMatchingCause {
		@Rule
		public ExpectedException thrown = none();

		@Test
		public void throwExceptionWithMatchingCause() {
			NullPointerException expectedCause = new NullPointerException("expected cause");

			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(is(expectedCause));

			throw new IllegalArgumentException("Ack!", expectedCause);
		}
	}

	public static class ThrowExpectedNullCause {
		@Rule
		public ExpectedException thrown = none();

		@Test
		public void throwExpectedNullCause() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(CoreMatchers.<Throwable>nullValue());

			throw new IllegalArgumentException("Ack!");
		}
	}

	public static class ThrowUnexpectedCause {

		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwWithCause() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(is(new NullPointerException("expected cause")));

			throw new IllegalArgumentException("Ack!", new NullPointerException("an unexpected cause"));
		}
	}


	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}

			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6106f5b_e1f50b5/rev_6106f5b-e1f50b5/src/main/java/redis/clients/jedis/ScanParams.java;<<<<<<< MINE
    public ScanParams match(final String pattern) {
=======
    public void match(final byte[] pattern) {
	params.add(MATCH.raw);
	params.add(pattern);
    }
    
    public void match(final String pattern) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6106f5b_e1f50b5/rev_6106f5b-e1f50b5/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
    @Override
    public Long pfadd(final byte[] key, final byte[]... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    @Override
    public long pfcount(final byte[] key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    @Override
    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }

    @Override
    public Long pfcount(byte[]... keys) {
        checkIsInMulti();
        client.pfcount(keys);
        return client.getIntegerReply();
    }

=======
    public ScanResult<byte[]> scan(final byte[] cursor) {
	return scan(cursor, new ScanParams());
    }
    
    public ScanResult<byte[]> scan(final byte[] cursor, final ScanParams params) {
	checkIsInMulti();
	client.scan(cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	return new ScanResult<byte[]>(newcursor, rawResults);
    }
    
    public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key,
	    final byte[] cursor) {
	return hscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key,
	    final byte[] cursor, final ScanParams params) {
	checkIsInMulti();
	client.hscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<Map.Entry<byte[], byte[]>> results = new ArrayList<Map.Entry<byte[], byte[]>>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new AbstractMap.SimpleEntry<byte[], byte[]>(iterator.next(), 
		    iterator.next()));
	}
	return new ScanResult<Map.Entry<byte[], byte[]>>(newcursor, results);
    }
    
    public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor) {
	return sscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.sscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	return new ScanResult<byte[]>(newcursor, rawResults);
    }
    
    public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor) {
	return zscan(key, cursor, new ScanParams());
    }
    
    public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.zscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	byte[] newcursor = (byte[]) result.get(0);
	List<Tuple> results = new ArrayList<Tuple>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new Tuple(iterator.next(), Double
		    .valueOf(SafeEncoder.encode(iterator.next()))));
	}
	return new ScanResult<Tuple>(newcursor, results);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_daeda1a_2162def/rev_daeda1a-2162def/src/main/java/org/junit/rules/TestWatcher.java;<<<<<<< MINE
=======
 * @since 4.9
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0d5062c_6af41cd/rev_0d5062c-6af41cd/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
    public Response<String> lindex(String key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.STRING);
=======
    public Response<Double> incrByFloat(String key, double value) {
        getClient(key).incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double value) {
        getClient(key).incrByFloat(key, value);
        return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<String> lindex(String key, int index) {
        getClient(key).lindex(key, index);
        return getResponse(BuilderFactory.STRING);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0d5062c_6af41cd/rev_0d5062c-6af41cd/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, PFADD, PFCOUNT, PFMERGE;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCRBYFLOAT, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HINCRBYFLOAT, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_be8d4ee_2e53904/rev_be8d4ee-2e53904/src/test/java/org/junit/tests/experimental/rules/TestRuleTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;

import java.util.LinkedList;
import java.util.List;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
import java.io.Closeable;
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.util.Hashing;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.util.Hashing;
import redis.clients.util.Pool;

public class ShardedJedis extends BinaryShardedJedis implements JedisCommands,
	Closeable {

    protected Pool<ShardedJedis> dataSource = null;

=======
public class ShardedJedis extends BinaryShardedJedis implements JedisCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE

    @Override
    public void close() {
	if (dataSource != null) {
	    boolean broken = false;

	    for (Jedis jedis : getAllShards()) {
		if (jedis.getClient().isBroken()) {
		    broken = true;
		}
	    }

	    if (broken) {
		dataSource.returnBrokenResource(this);
	    } else {
		this.resetState();
		dataSource.returnResource(this);
	    }

	} else {
	    disconnect();
	}
    }

    public void setDataSource(Pool<ShardedJedis> shardedJedisPool) {
	this.dataSource = shardedJedisPool;
    }

    public void resetState() {
	for (Jedis jedis : getAllShards()) {
	    jedis.resetState();
	}
    }
=======

    @Override
    public Long pfadd(String key, String... elements) {
	Jedis j = getShard(key);
	return j.pfadd(key, elements);
    }

    @Override
    public long pfcount(String key) {
	Jedis j = getShard(key);
	return j.pfcount(key);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

    @Override
    public void close() {
	if (dataSource != null) {
	    if (client.isBroken()) {
		this.dataSource.returnBrokenResource(this);
	    } else {
		this.dataSource.returnResource(this);
	    }
	} else {
	    client.close();
	}
    }

    public void setDataSource(Pool<Jedis> jedisPool) {
	this.dataSource = jedisPool;
    }
=======

    public Long pfadd(final String key, final String... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    public long pfcount(final String key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    @Override
    public long pfcount(String... keys) {
        checkIsInMulti();
        client.pfcount(keys);
        return client.getIntegerReply();
    }

    public String pfmerge(final String destkey, final String... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
=======
    public void returnBrokenResource(final Jedis resource) {
	if (resource != null) {
	    returnBrokenResourceObject(resource);
	}
    }

    public void returnResource(final Jedis resource) {
	if (resource != null) {
	    resource.resetState();
	    returnResourceObject(resource);
	}
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE

    @Test
    public void checkResourceIsCloseable() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisPool pool = new JedisPool(config, hnp.getHost(), hnp.getPort(),
		2000, "foobared");

	Jedis jedis = pool.getResource();
	try {
	    jedis.set("hello", "jedis");
	} finally {
	    jedis.close();
	}

	Jedis jedis2 = pool.getResource();
	try {
	    assertEquals(jedis, jedis2);
	} finally {
	    jedis2.close();
	}
    }
=======
    
    @Test
    public void returnNullObjectShouldNotFail() {
	JedisPool pool = new JedisPool(new JedisPoolConfig(), hnp.getHost(),
		hnp.getPort(), 2000, "foobared", 0, "my_shiny_client_name");

	pool.returnBrokenResource(null);
	pool.returnResource(null);
	pool.returnResourceObject(null);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.util.Set;
=======
import java.util.*;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
	    HostAndPort node = getHostAndPortFromNodeLine(nodeInfo, jedis);
        setNodeIfNotExist(node);

	    JedisPool nodePool = nodes.get(getNodeKey(node));
	    populateNodeSlots(nodeInfo, nodePool);
	}
    }
    
    private void setNodeIfNotExist(HostAndPort node) {
	String nodeKey = getNodeKey(node);
	if (nodes.containsKey(nodeKey))
	    return;
	
	JedisPool nodePool = new JedisPool(poolConfig, node.getHost(), node.getPort());
	nodes.put(nodeKey, nodePool);
    }
=======
	    ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
		    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
			    jedis.getClient().getPort()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import redis.clients.jedis.BinaryClient.LIST_POSITION;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
import redis.clients.jedis.exceptions.*;
=======
import redis.clients.jedis.exceptions.JedisAskDataException;
import redis.clients.jedis.exceptions.JedisClusterException;
import redis.clients.jedis.exceptions.JedisClusterMaxRedirectionsException;
import redis.clients.jedis.exceptions.JedisException;
import redis.clients.jedis.exceptions.JedisMovedDataException;
import redis.clients.jedis.tests.utils.JedisClusterTestUtil;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6c68624_74b527d/rev_6c68624-74b527d/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

    private void waitForClusterReady() throws InterruptedException {
	boolean clusterOk = false;
	while (!clusterOk) {
	    if (node1.clusterInfo().split("\n")[0].contains("ok")
		    && node2.clusterInfo().split("\n")[0].contains("ok")
		    && node3.clusterInfo().split("\n")[0].contains("ok")) {
		clusterOk = true;
=======
    private List<Integer> getSlotsBeingMigrated(String infoLine) {
	List<Integer> inconsistentSlots = new ArrayList<Integer>();
	
	String[] splitted = infoLine.split(" ");
	
	if (splitted.length > 8) {
	    for (int index = 8 ; index < splitted.length ; index++) {
		String info = splitted[index];
		Integer slot = getSlotFromMigrationInfo(info);
		if (slot != null) {
		    inconsistentSlots.add(slot);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_737112a_79d27ef/rev_737112a-79d27ef/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster implements JedisCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
=======
public class JedisCluster extends BinaryJedisCluster implements JedisCommands, 
        JedisClusterScriptingCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_737112a_79d27ef/rev_737112a-79d27ef/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_737112a_79d27ef/rev_737112a-79d27ef/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
    @Test(expected = JedisClusterException.class)
    public void testThrowExceptionWithoutKey() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.ping();
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_5939d5b_76df52e/rev_5939d5b-76df52e/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
=======
public class JedisCluster implements JedisCommands, BasicCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_5939d5b_76df52e/rev_5939d5b-76df52e/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    
    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object eval(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script);
        }
    }.run(key);
    }
    
    @Override
    public Object eval(final String script, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String sha1, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object evalsha(final String sha1, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(script);
        }
    }.run(key);
    }
    
    @Override
    public Boolean scriptExists(final String sha1, final String key) {
    return new JedisClusterCommand<Boolean>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Boolean execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public List<Boolean> scriptExists(final String key, final String... sha1) {
    return new JedisClusterCommand<List<Boolean>>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public List<Boolean> execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
    return new JedisClusterCommand<String>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public String execute(Jedis connection) {
        return connection.scriptLoad(script);
        }
    }.run(key);
    }
=======

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return (List<byte[]>) Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return (List<byte[]>) readProtocolWithCheckingBroken();
    }

    public void resetPipelinedCount() {
	pipelinedCommands = 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return (List<Object>) Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return getRawObjectMultiBulkReply();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
=======
    public List<Object> getAll() {
	return getAll(0);
    }

    public List<Object> getAll(int except) {
	List<Object> all = new ArrayList<Object>();
	flush();
	while (pipelinedCommands > except) {
	    try {
		all.add(readProtocolWithCheckingBroken());
	    } catch (JedisDataException e) {
		all.add(e);
	    }
	    pipelinedCommands--;
	}
	return all;
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_360e25e_03c0af2/rev_360e25e-03c0af2/src/main/java/redis/clients/jedis/Connection.java;<<<<<<< MINE
        flush();
        return Protocol.read(inputStream);
=======
	flush();
	pipelinedCommands--;
	return readProtocolWithCheckingBroken();
    }

    public boolean isBroken() {
	return broken;
    }

    protected void flush() {
	try {
	    outputStream.flush();
	} catch (IOException ex) {
	    broken = true;
	    throw new JedisConnectionException(ex);
	}
    }

    protected Object readProtocolWithCheckingBroken() {
	try {
	    return Protocol.read(inputStream);
	} catch (JedisConnectionException exc) {
	    broken = true;
	    throw exc;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Entry<String, String>> hscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.hscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.sscan(key, cursor);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(String key, int cursor) {
	Jedis j = getShard(key);
	return j.zscan(key, cursor);
    }

    public ScanResult<Entry<String, String>> hscan(String key,
	    final String cursor) {
=======
    public ScanResult<Entry<String, String>> hscan(String key, final String cursor) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }
    
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> scan(int cursor) {
	return scan(cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> scan(int cursor, final ScanParams params) {
	checkIsInMulti();
	client.scan(cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Map.Entry<String, String>> hscan(final String key,
	    int cursor) {
	return hscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Map.Entry<String, String>> hscan(final String key,
	    int cursor, final ScanParams params) {
	checkIsInMulti();
	client.hscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<Map.Entry<String, String>> results = new ArrayList<Map.Entry<String, String>>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new AbstractMap.SimpleEntry<String, String>(SafeEncoder
		    .encode(iterator.next()), SafeEncoder.encode(iterator
		    .next())));
	}
	return new ScanResult<Map.Entry<String, String>>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(final String key, int cursor) {
	return sscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<String> sscan(final String key, int cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.sscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<String> results = new ArrayList<String>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	for (byte[] bs : rawResults) {
	    results.add(SafeEncoder.encode(bs));
	}
	return new ScanResult<String>(newcursor, results);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(final String key, int cursor) {
	return zscan(key, cursor, new ScanParams());
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    public ScanResult<Tuple> zscan(final String key, int cursor,
	    final ScanParams params) {
	checkIsInMulti();
	client.zscan(key, cursor, params);
	List<Object> result = client.getObjectMultiBulkReply();
	int newcursor = Integer.parseInt(new String((byte[]) result.get(0)));
	List<Tuple> results = new ArrayList<Tuple>();
	List<byte[]> rawResults = (List<byte[]>) result.get(1);
	Iterator<byte[]> iterator = rawResults.iterator();
	while (iterator.hasNext()) {
	    results.add(new Tuple(SafeEncoder.encode(iterator.next()), Double
		    .valueOf(SafeEncoder.encode(iterator.next()))));
	}
	return new ScanResult<Tuple>(newcursor, results);
    }

=======
    public Double hincrByFloat(final String key, final String field,
	    double increment) {
	checkIsInMulti();
	client.hincrByFloat(key, field, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_26d1f4a_0aacd48/rev_26d1f4a-0aacd48/src/main/java/redis/clients/jedis/ScanResult.java;<<<<<<< MINE
    
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531
     * @return int(currently), but will be changed to String, so be careful to prepare! 
     */
    public int getCursor() {
	return Integer.parseInt(getStringCursor());
    }

    /**
     * FIXME: This method should be changed to getCursor() on next major release
     */
    public String getStringCursor() {
	return SafeEncoder.encode(cursor);
    }
    
    public byte[] getCursorAsBytes() {
=======

    public String getCursor() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/rules/MethodRule.java;<<<<<<< MINE
 * 
 * Note that {@link MethodRule} has been replaced by {@link TestRule},
 * which has the added benefit of supporting class rules.
=======
 *
 * Note that {@link MethodRule} is now deprecated, you should be using {@link TestRule} instead.
 *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/rules/TestWatchman.java;<<<<<<< MINE
 * 
 * @deprecated Use {@link TestWatcher} (which implements {@link TestRule}) instead.
 * @since 4.7
=======
 *
 * @since 4.7
 * @deprecated {@link MethodRule} is deprecated.
 *             Use {@link TestWatcher} implements {@link TestRule} instead.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/runners/BlockJUnit4ClassRunner.java;<<<<<<< MINE
	/**
	 * Creates a BlockJUnit4ClassRunner to run {@code klass}
	 * 
	 * @throws InitializationError
	 *             if the test class is malformed.
	 */
	public BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {
		super(klass);
	}

	//
	// Implementation of ParentRunner
	// 

	@Override
	protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
		Description description= describeChild(method);
		if (method.getAnnotation(Ignore.class) != null) {
			notifier.fireTestIgnored(description);
		} else {
			runLeaf(methodBlock(method), description, notifier);
		}
	}

	@Override
	protected Description describeChild(FrameworkMethod method) {
		return Description.createTestDescription(getTestClass().getJavaClass(),
				testName(method), method.getAnnotations());
	}

	@Override
	protected List<FrameworkMethod> getChildren() {
		return computeTestMethods();
	}

	//
	// Override in subclasses
	//

	/**
	 * Returns the methods that run tests. Default implementation returns all
	 * methods annotated with {@code @Test} on this class and superclasses that
	 * are not overridden.
	 */
	protected List<FrameworkMethod> computeTestMethods() {
		return getTestClass().getAnnotatedMethods(Test.class);
	}

	@Override
	protected void collectInitializationErrors(List<Throwable> errors) {
		super.collectInitializationErrors(errors);

		validateNoNonStaticInnerClass(errors);
		validateConstructor(errors);
		validateInstanceMethods(errors);
		validateFields(errors);
		validateMethods(errors);
	}

	protected void validateNoNonStaticInnerClass(List<Throwable> errors) {
		if (getTestClass().isANonStaticInnerClass()) {
			String gripe= "The inner class " + getTestClass().getName()
					+ " is not static.";
			errors.add(new Exception(gripe));
		}
	}

	/**
	 * Adds to {@code errors} if the test class has more than one constructor,
	 * or if the constructor takes parameters. Override if a subclass requires
	 * different validation rules.
	 */
	protected void validateConstructor(List<Throwable> errors) {
		validateOnlyOneConstructor(errors);
		validateZeroArgConstructor(errors);
	}

	/**
	 * Adds to {@code errors} if the test class has more than one constructor
	 * (do not override)
	 */
	protected void validateOnlyOneConstructor(List<Throwable> errors) {
		if (!hasOneConstructor()) {
			String gripe= "Test class should have exactly one public constructor";
			errors.add(new Exception(gripe));
		}
	}

	/**
	 * Adds to {@code errors} if the test class's single constructor takes
	 * parameters (do not override)
	 */
	protected void validateZeroArgConstructor(List<Throwable> errors) {
		if (!getTestClass().isANonStaticInnerClass()
				&& hasOneConstructor()
				&& (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {
			String gripe= "Test class should have exactly one public zero-argument constructor";
			errors.add(new Exception(gripe));
		}
	}

	private boolean hasOneConstructor() {
		return getTestClass().getJavaClass().getConstructors().length == 1;
	}

	/**
	 * Adds to {@code errors} for each method annotated with {@code @Test},
	 * {@code @Before}, or {@code @After} that is not a public, void instance
	 * method with no arguments.
	 * 
	 * @deprecated unused API, will go away in future version
	 */
	@Deprecated
	protected void validateInstanceMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(After.class, false, errors);
		validatePublicVoidNoArgMethods(Before.class, false, errors);
		validateTestMethods(errors);

		if (computeTestMethods().size() == 0)
			errors.add(new Exception("No runnable methods"));
	}

	protected void validateFields(List<Throwable> errors) {
		RULE_VALIDATOR.validate(getTestClass(), errors);
	}

	private void validateMethods(List<Throwable> errors) {
		RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
	}

	/**
	 * Adds to {@code errors} for each method annotated with {@code @Test}that
	 * is not a public, void instance method with no arguments.
	 */
	protected void validateTestMethods(List<Throwable> errors) {
		validatePublicVoidNoArgMethods(Test.class, false, errors);
	}

	/**
	 * Returns a new fixture for running a test. Default implementation executes
	 * the test class's no-argument constructor (validation should have ensured
	 * one exists).
	 */
	protected Object createTest() throws Exception {
		return getTestClass().getOnlyConstructor().newInstance();
	}

	/**
	 * Returns the name that describes {@code method} for {@link Description}s.
	 * Default implementation is the method's name
	 */
	protected String testName(FrameworkMethod method) {
		return method.getName();
	}

	/**
	 * Returns a Statement that, when executed, either returns normally if
	 * {@code method} passes, or throws an exception if {@code method} fails.
	 * 
	 * Here is an outline of the default implementation:
	 * 
	 * <ul>
	 * <li>Invoke {@code method} on the result of {@code createTest()}, and
	 * throw any exceptions thrown by either operation.
	 * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
	 * expecting} attribute, return normally only if the previous step threw an
	 * exception of the correct type, and throw an exception otherwise.
	 * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
	 * timeout} attribute, throw an exception if the previous step takes more
	 * than the specified number of milliseconds.
	 * <li>ALWAYS run all non-overridden {@code @Before} methods on this class
	 * and superclasses before any of the previous steps; if any throws an
	 * Exception, stop execution and pass the exception on.
	 * <li>ALWAYS run all non-overridden {@code @After} methods on this class
	 * and superclasses after any of the previous steps; all After methods are
	 * always executed: exceptions thrown by previous steps are combined, if
	 * necessary, with exceptions from After methods into a
	 * {@link MultipleFailureException}.
	 * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the
	 * above steps. A {@code Rule} may prevent all execution of the above steps,
	 * or add additional behavior before and after, or modify thrown exceptions.
	 * For more information, see {@link TestRule}
	 * </ul>
	 * 
	 * This can be overridden in subclasses, either by overriding this method,
	 * or the implementations creating each sub-statement.
	 */
	protected Statement methodBlock(FrameworkMethod method) {
		Object test;
		try {
			test= new ReflectiveCallable() {
				@Override
				protected Object runReflectiveCall() throws Throwable {
					return createTest();
				}
			}.run();
		} catch (Throwable e) {
			return new Fail(e);
		}

		Statement statement= methodInvoker(method, test);
		statement= possiblyExpectingExceptions(method, test, statement);
		statement= withPotentialTimeout(method, test, statement);
		statement= withBefores(method, test, statement);
		statement= withAfters(method, test, statement);
		statement= withRules(method, test, statement);
		return statement;
	}

	//
	// Statement builders
	//

	/**
	 * Returns a {@link Statement} that invokes {@code method} on {@code test}
	 */
	protected Statement methodInvoker(FrameworkMethod method, Object test) {
		return new InvokeMethod(method, test);
	}

	/**
	 * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
	 * has the {@code expecting} attribute, return normally only if {@code next}
	 * throws an exception of the correct type, and throw an exception
	 * otherwise.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement possiblyExpectingExceptions(FrameworkMethod method,
			Object test, Statement next) {
		Test annotation= method.getAnnotation(Test.class);
		return expectsException(annotation) ? new ExpectException(next,
				getExpectedException(annotation)) : next;
	}

	/**
	 * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
	 * has the {@code timeout} attribute, throw an exception if {@code next}
	 * takes more than the specified number of milliseconds.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withPotentialTimeout(FrameworkMethod method,
			Object test, Statement next) {
		long timeout= getTimeout(method.getAnnotation(Test.class));
		return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
	}

	/**
	 * Returns a {@link Statement}: run all non-overridden {@code @Before}
	 * methods on this class and superclasses before running {@code next}; if
	 * any throws an Exception, stop execution and pass the exception on.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withBefores(FrameworkMethod method, Object target,
			Statement statement) {
		List<FrameworkMethod> befores= getTestClass().getAnnotatedMethods(
				Before.class);
		return befores.isEmpty() ? statement : new RunBefores(statement,
				befores, target);
	}

	/**
	 * Returns a {@link Statement}: run all non-overridden {@code @After}
	 * methods on this class and superclasses before running {@code next}; all
	 * After methods are always executed: exceptions thrown by previous steps
	 * are combined, if necessary, with exceptions from After methods into a
	 * {@link MultipleFailureException}.
	 * 
	 * @deprecated Will be private soon: use Rules instead
	 */
	@Deprecated
	protected Statement withAfters(FrameworkMethod method, Object target,
			Statement statement) {
		List<FrameworkMethod> afters= getTestClass().getAnnotatedMethods(
				After.class);
		return afters.isEmpty() ? statement : new RunAfters(statement, afters,
				target);
	}

	private Statement withRules(FrameworkMethod method, Object target,
			Statement statement) {
		List<TestRule> testRules= getTestRules(target);
		Statement result= statement;
		result= withMethodRules(method, testRules, target, result);
		result= withTestRules(method, testRules, result);
		
		return result;
	}

	private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
			Object target, Statement result) {
		for (org.junit.rules.MethodRule each : getMethodRules(target))
			if (! testRules.contains(each))
				result= each.apply(result, method, target);
		return result;
	}

	private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
		return rules(target);
	}

	/**
	 * @param target
	 *            the test case instance
	 * @return a list of MethodRules that should be applied when executing this
	 *         test
	 */
	protected List<org.junit.rules.MethodRule> rules(Object target) {
		return getTestClass().getAnnotatedFieldValues(target, Rule.class,
				org.junit.rules.MethodRule.class);
	}

	/**
	 * Returns a {@link Statement}: apply all non-static {@link Value} fields
	 * annotated with {@link Rule}.
	 * @param method 
	 * @param testRules 
	 * @param statement The base statement
	 * @return a RunRules statement if any class-level {@link Rule}s are
	 *         found, or the base statement
	 */
	private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,
			Statement statement) {
		return testRules.isEmpty() ? statement :
			new RunRules(statement, testRules, describeChild(method));
	}

	/**
	 * @param target
	 *            the test case instance
	 * @return a list of TestRules that should be applied when executing this
	 *         test
	 */
	protected List<TestRule> getTestRules(Object target) {
		List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,
				Rule.class, TestRule.class);
			
		result.addAll(getTestClass().getAnnotatedFieldValues(target,
				Rule.class, TestRule.class));

		return result;
	}
	
	private Class<? extends Throwable> getExpectedException(Test annotation) {
		if (annotation == null || annotation.expected() == None.class)
			return null;
		else
			return annotation.expected();
	}

	private boolean expectsException(Test annotation) {
		return getExpectedException(annotation) != null;
	}

	private long getTimeout(Test annotation) {
		if (annotation == null)
			return 0;
		return annotation.timeout();
	}
=======
    /**
     * Creates a BlockJUnit4ClassRunner to run {@code klass}
     *
     * @throws InitializationError if the test class is malformed.
     */
    public BlockJUnit4ClassRunner(Class<?> klass) throws InitializationError {
        super(klass);
    }

    //
    // Implementation of ParentRunner
    //

    @Override
    protected void runChild(final FrameworkMethod method, RunNotifier notifier) {
        Description description = describeChild(method);
        if (method.getAnnotation(Ignore.class) != null) {
            notifier.fireTestIgnored(description);
        } else {
            runLeaf(methodBlock(method), description, notifier);
        }
    }

    @Override
    protected Description describeChild(FrameworkMethod method) {
        return Description.createTestDescription(getTestClass().getJavaClass(),
                testName(method), method.getAnnotations());
    }

    @Override
    protected List<FrameworkMethod> getChildren() {
        return computeTestMethods();
    }

    //
    // Override in subclasses
    //

    /**
     * Returns the methods that run tests. Default implementation returns all
     * methods annotated with {@code @Test} on this class and superclasses that
     * are not overridden.
     */
    protected List<FrameworkMethod> computeTestMethods() {
        return getTestClass().getAnnotatedMethods(Test.class);
    }

    @Override
    protected void collectInitializationErrors(List<Throwable> errors) {
        super.collectInitializationErrors(errors);

        validateNoNonStaticInnerClass(errors);
        validateConstructor(errors);
        validateInstanceMethods(errors);
        validateFields(errors);
        validateMethods(errors);
    }

    protected void validateNoNonStaticInnerClass(List<Throwable> errors) {
        if (getTestClass().isANonStaticInnerClass()) {
            String gripe = "The inner class " + getTestClass().getName()
                    + " is not static.";
            errors.add(new Exception(gripe));
        }
    }

    /**
     * Adds to {@code errors} if the test class has more than one constructor,
     * or if the constructor takes parameters. Override if a subclass requires
     * different validation rules.
     */
    protected void validateConstructor(List<Throwable> errors) {
        validateOnlyOneConstructor(errors);
        validateZeroArgConstructor(errors);
    }

    /**
     * Adds to {@code errors} if the test class has more than one constructor
     * (do not override)
     */
    protected void validateOnlyOneConstructor(List<Throwable> errors) {
        if (!hasOneConstructor()) {
            String gripe = "Test class should have exactly one public constructor";
            errors.add(new Exception(gripe));
        }
    }

    /**
     * Adds to {@code errors} if the test class's single constructor takes
     * parameters (do not override)
     */
    protected void validateZeroArgConstructor(List<Throwable> errors) {
        if (!getTestClass().isANonStaticInnerClass()
                && hasOneConstructor()
                && (getTestClass().getOnlyConstructor().getParameterTypes().length != 0)) {
            String gripe = "Test class should have exactly one public zero-argument constructor";
            errors.add(new Exception(gripe));
        }
    }

    private boolean hasOneConstructor() {
        return getTestClass().getJavaClass().getConstructors().length == 1;
    }

    /**
     * Adds to {@code errors} for each method annotated with {@code @Test},
     * {@code @Before}, or {@code @After} that is not a public, void instance
     * method with no arguments.
     *
     * @deprecated unused API, will go away in future version
     */
    @Deprecated
    protected void validateInstanceMethods(List<Throwable> errors) {
        validatePublicVoidNoArgMethods(After.class, false, errors);
        validatePublicVoidNoArgMethods(Before.class, false, errors);
        validateTestMethods(errors);

        if (computeTestMethods().size() == 0) {
            errors.add(new Exception("No runnable methods"));
        }
    }

    protected void validateFields(List<Throwable> errors) {
        RULE_VALIDATOR.validate(getTestClass(), errors);
    }

    private void validateMethods(List<Throwable> errors) {
        RULE_METHOD_VALIDATOR.validate(getTestClass(), errors);
    }

    /**
     * Adds to {@code errors} for each method annotated with {@code @Test}that
     * is not a public, void instance method with no arguments.
     */
    protected void validateTestMethods(List<Throwable> errors) {
        validatePublicVoidNoArgMethods(Test.class, false, errors);
    }

    /**
     * Returns a new fixture for running a test. Default implementation executes
     * the test class's no-argument constructor (validation should have ensured
     * one exists).
     */
    protected Object createTest() throws Exception {
        return getTestClass().getOnlyConstructor().newInstance();
    }

    /**
     * Returns the name that describes {@code method} for {@link Description}s.
     * Default implementation is the method's name
     */
    protected String testName(FrameworkMethod method) {
        return method.getName();
    }

    /**
     * Returns a Statement that, when executed, either returns normally if
     * {@code method} passes, or throws an exception if {@code method} fails.
     *
     * Here is an outline of the default implementation:
     *
     * <ul>
     * <li>Invoke {@code method} on the result of {@code createTest()}, and
     * throw any exceptions thrown by either operation.
     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
     * expecting} attribute, return normally only if the previous step threw an
     * exception of the correct type, and throw an exception otherwise.
     * <li>HOWEVER, if {@code method}'s {@code @Test} annotation has the {@code
     * timeout} attribute, throw an exception if the previous step takes more
     * than the specified number of milliseconds.
     * <li>ALWAYS run all non-overridden {@code @Before} methods on this class
     * and superclasses before any of the previous steps; if any throws an
     * Exception, stop execution and pass the exception on.
     * <li>ALWAYS run all non-overridden {@code @After} methods on this class
     * and superclasses after any of the previous steps; all After methods are
     * always executed: exceptions thrown by previous steps are combined, if
     * necessary, with exceptions from After methods into a
     * {@link MultipleFailureException}.
     * <li>ALWAYS allow {@code @Rule} fields to modify the execution of the
     * above steps. A {@code Rule} may prevent all execution of the above steps,
     * or add additional behavior before and after, or modify thrown exceptions.
     * For more information, see {@link TestRule}
     * </ul>
     *
     * This can be overridden in subclasses, either by overriding this method,
     * or the implementations creating each sub-statement.
     */
    protected Statement methodBlock(FrameworkMethod method) {
        Object test;
        try {
            test = new ReflectiveCallable() {
                @Override
                protected Object runReflectiveCall() throws Throwable {
                    return createTest();
                }
            }.run();
        } catch (Throwable e) {
            return new Fail(e);
        }

        Statement statement = methodInvoker(method, test);
        statement = possiblyExpectingExceptions(method, test, statement);
        statement = withPotentialTimeout(method, test, statement);
        statement = withBefores(method, test, statement);
        statement = withAfters(method, test, statement);
        statement = withRules(method, test, statement);
        return statement;
    }

    //
    // Statement builders
    //

    /**
     * Returns a {@link Statement} that invokes {@code method} on {@code test}
     */
    protected Statement methodInvoker(FrameworkMethod method, Object test) {
        return new InvokeMethod(method, test);
    }

    /**
     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
     * has the {@code expecting} attribute, return normally only if {@code next}
     * throws an exception of the correct type, and throw an exception
     * otherwise.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement possiblyExpectingExceptions(FrameworkMethod method,
            Object test, Statement next) {
        Test annotation = method.getAnnotation(Test.class);
        return expectsException(annotation) ? new ExpectException(next,
                getExpectedException(annotation)) : next;
    }

    /**
     * Returns a {@link Statement}: if {@code method}'s {@code @Test} annotation
     * has the {@code timeout} attribute, throw an exception if {@code next}
     * takes more than the specified number of milliseconds.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement withPotentialTimeout(FrameworkMethod method,
            Object test, Statement next) {
        long timeout = getTimeout(method.getAnnotation(Test.class));
        return timeout > 0 ? new FailOnTimeout(next, timeout) : next;
    }

    /**
     * Returns a {@link Statement}: run all non-overridden {@code @Before}
     * methods on this class and superclasses before running {@code next}; if
     * any throws an Exception, stop execution and pass the exception on.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement withBefores(FrameworkMethod method, Object target,
            Statement statement) {
        List<FrameworkMethod> befores = getTestClass().getAnnotatedMethods(
                Before.class);
        return befores.isEmpty() ? statement : new RunBefores(statement,
                befores, target);
    }

    /**
     * Returns a {@link Statement}: run all non-overridden {@code @After}
     * methods on this class and superclasses before running {@code next}; all
     * After methods are always executed: exceptions thrown by previous steps
     * are combined, if necessary, with exceptions from After methods into a
     * {@link MultipleFailureException}.
     *
     * @deprecated Will be private soon: use Rules instead
     */
    @Deprecated
    protected Statement withAfters(FrameworkMethod method, Object target,
            Statement statement) {
        List<FrameworkMethod> afters = getTestClass().getAnnotatedMethods(
                After.class);
        return afters.isEmpty() ? statement : new RunAfters(statement, afters,
                target);
    }

    private Statement withRules(FrameworkMethod method, Object target,
            Statement statement) {
        List<TestRule> testRules = getTestRules(target);
        Statement result = statement;
        result = withMethodRules(method, testRules, target, result);
        result = withTestRules(method, testRules, result);

        return result;
    }

    @SuppressWarnings("deprecation")
    private Statement withMethodRules(FrameworkMethod method, List<TestRule> testRules,
            Object target, Statement result) {
        for (org.junit.rules.MethodRule each : getMethodRules(target)) {
            if (!testRules.contains(each)) {
                result = each.apply(result, method, target);
            }
        }
        return result;
    }

    @SuppressWarnings("deprecation")
    private List<org.junit.rules.MethodRule> getMethodRules(Object target) {
        return rules(target);
    }

    /**
     * @param target the test case instance
     * @return a list of MethodRules that should be applied when executing this
     *         test
     * @deprecated {@link org.junit.rules.MethodRule} is a deprecated interface. Port to
     *             {@link TestRule} and
     *             {@link BlockJUnit4ClassRunner#getTestRules(Object)}
     */
    @Deprecated
    protected List<org.junit.rules.MethodRule> rules(Object target) {
        return getTestClass().getAnnotatedFieldValues(target, Rule.class,
                org.junit.rules.MethodRule.class);
    }

    /**
     * Returns a {@link Statement}: apply all non-static {@link Value} fields
     * annotated with {@link Rule}.
     *
     * @param statement The base statement
     * @return a RunRules statement if any class-level {@link Rule}s are
     *         found, or the base statement
     */
    private Statement withTestRules(FrameworkMethod method, List<TestRule> testRules,
            Statement statement) {
        return testRules.isEmpty() ? statement :
                new RunRules(statement, testRules, describeChild(method));
    }

    /**
     * @param target the test case instance
     * @return a list of TestRules that should be applied when executing this
     *         test
     */
    protected List<TestRule> getTestRules(Object target) {
        List<TestRule> result = getTestClass().getAnnotatedMethodValues(target,
                Rule.class, TestRule.class);

        result.addAll(getTestClass().getAnnotatedFieldValues(target,
                Rule.class, TestRule.class));

        return result;
    }

    private Class<? extends Throwable> getExpectedException(Test annotation) {
        if (annotation == null || annotation.expected() == None.class) {
            return null;
        } else {
            return annotation.expected();
        }
    }

    private boolean expectsException(Test annotation) {
        return getExpectedException(annotation) != null;
    }

    private long getTimeout(Test annotation) {
        if (annotation == null) {
            return 0;
        }
        return annotation.timeout();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/Rule.java;<<<<<<< MINE
 * Annotates fields that reference rules or methods that return a rule. A field must be public, not
 * static, and a subtype of {@link org.junit.rules.TestRule} (preferred) or
 * {@link org.junit.rules.MethodRule}. A method must be public, not static
 * and must return a subtype of {@link org.junit.rules.TestRule} (preferred) or
 * {@link org.junit.rules.MethodRule}.<p>
 *
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link Before} methods, 
=======
 * Annotates fields that contain rules or methods that return a rule. A field must be public, not
 * static, and a subtype of {@link org.junit.rules.TestRule}. A method must be public, not static
 * and must return a subtype of {@link org.junit.rules.TestRule}.
 * The {@link org.junit.runners.model.Statement} passed
 * to the {@link org.junit.rules.TestRule} will run any {@link Before} methods,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/Rule.java;<<<<<<< MINE
 * 
 * For more information and more examples, see 
 * {@link org.junit.rules.TestRule}. 
=======
 *
 * For more information and more examples, see
 * {@link org.junit.rules.TestRule}.
 *
 * Note: for backwards compatibility, this annotation may also mark
 * fields or methods of type {@link org.junit.rules.MethodRule}, which will be honored.  However,
 * this is a deprecated interface and feature.
 *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_bbacbd9_2f879b9/rev_bbacbd9-2f879b9/src/main/java/org/junit/ClassRule.java;<<<<<<< MINE
 * a subtype of {@link org.junit.rules.TestRule}.<p>
 *
 * The {@link org.junit.runners.model.Statement} passed 
 * to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods, 
=======
 * a subtype of {@link org.junit.rules.TestRule}
 * The {@link org.junit.runners.model.Statement} passed
 * to the {@link org.junit.rules.TestRule} will run any {@link BeforeClass} methods,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_5bf4a69_92f6785/rev_5bf4a69-92f6785/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
    @Deprecated
    public void pexpire(final String key, final int milliseconds) {
	pexpire(key, (long) milliseconds);
    }
    
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6fb53a7_2f879b9/rev_6fb53a7-2f879b9/src/main/java/org/junit/rules/TestWatcher.java;<<<<<<< MINE
	public Statement apply(final Statement base, final Description description) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				List<Throwable> errors = new ArrayList<Throwable>();

				startingQuietly(description, errors);
				try {
					base.evaluate();
					succeededQuietly(description, errors);
				} catch (AssumptionViolatedException e) {
					errors.add(e);
					skippedQuietly(e, description, errors);
				} catch (Throwable t) {
					errors.add(t);
					failedQuietly(t, description, errors);
				} finally {
					finishedQuietly(description, errors);
				}
				
				MultipleFailureException.assertEmpty(errors);
			}
		};
	}

	private void succeededQuietly(Description description,
			List<Throwable> errors) {
		try {
			succeeded(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	private void failedQuietly(Throwable t, Description description,
			List<Throwable> errors) {
		try {
			failed(t, description);
		} catch (Throwable t1) {
			errors.add(t1);
		}
	}

	private void skippedQuietly(AssumptionViolatedException e, Description description,
			List<Throwable> errors) {
		try {
			skipped(e, description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}

	private void startingQuietly(Description description,
			List<Throwable> errors) {
		try {
			starting(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	private void finishedQuietly(Description description,
			List<Throwable> errors) {
		try {
			finished(description);
		} catch (Throwable t) {
			errors.add(t);
		}
	}
	
	/**
	 * Invoked when a test succeeds
	 * 
	 * @param description
	 */
	protected void succeeded(Description description) {
	}

	/**
	 * Invoked when a test fails
	 * 
	 * @param e 
	 * @param description
	 */
	protected void failed(Throwable e, Description description) {
	}

	/**
	 * Invoked when a test is skipped due to a failed assumption.
	 *
	 * @param e
	 * @param description
	 */
	protected void skipped(AssumptionViolatedException e, Description description) {
	}

	/**
	 * Invoked when a test is about to start
	 * 
	 * @param description  
	 */
	protected void starting(Description description) {
	}

	/**
	 * Invoked when a test method finishes (whether passing or failing)
	 * 
	 * @param description  
	 */
	protected void finished(Description description) {
	}
=======
    public Statement apply(final Statement base, final Description description) {
        return new Statement() {
            @Override
            public void evaluate() throws Throwable {
                List<Throwable> errors = new ArrayList<Throwable>();

                startingQuietly(description, errors);
                try {
                    base.evaluate();
                    succeededQuietly(description, errors);
                } catch (AssumptionViolatedException e) {
                    skipped(e, description);
                    throw e;
                } catch (Throwable t) {
                    errors.add(t);
                    failedQuietly(t, description, errors);
                } finally {
                    finishedQuietly(description, errors);
                }

                MultipleFailureException.assertEmpty(errors);
            }
        };
    }

    private void succeededQuietly(Description description,
            List<Throwable> errors) {
        try {
            succeeded(description);
        } catch (Throwable t) {
            errors.add(t);
        }
    }

    private void failedQuietly(Throwable t, Description description,
            List<Throwable> errors) {
        try {
            failed(t, description);
        } catch (Throwable t1) {
            errors.add(t1);
        }
    }

    private void startingQuietly(Description description,
            List<Throwable> errors) {
        try {
            starting(description);
        } catch (Throwable t) {
            errors.add(t);
        }
    }

    private void finishedQuietly(Description description,
            List<Throwable> errors) {
        try {
            finished(description);
        } catch (Throwable t) {
            errors.add(t);
        }
    }

    /**
     * Invoked when a test succeeds
     */
    protected void succeeded(Description description) {
    }

    /**
     * Invoked when a test fails
     */
    protected void failed(Throwable e, Description description) {
    }

    /**
     * Invoked when a test is skipped due to a failed assumption.
     */
    protected void skipped(AssumptionViolatedException e, Description description) {
    }

    /**
     * Invoked when a test is about to start
     */
    protected void starting(Description description) {
    }

    /**
     * Invoked when a test method finishes (whether passing or failing)
     */
    protected void finished(Description description) {
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6fb53a7_2f879b9/rev_6fb53a7-2f879b9/src/test/java/org/junit/tests/experimental/rules/TestWatcherTest.java;<<<<<<< MINE
		@Test
		public void succeeds() {
			assumeTrue(false);
		}
	}

	@Test
	public void neitherLogSuccessNorFailedForViolatedAssumption() {
		ViolatedAssumptionTest.watchedLog= new StringBuilder();
		runClasses(ViolatedAssumptionTest.class);
		assertThat(ViolatedAssumptionTest.watchedLog.toString(),
				is("starting finished "));
	}

	public static class TestWatcherSkippedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void skipped(AssumptionViolatedException e, Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new AssumptionViolatedException("test failure");
		}
	}

	@Test
	public void testWatcherSkippedThrowsException() {
		PrintableResult result= testResult(TestWatcherSkippedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}

	public static class FailingTest {
		private static StringBuilder watchedLog= new StringBuilder();

		@Rule
		public TestRule watcher= new LoggingTestWatcher(watchedLog);

		@Test
		public void succeeds() {
			fail();
		}
	}

	@Test
	public void logFailingTest() {
		FailingTest.watchedLog= new StringBuilder();
		runClasses(FailingTest.class);
		assertThat(FailingTest.watchedLog.toString(),
				is("starting failed finished "));
	}
	
	public static class TestWatcherFailedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable e, Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherStartingThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void starting(Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherStartingThrowsException() {
		PrintableResult result= testResult(TestWatcherStartingThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherFailedAndFinishedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable t, Description description) {
				throw new RuntimeException("watcher failed failure");
			}
			
			@Override
			protected void finished(Description description) {
				throw new RuntimeException("watcher finished failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedAndFinishedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(3));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failed failure"));
		assertThat(result, hasFailureContaining("watcher finished failure"));
	}	
=======
        @Test
        public void succeeds() {
            assumeTrue(false);
        }
    }

    @Test
    public void neitherLogSuccessNorFailedForViolatedAssumption() {
        ViolatedAssumptionTest.watchedLog = new StringBuilder();
        runClasses(ViolatedAssumptionTest.class);
        assertThat(ViolatedAssumptionTest.watchedLog.toString(),
                is("starting finished "));
    }

    public static class FailingTest {
        private static StringBuilder watchedLog = new StringBuilder();

        @Rule
        public TestRule watcher = new LoggingTestWatcher(watchedLog);

        @Test
        public void succeeds() {
            fail();
        }
    }

    @Test
    public void logFailingTest() {
        FailingTest.watchedLog = new StringBuilder();
        runClasses(FailingTest.class);
        assertThat(FailingTest.watchedLog.toString(),
                is("starting failed finished "));
    }

    public static class TestWatcherFailedThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void failed(Throwable e, Description description) {
                throw new RuntimeException("watcher failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherFailedThrowsException() {
        PrintableResult result = testResult(TestWatcherFailedThrowsExceptionTest.class);
        assertThat(result, failureCountIs(2));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failure"));
    }

    public static class TestWatcherStartingThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void starting(Description description) {
                throw new RuntimeException("watcher failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherStartingThrowsException() {
        PrintableResult result = testResult(TestWatcherStartingThrowsExceptionTest.class);
        assertThat(result, failureCountIs(2));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failure"));
    }

    public static class TestWatcherFailedAndFinishedThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void failed(Throwable t, Description description) {
                throw new RuntimeException("watcher failed failure");
            }

            @Override
            protected void finished(Description description) {
                throw new RuntimeException("watcher finished failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherFailedAndFinishedThrowsException() {
        PrintableResult result = testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
        assertThat(result, failureCountIs(3));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failed failure"));
        assertThat(result, hasFailureContaining("watcher finished failure"));
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

=======

    @Override
    public void close() {
	if (dataSource != null) {
	    if (client.isBroken()) {
		this.dataSource.returnBrokenResource(this);
	    } else {
		this.dataSource.returnResource(this);
	    }
	} else {
	    client.close();
	}
    }

    public void setDataSource(Pool<Jedis> jedisPool) {
        this.dataSource = jedisPool;
    }

    public Long pfadd(final String key, final String... elements) {
	checkIsInMulti();
	client.pfadd(key, elements);
	return client.getIntegerReply();
    }

    public long pfcount(final String key) {
	checkIsInMulti();
	client.pfcount(key);
	return client.getIntegerReply();
    }

    @Override
    public long pfcount(String... keys) {
        checkIsInMulti();
	client.pfcount(keys);
	return client.getIntegerReply();
    }

    public String pfmerge(final String destkey, final String... sourcekeys) {
	checkIsInMulti();
	client.pfmerge(destkey, sourcekeys);
	return client.getStatusCodeReply();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, ZLEXCOUNT, ZRANGEBYLEX, ZREMRANGEBYLEX, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING;
=======
	PING, SET, GET, QUIT, EXISTS, DEL, TYPE, FLUSHDB, KEYS, RANDOMKEY, RENAME, RENAMENX, RENAMEX, DBSIZE, EXPIRE, EXPIREAT, TTL, SELECT, MOVE, FLUSHALL, GETSET, MGET, SETNX, SETEX, MSET, MSETNX, DECRBY, DECR, INCRBY, INCR, APPEND, SUBSTR, HSET, HGET, HSETNX, HMSET, HMGET, HINCRBY, HEXISTS, HDEL, HLEN, HKEYS, HVALS, HGETALL, RPUSH, LPUSH, LLEN, LRANGE, LTRIM, LINDEX, LSET, LREM, LPOP, RPOP, RPOPLPUSH, SADD, SMEMBERS, SREM, SPOP, SMOVE, SCARD, SISMEMBER, SINTER, SINTERSTORE, SUNION, SUNIONSTORE, SDIFF, SDIFFSTORE, SRANDMEMBER, ZADD, ZRANGE, ZREM, ZINCRBY, ZRANK, ZREVRANK, ZREVRANGE, ZCARD, ZSCORE, MULTI, DISCARD, EXEC, WATCH, UNWATCH, SORT, BLPOP, BRPOP, AUTH, SUBSCRIBE, PUBLISH, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBSUB, ZCOUNT, ZRANGEBYSCORE, ZREVRANGEBYSCORE, ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZUNIONSTORE, ZINTERSTORE, SAVE, BGSAVE, BGREWRITEAOF, LASTSAVE, SHUTDOWN, INFO, MONITOR, SLAVEOF, CONFIG, STRLEN, SYNC, LPUSHX, PERSIST, RPUSHX, ECHO, LINSERT, DEBUG, BRPOPLPUSH, SETBIT, GETBIT, BITPOS, SETRANGE, GETRANGE, EVAL, EVALSHA, SCRIPT, SLOWLOG, OBJECT, BITCOUNT, BITOP, SENTINEL, DUMP, RESTORE, PEXPIRE, PEXPIREAT, PTTL, INCRBYFLOAT, PSETEX, CLIENT, TIME, MIGRATE, HINCRBYFLOAT, SCAN, HSCAN, SSCAN, ZSCAN, WAIT, CLUSTER, ASKING, PFADD, PFCOUNT, PFMERGE;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE

=======
    
    @Override
    public Long pfadd(final byte[] key, final byte[]... elements) {
	Jedis j = getShard(key);
	return j.pfadd(key, elements);
    }

    @Override
    public long pfcount(final byte[] key) {
	Jedis j = getShard(key);
	return j.pfcount(key);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_409740f_36810df/rev_409740f-36810df/src/test/java/redis/clients/jedis/tests/commands/SortedSetCommandsTest.java;<<<<<<< MINE
    final byte[] bInclusiveB = { 0x5B, 0x0B }; 
    final byte[] bExclusiveC = { 0x28, 0x0C }; 
    final byte[] bLexMinusInf = { 0x2D };
    final byte[] bLexPlusInf = { 0x2B };
=======
    
    final byte[] bbar1 = { 0x05, 0x06, 0x07, 0x08, 0x0A };
    final byte[] bbar2 = { 0x05, 0x06, 0x07, 0x08, 0x0B };
    final byte[] bbar3 = { 0x05, 0x06, 0x07, 0x08, 0x0C };
    final byte[] bbarstar = { 0x05, 0x06, 0x07, 0x08, '*' };
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6766336_b04c86a/rev_6766336-b04c86a/src/test/java/org/junit/internal/MethodSorterTest.java;<<<<<<< MINE
=======
    public void testDefaultMethodSorter() {
        List<String> expected = Arrays.asList(new String[]{EPSILON, BETA, ALPHA, DELTA, GAMMA_VOID, GAMMA_BOOLEAN});
        List<String> actual = getDeclaredFilteredMethods(DummySortWithDefault.class, expected);
        assertEquals(expected, actual);
    }

    
    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
=======
    
    @Override
    public List<Object> clusterSlots() {
	checkIsInMulti();
	client.clusterSlots();
	return client.getObjectMultiBulkReply();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
=======
    
    public void clusterSlots() {
	cluster(Protocol.CLUSTER_SLOTS);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/Protocol.java;<<<<<<< MINE
=======
    public static final String CLUSTER_SLOTS = "slots";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/main/java/redis/clients/jedis/ClusterCommands.java;<<<<<<< MINE
=======
    
    List<Object> clusterSlots();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/test/java/redis/clients/jedis/tests/commands/ClusterCommandsTest.java;<<<<<<< MINE
=======
	node1.clusterDelSlots(3000, 3001, 3002);
	node2.clusterDelSlots(4000, 4001, 4002);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_36810df_15ab934/rev_36810df-15ab934/src/test/java/redis/clients/jedis/tests/commands/ClusterCommandsTest.java;<<<<<<< MINE
=======
    
    @Test
    public void clusterSlots() {
	// please see cluster slot output format from below commit
	// @see:
	// https://github.com/antirez/redis/commit/e14829de3025ffb0d3294e5e5a1553afd9f10b60
	String status = node1.clusterAddSlots(3000, 3001, 3002);
	assertEquals("OK", status);
	status = node2.clusterAddSlots(4000, 4001, 4002);
	assertEquals("OK", status);

	List<Object> slots = node1.clusterSlots();
	assertNotNull(slots);
	assertTrue(slots.size() > 0);

	for (Object slotInfoObj : slots) {
	    List<Object> slotInfo = (List<Object>) slotInfoObj;
	    assertNotNull(slots);
	    assertTrue(slots.size() >= 2);

	    assertTrue(slotInfo.get(0) instanceof Long);
	    assertTrue(slotInfo.get(1) instanceof Long);

	    if (slots.size() > 2) {
		// assigned slots
		assertTrue(slotInfo.get(2) instanceof List);
	    }
	}
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_992ae7a_a30598b/rev_992ae7a-a30598b/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE

=======

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_992ae7a_a30598b/rev_992ae7a-a30598b/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE

=======

    @Override
    public List<String> blpop(int timeout, String key) {
	checkIsInMulti();
	List<String> args = new ArrayList<String>();
	args.add(key);
	args.add(String.valueOf(timeout));
	client.blpop(args.toArray(new String[args.size()]));
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    @Override
    public List<String> brpop(int timeout, String key) {
	checkIsInMulti();
	List<String> args = new ArrayList<String>();
	args.add(key);
	args.add(String.valueOf(timeout));
	client.brpop(args.toArray(new String[args.size()]));
	client.setTimeoutInfinite();
	final List<String> multiBulkReply = client.getMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }  

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    public JedisSentinelPool(String masterName, Set<String> sentinels,
	    final GenericObjectPoolConfig poolConfig, int timeout,
	    final String password, final int database) {

	this.poolConfig = poolConfig;
	this.timeout = timeout;
	this.password = password;
	this.database = database;
=======
	public JedisSentinelPool(String masterName, Set<String> sentinels,
			final GenericObjectPoolConfig poolConfig, int timeout,
			final String password, final int database) {
		this.poolConfig = poolConfig;
		this.timeout = timeout;
		this.password = password;
		this.database = database;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
	HostAndPort master = initSentinels(sentinels, masterName);
	initPool(master);
    }

    private volatile JedisFactory factory;
    private volatile HostAndPort currentHostMaster;

    public void destroy() {
	for (MasterListener m : masterListeners) {
	    m.shutdown();
=======
		HostAndPort master = initSentinels(sentinels, masterName);
		initPool(master);
	}

	public void returnBrokenResource(final Jedis resource) {
		if (resource != null) {
			returnBrokenResourceObject(resource);
		}
	}

	public void returnResource(final Jedis resource) {
		if (resource != null) {
			resource.resetState();
			returnResourceObject(resource);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    private void initPool(HostAndPort master) {
	if (!master.equals(currentHostMaster)) {
	    currentHostMaster = master;
	    if (factory == null) {
	        factory = new JedisFactory(master.getHost(), master.getPort(),
	                                   timeout, password, database);
	        initPool(poolConfig, factory);
	    } else {
	        factory.setHostAndPort(currentHostMaster);
	        // although we clear the pool, we still have to check the returned object
	        // in getResource, this call only clears idle instances, not borrowed instances
	        internalPool.clear();
	    }

	    log.info("Created JedisPool to master at " + master);
=======
		super.destroy();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
		Jedis jedis = null;
		try {
		    jedis = new Jedis(hap.getHost(), hap.getPort());
=======
		log.info("Redis master running at " + master
				+ ", starting Sentinel listeners...");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
		    if (master == null) {
			master = toHostAndPort(jedis
				.sentinelGetMasterAddrByName(masterName));
			log.fine("Found Redis master at " + master);
			break outer;
		    }
		} catch (JedisConnectionException e) {
		    log.warning("Cannot connect to sentinel running @ " + hap
			    + ". Trying next one.");
		} finally {
		    if (jedis != null) {
	        jedis.close();
		    }
=======
		for (String sentinel : sentinels) {
			final HostAndPort hap = toHostAndPort(Arrays.asList(sentinel
					.split(":")));
			MasterListener masterListener = new MasterListener(masterName,
					hap.getHost(), hap.getPort());
			masterListeners.add(masterListener);
			masterListener.start();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    @Override
    public Jedis getResource() {
	while (true) {
	    Jedis jedis = super.getResource();
	    jedis.setDataSource(this);

	    // get a reference because it can change concurrently
	    final HostAndPort master = currentHostMaster;
	    final HostAndPort connection = new HostAndPort(jedis.getClient().getHost(),
	       jedis.getClient().getPort());

	    if (master.equals(connection)) {
	        // connected to the correct master
	        return jedis;
	    } else {
	        returnBrokenResource(jedis);
	    }
	}
    }

    public void returnBrokenResource(final Jedis resource) {
	if (resource != null) {
	    returnBrokenResourceObject(resource);
	}
    }

    public void returnResource(final Jedis resource) {
	if (resource != null) {
	    resource.resetState();
	    returnResourceObject(resource);
	}
    }

    protected class JedisPubSubAdapter extends JedisPubSub {
	@Override
	public void onMessage(String channel, String message) {
	}
=======
		@Override
		public void onPUnsubscribe(String pattern, int subscribedChannels) {
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/test/java/redis/clients/jedis/tests/JedisSentinelPoolTest.java;<<<<<<< MINE
    protected static HostAndPort master = HostAndPortUtil.getRedisServers()
	    .get(2);
    protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
	    .get(3);

    protected static HostAndPort sentinel1 = HostAndPortUtil
	    .getSentinelServers().get(1);
    protected static HostAndPort sentinel2 = HostAndPortUtil
            .getSentinelServers().get(3);

    protected static Jedis sentinelJedis1;
    protected static Jedis sentinelJedis2;

    protected Set<String> sentinels = new HashSet<String>();

    @Before
    public void setUp() throws Exception {
	sentinels.add(sentinel1.toString());
	sentinels.add(sentinel2.toString());

	sentinelJedis1 = new Jedis(sentinel1.getHost(), sentinel1.getPort());
	sentinelJedis2 = new Jedis(sentinel2.getHost(), sentinel2.getPort());
    }
    
    @Test
    public void checkCloseableConnections() throws Exception {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();

	JedisSentinelPool pool = new JedisSentinelPool(
		MASTER_NAME, sentinels, config, 1000, "foobared", 2);
	Jedis jedis = pool.getResource();
	jedis.auth("foobared");
	jedis.set("foo", "bar");
	assertEquals("bar", jedis.get("foo"));
	pool.returnResource(jedis);
	pool.close();
	assertTrue(pool.isClosed());
    }

    @Test
    public void ensureSafeTwiceFailover() throws InterruptedException {
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		new GenericObjectPoolConfig(), 1000, "foobared", 2);

	forceFailover(pool);
	// after failover sentinel needs a bit of time to stabilize before a new failover
	Thread.sleep(100);
	forceFailover(pool);

	// you can test failover as much as possible
    }
    
    @Test
    public void returnResourceShouldResetState() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis jedis = pool.getResource();
	Jedis jedis2 = null;
	
	try {
	    jedis.set("hello", "jedis");
	    Transaction t = jedis.multi();
	    t.set("hello", "world");
	    pool.returnResource(jedis);
	    
	    jedis2 = pool.getResource();

	    assertTrue(jedis == jedis2);
	    assertEquals("jedis", jedis2.get("hello"));
	} catch (JedisConnectionException e) {
	    if (jedis2 != null) {
		pool.returnBrokenResource(jedis2);
		jedis2 = null;
	    }
	} finally {
	    if (jedis2 != null)
		pool.returnResource(jedis2);
	    
	    pool.destroy();
	}
    }
    
    @Test
    public void checkResourceIsCloseable() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis jedis = pool.getResource();
	try {
	    jedis.set("hello", "jedis");
	} finally {
	    jedis.close();
	}

	Jedis jedis2 = pool.getResource();
	try {
	    assertEquals(jedis, jedis2);
	} finally {
	    jedis2.close();
	}
    }

    @Test
    public void returnResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnResource(nullJedis);
	pool.destroy();
    }

    @Test
    public void returnBrokenResourceWithNullResource() {
	GenericObjectPoolConfig config = new GenericObjectPoolConfig();
	config.setMaxTotal(1);
	config.setBlockWhenExhausted(false);
	JedisSentinelPool pool = new JedisSentinelPool(MASTER_NAME, sentinels,
		config, 1000, "foobared", 2);

	Jedis nullJedis = null;
	pool.returnBrokenResource(nullJedis);
	pool.destroy();
    }

    private void forceFailover(JedisSentinelPool pool)
	    throws InterruptedException {
	HostAndPort oldMaster = pool.getCurrentHostMaster();

	// jedis connection should be master
	Jedis beforeFailoverJedis = pool.getResource();
	assertEquals("PONG", beforeFailoverJedis.ping());

	waitForFailover(pool, oldMaster);

	Jedis afterFailoverJedis = pool.getResource();
	assertEquals("PONG", afterFailoverJedis.ping());
	assertEquals("foobared", afterFailoverJedis.configGet("requirepass").get(1));
	assertEquals(2, afterFailoverJedis.getDB().intValue());
	
	// returning both connections to the pool should not throw
	beforeFailoverJedis.close();
	afterFailoverJedis.close();
    }

    private void waitForFailover(JedisSentinelPool pool, HostAndPort oldMaster)
	    throws InterruptedException {
	HostAndPort newMaster = JedisSentinelTestUtil
		.waitForNewPromotedMaster(MASTER_NAME, sentinelJedis1, sentinelJedis2);

	waitForJedisSentinelPoolRecognizeNewMaster(pool, newMaster);
    }

    private void waitForJedisSentinelPoolRecognizeNewMaster(
	    JedisSentinelPool pool, HostAndPort newMaster)
	    throws InterruptedException {

	while (true) {
	    HostAndPort currentHostMaster = pool.getCurrentHostMaster();

	    if (newMaster.equals(currentHostMaster))
		break;
=======
	protected static HostAndPort master = HostAndPortUtil.getRedisServers()
			.get(2);
	protected static HostAndPort slave1 = HostAndPortUtil.getRedisServers()
			.get(3);
	protected static HostAndPort sentinel1 = HostAndPortUtil
			.getSentinelServers().get(1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

import java.util.*;
=======
import redis.clients.jedis.exceptions.JedisConnectionException;

import java.util.Map;
import java.util.Random;
import java.util.Set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
    public static ClusterNodeInformationParser nodeInfoParser = new ClusterNodeInformationParser();

    protected Map<String, JedisPool> nodes = new HashMap<String, JedisPool>();
    protected Map<Integer, JedisPool> slots = new HashMap<Integer, JedisPool>();
    final protected GenericObjectPoolConfig poolConfig;
=======
    protected JedisClusterInfoCache cache = new JedisClusterInfoCache();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
    private void discoverClusterNodesAndSlots(Jedis jedis) {
        String localNodes = jedis.clusterNodes();
        for (String nodeInfo : localNodes.split("\n")) {
            ClusterNodeInformation clusterNodeInfo = nodeInfoParser.parse(
                    nodeInfo, new HostAndPort(jedis.getClient().getHost(),
                    jedis.getClient().getPort()));

            HostAndPort targetNode = clusterNodeInfo.getNode();
            setNodeIfNotExist(targetNode);
            assignSlotsToNode(clusterNodeInfo.getAvailableSlots(), targetNode);
        }
    }

    public void assignSlotToNode(int slot, HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}
	slots.put(slot, targetPool);
    }

    public void assignSlotsToNode(List<Integer> targetSlots,
	    HostAndPort targetNode) {
	JedisPool targetPool = nodes.get(getNodeKey(targetNode));

	if (targetPool == null) {
	    setNodeIfNotExist(targetNode);
	    targetPool = nodes.get(getNodeKey(targetNode));
	}

	for (Integer slot : targetSlots) {
	    slots.put(slot, targetPool);
=======
    public void renewSlotCache() {
	for (JedisPool jp : cache.getNodes().values()) {
	    Jedis jedis = null;
	    try {
		jedis = jp.getResource();
		cache.discoverClusterSlots(jedis);
		break;
	    } finally {
		if (jedis != null) {
		    jedis.close();
		}
	    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisClusterConnectionHandler.java;<<<<<<< MINE
    protected String getNodeKey(HostAndPort hnp) {
	return hnp.getHost() + ":" + hnp.getPort();
    }

    protected String getNodeKey(Client client) {
	return client.getHost() + ":" + client.getPort();
    }

    private void setNodeIfNotExist(HostAndPort node) {
	String nodeKey = getNodeKey(node);
	if (nodes.containsKey(nodeKey))
	    return;

	JedisPool nodePool = new JedisPool(poolConfig, node.getHost(), node.getPort());
	nodes.put(nodeKey, nodePool);
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

public class JedisCluster implements JedisCommands, BasicCommands {
=======
public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
import redis.clients.jedis.exceptions.*;
=======
import redis.clients.jedis.JedisPool;
import redis.clients.jedis.exceptions.JedisAskDataException;
import redis.clients.jedis.exceptions.JedisClusterException;
import redis.clients.jedis.exceptions.JedisClusterMaxRedirectionsException;
import redis.clients.jedis.exceptions.JedisConnectionException;
import redis.clients.jedis.exceptions.JedisException;
import redis.clients.jedis.exceptions.JedisMovedDataException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE

    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

=======
    
    @Test
    public void testCloseable() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	
	JedisCluster jc = null;
	try {
	    jc = new JedisCluster(jedisClusterNode);
	    jc.set("51", "foo");
	} finally {
	    if (jc != null) {
		jc.close();
	    }
	}

	Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
	while (poolIterator.hasNext()) {
	    JedisPool pool = poolIterator.next();
	    try {
		pool.getResource();
		fail("JedisCluster's internal pools should be already destroyed");
	    } catch (JedisConnectionException e) {
		// ok to go...
	    }
	}
    }
    
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8b0d35b_067ed0a/rev_8b0d35b-067ed0a/src/main/java/junit/runner/Version.java;<<<<<<< MINE
    private static final String VERSION = getVersion();

	private Version() {
		// don't instantiate
	}
=======
	private Version() {
		// don't instantiate
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8b0d35b_067ed0a/rev_8b0d35b-067ed0a/src/main/java/junit/runner/Version.java;<<<<<<< MINE
	public static String id() {
		return VERSION;
	}
	
	public static void main(String[] args) {
		System.out.println(id());
	}

	private static InputStream getPomPropertiesAsStream(String artifactId) {
		return Version.class.getResourceAsStream("/META-INF/maven/junit/" + artifactId + "/pom.properties");
	}
    
	private static String getVersion() {
		try {
			final Properties properties= new Properties();
			InputStream pomProps= getPomPropertiesAsStream("junit");
			if (pomProps != null) properties.load(pomProps);
			String version= properties.getProperty("version", "<version>");
			if (pomProps != null) pomProps.close();
			assert !version.equals("<version>") : "your class loader does not load resources at /META-INF/maven/junit/...";
			return version;
		} catch (IOException e) {
			throw new IllegalStateException(e);
		}
    }
=======
	public static String id() {
		return "4.12-SNAPSHOT";
	}
	
	public static void main(String[] args) {
		System.out.println(id());
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
=======
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
    
    public static enum Reset {SOFT, HARD}

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	    int maxRedirections) {
	super(jedisClusterNode, timeout, maxRedirections);
=======
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
    this.connectionHandler = new JedisSlotBasedConnectionHandler(
            jedisClusterNode, poolConfig);
    this.timeout = timeout;
    this.maxRedirections = maxRedirections;
    }
    
    @Override
    public void close() {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }
    
=======
    @Override
    public String ping() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ping();
	    }
	}.run(null);
    }

    @Override
    public String quit() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.quit();
	    }
	}.run(null);
    }

    @Override
    public String flushDB() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushDB();
	    }
	}.run(null);
    }

    @Override
    public Long dbSize() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.dbSize();
	    }
	}.run(null);
    }

    @Override
    public String select(final int index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.select(index);
	    }
	}.run(null);
    }

    @Override
    public String flushAll() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.flushAll();
	    }
	}.run(null);
    }

    @Override
    public String auth(final String password) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.auth(password);
	    }
	}.run(null);
    }

    @Override
    public String save() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.save();
	    }
	}.run(null);
    }

    @Override
    public String bgsave() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgsave();
	    }
	}.run(null);
    }

    @Override
    public String bgrewriteaof() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.bgrewriteaof();
	    }
	}.run(null);
    }

    @Override
    public Long lastsave() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lastsave();
	    }
	}.run(null);
    }

    @Override
    public String shutdown() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.shutdown();
	    }
	}.run(null);
    }

    @Override
    public String info() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info();
	    }
	}.run(null);
    }

    @Override
    public String info(final String section) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.info(section);
	    }
	}.run(null);
    }

    @Override
    public String slaveof(final String host, final int port) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveof(host, port);
	    }
	}.run(null);
    }

    @Override
    public String slaveofNoOne() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.slaveofNoOne();
	    }
	}.run(null);
    }

    @Override
    public Long getDB() {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.getDB();
	    }
	}.run(null);
    }

    @Override
    public String debug(final DebugParams params) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.debug(params);
	    }
	}.run(null);
    }

    @Override
    public String configResetStat() {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.configResetStat();
	    }
	}.run(null);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public Long waitReplicas(int replicas, long timeout) {
	// TODO Auto-generated method stub
	return null;
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
    
    private T runWithRetries(byte[] key, int redirections,
            boolean tryRandomNode, boolean asking) {
        if (redirections <= 0) {
            throw new JedisClusterMaxRedirectionsException(
                "Too many Cluster redirections?");
        }

        Jedis connection = null;
        try {
            if (tryRandomNode) {
            connection = connectionHandler.getConnection();
            } else {
            connection = connectionHandler
                .getConnectionFromSlot(JedisClusterCRC16.getSlot(key));
            }

            if (asking) {
            // TODO: Pipeline asking with the original command to make it
            // faster....
            connection.asking();

            // if asking success, reset asking flag
            asking = false;
            }

            return execute(connection);
        } catch (JedisConnectionException jce) {
            if (tryRandomNode) {
            // maybe all connection is down
            throw jce;
            }
            
            releaseConnection(connection, true);
            connection = null;
            
            // retry with random connection
            return runWithRetries(key, redirections--, true, asking);
        } catch (JedisRedirectionException jre) {
            if (jre instanceof JedisAskDataException) {
            asking = true;
            } else if (jre instanceof JedisMovedDataException) {
            // TODO : In antirez's redis-rb-cluster implementation, 
            // it rebuilds cluster's slot and node cache
            }

            this.connectionHandler.assignSlotToNode(jre.getSlot(),
                jre.getTargetNode());

            releaseConnection(connection, false);
            connection = null;
            
            return runWithRetries(key, redirections - 1, false, asking);
        } finally {
            releaseConnection(connection, false);
        }

        }
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    private static int getCRC16(byte[] key, int s, int e) {
        int crc = 0x0000;
        for (int i = s; i < e; i++){
            for (int j = 0; j < 8; j++) {
                boolean bit = ((key[i] >> (7 - j) & 1) == 1);
                boolean c15 = ((crc >> 15 & 1) == 1);
                crc <<= 1;
                // If coefficient of bit and remainder polynomial = 1 xor crc
                // with polynomial
                if (c15 ^ bit)
                    crc ^= polynomial;
                }
        }
     
        return crc &= 0xffff ;
    }
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
=======
        JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}

    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final int cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(key);
=======
    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<String> sscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(key);
    }

    @Deprecated
    /**
     * This method is deprecated due to bug (scan cursor should be unsigned long)
     * And will be removed on next major release
     * @see https://github.com/xetorthio/jedis/issues/531 
     */
    @Override
    public ScanResult<Tuple> zscan(final String key, final int cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(key);
    }
    
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE

    @Override
    public Long del(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> blpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> brpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> mget(final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.run(keys.length - 1, keys);
    }

    @Override
    public String mset(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long msetnx(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public String rename(final String oldkey, final String newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final String oldkey, final String newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public String rpoplpush(final String srckey, final String dstkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Set<String> sdiff(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Set<String> sinter(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sinterstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long smove(final String srckey, final String dstkey,
	    final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Long sort(final String key, final SortingParams sortingParameters,
	    final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Long sort(final String key, final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Set<String> sunion(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sunionstore(final String dstkey, final String... keys) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final String... sets) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String brpoplpush(final String source, final String destination,
	    final int timeout) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.run(2, source, destination);
    }

    @Override
    public Long publish(final String channel, final String message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final JedisPubSub jedisPubSub,
	    final String... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final JedisPubSub jedisPubSub,
	    final String... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final String destKey,
	    final String... srcKeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String pfmerge(final String destkey, final String... sourcekeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public long pfcount(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.run(keys.length, keys);
    }
=======

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
	MultiKeyBinaryJedisClusterCommands, JedisClusterBinaryScriptingCommands {
=======
        JedisClusterBinaryScriptingCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_0f76459_53e7dc2/rev_0f76459-53e7dc2/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
    
    @Override
    public Long del(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> mget(final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.runBinary(keys.length - 1, keys);
    }

    @Override
    public String mset(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long msetnx(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public String rename(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public byte[] rpoplpush(final byte[] srckey, final byte[] dstkey) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Set<byte[]> sdiff(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Set<byte[]> sinter(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sinterstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long smove(final byte[] srckey, final byte[] dstkey,
	    final byte[] member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Set<byte[]> sunion(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sunionstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public byte[] brpoplpush(final byte[] source, final byte[] destination,
	    final int timeout) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.runBinary(2, source, destination);
    }

    @Override
    public Long publish(final byte[] channel, final byte[] message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final byte[] destKey,
	    final byte[]... srcKeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long pfcount(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.runBinary(keys.length, keys);
    }
=======

    @Override
    public void close() throws IOException {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}	
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_321e513_d710591/rev_321e513-d710591/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
=======
import java.net.URI;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_321e513_d710591/rev_321e513-d710591/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import java.net.URI;
import java.util.*;
import java.util.Map.Entry;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
import redis.clients.jedis.Protocol.Command;
import redis.clients.jedis.Protocol.Keyword;
import redis.clients.util.SafeEncoder;
=======
import static redis.clients.jedis.Protocol.toByteArray;
import static redis.clients.jedis.Protocol.Command.*;
import static redis.clients.jedis.Protocol.Keyword.ENCODING;
import static redis.clients.jedis.Protocol.Keyword.IDLETIME;
import static redis.clients.jedis.Protocol.Keyword.LEN;
import static redis.clients.jedis.Protocol.Keyword.LIMIT;
import static redis.clients.jedis.Protocol.Keyword.NO;
import static redis.clients.jedis.Protocol.Keyword.ONE;
import static redis.clients.jedis.Protocol.Keyword.REFCOUNT;
import static redis.clients.jedis.Protocol.Keyword.RESET;
import static redis.clients.jedis.Protocol.Keyword.STORE;
import static redis.clients.jedis.Protocol.Keyword.WITHSCORES;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE
import static redis.clients.jedis.Protocol.Command.*;
import static redis.clients.jedis.Protocol.Command.EXISTS;
import static redis.clients.jedis.Protocol.Command.PSUBSCRIBE;
import static redis.clients.jedis.Protocol.Command.PUNSUBSCRIBE;
import static redis.clients.jedis.Protocol.Command.SUBSCRIBE;
import static redis.clients.jedis.Protocol.Command.UNSUBSCRIBE;
import static redis.clients.jedis.Protocol.Keyword.*;
import static redis.clients.jedis.Protocol.toByteArray;
=======
import redis.clients.jedis.Protocol.Command;
import redis.clients.jedis.Protocol.Keyword;
import redis.clients.util.SafeEncoder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
=======
import java.net.URI;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_7845dc3_f778921/rev_7845dc3-f778921/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import java.net.URI;
import java.util.*;
import java.util.Map.Entry;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3495402_3ebc25e/rev_3495402-3ebc25e/src/main/java/redis/clients/jedis/PipelineBlock.java;<<<<<<< MINE
package redis.clients.jedis;

@Deprecated
/**
 * This method is deprecated due to its error prone with multi
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class PipelineBlock extends Pipeline {
    // For shadowing
    @SuppressWarnings("unused")
    private Client client;

    public abstract void execute();
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3495402_3ebc25e/rev_3495402-3ebc25e/src/main/java/redis/clients/jedis/TransactionBlock.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.exceptions.JedisException;

@Deprecated
/**
 * This class is deprecated due to its error prone
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class TransactionBlock extends Transaction {
    // For shadowing
    @SuppressWarnings("unused")
    private Client client;

    public TransactionBlock(Client client) {
	super(client);
    }

    public TransactionBlock() {
    }

    public abstract void execute() throws JedisException;

    public void setClient(Client client) {
	super.setClient(client);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f7995a7_a8891cb/rev_f7995a7-a8891cb/src/test/java/redis/clients/jedis/tests/PipeliningTest.java;<<<<<<< MINE
	assertTrue(result.get(1) instanceof JedisDataException);
=======
        assertEquals("val1", result.get(0));

        assertTrue(result.get(1) instanceof JedisDataException);

        Map<String, String> hashMapReceived = (Map<String, String>)result.get(2);
        Iterator<String> iterator = hashMapReceived.keySet().iterator();
        String mapKey1 = iterator.next();
        String mapKey2 = iterator.next();
        assertFalse(iterator.hasNext());
        verifyHasBothValues(mapKey1, mapKey2, field1, field2);
        String mapValue1 = hashMapReceived.get(mapKey1);
        String mapValue2 = hashMapReceived.get(mapKey2);
        verifyHasBothValues(mapValue1, mapValue2, value1, value2);

        assertTrue(result.get(3) instanceof JedisDataException);
    }
    
    @Test
    public void testSyncWithNoCommandQueued() {
	// we need to test with fresh instance of Jedis
	Jedis jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	
	Pipeline pipeline = jedis2.pipelined();
	pipeline.sync();
	
	jedis2.close();
	
	jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	
	pipeline = jedis2.pipelined();
	List<Object> resp = pipeline.syncAndReturnAll();
	assertTrue(resp.isEmpty());
	
	jedis2.close();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_318adee_e012e06/rev_318adee-e012e06/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
        StopwatchTest.class,
        FilterOptionIntegrationTest.class,
        JUnitCommandLineParserTest.class,
        FilterFactoryFactoryTest.class,
        FilterFactoryParamsTest.class,
        CategoryFilterFactoryTest.class
=======
        StopwatchTest.class,
        RunNotifierTest.class,
        ConcurrentRunNotifierTest.class,
        SynchronizedRunListenerTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

=======
import java.io.Closeable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 1;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

  public static enum Reset {
    SOFT, HARD
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }
=======
  private int timeout;
  private int maxRedirections;

  private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> nodes, int timeout,
	    int maxRedirections) {
        this(nodes, timeout, maxRedirections,
                new GenericObjectPoolConfig());
    }
=======
  public JedisCluster(Set<HostAndPort> nodes) {
    this(nodes, DEFAULT_TIMEOUT);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, int maxRedirections) {
    this(nodes, timeout, maxRedirections, new GenericObjectPoolConfig());
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	super(jedisClusterNode, timeout, maxRedirections, poolConfig);
    }
    
    @Override
    public String set(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.set(key, value);
	    }
	}.run(key);
    }

    @Override
    public String set(final String key, final String value, final String nxxx,
                      final String expx, final long time) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.set(key, value, nxxx, expx, time);
            }
        }.run(key);
    }

    @Override
    public String get(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.get(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean exists(final String key) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.exists(key);
	    }
	}.run(key);
    }

    @Override
    public Long persist(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.persist(key);
	    }
	}.run(key);
    }

    @Override
    public String type(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.type(key);
	    }
	}.run(key);
    }

    @Override
    public Long expire(final String key, final int seconds) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.expire(key, seconds);
	    }
	}.run(key);
    }

    @Override
    public Long expireAt(final String key, final long unixTime) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.expireAt(key, unixTime);
	    }
	}.run(key);
    }

    @Override
    public Long ttl(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.ttl(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final boolean value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final String value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean getbit(final String key, final long offset) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.getbit(key, offset);
	    }
	}.run(key);
    }

    @Override
    public Long setrange(final String key, final long offset, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setrange(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public String getrange(final String key, final long startOffset,
	    final long endOffset) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getrange(key,
			startOffset, endOffset);
	    }
	}.run(key);
    }

    @Override
    public String getSet(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getSet(key, value);
	    }
	}.run(key);
    }

    @Override
    public Long setnx(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setnx(key, value);
	    }
	}.run(key);
    }

    @Override
    public String setex(final String key, final int seconds, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.setex(key, seconds,
			value);
	    }
	}.run(key);
    }

    @Override
    public Long decrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long decr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decr(key);
	    }
	}.run(key);
    }

    @Override
    public Long incrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long incr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incr(key);
	    }
	}.run(key);
    }

    @Override
    public Long append(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.append(key, value);
	    }
	}.run(key);
    }

    @Override
    public String substr(final String key, final int start, final int end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.substr(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long hset(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.hset(key, field, value);
	    }
	}.run(key);
    }

    @Override
    public String hget(final String key, final String field) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hget(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hsetnx(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hsetnx(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public String hmset(final String key, final Map<String, String> hash) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hmset(key, hash);
	    }
	}.run(key);
    }

    @Override
    public List<String> hmget(final String key, final String... fields) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hmget(key, fields);
	    }
	}.run(key);
    }
=======
  public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout, int maxRedirections,
      final GenericObjectPoolConfig poolConfig) {
    this.connectionHandler = new JedisSlotBasedConnectionHandler(jedisClusterNode, poolConfig);
    this.timeout = timeout;
    this.maxRedirections = maxRedirections;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    @Override
    public Set<Tuple> zrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrangeWithScores(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrevrangeWithScores(
			key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zcard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcard(key);
	    }
	}.run(key);
    }

    @Override
    public Double zscore(final String key, final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zscore(key, member);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key,
	    final SortingParams sortingParameters) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key,
			sortingParameters);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final double min, final double max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByRank(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByRank(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final double start,
	    final double end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final String start,
	    final String end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }
    
    @Override
    public Long zlexcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long linsert(final String key, final LIST_POSITION where,
	    final String pivot, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.linsert(key, where,
			pivot, value);
	    }
	}.run(key);
    }

    @Override
    public Long lpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long rpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(arg);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(arg);
	    }
	}.run(null);
    }

    @Override
    public Long del(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(key);
	    }
	}.run(key);
    }

    @Override
    public String echo(final String string) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.echo(string);
	    }
	}.run(null);
    }

    @Override
    public Long move(final String key, final int dbIndex) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.move(key, dbIndex);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key, final long start, final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key, start,
			end);
	    }
	}.run(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final String cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<String> sscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(null);
    }
    
    @Override
    public ScanResult<Tuple> zscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(null);
    }

    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object eval(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script);
        }
    }.run(key);
    }
    
    @Override
    public Object eval(final String script, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.eval(script, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String sha1, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keyCount, params);
        }
    }.run(keyCount, params);
    }
    
    @Override
    public Object evalsha(final String sha1, final List<String> keys, final List<String> args) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(sha1, keys, args);
        }
    }.run(keys.size(), keys.toArray(new String[keys.size()]));
    }
    
    @Override
    public Object evalsha(final String script, final String key) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
        return connection.evalsha(script);
        }
    }.run(key);
    }
    
    @Override
    public Boolean scriptExists(final String sha1, final String key) {
    return new JedisClusterCommand<Boolean>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Boolean execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public List<Boolean> scriptExists(final String key, final String... sha1) {
    return new JedisClusterCommand<List<Boolean>>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public List<Boolean> execute(Jedis connection) {
        return connection.scriptExists(sha1);
        }
    }.run(key);
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
        return new JedisClusterCommand<String>(connectionHandler,
                timeout, maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.scriptLoad(script);
            }
        }.run(key);
    }

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout,key);
	    }
	}.run(null);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout,key);
	    }
	}.run(null);
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
		// if asking success, reset asking flag
		asking = false;
	    }

	    return execute(connection);
	} catch (JedisConnectionException jce) {
	    if (tryRandomNode) {
		// maybe all connection is down
		throw jce;
	    }

	    releaseConnection(connection, true);
	    connection = null;

	    // retry with random connection
	    return runWithRetries(key, redirections--, true, asking);
	} catch (JedisRedirectionException jre) {
	    if (jre instanceof JedisAskDataException) {
		asking = true;
	    } else if (jre instanceof JedisMovedDataException) {
		// TODO : In antirez's redis-rb-cluster implementation, 
		// it rebuilds cluster's slot and node cache
	    }

	    this.connectionHandler.assignSlotToNode(jre.getSlot(),
		    jre.getTargetNode());

	    releaseConnection(connection, false);
	    connection = null;

	    return runWithRetries(key, redirections - 1, false, asking);
	} finally {
	    releaseConnection(connection, false);
	}

    }
    
    private void releaseConnection(Jedis connection, boolean broken) {
	if (connection != null) {
	    if (broken) {
		connectionHandler.returnBrokenConnection(connection);
	    } else {
		connectionHandler.returnConnection(connection);
	    }
	}
=======
  }

  private void releaseConnection(Jedis connection, boolean broken) {
    if (connection != null) {
      if (broken) {
        connectionHandler.returnBrokenConnection(connection);
      } else {
        connectionHandler.returnConnection(connection);
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    public static int getSlot(byte[] key) {
        int s = -1;
        int e = -1;
        boolean sFound = false;
        for (int i = 0; i < key.length; i++) {
            if (key[i] == '{' && !sFound) {
                s = i;
                sFound = true;
            }
            if (key[i] == '}' && sFound) {
                e = i;
                break;
            }
        }
        if (s > -1 && e > -1 && e != s + 1) {
            return getCRC16(key, s+1, e) & (16384 - 1);
        }
        return getCRC16(key) & (16384 - 1);
    }
=======
    // optimization with modulo operator with power of 2
    // equivalent to getCRC16(key) % 16384
    return getCRC16(key) & (16384 - 1);
  }

  /**
   * Create a CRC16 checksum from the bytes. implementation is from mp911de/lettuce, modified with
   * some more optimizations
   * @param bytes
   * @return CRC16 as integer value
   * @see https://github.com/xetorthio/jedis/pull/733#issuecomment-55840331
   */
  public static int getCRC16(byte[] bytes) {
    int crc = 0x0000;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    /**
     * Create a CRC16 checksum from the bytes.
     * implementation is from mp911de/lettuce, modified with some more optimizations
     * 
     * @param bytes
     * @return CRC16 as integer value
     * @see https://github.com/xetorthio/jedis/pull/733#issuecomment-55840331
     */
    public static int getCRC16(byte[] bytes, int s, int e) {
	int crc = 0x0000;

	for (int i = s; i < e; i++) {
	    crc = ((crc << 8) ^ LOOKUP_TABLE[((crc >>> 8) ^ (bytes[i] & 0xFF)) & 0xFF]);
	}
	return crc & 0xFFFF;
=======
    for (byte b : bytes) {
      crc = ((crc << 8) ^ LOOKUP_TABLE[((crc >>> 8) ^ (b & 0xFF)) & 0xFF]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    
    public static int getCRC16(byte[] bytes) {
	return getCRC16(bytes, 0, bytes.length);
    }
=======
    return crc & 0xFFFF;
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/util/JedisClusterCRC16.java;<<<<<<< MINE
    public static int getCRC16(String key) {
	byte[] bytesKey = SafeEncoder.encode(key);
	return getCRC16(bytesKey, 0, bytesKey.length);
    }
=======
  public static int getCRC16(String key) {
    return getCRC16(SafeEncoder.encode(key));
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/utils/JedisClusterCRC16Test.java;<<<<<<< MINE
=======
import redis.clients.util.SafeEncoder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/utils/JedisClusterCRC16Test.java;<<<<<<< MINE
    @Test
    public void testGetCRC16() throws Exception {
	Map<String, Integer> solutions = prepareSolutionSet();
	
	for (Entry<String, Integer> entry : solutions.entrySet()) {
	    // string version
	    String key = entry.getKey();
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(key));
	    
	    // byte array version
	    byte[] bytesKey = SafeEncoder.encode(key);
	    assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(bytesKey));
	}
    }
    
    @Test
    public void testGetSlot() {
	assertEquals(7186, JedisClusterCRC16.getSlot("51"));
=======
  @Test
  public void testGetCRC16() throws Exception {
    Map<String, Integer> solutions = prepareSolutionSet();

    for (Entry<String, Integer> entry : solutions.entrySet()) {
      // string version
      assertEquals(entry.getValue().intValue(), JedisClusterCRC16.getCRC16(entry.getKey()));

      // byte array version
      assertEquals(entry.getValue().intValue(),
        JedisClusterCRC16.getCRC16(SafeEncoder.encode(entry.getKey())));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
import java.util.concurrent.BlockingQueue;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/test/java/redis/clients/jedis/tests/JedisClusterTest.java;<<<<<<< MINE
    private static Jedis node1;
    private static Jedis node2;
    private static Jedis node3;
    private static Jedis node4;

    private HostAndPort nodeInfo1 = HostAndPortUtil.getClusterServers().get(0);
    private HostAndPort nodeInfo2 = HostAndPortUtil.getClusterServers().get(1);
    private HostAndPort nodeInfo3 = HostAndPortUtil.getClusterServers().get(2);
    private HostAndPort nodeInfo4 = HostAndPortUtil.getClusterServers().get(3);
    
    @Before
    public void setUp() throws InterruptedException {
	node1 = new Jedis(nodeInfo1.getHost(), nodeInfo1.getPort());
	node1.connect();
	node1.flushAll();

	node2 = new Jedis(nodeInfo2.getHost(), nodeInfo2.getPort());
	node2.connect();
	node2.flushAll();

	node3 = new Jedis(nodeInfo3.getHost(), nodeInfo3.getPort());
	node3.connect();
	node3.flushAll();
	
	node4 = new Jedis(nodeInfo4.getHost(), nodeInfo4.getPort());
	node4.connect();
	node4.flushAll();

	// ---- configure cluster

	// add nodes to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo2.getPort());
	node1.clusterMeet("127.0.0.1", nodeInfo3.getPort());

	// split available slots across the three nodes
	int slotsPerNode = JedisCluster.HASHSLOTS / 3;
	int[] node1Slots = new int[slotsPerNode];
	int[] node2Slots = new int[slotsPerNode+1];
	int[] node3Slots = new int[slotsPerNode];
	for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0 ; i < JedisCluster.HASHSLOTS; i++) {
	    if (i < slotsPerNode) {
		node1Slots[slot1++] = i;
	    } else if (i > slotsPerNode * 2) {
		node3Slots[slot3++] = i;
	    } else {
		node2Slots[slot2++] = i;
	    }
	}
	
	node1.clusterAddSlots(node1Slots);
	node2.clusterAddSlots(node2Slots);
	node3.clusterAddSlots(node3Slots);
	
	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
    }
    
    @AfterClass
    public static void cleanUp() {
	node1.flushDB();
	node2.flushDB();
	node3.flushDB();
	node4.flushDB();
	node1.clusterReset(Reset.SOFT);
	node2.clusterReset(Reset.SOFT);
	node3.clusterReset(Reset.SOFT);
	node4.clusterReset(Reset.SOFT);
    }

    @After
    public void tearDown() throws InterruptedException {
	cleanUp();
    }

    @Test(expected = JedisMovedDataException.class)
    public void testThrowMovedException() {
	node1.set("foo", "bar");
    }

    @Test
    public void testMovedExceptionParameters() {
	try {
	    node1.set("foo", "bar");
	} catch (JedisMovedDataException jme) {
	    assertEquals(12182, jme.getSlot());
	    assertEquals(new HostAndPort("127.0.0.1", 7381),
		    jme.getTargetNode());
	    return;
	}
	fail();
    }

    @Test(expected = JedisAskDataException.class)
    public void testThrowAskException() {
	int keySlot = JedisClusterCRC16.getSlot("test");
	String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
	node2.clusterSetSlotMigrating(keySlot, node3Id);
	node2.get("test");
    }

    @Test
    public void testDiscoverNodesAutomatically() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	assertEquals(3, jc.getClusterNodes().size());
    }

    @Test
    public void testCalculateConnectionPerSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	jc.set("test", "test");
	assertEquals("bar", node3.get("foo"));
	assertEquals("test", node2.get("test"));
    }

    @Test
    public void testRecalculateSlotsWhenMoved() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node2.clusterDelSlots(slot51);
	node3.clusterDelSlots(slot51);
	node3.clusterAddSlots(slot51);

	JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test
    public void testAskResponse() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisClusterMaxRedirectionsException.class)
    public void testRedisClusterMaxRedirections() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	int slot51 = JedisClusterCRC16.getSlot("51");
	// This will cause an infinite redirection loop
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	jc.set("51", "foo");
    }
    
    @Test
    public void testRedisHashtag() {
	assertEquals(JedisClusterCRC16.getSlot("{bar"), JedisClusterCRC16.getSlot("foo{{bar}}zap"));
	assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"), JedisClusterCRC16.getSlot("{user1000}.followers"));
	assertNotEquals(JedisClusterCRC16.getSlot("foo{}{bar}"), JedisClusterCRC16.getSlot("bar"));
	assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"), JedisClusterCRC16.getSlot("bar"));
    }

    @Test
    public void testClusterForgetNode() throws InterruptedException {
	// at first, join node4 to cluster
	node1.clusterMeet("127.0.0.1", nodeInfo4.getPort());
	
	String node7Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());
	
	JedisClusterTestUtil.assertNodeIsKnown(node3, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node2, node7Id, 1000);
	JedisClusterTestUtil.assertNodeIsKnown(node1, node7Id, 1000);
	
	assertNodeHandshakeEnded(node3, 1000);
	assertNodeHandshakeEnded(node2, 1000);
	assertNodeHandshakeEnded(node1, 1000);
	
	assertEquals(4, node1.clusterNodes().split("\n").length);
	assertEquals(4, node2.clusterNodes().split("\n").length);
	assertEquals(4, node3.clusterNodes().split("\n").length);
	
	// do cluster forget
        node1.clusterForget(node7Id);
        node2.clusterForget(node7Id);
        node3.clusterForget(node7Id);
        
        JedisClusterTestUtil.assertNodeIsUnknown(node1, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node2, node7Id, 1000);
        JedisClusterTestUtil.assertNodeIsUnknown(node3, node7Id, 1000);
        
        assertEquals(3, node1.clusterNodes().split("\n").length);
        assertEquals(3, node2.clusterNodes().split("\n").length);
        assertEquals(3, node3.clusterNodes().split("\n").length);
    }
    
    @Test
    public void testClusterFlushSlots() {
	String slotRange = getNodeServingSlotRange(node1.clusterNodes()); 
	assertNotNull(slotRange);
	
	try {
	    node1.clusterFlushSlots();
	    assertNull(getNodeServingSlotRange(node1.clusterNodes()));
	} finally {
	    // rollback
	    String[] rangeInfo = slotRange.split("-");
	    int lower = Integer.parseInt(rangeInfo[0]);
	    int upper = Integer.parseInt(rangeInfo[1]);
	    
	    int[] node1Slots = new int[upper - lower + 1];
	    for (int i = 0 ; lower <= upper ; ) {
		node1Slots[i++] = lower++;
	    }
	    node1.clusterAddSlots(node1Slots);
	}
    }
    
    @Test
    public void testClusterKeySlot() {
	// It assumes JedisClusterCRC16 is correctly implemented
	assertEquals(node1.clusterKeySlot("foo{bar}zap}").intValue(), JedisClusterCRC16.getSlot("foo{bar}zap"));
	assertEquals(node1.clusterKeySlot("{user1000}.following").intValue(), JedisClusterCRC16.getSlot("{user1000}.following"));
    }
    
    @Test
    public void testClusterCountKeysInSlot() {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	for (int index = 0 ; index < 5 ; index++) {
	    jc.set("foo{bar}" + index, "hello");
	}
	
	int slot = JedisClusterCRC16.getSlot("foo{bar}");
	assertEquals(5, node1.clusterCountKeysInSlot(slot).intValue());
    }
    
    @Test
    public void testStableSlotWhenMigratingNodeOrImportingNodeIsNotSpecified() throws InterruptedException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	JedisCluster jc = new JedisCluster(jedisClusterNode);
	
	int slot51 = JedisClusterCRC16.getSlot("51");
	jc.set("51", "foo");
	// node2 is responsible of taking care of slot51 (7186)
	
	node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
	assertEquals("foo", jc.get("51"));
	node3.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
	
	node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
	//assertEquals("foo", jc.get("51")); // it leads Max Redirections
	node2.clusterSetSlotStable(slot51);
	assertEquals("foo", jc.get("51"));
    }

    @Test(expected = JedisConnectionException.class)
    public void testIfPoolConfigAppliesToClusterPools() {
        GenericObjectPoolConfig config = new GenericObjectPoolConfig();
        config.setMaxTotal(0);
        config.setMaxWaitMillis(2000);
        Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
        jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
        JedisCluster jc = new JedisCluster(jedisClusterNode, config);
        jc.set("52", "poolTestValue");
    }

    @Test
    public void testCloseable() throws IOException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
	
	JedisCluster jc = null;
	try {
	    jc = new JedisCluster(jedisClusterNode);
	    jc.set("51", "foo");
	} finally {
	    if (jc != null) {
		jc.close();
	    }
	}

	Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
	while (poolIterator.hasNext()) {
	    JedisPool pool = poolIterator.next();
	    try {
		pool.getResource();
		fail("JedisCluster's internal pools should be already destroyed");
	    } catch (JedisConnectionException e) {
		// ok to go...
	    }
	}
    }
    
    @Test
    public void testJedisClusterRunsWithMultithreaded() throws InterruptedException, ExecutionException, IOException {
	Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
	jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
	final JedisCluster jc = new JedisCluster(jedisClusterNode);
	jc.set("foo", "bar");
	
	ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 100, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(10));
	List<Future<String>> futures = new ArrayList<Future<String>>();
	for (int i = 0 ; i < 50 ; i++) {
	    executor.submit(new Callable<String>() {
		@Override
		public String call() throws Exception {
		    // FIXME : invalidate slot cache from JedisCluster to test random connection also does work
		    return jc.get("foo");
		}
	    });
	}

	for (Future<String> future : futures) {
	    String value = future.get();
	    assertEquals("bar", value);
	}
	
	jc.close();
    }
    
    private static String getNodeServingSlotRange(String infoOutput) {
	// f4f3dc4befda352a4e0beccf29f5e8828438705d 127.0.0.1:7380 master - 0 1394372400827 0 connected 5461-10922
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("myself")) {
		try {
		    return infoLine.split(" ")[8];
		} catch (ArrayIndexOutOfBoundsException e) {
		    return null;
		}
	    }
	}
	return null;
    }
    
    private void assertNodeHandshakeEnded(Jedis node, int timeoutMs) {
	int sleepInterval = 100;
	for (int sleepTime = 0 ; sleepTime <= timeoutMs ; sleepTime += sleepInterval) {
	    boolean isHandshaking = isAnyNodeHandshaking(node);
	    if (!isHandshaking)
		return;
	    
	    try {
		Thread.sleep(sleepInterval);
	    } catch (InterruptedException e) {
	    }
	}
	
	throw new JedisException("Node handshaking is not ended");
    }
    
    private boolean isAnyNodeHandshaking(Jedis node) {
	String infoOutput = node.clusterNodes();
	for (String infoLine : infoOutput.split("\n")) {
	    if (infoLine.contains("handshake")) {
		return true;
	    }
	}
	return false;
=======
  private static Jedis node1;
  private static Jedis node2;
  private static Jedis node3;
  private static Jedis node4;
  private String localHost = "127.0.0.1";

  private HostAndPort nodeInfo1 = HostAndPortUtil.getClusterServers().get(0);
  private HostAndPort nodeInfo2 = HostAndPortUtil.getClusterServers().get(1);
  private HostAndPort nodeInfo3 = HostAndPortUtil.getClusterServers().get(2);
  private HostAndPort nodeInfo4 = HostAndPortUtil.getClusterServers().get(3);
  protected Logger log = Logger.getLogger(getClass().getName());

  @Before
  public void setUp() throws InterruptedException {
    node1 = new Jedis(nodeInfo1.getHost(), nodeInfo1.getPort());
    node1.connect();
    node1.flushAll();

    node2 = new Jedis(nodeInfo2.getHost(), nodeInfo2.getPort());
    node2.connect();
    node2.flushAll();

    node3 = new Jedis(nodeInfo3.getHost(), nodeInfo3.getPort());
    node3.connect();
    node3.flushAll();

    node4 = new Jedis(nodeInfo4.getHost(), nodeInfo4.getPort());
    node4.connect();
    node4.flushAll();

    // ---- configure cluster

    // add nodes to cluster
    node1.clusterMeet(localHost, nodeInfo2.getPort());
    node1.clusterMeet(localHost, nodeInfo3.getPort());

    // split available slots across the three nodes
    int slotsPerNode = JedisCluster.HASHSLOTS / 3;
    int[] node1Slots = new int[slotsPerNode];
    int[] node2Slots = new int[slotsPerNode + 1];
    int[] node3Slots = new int[slotsPerNode];
    for (int i = 0, slot1 = 0, slot2 = 0, slot3 = 0; i < JedisCluster.HASHSLOTS; i++) {
      if (i < slotsPerNode) {
        node1Slots[slot1++] = i;
      } else if (i > slotsPerNode * 2) {
        node3Slots[slot3++] = i;
      } else {
        node2Slots[slot2++] = i;
      }
    }

    node1.clusterAddSlots(node1Slots);
    node2.clusterAddSlots(node2Slots);
    node3.clusterAddSlots(node3Slots);

    JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
  }

  @AfterClass
  public static void cleanUp() {
    node1.flushDB();
    node2.flushDB();
    node3.flushDB();
    node4.flushDB();
    node1.clusterReset(Reset.SOFT);
    node2.clusterReset(Reset.SOFT);
    node3.clusterReset(Reset.SOFT);
    node4.clusterReset(Reset.SOFT);
  }

  @After
  public void tearDown() throws InterruptedException {
    cleanUp();
  }

  @Test(expected = JedisMovedDataException.class)
  public void testThrowMovedException() {
    node1.set("foo", "bar");
  }

  @Test
  public void testMovedExceptionParameters() {
    try {
      node1.set("foo", "bar");
    } catch (JedisMovedDataException jme) {
      assertEquals(12182, jme.getSlot());
      assertEquals(new HostAndPort("127.0.0.1", 7381), jme.getTargetNode());
      return;
    }
    fail();
  }

  @Test(expected = JedisAskDataException.class)
  public void testThrowAskException() {
    int keySlot = JedisClusterCRC16.getSlot("test");
    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    node2.clusterSetSlotMigrating(keySlot, node3Id);
    node2.get("test");
  }

  @Test
  public void testDiscoverNodesAutomatically() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    assertEquals(3, jc.getClusterNodes().size());
  }

  @Test
  public void testCalculateConnectionPerSlot() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.set("foo", "bar");
    jc.set("test", "test");
    assertEquals("bar", node3.get("foo"));
    assertEquals("test", node2.get("test"));
  }

  /**
   * slot->nodes 15363 node3 e
   */
  @Test
  public void testMigrate() {
    log.info("test migrate slot");
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(nodeInfo1);
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    String node2Id = JedisClusterTestUtil.getNodeId(node2.clusterNodes());
    node3.clusterSetSlotMigrating(15363, node2Id);
    node2.clusterSetSlotImporting(15363, node3Id);
    try {
      node2.set("e", "e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }

    try {
      node3.set("e", "e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo2.getPort()), jae.getTargetNode());
    }

    jc.set("e", "e");

    try {
      node2.get("e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }
    try {
      node3.get("e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo2.getPort()), jae.getTargetNode());
    }

    assertEquals("e", jc.get("e"));

    node2.clusterSetSlotNode(15363, node2Id);
    node3.clusterSetSlotNode(15363, node2Id);
    // assertEquals("e", jc.get("e"));
    assertEquals("e", node2.get("e"));

    // assertEquals("e", node3.get("e"));

  }

  @Test
  public void testMigrateToNewNode() throws InterruptedException {
    log.info("test migrate slot to new node");
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(nodeInfo1);
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    node4.clusterMeet(localHost, nodeInfo1.getPort());

    String node3Id = JedisClusterTestUtil.getNodeId(node3.clusterNodes());
    String node4Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());
    JedisClusterTestUtil.waitForClusterReady(node4);
    node3.clusterSetSlotMigrating(15363, node4Id);
    node4.clusterSetSlotImporting(15363, node3Id);
    try {
      node4.set("e", "e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }

    try {
      node3.set("e", "e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo4.getPort()), jae.getTargetNode());
    }

    jc.set("e", "e");

    try {
      node4.get("e");
    } catch (JedisMovedDataException jme) {
      assertEquals(15363, jme.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo3.getPort()), jme.getTargetNode());
    }
    try {
      node3.get("e");
    } catch (JedisAskDataException jae) {
      assertEquals(15363, jae.getSlot());
      assertEquals(new HostAndPort(localHost, nodeInfo4.getPort()), jae.getTargetNode());
    }

    assertEquals("e", jc.get("e"));

    node4.clusterSetSlotNode(15363, node4Id);
    node3.clusterSetSlotNode(15363, node4Id);
    // assertEquals("e", jc.get("e"));
    assertEquals("e", node4.get("e"));

    // assertEquals("e", node3.get("e"));

  }

  @Test
  public void testRecalculateSlotsWhenMoved() throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    node2.clusterDelSlots(slot51);
    node3.clusterDelSlots(slot51);
    node3.clusterAddSlots(slot51);

    JedisClusterTestUtil.waitForClusterReady(node1, node2, node3);
    jc.set("51", "foo");
    assertEquals("foo", jc.get("51"));
  }

  @Test
  public void testAskResponse() throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    jc.set("51", "foo");
    assertEquals("foo", jc.get("51"));
  }

  @Test(expected = JedisClusterException.class)
  public void testThrowExceptionWithoutKey() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.ping();
  }

  @Test(expected = JedisClusterMaxRedirectionsException.class)
  public void testRedisClusterMaxRedirections() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode);
    int slot51 = JedisClusterCRC16.getSlot("51");
    // This will cause an infinite redirection loop
    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    jc.set("51", "foo");
  }

  @Test
  public void testRedisHashtag() {
    assertEquals(JedisClusterCRC16.getSlot("{bar"), JedisClusterCRC16.getSlot("foo{{bar}}zap"));
    assertEquals(JedisClusterCRC16.getSlot("{user1000}.following"),
      JedisClusterCRC16.getSlot("{user1000}.followers"));
    assertNotEquals(JedisClusterCRC16.getSlot("foo{}{bar}"), JedisClusterCRC16.getSlot("bar"));
    assertEquals(JedisClusterCRC16.getSlot("foo{bar}{zap}"), JedisClusterCRC16.getSlot("bar"));
  }

  @Test
  public void testClusterForgetNode() throws InterruptedException {
    // at first, join node4 to cluster
    node1.clusterMeet("127.0.0.1", nodeInfo4.getPort());

    String node7Id = JedisClusterTestUtil.getNodeId(node4.clusterNodes());

    JedisClusterTestUtil.assertNodeIsKnown(node3, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsKnown(node2, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsKnown(node1, node7Id, 1000);

    assertNodeHandshakeEnded(node3, 1000);
    assertNodeHandshakeEnded(node2, 1000);
    assertNodeHandshakeEnded(node1, 1000);

    assertEquals(4, node1.clusterNodes().split("\n").length);
    assertEquals(4, node2.clusterNodes().split("\n").length);
    assertEquals(4, node3.clusterNodes().split("\n").length);

    // do cluster forget
    node1.clusterForget(node7Id);
    node2.clusterForget(node7Id);
    node3.clusterForget(node7Id);

    JedisClusterTestUtil.assertNodeIsUnknown(node1, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsUnknown(node2, node7Id, 1000);
    JedisClusterTestUtil.assertNodeIsUnknown(node3, node7Id, 1000);

    assertEquals(3, node1.clusterNodes().split("\n").length);
    assertEquals(3, node2.clusterNodes().split("\n").length);
    assertEquals(3, node3.clusterNodes().split("\n").length);
  }

  @Test
  public void testClusterFlushSlots() {
    String slotRange = getNodeServingSlotRange(node1.clusterNodes());
    assertNotNull(slotRange);

    try {
      node1.clusterFlushSlots();
      assertNull(getNodeServingSlotRange(node1.clusterNodes()));
    } finally {
      // rollback
      String[] rangeInfo = slotRange.split("-");
      int lower = Integer.parseInt(rangeInfo[0]);
      int upper = Integer.parseInt(rangeInfo[1]);

      int[] node1Slots = new int[upper - lower + 1];
      for (int i = 0; lower <= upper;) {
        node1Slots[i++] = lower++;
      }
      node1.clusterAddSlots(node1Slots);
    }
  }

  @Test
  public void testClusterKeySlot() {
    // It assumes JedisClusterCRC16 is correctly implemented
    assertEquals(node1.clusterKeySlot("foo{bar}zap}").intValue(),
      JedisClusterCRC16.getSlot("foo{bar}zap"));
    assertEquals(node1.clusterKeySlot("{user1000}.following").intValue(),
      JedisClusterCRC16.getSlot("{user1000}.following"));
  }

  @Test
  public void testClusterCountKeysInSlot() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
    JedisCluster jc = new JedisCluster(jedisClusterNode);

    for (int index = 0; index < 5; index++) {
      jc.set("foo{bar}" + index, "hello");
    }

    int slot = JedisClusterCRC16.getSlot("foo{bar}");
    assertEquals(5, node1.clusterCountKeysInSlot(slot).intValue());
  }

  @Test
  public void testStableSlotWhenMigratingNodeOrImportingNodeIsNotSpecified()
      throws InterruptedException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));
    JedisCluster jc = new JedisCluster(jedisClusterNode);

    int slot51 = JedisClusterCRC16.getSlot("51");
    jc.set("51", "foo");
    // node2 is responsible of taking care of slot51 (7186)

    node3.clusterSetSlotImporting(slot51, JedisClusterTestUtil.getNodeId(node2.clusterNodes()));
    assertEquals("foo", jc.get("51"));
    node3.clusterSetSlotStable(slot51);
    assertEquals("foo", jc.get("51"));

    node2.clusterSetSlotMigrating(slot51, JedisClusterTestUtil.getNodeId(node3.clusterNodes()));
    // assertEquals("foo", jc.get("51")); // it leads Max Redirections
    node2.clusterSetSlotStable(slot51);
    assertEquals("foo", jc.get("51"));
  }

  @Test(expected = JedisConnectionException.class)
  public void testIfPoolConfigAppliesToClusterPools() {
    GenericObjectPoolConfig config = new GenericObjectPoolConfig();
    config.setMaxTotal(0);
    config.setMaxWaitMillis(2000);
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    JedisCluster jc = new JedisCluster(jedisClusterNode, config);
    jc.set("52", "poolTestValue");
  }

  @Test
  public void testCloseable() {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort(nodeInfo1.getHost(), nodeInfo1.getPort()));

    JedisCluster jc = null;
    try {
      jc = new JedisCluster(jedisClusterNode);
      jc.set("51", "foo");
    } finally {
      if (jc != null) {
        jc.close();
      }
    }

    Iterator<JedisPool> poolIterator = jc.getClusterNodes().values().iterator();
    while (poolIterator.hasNext()) {
      JedisPool pool = poolIterator.next();
      try {
        pool.getResource();
        fail("JedisCluster's internal pools should be already destroyed");
      } catch (JedisConnectionException e) {
        // ok to go...
      }
    }
  }

  @Test
  public void testJedisClusterRunsWithMultithreaded() throws InterruptedException,
      ExecutionException {
    Set<HostAndPort> jedisClusterNode = new HashSet<HostAndPort>();
    jedisClusterNode.add(new HostAndPort("127.0.0.1", 7379));
    final JedisCluster jc = new JedisCluster(jedisClusterNode);
    jc.set("foo", "bar");

    ThreadPoolExecutor executor = new ThreadPoolExecutor(10, 100, 0, TimeUnit.SECONDS,
        new ArrayBlockingQueue<Runnable>(10));
    List<Future<String>> futures = new ArrayList<Future<String>>();
    for (int i = 0; i < 50; i++) {
      executor.submit(new Callable<String>() {
        @Override
        public String call() throws Exception {
          // FIXME : invalidate slot cache from JedisCluster to test
          // random connection also does work
          return jc.get("foo");
        }
      });
    }

    for (Future<String> future : futures) {
      String value = future.get();
      assertEquals("bar", value);
    }

    jc.close();
  }

  private static String getNodeServingSlotRange(String infoOutput) {
    // f4f3dc4befda352a4e0beccf29f5e8828438705d 127.0.0.1:7380 master - 0
    // 1394372400827 0 connected 5461-10922
    for (String infoLine : infoOutput.split("\n")) {
      if (infoLine.contains("myself")) {
        try {
          return infoLine.split(" ")[8];
        } catch (ArrayIndexOutOfBoundsException e) {
          return null;
        }
      }
    }
    return null;
  }

  private void assertNodeHandshakeEnded(Jedis node, int timeoutMs) {
    int sleepInterval = 100;
    for (int sleepTime = 0; sleepTime <= timeoutMs; sleepTime += sleepInterval) {
      boolean isHandshaking = isAnyNodeHandshaking(node);
      if (!isHandshaking) return;

      try {
        Thread.sleep(sleepInterval);
      } catch (InterruptedException e) {
      }
    }

    throw new JedisException("Node handshaking is not ended");
  }

  private boolean isAnyNodeHandshaking(Jedis node) {
    String infoOutput = node.clusterNodes();
    for (String infoLine : infoOutput.split("\n")) {
      if (infoLine.contains("handshake")) {
        return true;
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
    jedisTransaction.execute();
    results = jedisTransaction.exec();
	return results;
    }

    protected void checkIsInMulti() {
	if (client.isInMulti()) {
	    throw new JedisDataException(
		    "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
	}
    }

    public void connect() {
	client.connect();
    }

    public void disconnect() {
	client.disconnect();
    }

    public void resetState() {
	client.resetState();
	client.getAll();
    }

    public String watch(final byte[]... keys) {
	client.watch(keys);
	return client.getStatusCodeReply();
    }

    public String unwatch() {
	client.unwatch();
	return client.getStatusCodeReply();
    }

    @Override
	public void close() {
	client.close();
    }

    /**
     * Sort a Set or a List.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key.
     * By default sorting is numeric with elements being compared as double
     * precision floating point numbers. This is the simplest form of SORT.
     * 
     * @see #sort(byte[], byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * 
     * @param key
     * @return Assuming the Set/List at key contains a list of numbers, the
     *         return value will be the list of numbers ordered from the
     *         smallest to the biggest number.
     */
    public List<byte[]> sort(final byte[] key) {
	checkIsInMulti();
	client.sort(key);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters.
     * <p>
     * <b>examples:</b>
     * <p>
     * Given are the following sets and key/values:
     * 
     * <pre>
     * x = [1, 2, 3]
     * y = [a, b, c]
     * 
     * k1 = z
     * k2 = y
     * k3 = x
     * 
     * w1 = 9
     * w2 = 8
     * w3 = 7
     * </pre>
     * 
     * Sort Order:
     * 
     * <pre>
     * sort(x) or sort(x, sp.asc())
     * -> [1, 2, 3]
     * 
     * sort(x, sp.desc())
     * -> [3, 2, 1]
     * 
     * sort(y)
     * -> [c, a, b]
     * 
     * sort(y, sp.alpha())
     * -> [a, b, c]
     * 
     * sort(y, sp.alpha().desc())
     * -> [c, a, b]
     * </pre>
     * 
     * Limit (e.g. for Pagination):
     * 
     * <pre>
     * sort(x, sp.limit(0, 2))
     * -> [1, 2]
     * 
     * sort(y, sp.alpha().desc().limit(1, 2))
     * -> [b, a]
     * </pre>
     * 
     * Sorting by external keys:
     * 
     * <pre>
     * sort(x, sb.by(w*))
     * -> [3, 2, 1]
     * 
     * sort(x, sb.by(w*).desc())
     * -> [1, 2, 3]
     * </pre>
     * 
     * Getting external keys:
     * 
     * <pre>
     * sort(x, sp.by(w*).get(k*))
     * -> [x, y, z]
     * 
     * sort(x, sp.by(w*).get(#).get(k*))
     * -> [3, x, 2, y, 1, z]
     * </pre>
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param sortingParameters
     * @return a list of sorted elements.
     */
    public List<byte[]> sort(final byte[] key,
	    final SortingParams sortingParameters) {
	checkIsInMulti();
	client.sort(key, sortingParameters);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #brpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.blpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Sort a Set or a List accordingly to the specified parameters and store
     * the result at dstkey.
     * 
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[])
     * @see #sort(byte[], byte[])
     * 
     * @param key
     * @param sortingParameters
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, sortingParameters, dstkey);
	return client.getIntegerReply();
    }

    /**
     * Sort a Set or a List and Store the Result at dstkey.
     * <p>
     * Sort the elements contained in the List, Set, or Sorted Set value at key
     * and store the result at dstkey. By default sorting is numeric with
     * elements being compared as double precision floating point numbers. This
     * is the simplest form of SORT.
     * 
     * @see #sort(byte[])
     * @see #sort(byte[], SortingParams)
     * @see #sort(byte[], SortingParams, byte[])
     * 
     * @param key
     * @param dstkey
     * @return The number of elements of the list at dstkey.
     */
    public Long sort(final byte[] key, final byte[] dstkey) {
	checkIsInMulti();
	client.sort(key, dstkey);
	return client.getIntegerReply();
    }

    /**
     * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this
     * commands as blocking versions of LPOP and RPOP able to block if the
     * specified keys don't exist or contain empty lists.
     * <p>
     * The following is a description of the exact semantic. We describe BLPOP
     * but the two commands are identical, the only difference is that BLPOP
     * pops the element from the left (head) of the list, and BRPOP pops from
     * the right (tail).
     * <p>
     * <b>Non blocking behavior</b>
     * <p>
     * When BLPOP is called, if at least one of the specified keys contain a non
     * empty list, an element is popped from the head of the list and returned
     * to the caller together with the name of the key (BLPOP returns a two
     * elements array, the first element is the key, the second the popped
     * value).
     * <p>
     * Keys are scanned from left to right, so for instance if you issue BLPOP
     * list1 list2 list3 0 against a dataset where list1 does not exist but
     * list2 and list3 contain non empty lists, BLPOP guarantees to return an
     * element from the list stored at list2 (since it is the first non empty
     * list starting from the left).
     * <p>
     * <b>Blocking behavior</b>
     * <p>
     * If none of the specified keys exist or contain non empty lists, BLPOP
     * blocks until some other client performs a LPUSH or an RPUSH operation
     * against one of the lists.
     * <p>
     * Once new data is present on one of the lists, the client finally returns
     * with the name of the key unblocking it and the popped value.
     * <p>
     * When blocking, if a non-zero timeout is specified, the client will
     * unblock returning a nil special value if the specified amount of seconds
     * passed without a push operation against at least one of the specified
     * keys.
     * <p>
     * The timeout argument is interpreted as an integer value. A timeout of
     * zero means instead to block forever.
     * <p>
     * <b>Multiple clients blocking for the same keys</b>
     * <p>
     * Multiple clients can block for the same key. They are put into a queue,
     * so the first to be served will be the one that started to wait earlier,
     * in a first-blpopping first-served fashion.
     * <p>
     * <b>blocking POP inside a MULTI/EXEC transaction</b>
     * <p>
     * BLPOP and BRPOP can be used with pipelining (sending multiple commands
     * and reading the replies in batch), but it does not make sense to use
     * BLPOP or BRPOP inside a MULTI/EXEC block (a Redis transaction).
     * <p>
     * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to
     * return a multi-bulk nil reply, exactly what happens when the timeout is
     * reached. If you like science fiction, think at it like if inside
     * MULTI/EXEC the time will flow at infinite speed :)
     * <p>
     * Time complexity: O(1)
     * 
     * @see #blpop(int, String...)
     * 
     * @param timeout
     * @param keys
     * @return BLPOP returns a two-elements array via a multi bulk reply in
     *         order to return both the unblocking key and the popped value.
     *         <p>
     *         When a non-zero timeout is specified, and the BLPOP operation
     *         timed out, the return value is a nil multi bulk reply. Most
     *         client values will return false or nil accordingly to the
     *         programming language used.
     */
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	checkIsInMulti();
	final List<byte[]> args = new ArrayList<byte[]>();
	for (final byte[] arg : keys) {
	    args.add(arg);
	}
	args.add(Protocol.toByteArray(timeout));

	client.brpop(args.toArray(new byte[args.size()][]));
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();

	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[] arg) {
	checkIsInMulti();
	byte[][] args = new byte[1][];
	args[0] = arg;
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> blpop(byte[]... args) {
	checkIsInMulti();
	client.blpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    public List<byte[]> brpop(byte[]... args) {
	checkIsInMulti();
	client.brpop(args);
	client.setTimeoutInfinite();
	final List<byte[]> multiBulkReply = client.getBinaryMultiBulkReply();
	client.rollbackTimeout();
	return multiBulkReply;
    }

    /**
     * Request for authentication in a password protected Redis server. A Redis
     * server can be instructed to require a password before to allow clients to
     * issue commands. This is done using the requirepass directive in the Redis
     * configuration file. If the password given by the client is correct the
     * server replies with an OK status code reply and starts accepting commands
     * from the client. Otherwise an error is returned and the clients needs to
     * try a new password. Note that for the high performance nature of Redis it
     * is possible to try a lot of passwords in parallel in very short time, so
     * make sure to generate a strong and very long password so that this attack
     * is infeasible.
     * 
     * @param password
     * @return Status code reply
     */
    public String auth(final String password) {
	checkIsInMulti();
	client.auth(password);
	return client.getStatusCodeReply();
    }

    @Deprecated
    /**
     * This method is deprecated due to its error prone with multi
     * and will be removed on next major release
     * You can use pipelined() instead
     * @see https://github.com/xetorthio/jedis/pull/498
     */
    public List<Object> pipelined(final PipelineBlock jedisPipeline) {
	jedisPipeline.setClient(client);
	jedisPipeline.execute();
	return jedisPipeline.syncAndReturnAll();
    }

    public Pipeline pipelined() {
	Pipeline pipeline = new Pipeline();
	pipeline.setClient(client);
	return pipeline;
    }

    public Long zcount(final byte[] key, final double min, final double max) {
	return zcount(key, toByteArray(min), toByteArray(max));
    }

    public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zcount(key, min, max);
	return client.getIntegerReply();
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<byte[]> zrangeByScore(final byte[] key, final double min,
	    final double max, final int offset, final int count) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max), offset,
		count);
    }

    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min,
	    final byte[] max, final int offset, final int count) {
	checkIsInMulti();
	client.zrangeByScore(key, min, max, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Return the all the elements in the sorted set at key with a score between
     * min and max (including elements with score equal to min or max).
     * <p>
     * The elements having the same score are returned sorted lexicographically
     * as ASCII strings (this follows from a property of Redis sorted sets and
     * does not involve further computation).
     * <p>
     * Using the optional
     * {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's
     * possible to get only a range of the matching elements in an SQL-alike
     * way. Note that if offset is large the commands needs to traverse the list
     * for offset elements and this adds up to the O(M) figure.
     * <p>
     * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
     * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead
     * of returning the actual elements in the specified interval, it just
     * returns the number of matching elements.
     * <p>
     * <b>Exclusive intervals and infinity</b>
     * <p>
     * min and max can be -inf and +inf, so that you are not required to know
     * what's the greatest or smallest element in order to take, for instance,
     * elements "up to a given value".
     * <p>
     * Also while the interval is for default closed (inclusive) it's possible
     * to specify open intervals prefixing the score with a "(" character, so
     * for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (1.3 5}
     * <p>
     * Will return all the values with score > 1.3 and <= 5, while for instance:
     * <p>
     * {@code ZRANGEBYSCORE zset (5 (10}
     * <p>
     * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements returned by the command, so if M is constant
     * (for instance you always ask for the first ten elements with LIMIT) you
     * can consider it O(log(N))
     * 
     * @see #zrangeByScore(byte[], double, double)
     * @see #zrangeByScore(byte[], double, double, int, int)
     * @see #zrangeByScoreWithScores(byte[], double, double)
     * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
     * @see #zcount(byte[], double, double)
     * 
     * @param key
     * @param min
     * @param max
     * @return Multi bulk reply specifically a list of elements in the specified
     *         score range.
     */
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final double min, final double max, final int offset,
	    final int count) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max),
		offset, count);
    }

    public Set<Tuple> zrangeByScoreWithScores(final byte[] key,
	    final byte[] min, final byte[] max, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrangeByScoreWithScores(key, min, max, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    private Set<Tuple> getBinaryTupledSet() {
	checkIsInMulti();
	List<byte[]> membersWithScores = client.getBinaryMultiBulkReply();
	Set<Tuple> set = new LinkedHashSet<Tuple>();
	Iterator<byte[]> iterator = membersWithScores.iterator();
	while (iterator.hasNext()) {
	    set.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder
		    .encode(iterator.next()))));
	}
	return set;
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min));
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max,
	    final double min, final int offset, final int count) {
	return zrevrangeByScore(key, toByteArray(max), toByteArray(min),
		offset, count);
    }

    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max,
	    final byte[] min, final int offset, final int count) {
	checkIsInMulti();
	client.zrevrangeByScore(key, max, min, offset, count);
	return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min));
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final double max, final double min, final int offset,
	    final int count) {
	return zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min), offset, count);
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key,
	    final byte[] max, final byte[] min, final int offset,
	    final int count) {
	checkIsInMulti();
	client.zrevrangeByScoreWithScores(key, max, min, offset, count);
	Set<Tuple> set = getBinaryTupledSet();
	return set;
    }

    /**
     * Remove all elements in the sorted set at key with rank between start and
     * end. Start and end are 0-based with rank 0 being the element with the
     * lowest score. Both start and end can be negative numbers, where they
     * indicate offsets starting at the element with the highest rank. For
     * example: -1 is the element with the highest score, -2 the element with
     * the second highest score and so forth.
     * <p>
     * <b>Time complexity:</b> O(log(N))+O(M) with N being the number of
     * elements in the sorted set and M the number of elements removed by the
     * operation
     * 
     */
    public Long zremrangeByRank(final byte[] key, final long start,
	    final long end) {
	checkIsInMulti();
	client.zremrangeByRank(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Remove all the elements in the sorted set at key with a score between min
     * and max (including elements with score equal to min or max).
     * <p>
     * <b>Time complexity:</b>
     * <p>
     * O(log(N))+O(M) with N being the number of elements in the sorted set and
     * M the number of elements removed by the operation
     * 
     * @param key
     * @param start
     * @param end
     * @return Integer reply, specifically the number of elements removed.
     */
    public Long zremrangeByScore(final byte[] key, final double start,
	    final double end) {
	return zremrangeByScore(key, toByteArray(start), toByteArray(end));
    }

    public Long zremrangeByScore(final byte[] key, final byte[] start,
	    final byte[] end) {
	checkIsInMulti();
	client.zremrangeByScore(key, start, end);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zunionstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, sets);
	return client.getIntegerReply();
    }

    /**
     * Creates a union or intersection of N sorted sets given by keys k1 through
     * kN, and stores it at dstkey. It is mandatory to provide the number of
     * input keys N, before passing the input keys and the other (optional)
     * arguments.
     * <p>
     * As the terms imply, the {@link #zinterstore(String, String...)
     * ZINTERSTORE} command requires an element to be present in each of the
     * given inputs to be inserted in the result. The
     * {@link #zunionstore(String, String...) ZUNIONSTORE} command inserts all
     * elements across all inputs.
     * <p>
     * Using the WEIGHTS option, it is possible to add weight to each input
     * sorted set. This means that the score of each element in the sorted set
     * is first multiplied by this weight before being passed to the
     * aggregation. When this option is not given, all weights default to 1.
     * <p>
     * With the AGGREGATE option, it's possible to specify how the results of
     * the union or intersection are aggregated. This option defaults to SUM,
     * where the score of an element is summed across the inputs where it
     * exists. When this option is set to be either MIN or MAX, the resulting
     * set will contain the minimum or maximum score of an element across the
     * inputs where it exists.
     * <p>
     * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the
     * sizes of the input sorted sets, and M being the number of elements in the
     * resulting sorted set
     * 
     * @see #zunionstore(String, String...)
     * @see #zunionstore(String, ZParams, String...)
     * @see #zinterstore(String, String...)
     * @see #zinterstore(String, ZParams, String...)
     * 
     * @param dstkey
     * @param sets
     * @param params
     * @return Integer reply, specifically the number of elements in the sorted
     *         set at dstkey
     */
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	checkIsInMulti();
	client.zinterstore(dstkey, params, sets);
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk.
     * <p>
     * Save the whole dataset on disk (this means that all the databases are
     * saved, as well as keys with an EXPIRE set (the expire is preserved). The
     * server hangs while the saving is not completed, no connection is served
     * in the meanwhile. An OK code is returned when the DB was fully stored in
     * disk.
     * <p>
     * The background variant of this command is {@link #bgsave() BGSAVE} that
     * is able to perform the saving in the background while the server
     * continues serving other clients.
     * <p>
     * 
     * @return Status code reply
     */
    public String save() {
	client.save();
	return client.getStatusCodeReply();
    }

    /**
     * Asynchronously save the DB on disk.
     * <p>
     * Save the DB in background. The OK code is immediately returned. Redis
     * forks, the parent continues to server the clients, the child saves the DB
     * on disk then exit. A client my be able to check if the operation
     * succeeded using the LASTSAVE command.
     * 
     * @return Status code reply
     */
    public String bgsave() {
	client.bgsave();
	return client.getStatusCodeReply();
    }

    /**
     * Rewrite the append only file in background when it gets too big. Please
     * for detailed information about the Redis Append Only File check the <a
     * href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append
     * Only File Howto</a>.
     * <p>
     * BGREWRITEAOF rewrites the Append Only File in background when it gets too
     * big. The Redis Append Only File is a Journal, so every operation
     * modifying the dataset is logged in the Append Only File (and replayed at
     * startup). This means that the Append Only File always grows. In order to
     * rebuild its content the BGREWRITEAOF creates a new version of the append
     * only file starting directly form the dataset in memory in order to
     * guarantee the generation of the minimal number of commands needed to
     * rebuild the database.
     * <p>
     * 
     * @return Status code reply
     */
    public String bgrewriteaof() {
	client.bgrewriteaof();
	return client.getStatusCodeReply();
    }

    /**
     * Return the UNIX time stamp of the last successfully saving of the dataset
     * on disk.
     * <p>
     * Return the UNIX TIME of the last DB save executed with success. A client
     * may check if a {@link #bgsave() BGSAVE} command succeeded reading the
     * LASTSAVE value, then issuing a BGSAVE command and checking at regular
     * intervals every N seconds if LASTSAVE changed.
     * 
     * @return Integer reply, specifically an UNIX time stamp.
     */
    public Long lastsave() {
	client.lastsave();
	return client.getIntegerReply();
    }

    /**
     * Synchronously save the DB on disk, then shutdown the server.
     * <p>
     * Stop all the clients, save the DB, then quit the server. This commands
     * makes sure that the DB is switched off without the lost of any data. This
     * is not guaranteed if the client uses simply {@link #save() SAVE} and then
     * {@link #quit() QUIT} because other clients may alter the DB data between
     * the two commands.
     * 
     * @return Status code reply on error. On success nothing is returned since
     *         the server quits and the connection is closed.
     */
    public String shutdown() {
	client.shutdown();
	String status = null;
	try {
	    status = client.getStatusCodeReply();
	} catch (JedisException ex) {
	    status = null;
	}
	return status;
    }

    /**
     * Provide information and statistics about the server.
     * <p>
     * The info command returns different information and statistics about the
     * server in an format that's simple to parse by computers and easy to read
     * by humans.
     * <p>
     * <b>Format of the returned String:</b>
     * <p>
     * All the fields are in the form field:value
     * 
     * <pre>
     * edis_version:0.07
     * connected_clients:1
     * connected_slaves:0
     * used_memory:3187
     * changes_since_last_save:0
     * last_save_time:1237655729
     * total_connections_received:1
     * total_commands_processed:1
     * uptime_in_seconds:25
     * uptime_in_days:0
     * </pre>
     * 
     * <b>Notes</b>
     * <p>
     * used_memory is returned in bytes, and is the total number of bytes
     * allocated by the program using malloc.
     * <p>
     * uptime_in_days is redundant since the uptime in seconds contains already
     * the full uptime information, this field is only mainly present for
     * humans.
     * <p>
     * changes_since_last_save does not refer to the number of key changes, but
     * to the number of operations that produced some kind of change in the
     * dataset.
     * <p>
     * 
     * @return Bulk reply
     */
    public String info() {
	client.info();
	return client.getBulkReply();
    }

    public String info(final String section) {
	client.info(section);
	return client.getBulkReply();
    }

    /**
     * Dump all the received requests in real time.
     * <p>
     * MONITOR is a debugging command that outputs the whole sequence of
     * commands received by the Redis server. is very handy in order to
     * understand what is happening into the database. This command is used
     * directly via telnet.
     * 
     * @param jedisMonitor
     */
    public void monitor(final JedisMonitor jedisMonitor) {
	client.monitor();
	client.getStatusCodeReply();
	jedisMonitor.proceed(client);
    }

    /**
     * Change the replication settings.
     * <p>
     * The SLAVEOF command can change the replication settings of a slave on the
     * fly. If a Redis server is arleady acting as slave, the command SLAVEOF NO
     * ONE will turn off the replicaiton turning the Redis server into a MASTER.
     * In the proper form SLAVEOF hostname port will make the server a slave of
     * the specific server listening at the specified hostname and port.
     * <p>
     * If a server is already a slave of some master, SLAVEOF hostname port will
     * stop the replication against the old server and start the
     * synchrnonization against the new one discarding the old dataset.
     * <p>
     * The form SLAVEOF no one will stop replication turning the server into a
     * MASTER but will not discard the replication. So if the old master stop
     * working it is possible to turn the slave into a master and set the
     * application to use the new master in read/write. Later when the other
     * Redis server will be fixed it can be configured in order to work as
     * slave.
     * <p>
     * 
     * @param host
     * @param port
     * @return Status code reply
     */
    public String slaveof(final String host, final int port) {
	client.slaveof(host, port);
	return client.getStatusCodeReply();
    }

    public String slaveofNoOne() {
	client.slaveofNoOne();
	return client.getStatusCodeReply();
    }

    /**
     * Retrieve the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * CONFIG GET returns the current configuration parameters. This sub command
     * only accepts a single argument, that is glob style pattern. All the
     * configuration parameters matching this parameter are reported as a list
     * of key-value pairs.
     * <p>
     * <b>Example:</b>
     * 
     * <pre>
     * $ redis-cli config get '*'
     * 1. "dbfilename"
     * 2. "dump.rdb"
     * 3. "requirepass"
     * 4. (nil)
     * 5. "masterauth"
     * 6. (nil)
     * 7. "maxmemory"
     * 8. "0\n"
     * 9. "appendfsync"
     * 10. "everysec"
     * 11. "save"
     * 12. "3600 1 300 100 60 10000"
     * 
     * $ redis-cli config get 'm*'
     * 1. "masterauth"
     * 2. (nil)
     * 3. "maxmemory"
     * 4. "0\n"
     * </pre>
     * 
     * @param pattern
     * @return Bulk reply.
     */
    public List<byte[]> configGet(final byte[] pattern) {
	client.configGet(pattern);
	return client.getBinaryMultiBulkReply();
    }

    /**
     * Reset the stats returned by INFO
     * 
     * @return
     */
    public String configResetStat() {
	client.configResetStat();
	return client.getStatusCodeReply();
    }

    /**
     * Alter the configuration of a running Redis server. Not all the
     * configuration parameters are supported.
     * <p>
     * The list of configuration parameters supported by CONFIG SET can be
     * obtained issuing a {@link #configGet(String) CONFIG GET *} command.
     * <p>
     * The configuration set using CONFIG SET is immediately loaded by the Redis
     * server that will start acting as specified starting from the next
     * command.
     * <p>
     * 
     * <b>Parameters value format</b>
     * <p>
     * The value of the configuration parameter is the same as the one of the
     * same parameter in the Redis configuration file, with the following
     * exceptions:
     * <p>
     * <ul>
     * <li>The save paramter is a list of space-separated integers. Every pair
     * of integers specify the time and number of changes limit to trigger a
     * save. For instance the command CONFIG SET save "3600 10 60 10000" will
     * configure the server to issue a background saving of the RDB file every
     * 3600 seconds if there are at least 10 changes in the dataset, and every
     * 60 seconds if there are at least 10000 changes. To completely disable
     * automatic snapshots just set the parameter as an empty string.
     * <li>All the integer parameters representing memory are returned and
     * accepted only using bytes as unit.
     * </ul>
     * 
     * @param parameter
     * @param value
     * @return Status code reply
     */
    public byte[] configSet(final byte[] parameter, final byte[] value) {
	client.configSet(parameter, value);
	return client.getBinaryBulkReply();
    }

    public boolean isConnected() {
	return client.isConnected();
    }

    public Long strlen(final byte[] key) {
	client.strlen(key);
	return client.getIntegerReply();
    }

    public void sync() {
	client.sync();
    }

    public Long lpushx(final byte[] key, final byte[]... string) {
	client.lpushx(key, string);
	return client.getIntegerReply();
    }

    /**
     * Undo a {@link #expire(byte[], int) expire} at turning the expire key into
     * a normal key.
     * <p>
     * Time complexity: O(1)
     * 
     * @param key
     * @return Integer reply, specifically: 1: the key is now persist. 0: the
     *         key is not persist (only happens when key not set).
     */
    public Long persist(final byte[] key) {
	client.persist(key);
	return client.getIntegerReply();
    }

    public Long rpushx(final byte[] key, final byte[]... string) {
	client.rpushx(key, string);
	return client.getIntegerReply();
    }

    public byte[] echo(final byte[] string) {
	client.echo(string);
	return client.getBinaryBulkReply();
    }

    public Long linsert(final byte[] key, final LIST_POSITION where,
	    final byte[] pivot, final byte[] value) {
	client.linsert(key, where, pivot, value);
	return client.getIntegerReply();
    }

    public String debug(final DebugParams params) {
	client.debug(params);
	return client.getStatusCodeReply();
    }

    public Client getClient() {
	return client;
    }

    /**
     * Pop a value from a list, push it to another list and return it; or block
     * until one is available
     * 
     * @param source
     * @param destination
     * @param timeout
     * @return the element
     */
    public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
	client.brpoplpush(source, destination, timeout);
	client.setTimeoutInfinite();
	byte[] reply = client.getBinaryBulkReply();
	client.rollbackTimeout();
	return reply;
    }

    /**
     * Sets or clears the bit at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @param value
     * @return
     */
    public Boolean setbit(byte[] key, long offset, boolean value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    public Boolean setbit(byte[] key, long offset, byte[] value) {
	client.setbit(key, offset, value);
	return client.getIntegerReply() == 1;
    }

    /**
     * Returns the bit value at offset in the string value stored at key
     * 
     * @param key
     * @param offset
     * @return
     */
    public Boolean getbit(byte[] key, long offset) {
	client.getbit(key, offset);
	return client.getIntegerReply() == 1;
    }

    public Long setrange(byte[] key, long offset, byte[] value) {
	client.setrange(key, offset, value);
	return client.getIntegerReply();
    }

    public byte[] getrange(byte[] key, long startOffset, long endOffset) {
	client.getrange(key, startOffset, endOffset);
	return client.getBinaryBulkReply();
    }

    public Long publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return client.getIntegerReply();
    }

    public void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels) {
	client.setTimeoutInfinite();
	jedisPubSub.proceed(client, channels);
	client.rollbackTimeout();
    }

    public void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns) {
	client.setTimeoutInfinite();
	jedisPubSub.proceedWithPatterns(client, patterns);
	client.rollbackTimeout();
    }

    public Long getDB() {
	return client.getDB();
    }

    /**
     * Evaluates scripts using the Lua interpreter built into Redis starting
     * from version 2.6.0.
     * <p>
     * 
     * @return Script result
     */
    public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	client.setTimeoutInfinite();
	client.eval(script, toByteArray(keys.size()), getParamsWithBinary(keys, args));
	return client.getOne();
    }

    protected static byte[][] getParamsWithBinary(List<byte[]> keys, List<byte[]> args) {
	int keyCount = keys.size();
	int argCount = args.size();
	byte[][] params = new byte[keyCount + args.size()][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return params;
    }

    public Object eval(byte[] script, byte[] keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, keyCount, params);
	return client.getOne();
    }

    public Object eval(byte[] script, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.eval(script, SafeEncoder.encode(Integer.toString(keyCount)),
		params);
	return client.getOne();
    }

    public Object eval(byte[] script) {
	client.setTimeoutInfinite();
	client.eval(script, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, 0);
	return client.getOne();
    }

    public Object evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {

	int keyCount = keys == null ? 0 : keys.size();
	int argCount = args == null ? 0 : args.size();

	byte[][] params = new byte[keyCount + argCount][];

	for (int i = 0; i < keyCount; i++)
	    params[i] = keys.get(i);

	for (int i = 0; i < argCount; i++)
	    params[keyCount + i] = args.get(i);

	return evalsha(sha1, keyCount, params);
    }

    public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
	client.setTimeoutInfinite();
	client.evalsha(sha1, keyCount, params);
	return client.getOne();
    }

    public String scriptFlush() {
	client.scriptFlush();
	return client.getStatusCodeReply();
    }

    public Long scriptExists(byte[] sha1) {
	byte[][] a = new byte[1][];
	a[0] = sha1;
	return scriptExists(a).get(0);
    }
    
    public List<Long> scriptExists(byte[]... sha1) {
	client.scriptExists(sha1);
	return client.getIntegerMultiBulkReply();
    }

    public byte[] scriptLoad(byte[] script) {
	client.scriptLoad(script);
	return client.getBinaryBulkReply();
    }

    public String scriptKill() {
	client.scriptKill();
	return client.getStatusCodeReply();
    }

    public String slowlogReset() {
	client.slowlogReset();
	return client.getBulkReply();
    }

    public Long slowlogLen() {
	client.slowlogLen();
	return client.getIntegerReply();
    }

    public List<byte[]> slowlogGetBinary() {
	client.slowlogGet();
	return client.getBinaryMultiBulkReply();
    }

    public List<byte[]> slowlogGetBinary(long entries) {
	client.slowlogGet(entries);
	return client.getBinaryMultiBulkReply();
    }

    public Long objectRefcount(byte[] key) {
	client.objectRefcount(key);
	return client.getIntegerReply();
    }

    public byte[] objectEncoding(byte[] key) {
	client.objectEncoding(key);
	return client.getBinaryBulkReply();
    }

    public Long objectIdletime(byte[] key) {
	client.objectIdletime(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key) {
	client.bitcount(key);
	return client.getIntegerReply();
    }

    public Long bitcount(final byte[] key, long start, long end) {
	client.bitcount(key, start, end);
	return client.getIntegerReply();
    }

    public Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return client.getIntegerReply();
    }

    public byte[] dump(final byte[] key) {
	checkIsInMulti();
	client.dump(key);
	return client.getBinaryBulkReply();
    }

    public String restore(final byte[] key, final int ttl,
	    final byte[] serializedValue) {
	checkIsInMulti();
	client.restore(key, ttl, serializedValue);
	return client.getStatusCodeReply();
    }

    public Long pexpire(final byte[] key, final int milliseconds) {
	checkIsInMulti();
	client.pexpire(key, milliseconds);
	return client.getIntegerReply();
    }

    public Long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
	checkIsInMulti();
	client.pexpireAt(key, millisecondsTimestamp);
	return client.getIntegerReply();
    }

    public Long pttl(final byte[] key) {
	checkIsInMulti();
	client.pttl(key);
	return client.getIntegerReply();
    }

    public Double incrByFloat(final byte[] key, final double increment) {
	checkIsInMulti();
	client.incrByFloat(key, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    public String psetex(final byte[] key, final int milliseconds,
	    final byte[] value) {
	checkIsInMulti();
	client.psetex(key, milliseconds, value);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
	checkIsInMulti();
	client.set(key, value, nxxx);
	return client.getStatusCodeReply();
    }

    public String set(final byte[] key, final byte[] value, final byte[] nxxx,
	    final byte[] expx, final int time) {
	checkIsInMulti();
	client.set(key, value, nxxx, expx, time);
	return client.getStatusCodeReply();
    }

    public String clientKill(final byte[] client) {
	checkIsInMulti();
	this.client.clientKill(client);
	return this.client.getStatusCodeReply();
    }

    public String clientGetname() {
	checkIsInMulti();
	client.clientGetname();
	return client.getBulkReply();
    }

    public String clientList() {
	checkIsInMulti();
	client.clientList();
	return client.getBulkReply();
    }

    public String clientSetname(final byte[] name) {
	checkIsInMulti();
	client.clientSetname(name);
	return client.getBulkReply();
    }

    public List<String> time() {
	checkIsInMulti();
	client.time();
	return client.getMultiBulkReply();
    }

    public String migrate(final byte[] host, final int port, final byte[] key,
	    final int destinationDb, final int timeout) {
	checkIsInMulti();
	client.migrate(host, port, key, destinationDb, timeout);
	return client.getStatusCodeReply();
    }

    public Double hincrByFloat(final byte[] key, final byte[] field,
	    double increment) {
	checkIsInMulti();
	client.hincrByFloat(key, field, increment);
	String relpy = client.getBulkReply();
	return (relpy != null ? new Double(relpy) : null);
    }

    /**
     * Syncrhonous replication of Redis as described here:
     * http://antirez.com/news/66
     * 
     * Since Java Object class has implemented "wait" method, we cannot use it,
     * so I had to change the name of the method. Sorry :S
     */
    public Long waitReplicas(int replicas, long timeout) {
	checkIsInMulti();
	client.waitReplicas(replicas, timeout);
	return client.getIntegerReply();
=======
    client.getOne(); // expected OK
    transaction = new Transaction(client);
    return transaction;
  }

  protected void checkIsInMulti() {
    if (client.isInMulti()) {
      throw new JedisDataException(
          "Cannot use Jedis when in Multi. Please use JedisTransaction instead.");
    }
  }

  public void connect() {
    client.connect();
  }

  public void disconnect() {
    client.disconnect();
  }

  public void resetState() {
    if (client.isConnected()) {
      if (transaction != null) {
        transaction.clear();
      }

      if (pipeline != null) {
        pipeline.clear();
      }

      if (client.isInWatch()) {
        unwatch();
      }

      client.resetState();
    }

    transaction = null;
    pipeline = null;
  }

  public String watch(final byte[]... keys) {
    client.watch(keys);
    return client.getStatusCodeReply();
  }

  public String unwatch() {
    client.unwatch();
    return client.getStatusCodeReply();
  }

  @Override
  public void close() {
    client.close();
  }

  /**
   * Sort a Set or a List.
   * <p>
   * Sort the elements contained in the List, Set, or Sorted Set value at key. By default sorting is
   * numeric with elements being compared as double precision floating point numbers. This is the
   * simplest form of SORT.
   * @see #sort(byte[], byte[])
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @return Assuming the Set/List at key contains a list of numbers, the return value will be the
   *         list of numbers ordered from the smallest to the biggest number.
   */
  public List<byte[]> sort(final byte[] key) {
    checkIsInMulti();
    client.sort(key);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * Sort a Set or a List accordingly to the specified parameters.
   * <p>
   * <b>examples:</b>
   * <p>
   * Given are the following sets and key/values:
   * 
   * <pre>
   * x = [1, 2, 3]
   * y = [a, b, c]
   * 
   * k1 = z
   * k2 = y
   * k3 = x
   * 
   * w1 = 9
   * w2 = 8
   * w3 = 7
   * </pre>
   * 
   * Sort Order:
   * 
   * <pre>
   * sort(x) or sort(x, sp.asc())
   * -> [1, 2, 3]
   * 
   * sort(x, sp.desc())
   * -> [3, 2, 1]
   * 
   * sort(y)
   * -> [c, a, b]
   * 
   * sort(y, sp.alpha())
   * -> [a, b, c]
   * 
   * sort(y, sp.alpha().desc())
   * -> [c, a, b]
   * </pre>
   * 
   * Limit (e.g. for Pagination):
   * 
   * <pre>
   * sort(x, sp.limit(0, 2))
   * -> [1, 2]
   * 
   * sort(y, sp.alpha().desc().limit(1, 2))
   * -> [b, a]
   * </pre>
   * 
   * Sorting by external keys:
   * 
   * <pre>
   * sort(x, sb.by(w*))
   * -> [3, 2, 1]
   * 
   * sort(x, sb.by(w*).desc())
   * -> [1, 2, 3]
   * </pre>
   * 
   * Getting external keys:
   * 
   * <pre>
   * sort(x, sp.by(w*).get(k*))
   * -> [x, y, z]
   * 
   * sort(x, sp.by(w*).get(#).get(k*))
   * -> [3, x, 2, y, 1, z]
   * </pre>
   * @see #sort(byte[])
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @param sortingParameters
   * @return a list of sorted elements.
   */
  public List<byte[]> sort(final byte[] key, final SortingParams sortingParameters) {
    checkIsInMulti();
    client.sort(key, sortingParameters);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this commands as blocking
   * versions of LPOP and RPOP able to block if the specified keys don't exist or contain empty
   * lists.
   * <p>
   * The following is a description of the exact semantic. We describe BLPOP but the two commands
   * are identical, the only difference is that BLPOP pops the element from the left (head) of the
   * list, and BRPOP pops from the right (tail).
   * <p>
   * <b>Non blocking behavior</b>
   * <p>
   * When BLPOP is called, if at least one of the specified keys contain a non empty list, an
   * element is popped from the head of the list and returned to the caller together with the name
   * of the key (BLPOP returns a two elements array, the first element is the key, the second the
   * popped value).
   * <p>
   * Keys are scanned from left to right, so for instance if you issue BLPOP list1 list2 list3 0
   * against a dataset where list1 does not exist but list2 and list3 contain non empty lists, BLPOP
   * guarantees to return an element from the list stored at list2 (since it is the first non empty
   * list starting from the left).
   * <p>
   * <b>Blocking behavior</b>
   * <p>
   * If none of the specified keys exist or contain non empty lists, BLPOP blocks until some other
   * client performs a LPUSH or an RPUSH operation against one of the lists.
   * <p>
   * Once new data is present on one of the lists, the client finally returns with the name of the
   * key unblocking it and the popped value.
   * <p>
   * When blocking, if a non-zero timeout is specified, the client will unblock returning a nil
   * special value if the specified amount of seconds passed without a push operation against at
   * least one of the specified keys.
   * <p>
   * The timeout argument is interpreted as an integer value. A timeout of zero means instead to
   * block forever.
   * <p>
   * <b>Multiple clients blocking for the same keys</b>
   * <p>
   * Multiple clients can block for the same key. They are put into a queue, so the first to be
   * served will be the one that started to wait earlier, in a first-blpopping first-served fashion.
   * <p>
   * <b>blocking POP inside a MULTI/EXEC transaction</b>
   * <p>
   * BLPOP and BRPOP can be used with pipelining (sending multiple commands and reading the replies
   * in batch), but it does not make sense to use BLPOP or BRPOP inside a MULTI/EXEC block (a Redis
   * transaction).
   * <p>
   * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to return a multi-bulk nil
   * reply, exactly what happens when the timeout is reached. If you like science fiction, think at
   * it like if inside MULTI/EXEC the time will flow at infinite speed :)
   * <p>
   * Time complexity: O(1)
   * @see #brpop(int, byte[]...)
   * @param timeout
   * @param keys
   * @return BLPOP returns a two-elements array via a multi bulk reply in order to return both the
   *         unblocking key and the popped value.
   *         <p>
   *         When a non-zero timeout is specified, and the BLPOP operation timed out, the return
   *         value is a nil multi bulk reply. Most client values will return false or nil
   *         accordingly to the programming language used.
   */
  public List<byte[]> blpop(final int timeout, final byte[]... keys) {
    return blpop(getArgsAddTimeout(timeout, keys));
  }

  private byte[][] getArgsAddTimeout(int timeout, byte[][] keys) {
    int size = keys.length;
    final byte[][] args = new byte[size + 1][];
    for (int at = 0; at != size; ++at) {
      args[at] = keys[at];
    }
    args[size] = Protocol.toByteArray(timeout);
    return args;
  }

  /**
   * Sort a Set or a List accordingly to the specified parameters and store the result at dstkey.
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[])
   * @see #sort(byte[], byte[])
   * @param key
   * @param sortingParameters
   * @param dstkey
   * @return The number of elements of the list at dstkey.
   */
  public Long sort(final byte[] key, final SortingParams sortingParameters, final byte[] dstkey) {
    checkIsInMulti();
    client.sort(key, sortingParameters, dstkey);
    return client.getIntegerReply();
  }

  /**
   * Sort a Set or a List and Store the Result at dstkey.
   * <p>
   * Sort the elements contained in the List, Set, or Sorted Set value at key and store the result
   * at dstkey. By default sorting is numeric with elements being compared as double precision
   * floating point numbers. This is the simplest form of SORT.
   * @see #sort(byte[])
   * @see #sort(byte[], SortingParams)
   * @see #sort(byte[], SortingParams, byte[])
   * @param key
   * @param dstkey
   * @return The number of elements of the list at dstkey.
   */
  public Long sort(final byte[] key, final byte[] dstkey) {
    checkIsInMulti();
    client.sort(key, dstkey);
    return client.getIntegerReply();
  }

  /**
   * BLPOP (and BRPOP) is a blocking list pop primitive. You can see this commands as blocking
   * versions of LPOP and RPOP able to block if the specified keys don't exist or contain empty
   * lists.
   * <p>
   * The following is a description of the exact semantic. We describe BLPOP but the two commands
   * are identical, the only difference is that BLPOP pops the element from the left (head) of the
   * list, and BRPOP pops from the right (tail).
   * <p>
   * <b>Non blocking behavior</b>
   * <p>
   * When BLPOP is called, if at least one of the specified keys contain a non empty list, an
   * element is popped from the head of the list and returned to the caller together with the name
   * of the key (BLPOP returns a two elements array, the first element is the key, the second the
   * popped value).
   * <p>
   * Keys are scanned from left to right, so for instance if you issue BLPOP list1 list2 list3 0
   * against a dataset where list1 does not exist but list2 and list3 contain non empty lists, BLPOP
   * guarantees to return an element from the list stored at list2 (since it is the first non empty
   * list starting from the left).
   * <p>
   * <b>Blocking behavior</b>
   * <p>
   * If none of the specified keys exist or contain non empty lists, BLPOP blocks until some other
   * client performs a LPUSH or an RPUSH operation against one of the lists.
   * <p>
   * Once new data is present on one of the lists, the client finally returns with the name of the
   * key unblocking it and the popped value.
   * <p>
   * When blocking, if a non-zero timeout is specified, the client will unblock returning a nil
   * special value if the specified amount of seconds passed without a push operation against at
   * least one of the specified keys.
   * <p>
   * The timeout argument is interpreted as an integer value. A timeout of zero means instead to
   * block forever.
   * <p>
   * <b>Multiple clients blocking for the same keys</b>
   * <p>
   * Multiple clients can block for the same key. They are put into a queue, so the first to be
   * served will be the one that started to wait earlier, in a first-blpopping first-served fashion.
   * <p>
   * <b>blocking POP inside a MULTI/EXEC transaction</b>
   * <p>
   * BLPOP and BRPOP can be used with pipelining (sending multiple commands and reading the replies
   * in batch), but it does not make sense to use BLPOP or BRPOP inside a MULTI/EXEC block (a Redis
   * transaction).
   * <p>
   * The behavior of BLPOP inside MULTI/EXEC when the list is empty is to return a multi-bulk nil
   * reply, exactly what happens when the timeout is reached. If you like science fiction, think at
   * it like if inside MULTI/EXEC the time will flow at infinite speed :)
   * <p>
   * Time complexity: O(1)
   * @see #blpop(int, byte[]...)
   * @param timeout
   * @param keys
   * @return BLPOP returns a two-elements array via a multi bulk reply in order to return both the
   *         unblocking key and the popped value.
   *         <p>
   *         When a non-zero timeout is specified, and the BLPOP operation timed out, the return
   *         value is a nil multi bulk reply. Most client values will return false or nil
   *         accordingly to the programming language used.
   */
  public List<byte[]> brpop(final int timeout, final byte[]... keys) {
    return brpop(getArgsAddTimeout(timeout, keys));
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  public List<byte[]> blpop(byte[] arg) {
    return blpop(new byte[][] { arg });
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  public List<byte[]> brpop(byte[] arg) {
    return brpop(new byte[][] { arg });
  }

  public List<byte[]> blpop(byte[]... args) {
    checkIsInMulti();
    client.blpop(args);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryMultiBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  public List<byte[]> brpop(byte[]... args) {
    checkIsInMulti();
    client.brpop(args);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryMultiBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  /**
   * Request for authentication in a password protected Redis server. A Redis server can be
   * instructed to require a password before to allow clients to issue commands. This is done using
   * the requirepass directive in the Redis configuration file. If the password given by the client
   * is correct the server replies with an OK status code reply and starts accepting commands from
   * the client. Otherwise an error is returned and the clients needs to try a new password. Note
   * that for the high performance nature of Redis it is possible to try a lot of passwords in
   * parallel in very short time, so make sure to generate a strong and very long password so that
   * this attack is infeasible.
   * @param password
   * @return Status code reply
   */
  public String auth(final String password) {
    checkIsInMulti();
    client.auth(password);
    return client.getStatusCodeReply();
  }

  public Pipeline pipelined() {
    pipeline = new Pipeline();
    pipeline.setClient(client);
    return pipeline;
  }

  public Long zcount(final byte[] key, final double min, final double max) {
    return zcount(key, toByteArray(min), toByteArray(max));
  }

  public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zcount(key, min, max);
    return client.getIntegerReply();
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max));
  }

  public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByScore(key, min, max);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max,
      final int offset, final int count) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByScore(key, min, max, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
  }

  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByScoreWithScores(key, min, max);
    return getBinaryTupledSet();
  }

  /**
   * Return the all the elements in the sorted set at key with a score between min and max
   * (including elements with score equal to min or max).
   * <p>
   * The elements having the same score are returned sorted lexicographically as ASCII strings (this
   * follows from a property of Redis sorted sets and does not involve further computation).
   * <p>
   * Using the optional {@link #zrangeByScore(byte[], double, double, int, int) LIMIT} it's possible
   * to get only a range of the matching elements in an SQL-alike way. Note that if offset is large
   * the commands needs to traverse the list for offset elements and this adds up to the O(M)
   * figure.
   * <p>
   * The {@link #zcount(byte[], double, double) ZCOUNT} command is similar to
   * {@link #zrangeByScore(byte[], double, double) ZRANGEBYSCORE} but instead of returning the
   * actual elements in the specified interval, it just returns the number of matching elements.
   * <p>
   * <b>Exclusive intervals and infinity</b>
   * <p>
   * min and max can be -inf and +inf, so that you are not required to know what's the greatest or
   * smallest element in order to take, for instance, elements "up to a given value".
   * <p>
   * Also while the interval is for default closed (inclusive) it's possible to specify open
   * intervals prefixing the score with a "(" character, so for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (1.3 5}
   * <p>
   * Will return all the values with score > 1.3 and <= 5, while for instance:
   * <p>
   * {@code ZRANGEBYSCORE zset (5 (10}
   * <p>
   * Will return all the values with score > 5 and < 10 (5 and 10 excluded).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements returned by the command, so if M is constant (for instance you always ask for the
   * first ten elements with LIMIT) you can consider it O(log(N))
   * @see #zrangeByScore(byte[], double, double)
   * @see #zrangeByScore(byte[], double, double, int, int)
   * @see #zrangeByScoreWithScores(byte[], double, double)
   * @see #zrangeByScoreWithScores(byte[], double, double, int, int)
   * @see #zcount(byte[], double, double)
   * @param key
   * @param min
   * @param max
   * @return Multi bulk reply specifically a list of elements in the specified score range.
   */
  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max,
      final int offset, final int count) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByScoreWithScores(key, min, max, offset, count);
    return getBinaryTupledSet();
  }

  private Set<Tuple> getBinaryTupledSet() {
    checkIsInMulti();
    List<byte[]> membersWithScores = client.getBinaryMultiBulkReply();
    Set<Tuple> set = new LinkedHashSet<Tuple>();
    Iterator<byte[]> iterator = membersWithScores.iterator();
    while (iterator.hasNext()) {
      set.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
    }
    return set;
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min) {
    return zrevrangeByScore(key, toByteArray(max), toByteArray(min));
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
    checkIsInMulti();
    client.zrevrangeByScore(key, max, min);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min,
      final int offset, final int count) {
    return zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
  }

  public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrevrangeByScore(key, max, min, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
    return zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max,
      final double min, final int offset, final int count) {
    return zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset, count);
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
    checkIsInMulti();
    client.zrevrangeByScoreWithScores(key, max, min);
    return getBinaryTupledSet();
  }

  public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max,
      final byte[] min, final int offset, final int count) {
    checkIsInMulti();
    client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getBinaryTupledSet();
  }

  /**
   * Remove all elements in the sorted set at key with rank between start and end. Start and end are
   * 0-based with rank 0 being the element with the lowest score. Both start and end can be negative
   * numbers, where they indicate offsets starting at the element with the highest rank. For
   * example: -1 is the element with the highest score, -2 the element with the second highest score
   * and so forth.
   * <p>
   * <b>Time complexity:</b> O(log(N))+O(M) with N being the number of elements in the sorted set
   * and M the number of elements removed by the operation
   */
  public Long zremrangeByRank(final byte[] key, final long start, final long end) {
    checkIsInMulti();
    client.zremrangeByRank(key, start, end);
    return client.getIntegerReply();
  }

  /**
   * Remove all the elements in the sorted set at key with a score between min and max (including
   * elements with score equal to min or max).
   * <p>
   * <b>Time complexity:</b>
   * <p>
   * O(log(N))+O(M) with N being the number of elements in the sorted set and M the number of
   * elements removed by the operation
   * @param key
   * @param start
   * @param end
   * @return Integer reply, specifically the number of elements removed.
   */
  public Long zremrangeByScore(final byte[] key, final double start, final double end) {
    return zremrangeByScore(key, toByteArray(start), toByteArray(end));
  }

  public Long zremrangeByScore(final byte[] key, final byte[] start, final byte[] end) {
    checkIsInMulti();
    client.zremrangeByScore(key, start, end);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...)} ZINTERSTORE} command requires
   * an element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...)} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
    checkIsInMulti();
    client.zunionstore(dstkey, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @param params
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zunionstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
    checkIsInMulti();
    client.zunionstore(dstkey, params, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
    checkIsInMulti();
    client.zinterstore(dstkey, sets);
    return client.getIntegerReply();
  }

  /**
   * Creates a union or intersection of N sorted sets given by keys k1 through kN, and stores it at
   * dstkey. It is mandatory to provide the number of input keys N, before passing the input keys
   * and the other (optional) arguments.
   * <p>
   * As the terms imply, the {@link #zinterstore(byte[], byte[]...) ZINTERSTORE} command requires an
   * element to be present in each of the given inputs to be inserted in the result. The {@link
   * #zunionstore(byte[], byte[]...) ZUNIONSTORE} command inserts all elements across all inputs.
   * <p>
   * Using the WEIGHTS option, it is possible to add weight to each input sorted set. This means
   * that the score of each element in the sorted set is first multiplied by this weight before
   * being passed to the aggregation. When this option is not given, all weights default to 1.
   * <p>
   * With the AGGREGATE option, it's possible to specify how the results of the union or
   * intersection are aggregated. This option defaults to SUM, where the score of an element is
   * summed across the inputs where it exists. When this option is set to be either MIN or MAX, the
   * resulting set will contain the minimum or maximum score of an element across the inputs where
   * it exists.
   * <p>
   * <b>Time complexity:</b> O(N) + O(M log(M)) with N being the sum of the sizes of the input
   * sorted sets, and M being the number of elements in the resulting sorted set
   * @see #zunionstore(byte[], byte[]...)
   * @see #zunionstore(byte[], ZParams, byte[]...)
   * @see #zinterstore(byte[], byte[]...)
   * @see #zinterstore(byte[], ZParams, byte[]...)
   * @param dstkey
   * @param sets
   * @param params
   * @return Integer reply, specifically the number of elements in the sorted set at dstkey
   */
  public Long zinterstore(final byte[] dstkey, final ZParams params, final byte[]... sets) {
    checkIsInMulti();
    client.zinterstore(dstkey, params, sets);
    return client.getIntegerReply();
  }

  @Override
  public Long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zlexcount(key, min, max);
    return client.getIntegerReply();
  }

  @Override
  public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zrangeByLex(key, min, max);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    checkIsInMulti();
    client.zrangeByLex(key, min, max, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrevrangeByLex(byte[] key, byte[] max, byte[] min) {
    checkIsInMulti();
    client.zrevrangeByLex(key, max, min);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Set<byte[]> zrevrangeByLex(byte[] key, byte[] max, byte[] min, int offset, int count) {
    checkIsInMulti();
    client.zrevrangeByLex(key, max, min, offset, count);
    return new LinkedHashSet<byte[]>(client.getBinaryMultiBulkReply());
  }

  @Override
  public Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    checkIsInMulti();
    client.zremrangeByLex(key, min, max);
    return client.getIntegerReply();
  }

  /**
   * Synchronously save the DB on disk.
   * <p>
   * Save the whole dataset on disk (this means that all the databases are saved, as well as keys
   * with an EXPIRE set (the expire is preserved). The server hangs while the saving is not
   * completed, no connection is served in the meanwhile. An OK code is returned when the DB was
   * fully stored in disk.
   * <p>
   * The background variant of this command is {@link #bgsave() BGSAVE} that is able to perform the
   * saving in the background while the server continues serving other clients.
   * <p>
   * @return Status code reply
   */
  public String save() {
    client.save();
    return client.getStatusCodeReply();
  }

  /**
   * Asynchronously save the DB on disk.
   * <p>
   * Save the DB in background. The OK code is immediately returned. Redis forks, the parent
   * continues to server the clients, the child saves the DB on disk then exit. A client my be able
   * to check if the operation succeeded using the LASTSAVE command.
   * @return Status code reply
   */
  public String bgsave() {
    client.bgsave();
    return client.getStatusCodeReply();
  }

  /**
   * Rewrite the append only file in background when it gets too big. Please for detailed
   * information about the Redis Append Only File check the <a
   * href="http://code.google.com/p/redis/wiki/AppendOnlyFileHowto">Append Only File Howto</a>.
   * <p>
   * BGREWRITEAOF rewrites the Append Only File in background when it gets too big. The Redis Append
   * Only File is a Journal, so every operation modifying the dataset is logged in the Append Only
   * File (and replayed at startup). This means that the Append Only File always grows. In order to
   * rebuild its content the BGREWRITEAOF creates a new version of the append only file starting
   * directly form the dataset in memory in order to guarantee the generation of the minimal number
   * of commands needed to rebuild the database.
   * <p>
   * @return Status code reply
   */
  public String bgrewriteaof() {
    client.bgrewriteaof();
    return client.getStatusCodeReply();
  }

  /**
   * Return the UNIX time stamp of the last successfully saving of the dataset on disk.
   * <p>
   * Return the UNIX TIME of the last DB save executed with success. A client may check if a
   * {@link #bgsave() BGSAVE} command succeeded reading the LASTSAVE value, then issuing a BGSAVE
   * command and checking at regular intervals every N seconds if LASTSAVE changed.
   * @return Integer reply, specifically an UNIX time stamp.
   */
  public Long lastsave() {
    client.lastsave();
    return client.getIntegerReply();
  }

  /**
   * Synchronously save the DB on disk, then shutdown the server.
   * <p>
   * Stop all the clients, save the DB, then quit the server. This commands makes sure that the DB
   * is switched off without the lost of any data. This is not guaranteed if the client uses simply
   * {@link #save() SAVE} and then {@link #quit() QUIT} because other clients may alter the DB data
   * between the two commands.
   * @return Status code reply on error. On success nothing is returned since the server quits and
   *         the connection is closed.
   */
  public String shutdown() {
    client.shutdown();
    String status;
    try {
      status = client.getStatusCodeReply();
    } catch (JedisException ex) {
      status = null;
    }
    return status;
  }

  /**
   * Provide information and statistics about the server.
   * <p>
   * The info command returns different information and statistics about the server in an format
   * that's simple to parse by computers and easy to read by humans.
   * <p>
   * <b>Format of the returned String:</b>
   * <p>
   * All the fields are in the form field:value
   * 
   * <pre>
   * edis_version:0.07
   * connected_clients:1
   * connected_slaves:0
   * used_memory:3187
   * changes_since_last_save:0
   * last_save_time:1237655729
   * total_connections_received:1
   * total_commands_processed:1
   * uptime_in_seconds:25
   * uptime_in_days:0
   * </pre>
   * 
   * <b>Notes</b>
   * <p>
   * used_memory is returned in bytes, and is the total number of bytes allocated by the program
   * using malloc.
   * <p>
   * uptime_in_days is redundant since the uptime in seconds contains already the full uptime
   * information, this field is only mainly present for humans.
   * <p>
   * changes_since_last_save does not refer to the number of key changes, but to the number of
   * operations that produced some kind of change in the dataset.
   * <p>
   * @return Bulk reply
   */
  public String info() {
    client.info();
    return client.getBulkReply();
  }

  public String info(final String section) {
    client.info(section);
    return client.getBulkReply();
  }

  /**
   * Dump all the received requests in real time.
   * <p>
   * MONITOR is a debugging command that outputs the whole sequence of commands received by the
   * Redis server. is very handy in order to understand what is happening into the database. This
   * command is used directly via telnet.
   * @param jedisMonitor
   */
  public void monitor(final JedisMonitor jedisMonitor) {
    client.monitor();
    client.getStatusCodeReply();
    jedisMonitor.proceed(client);
  }

  /**
   * Change the replication settings.
   * <p>
   * The SLAVEOF command can change the replication settings of a slave on the fly. If a Redis
   * server is arleady acting as slave, the command SLAVEOF NO ONE will turn off the replicaiton
   * turning the Redis server into a MASTER. In the proper form SLAVEOF hostname port will make the
   * server a slave of the specific server listening at the specified hostname and port.
   * <p>
   * If a server is already a slave of some master, SLAVEOF hostname port will stop the replication
   * against the old server and start the synchrnonization against the new one discarding the old
   * dataset.
   * <p>
   * The form SLAVEOF no one will stop replication turning the server into a MASTER but will not
   * discard the replication. So if the old master stop working it is possible to turn the slave
   * into a master and set the application to use the new master in read/write. Later when the other
   * Redis server will be fixed it can be configured in order to work as slave.
   * <p>
   * @param host
   * @param port
   * @return Status code reply
   */
  public String slaveof(final String host, final int port) {
    client.slaveof(host, port);
    return client.getStatusCodeReply();
  }

  public String slaveofNoOne() {
    client.slaveofNoOne();
    return client.getStatusCodeReply();
  }

  /**
   * Retrieve the configuration of a running Redis server. Not all the configuration parameters are
   * supported.
   * <p>
   * CONFIG GET returns the current configuration parameters. This sub command only accepts a single
   * argument, that is glob style pattern. All the configuration parameters matching this parameter
   * are reported as a list of key-value pairs.
   * <p>
   * <b>Example:</b>
   * 
   * <pre>
   * $ redis-cli config get '*'
   * 1. "dbfilename"
   * 2. "dump.rdb"
   * 3. "requirepass"
   * 4. (nil)
   * 5. "masterauth"
   * 6. (nil)
   * 7. "maxmemory"
   * 8. "0\n"
   * 9. "appendfsync"
   * 10. "everysec"
   * 11. "save"
   * 12. "3600 1 300 100 60 10000"
   * 
   * $ redis-cli config get 'm*'
   * 1. "masterauth"
   * 2. (nil)
   * 3. "maxmemory"
   * 4. "0\n"
   * </pre>
   * @param pattern
   * @return Bulk reply.
   */
  public List<byte[]> configGet(final byte[] pattern) {
    client.configGet(pattern);
    return client.getBinaryMultiBulkReply();
  }

  /**
   * Reset the stats returned by INFO
   * @return
   */
  public String configResetStat() {
    client.configResetStat();
    return client.getStatusCodeReply();
  }

  /**
   * Alter the configuration of a running Redis server. Not all the configuration parameters are
   * supported.
   * <p>
   * The list of configuration parameters supported by CONFIG SET can be obtained issuing a
   * {@link #configGet(byte[]) CONFIG GET *} command.
   * <p>
   * The configuration set using CONFIG SET is immediately loaded by the Redis server that will
   * start acting as specified starting from the next command.
   * <p>
   * <b>Parameters value format</b>
   * <p>
   * The value of the configuration parameter is the same as the one of the same parameter in the
   * Redis configuration file, with the following exceptions:
   * <p>
   * <ul>
   * <li>The save paramter is a list of space-separated integers. Every pair of integers specify the
   * time and number of changes limit to trigger a save. For instance the command CONFIG SET save
   * "3600 10 60 10000" will configure the server to issue a background saving of the RDB file every
   * 3600 seconds if there are at least 10 changes in the dataset, and every 60 seconds if there are
   * at least 10000 changes. To completely disable automatic snapshots just set the parameter as an
   * empty string.
   * <li>All the integer parameters representing memory are returned and accepted only using bytes
   * as unit.
   * </ul>
   * @param parameter
   * @param value
   * @return Status code reply
   */
  public byte[] configSet(final byte[] parameter, final byte[] value) {
    client.configSet(parameter, value);
    return client.getBinaryBulkReply();
  }

  public boolean isConnected() {
    return client.isConnected();
  }

  public Long strlen(final byte[] key) {
    client.strlen(key);
    return client.getIntegerReply();
  }

  public void sync() {
    client.sync();
  }

  public Long lpushx(final byte[] key, final byte[]... string) {
    client.lpushx(key, string);
    return client.getIntegerReply();
  }

  /**
   * Undo a {@link #expire(byte[], int) expire} at turning the expire key into a normal key.
   * <p>
   * Time complexity: O(1)
   * @param key
   * @return Integer reply, specifically: 1: the key is now persist. 0: the key is not persist (only
   *         happens when key not set).
   */
  public Long persist(final byte[] key) {
    client.persist(key);
    return client.getIntegerReply();
  }

  public Long rpushx(final byte[] key, final byte[]... string) {
    client.rpushx(key, string);
    return client.getIntegerReply();
  }

  public byte[] echo(final byte[] string) {
    client.echo(string);
    return client.getBinaryBulkReply();
  }

  public Long linsert(final byte[] key, final LIST_POSITION where, final byte[] pivot,
      final byte[] value) {
    client.linsert(key, where, pivot, value);
    return client.getIntegerReply();
  }

  public String debug(final DebugParams params) {
    client.debug(params);
    return client.getStatusCodeReply();
  }

  public Client getClient() {
    return client;
  }

  /**
   * Pop a value from a list, push it to another list and return it; or block until one is available
   * @param source
   * @param destination
   * @param timeout
   * @return the element
   */
  public byte[] brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    client.setTimeoutInfinite();
    try {
      return client.getBinaryBulkReply();
    } finally {
      client.rollbackTimeout();
    }
  }

  /**
   * Sets or clears the bit at offset in the string value stored at key
   * @param key
   * @param offset
   * @param value
   * @return
   */
  public Boolean setbit(byte[] key, long offset, boolean value) {
    client.setbit(key, offset, value);
    return client.getIntegerReply() == 1;
  }

  public Boolean setbit(byte[] key, long offset, byte[] value) {
    client.setbit(key, offset, value);
    return client.getIntegerReply() == 1;
  }

  /**
   * Returns the bit value at offset in the string value stored at key
   * @param key
   * @param offset
   * @return
   */
  public Boolean getbit(byte[] key, long offset) {
    client.getbit(key, offset);
    return client.getIntegerReply() == 1;
  }

  public Long bitpos(final byte[] key, final boolean value) {
    return bitpos(key, value, new BitPosParams());
  }

  public Long bitpos(final byte[] key, final boolean value, final BitPosParams params) {
    client.bitpos(key, value, params);
    return client.getIntegerReply();
  }

  public Long setrange(byte[] key, long offset, byte[] value) {
    client.setrange(key, offset, value);
    return client.getIntegerReply();
  }

  public byte[] getrange(byte[] key, long startOffset, long endOffset) {
    client.getrange(key, startOffset, endOffset);
    return client.getBinaryBulkReply();
  }

  public Long publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return client.getIntegerReply();
  }

  public void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels) {
    client.setTimeoutInfinite();
    try {
      jedisPubSub.proceed(client, channels);
    } finally {
      client.rollbackTimeout();
    }
  }

  public void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns) {
    client.setTimeoutInfinite();
    try {
      jedisPubSub.proceedWithPatterns(client, patterns);
    } finally {
      client.rollbackTimeout();
    }
  }

  public Long getDB() {
    return client.getDB();
  }

  /**
   * Evaluates scripts using the Lua interpreter built into Redis starting from version 2.6.0.
   * <p>
   * @return Script result
   */
  public Object eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
    return eval(script, toByteArray(keys.size()), getParams(keys, args));
  }

  private byte[][] getParams(List<byte[]> keys, List<byte[]> args) {
    final int keyCount = keys.size();
    final int argCount = args.size();
    byte[][] params = new byte[keyCount + argCount][];

    for (int i = 0; i < keyCount; i++)
      params[i] = keys.get(i);

    for (int i = 0; i < argCount; i++)
      params[keyCount + i] = args.get(i);

    return params;
  }

  public Object eval(byte[] script, byte[] keyCount, byte[]... params) {
    client.setTimeoutInfinite();
    try {
      client.eval(script, keyCount, params);
      return client.getOne();
    } finally {
      client.rollbackTimeout();
    }
  }

  public Object eval(byte[] script, int keyCount, byte[]... params) {
    return eval(script, toByteArray(keyCount), params);
  }

  public Object eval(byte[] script) {
    return eval(script, 0);
  }

  public Object evalsha(byte[] sha1) {
    return evalsha(sha1, 1);
  }

  public Object evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
    return evalsha(sha1, keys.size(), getParams(keys, args));
  }

  public Object evalsha(byte[] sha1, int keyCount, byte[]... params) {
    client.setTimeoutInfinite();
    try {
      client.evalsha(sha1, keyCount, params);
      return client.getOne();
    } finally {
      client.rollbackTimeout();
    }
  }

  public String scriptFlush() {
    client.scriptFlush();
    return client.getStatusCodeReply();
  }

  public List<Long> scriptExists(byte[]... sha1) {
    client.scriptExists(sha1);
    return client.getIntegerMultiBulkReply();
  }

  public byte[] scriptLoad(byte[] script) {
    client.scriptLoad(script);
    return client.getBinaryBulkReply();
  }

  public String scriptKill() {
    client.scriptKill();
    return client.getStatusCodeReply();
  }

  public String slowlogReset() {
    client.slowlogReset();
    return client.getBulkReply();
  }

  public Long slowlogLen() {
    client.slowlogLen();
    return client.getIntegerReply();
  }

  public List<byte[]> slowlogGetBinary() {
    client.slowlogGet();
    return client.getBinaryMultiBulkReply();
  }

  public List<byte[]> slowlogGetBinary(long entries) {
    client.slowlogGet(entries);
    return client.getBinaryMultiBulkReply();
  }

  public Long objectRefcount(byte[] key) {
    client.objectRefcount(key);
    return client.getIntegerReply();
  }

  public byte[] objectEncoding(byte[] key) {
    client.objectEncoding(key);
    return client.getBinaryBulkReply();
  }

  public Long objectIdletime(byte[] key) {
    client.objectIdletime(key);
    return client.getIntegerReply();
  }

  public Long bitcount(final byte[] key) {
    client.bitcount(key);
    return client.getIntegerReply();
  }

  public Long bitcount(final byte[] key, long start, long end) {
    client.bitcount(key, start, end);
    return client.getIntegerReply();
  }

  public Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return client.getIntegerReply();
  }

  public byte[] dump(final byte[] key) {
    checkIsInMulti();
    client.dump(key);
    return client.getBinaryBulkReply();
  }

  public String restore(final byte[] key, final int ttl, final byte[] serializedValue) {
    checkIsInMulti();
    client.restore(key, ttl, serializedValue);
    return client.getStatusCodeReply();
  }

  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  public Long pexpireAt(final byte[] key, final long millisecondsTimestamp) {
    checkIsInMulti();
    client.pexpireAt(key, millisecondsTimestamp);
    return client.getIntegerReply();
  }

  public Long pttl(final byte[] key) {
    checkIsInMulti();
    client.pttl(key);
    return client.getIntegerReply();
  }

  public String psetex(final byte[] key, final int milliseconds, final byte[] value) {
    checkIsInMulti();
    client.psetex(key, milliseconds, value);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
    checkIsInMulti();
    client.set(key, value, nxxx);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final int time) {
    checkIsInMulti();
    client.set(key, value, nxxx, expx, time);
    return client.getStatusCodeReply();
  }

  public String clientKill(final byte[] client) {
    checkIsInMulti();
    this.client.clientKill(client);
    return this.client.getStatusCodeReply();
  }

  public String clientGetname() {
    checkIsInMulti();
    client.clientGetname();
    return client.getBulkReply();
  }

  public String clientList() {
    checkIsInMulti();
    client.clientList();
    return client.getBulkReply();
  }

  public String clientSetname(final byte[] name) {
    checkIsInMulti();
    client.clientSetname(name);
    return client.getBulkReply();
  }

  public List<String> time() {
    checkIsInMulti();
    client.time();
    return client.getMultiBulkReply();
  }

  public String migrate(final byte[] host, final int port, final byte[] key,
      final int destinationDb, final int timeout) {
    checkIsInMulti();
    client.migrate(host, port, key, destinationDb, timeout);
    return client.getStatusCodeReply();
  }

  /**
   * Syncrhonous replication of Redis as described here: http://antirez.com/news/66 Since Java
   * Object class has implemented "wait" method, we cannot use it, so I had to change the name of
   * the method. Sorry :S
   */
  public Long waitReplicas(int replicas, long timeout) {
    checkIsInMulti();
    client.waitReplicas(replicas, timeout);
    return client.getIntegerReply();
  }

  @Override
  public Long pfadd(final byte[] key, final byte[]... elements) {
    checkIsInMulti();
    client.pfadd(key, elements);
    return client.getIntegerReply();
  }

  @Override
  public long pfcount(final byte[] key) {
    checkIsInMulti();
    client.pfcount(key);
    return client.getIntegerReply();
  }

  @Override
  public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
    checkIsInMulti();
    client.pfmerge(destkey, sourcekeys);
    return client.getStatusCodeReply();
  }

  @Override
  public Long pfcount(byte[]... keys) {
    checkIsInMulti();
    client.pfcount(keys);
    return client.getIntegerReply();
  }

  public ScanResult<byte[]> scan(final byte[] cursor) {
    return scan(cursor, new ScanParams());
  }

  public ScanResult<byte[]> scan(final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.scan(cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    return new ScanResult<byte[]>(newcursor, rawResults);
  }

  public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key, final byte[] cursor) {
    return hscan(key, cursor, new ScanParams());
  }

  public ScanResult<Map.Entry<byte[], byte[]>> hscan(final byte[] key, final byte[] cursor,
      final ScanParams params) {
    checkIsInMulti();
    client.hscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<Map.Entry<byte[], byte[]>> results = new ArrayList<Map.Entry<byte[], byte[]>>();
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    Iterator<byte[]> iterator = rawResults.iterator();
    while (iterator.hasNext()) {
      results.add(new AbstractMap.SimpleEntry<byte[], byte[]>(iterator.next(), iterator.next()));
    }
    return new ScanResult<Map.Entry<byte[], byte[]>>(newcursor, results);
  }

  public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor) {
    return sscan(key, cursor, new ScanParams());
  }

  public ScanResult<byte[]> sscan(final byte[] key, final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.sscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    return new ScanResult<byte[]>(newcursor, rawResults);
  }

  public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor) {
    return zscan(key, cursor, new ScanParams());
  }

  public ScanResult<Tuple> zscan(final byte[] key, final byte[] cursor, final ScanParams params) {
    checkIsInMulti();
    client.zscan(key, cursor, params);
    List<Object> result = client.getObjectMultiBulkReply();
    byte[] newcursor = (byte[]) result.get(0);
    List<Tuple> results = new ArrayList<Tuple>();
    List<byte[]> rawResults = (List<byte[]>) result.get(1);
    Iterator<byte[]> iterator = rawResults.iterator();
    while (iterator.hasNext()) {
      results.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
    public Response<Long> append(String key, String value) {
	getClient(key).append(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> append(byte[] key, byte[] value) {
	getClient(key).append(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> blpop(String key) {
	String[] temp = new String[1];
	temp[0] = key;
	getClient(key).blpop(temp);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(String key) {
	String[] temp = new String[1];
	temp[0] = key;
	getClient(key).brpop(temp);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> blpop(byte[] key) {
	byte[][] temp = new byte[1][];
	temp[0] = key;
	getClient(key).blpop(temp);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<byte[]>> brpop(byte[] key) {
	byte[][] temp = new byte[1][];
	temp[0] = key;
	getClient(key).brpop(temp);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> decr(String key) {
	getClient(key).decr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decr(byte[] key) {
	getClient(key).decr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(String key, long integer) {
	getClient(key).decrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> decrBy(byte[] key, long integer) {
	getClient(key).decrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(String key) {
	getClient(key).del(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[] key) {
	getClient(key).del(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> echo(String string) {
	getClient(string).echo(string);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> echo(byte[] string) {
	getClient(string).echo(string);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> exists(String key) {
	getClient(key).exists(key);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> exists(byte[] key) {
	getClient(key).exists(key);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Long> expire(String key, int seconds) {
	getClient(key).expire(key, seconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expire(byte[] key, int seconds) {
	getClient(key).expire(key, seconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(String key, long unixTime) {
	getClient(key).expireAt(key, unixTime);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> expireAt(byte[] key, long unixTime) {
	getClient(key).expireAt(key, unixTime);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> get(String key) {
	getClient(key).get(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> get(byte[] key) {
	getClient(key).get(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Boolean> getbit(String key, long offset) {
	getClient(key).getbit(key, offset);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> getbit(byte[] key, long offset) {
	getClient(key).getbit(key, offset);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> getrange(String key, long startOffset,
	    long endOffset) {
	getClient(key).getrange(key, startOffset, endOffset);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> getSet(String key, String value) {
	getClient(key).getSet(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> getSet(byte[] key, byte[] value) {
	getClient(key).getSet(key, value);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> getrange(byte[] key, long startOffset, long endOffset) {
	getClient(key).getrange(key, startOffset, endOffset);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(String key, String... field) {
	getClient(key).hdel(key, field);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hdel(byte[] key, byte[]... field) {
	getClient(key).hdel(key, field);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> hexists(String key, String field) {
	getClient(key).hexists(key, field);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> hexists(byte[] key, byte[] field) {
	getClient(key).hexists(key, field);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> hget(String key, String field) {
	getClient(key).hget(key, field);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> hget(byte[] key, byte[] field) {
	getClient(key).hget(key, field);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Map<String, String>> hgetAll(String key) {
	getClient(key).hgetAll(key);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<Map<byte[], byte[]>> hgetAll(byte[] key) {
	getClient(key).hgetAll(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_MAP);
    }

    public Response<Long> hincrBy(String key, String field, long value) {
	getClient(key).hincrBy(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
	getClient(key).hincrBy(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> hkeys(String key) {
	getClient(key).hkeys(key);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> hkeys(byte[] key) {
	getClient(key).hkeys(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> hlen(String key) {
	getClient(key).hlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hlen(byte[] key) {
	getClient(key).hlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hmget(String key, String... fields) {
	getClient(key).hmget(key, fields);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> hmget(byte[] key, byte[]... fields) {
	getClient(key).hmget(key, fields);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> hmset(String key, Map<String, String> hash) {
	getClient(key).hmset(key, hash);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
	getClient(key).hmset(key, hash);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> hset(String key, String field, String value) {
	getClient(key).hset(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
	getClient(key).hset(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(String key, String field, String value) {
	getClient(key).hsetnx(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
	getClient(key).hsetnx(key, field, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> hvals(String key) {
	getClient(key).hvals(key);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> hvals(byte[] key) {
	getClient(key).hvals(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> incr(String key) {
	getClient(key).incr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incr(byte[] key) {
	getClient(key).incr(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(String key, long integer) {
	getClient(key).incrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> incrBy(byte[] key, long integer) {
	getClient(key).incrBy(key, integer);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lindex(String key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> lindex(byte[] key, long index) {
	getClient(key).lindex(key, index);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> linsert(String key, LIST_POSITION where,
	    String pivot, String value) {
	getClient(key).linsert(key, where, pivot, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> linsert(byte[] key, LIST_POSITION where,
	    byte[] pivot, byte[] value) {
	getClient(key).linsert(key, where, pivot, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(String key) {
	getClient(key).llen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> llen(byte[] key) {
	getClient(key).llen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lpop(String key) {
	getClient(key).lpop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> lpop(byte[] key) {
	getClient(key).lpop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> lpush(String key, String... string) {
	getClient(key).lpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpush(byte[] key, byte[]... string) {
	getClient(key).lpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(String key, String... string) {
	getClient(key).lpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lpushx(byte[] key, byte[]... bytes) {
	getClient(key).lpushx(key, bytes);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<List<String>> lrange(String key, long start, long end) {
	getClient(key).lrange(key, start, end);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> lrange(byte[] key, long start, long end) {
	getClient(key).lrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> lrem(String key, long count, String value) {
	getClient(key).lrem(key, count, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> lrem(byte[] key, long count, byte[] value) {
	getClient(key).lrem(key, count, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> lset(String key, long index, String value) {
	getClient(key).lset(key, index, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> lset(byte[] key, long index, byte[] value) {
	getClient(key).lset(key, index, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(String key, long start, long end) {
	getClient(key).ltrim(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ltrim(byte[] key, long start, long end) {
	getClient(key).ltrim(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> move(String key, int dbIndex) {
	getClient(key).move(key, dbIndex);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> move(byte[] key, int dbIndex) {
	getClient(key).move(key, dbIndex);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(String key) {
	getClient(key).persist(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> persist(byte[] key) {
	getClient(key).persist(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpop(String key) {
	getClient(key).rpop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpop(byte[] key) {
	getClient(key).rpop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> rpush(String key, String... string) {
	getClient(key).rpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpush(byte[] key, byte[]... string) {
	getClient(key).rpush(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(String key, String... string) {
	getClient(key).rpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> rpushx(byte[] key, byte[]... string) {
	getClient(key).rpushx(key, string);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(String key, String... member) {
	getClient(key).sadd(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sadd(byte[] key, byte[]... member) {
	getClient(key).sadd(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(String key) {
	getClient(key).scard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> scard(byte[] key) {
	getClient(key).scard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> set(String key, String value) {
	getClient(key).set(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value) {
	getClient(key).set(key, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Boolean> setbit(String key, long offset, boolean value) {
	getClient(key).setbit(key, offset, value);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> setbit(byte[] key, long offset, byte[] value) {
	getClient(key).setbit(key, offset, value);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<String> setex(String key, int seconds, String value) {
	getClient(key).setex(key, seconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> setex(byte[] key, int seconds, byte[] value) {
	getClient(key).setex(key, seconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> setnx(String key, String value) {
	getClient(key).setnx(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setnx(byte[] key, byte[] value) {
	getClient(key).setnx(key, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(String key, long offset, String value) {
	getClient(key).setrange(key, offset, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> setrange(byte[] key, long offset, byte[] value) {
	getClient(key).setrange(key, offset, value);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Boolean> sismember(String key, String member) {
	getClient(key).sismember(key, member);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Boolean> sismember(byte[] key, byte[] member) {
	getClient(key).sismember(key, member);
	return getResponse(BuilderFactory.BOOLEAN);
    }

    public Response<Set<String>> smembers(String key) {
	getClient(key).smembers(key);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> smembers(byte[] key) {
	getClient(key).smembers(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> sort(String key) {
	getClient(key).sort(key);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> sort(byte[] key) {
	getClient(key).sort(key);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> sort(String key,
	    SortingParams sortingParameters) {
	getClient(key).sort(key, sortingParameters);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> sort(byte[] key,
	    SortingParams sortingParameters) {
	getClient(key).sort(key, sortingParameters);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> spop(String key) {
	getClient(key).spop(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> spop(byte[] key) {
	getClient(key).spop(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> srandmember(String key) {
	getClient(key).srandmember(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> srandmember(String key, int count) {
	getClient(key).srandmember(key, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<byte[]> srandmember(byte[] key) {
	getClient(key).srandmember(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<List<byte[]>> srandmember(byte[] key, int count) {
	getClient(key).srandmember(key, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<Long> srem(String key, String... member) {
	getClient(key).srem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> srem(byte[] key, byte[]... member) {
	getClient(key).srem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(String key) {
	getClient(key).strlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> strlen(byte[] key) {
	getClient(key).strlen(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> substr(String key, int start, int end) {
	getClient(key).substr(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> substr(byte[] key, int start, int end) {
	getClient(key).substr(key, start, end);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> ttl(String key) {
	getClient(key).ttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> ttl(byte[] key) {
	getClient(key).ttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> type(String key) {
	getClient(key).type(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> type(byte[] key) {
	getClient(key).type(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zadd(String key, double score, String member) {
	getClient(key).zadd(key, score, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(String key, Map<String, Double> scoreMembers) {
	getClient(key).zadd(key, scoreMembers);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zadd(byte[] key, double score, byte[] member) {
	getClient(key).zadd(key, score, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(String key) {
	getClient(key).zcard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcard(byte[] key) {
	getClient(key).zcard(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, double min, double max) {
	getClient(key).zcount(key, min, max);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(String key, String min, String max) {
	getClient(key).zcount(key, min, max);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zcount(byte[] key, double min, double max) {
	getClient(key).zcount(key, toByteArray(min), toByteArray(max));
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zincrby(String key, double score, String member) {
	getClient(key).zincrby(key, score, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zincrby(byte[] key, double score, byte[] member) {
	getClient(key).zincrby(key, score, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Set<String>> zrange(String key, long start, long end) {
	getClient(key).zrange(key, start, end);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrange(byte[] key, long start, long end) {
	getClient(key).zrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
	    double max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, double min,
	    double max) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max));
    }

    public Response<Set<String>> zrangeByScore(String key, String min,
	    String max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min,
	    byte[] max) {
	getClient(key).zrangeByScore(key, min, max);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrangeByScore(String key, String min,
	    String max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, double min,
	    double max, int offset, int count) {
	return zrangeByScore(key, toByteArray(min), toByteArray(max), offset,
		count);
    }

    public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min,
	    byte[] max, int offset, int count) {
	getClient(key).zrangeByScore(key, min, max, offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
	    double max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min,
	    String max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
	    double max) {
	return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
	    byte[] max) {
	getClient(key).zrangeByScoreWithScores(key, min, max);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min,
	    String max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min,
	    double max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, toByteArray(min),
		toByteArray(max), offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min,
	    byte[] max, int offset, int count) {
	getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
	    double min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max,
	    double min) {
	getClient(key)
		.zrevrangeByScore(key, toByteArray(max), toByteArray(min));
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
	    String min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max,
	    byte[] min) {
	getClient(key).zrevrangeByScore(key, max, min);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, double max,
	    double min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<String>> zrevrangeByScore(String key, String max,
	    String min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max,
	    double min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, toByteArray(max),
		toByteArray(min), offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max,
	    byte[] min, int offset, int count) {
	getClient(key).zrevrangeByScore(key, max, min, offset, count);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    double max, double min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    String max, String min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    double max, double min) {
	getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min));
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    byte[] max, byte[] min) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    double max, double min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key,
	    String max, String min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    double max, double min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max),
		toByteArray(min), offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key,
	    byte[] max, byte[] min, int offset, int count) {
	getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Set<Tuple>> zrangeWithScores(String key, long start,
	    long end) {
	getClient(key).zrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrangeWithScores(byte[] key, long start,
	    long end) {
	getClient(key).zrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
    }

    public Response<Long> zrank(String key, String member) {
	getClient(key).zrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrank(byte[] key, byte[] member) {
	getClient(key).zrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(String key, String... member) {
	getClient(key).zrem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrem(byte[] key, byte[]... member) {
	getClient(key).zrem(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(String key, long start, long end) {
	getClient(key).zremrangeByRank(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByRank(byte[] key, long start, long end) {
	getClient(key).zremrangeByRank(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, double start, double end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(String key, String start, String end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
	getClient(key).zremrangeByScore(key, toByteArray(start),
		toByteArray(end));
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
	getClient(key).zremrangeByScore(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> zrevrange(String key, long start, long end) {
	getClient(key).zrevrange(key, start, end);
	return getResponse(BuilderFactory.STRING_ZSET);
    }

    public Response<Set<byte[]>> zrevrange(byte[] key, long start, long end) {
	getClient(key).zrevrange(key, start, end);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(String key, long start,
	    long end) {
	getClient(key).zrevrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start,
	    long end) {
	getClient(key).zrevrangeWithScores(key, start, end);
	return getResponse(BuilderFactory.TUPLE_ZSET);
    }

    public Response<Long> zrevrank(String key, String member) {
	getClient(key).zrevrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zrevrank(byte[] key, byte[] member) {
	getClient(key).zrevrank(key, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Double> zscore(String key, String member) {
	getClient(key).zscore(key, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> zscore(byte[] key, byte[] member) {
	getClient(key).zscore(key, member);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Long> bitcount(String key) {
	getClient(key).bitcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(String key, long start, long end) {
	getClient(key).bitcount(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(byte[] key) {
	getClient(key).bitcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitcount(byte[] key, long start, long end) {
	getClient(key).bitcount(key, start, end);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<byte[]> dump(String key) {
	getClient(key).dump(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<byte[]> dump(byte[] key) {
	getClient(key).dump(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> migrate(String host, int port, String key,
	    int destinationDb, int timeout) {
	getClient(key).migrate(host, port, key, destinationDb, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> migrate(byte[] host, int port, byte[] key,
	    int destinationDb, int timeout) {
	getClient(key).migrate(host, port, key, destinationDb, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> objectRefcount(String key) {
	getClient(key).objectRefcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> objectRefcount(byte[] key) {
	getClient(key).objectRefcount(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> objectEncoding(String key) {
	getClient(key).objectEncoding(key);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> objectEncoding(byte[] key) {
	getClient(key).objectEncoding(key);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Long> objectIdletime(String key) {
	getClient(key).objectIdletime(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> objectIdletime(byte[] key) {
	getClient(key).objectIdletime(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpire(String key, int milliseconds) {
	getClient(key).pexpire(key, milliseconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpire(byte[] key, int milliseconds) {
	getClient(key).pexpire(key, milliseconds);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpireAt(String key, long millisecondsTimestamp) {
	getClient(key).pexpireAt(key, millisecondsTimestamp);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp) {
	getClient(key).pexpireAt(key, millisecondsTimestamp);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pttl(String key) {
	getClient(key).pttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> pttl(byte[] key) {
	getClient(key).pttl(key);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> restore(String key, int ttl, byte[] serializedValue) {
	getClient(key).restore(key, ttl, serializedValue);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> restore(byte[] key, int ttl, byte[] serializedValue) {
	getClient(key).restore(key, ttl, serializedValue);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Double> incrByFloat(String key, double increment) {
	getClient(key).incrByFloat(key, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> incrByFloat(byte[] key, double increment) {
	getClient(key).incrByFloat(key, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<String> psetex(String key, int milliseconds, String value) {
	getClient(key).psetex(key, milliseconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> psetex(byte[] key, int milliseconds, byte[] value) {
	getClient(key).psetex(key, milliseconds, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(String key, String value, String nxxx) {
	getClient(key).set(key, value, nxxx);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value, byte[] nxxx) {
	getClient(key).set(key, value, nxxx);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(String key, String value, String nxxx,
	    String expx, int time) {
	getClient(key).set(key, value, nxxx, expx, time);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> set(byte[] key, byte[] value, byte[] nxxx,
	    byte[] expx, int time) {
	getClient(key).set(key, value, nxxx, expx, time);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Double> hincrByFloat(String key, String field,
	    double increment) {
	getClient(key).hincrByFloat(key, field, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

    public Response<Double> hincrByFloat(byte[] key, byte[] field,
	    double increment) {
	getClient(key).hincrByFloat(key, field, increment);
	return getResponse(BuilderFactory.DOUBLE);
    }

=======
  public Response<Long> append(String key, String value) {
    getClient(key).append(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> append(byte[] key, byte[] value) {
    getClient(key).append(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> blpop(String key) {
    String[] temp = new String[1];
    temp[0] = key;
    getClient(key).blpop(temp);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(String key) {
    String[] temp = new String[1];
    temp[0] = key;
    getClient(key).brpop(temp);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> blpop(byte[] key) {
    byte[][] temp = new byte[1][];
    temp[0] = key;
    getClient(key).blpop(temp);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<byte[]>> brpop(byte[] key) {
    byte[][] temp = new byte[1][];
    temp[0] = key;
    getClient(key).brpop(temp);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> decr(String key) {
    getClient(key).decr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> decr(byte[] key) {
    getClient(key).decr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> decrBy(String key, long integer) {
    getClient(key).decrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> decrBy(byte[] key, long integer) {
    getClient(key).decrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(String key) {
    getClient(key).del(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[] key) {
    getClient(key).del(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> echo(String string) {
    getClient(string).echo(string);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> echo(byte[] string) {
    getClient(string).echo(string);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Boolean> exists(String key) {
    getClient(key).exists(key);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> exists(byte[] key) {
    getClient(key).exists(key);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Long> expire(String key, int seconds) {
    getClient(key).expire(key, seconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> expire(byte[] key, int seconds) {
    getClient(key).expire(key, seconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> expireAt(String key, long unixTime) {
    getClient(key).expireAt(key, unixTime);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> expireAt(byte[] key, long unixTime) {
    getClient(key).expireAt(key, unixTime);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> get(String key) {
    getClient(key).get(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> get(byte[] key) {
    getClient(key).get(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Boolean> getbit(String key, long offset) {
    getClient(key).getbit(key, offset);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> getbit(byte[] key, long offset) {
    getClient(key).getbit(key, offset);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Long> bitpos(final String key, final boolean value) {
    return bitpos(key, value, new BitPosParams());
  }

  public Response<Long> bitpos(final String key, final boolean value, final BitPosParams params) {
    getClient(key).bitpos(key, value, params);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitpos(final byte[] key, final boolean value) {
    return bitpos(key, value, new BitPosParams());
  }

  public Response<Long> bitpos(final byte[] key, final boolean value, final BitPosParams params) {
    getClient(key).bitpos(key, value, params);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> getrange(String key, long startOffset, long endOffset) {
    getClient(key).getrange(key, startOffset, endOffset);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> getSet(String key, String value) {
    getClient(key).getSet(key, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> getSet(byte[] key, byte[] value) {
    getClient(key).getSet(key, value);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<byte[]> getrange(byte[] key, long startOffset, long endOffset) {
    getClient(key).getrange(key, startOffset, endOffset);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> hdel(String key, String... field) {
    getClient(key).hdel(key, field);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hdel(byte[] key, byte[]... field) {
    getClient(key).hdel(key, field);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Boolean> hexists(String key, String field) {
    getClient(key).hexists(key, field);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> hexists(byte[] key, byte[] field) {
    getClient(key).hexists(key, field);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<String> hget(String key, String field) {
    getClient(key).hget(key, field);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> hget(byte[] key, byte[] field) {
    getClient(key).hget(key, field);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Map<String, String>> hgetAll(String key) {
    getClient(key).hgetAll(key);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<Map<byte[], byte[]>> hgetAll(byte[] key) {
    getClient(key).hgetAll(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_MAP);
  }

  public Response<Long> hincrBy(String key, String field, long value) {
    getClient(key).hincrBy(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hincrBy(byte[] key, byte[] field, long value) {
    getClient(key).hincrBy(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> hkeys(String key) {
    getClient(key).hkeys(key);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> hkeys(byte[] key) {
    getClient(key).hkeys(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> hlen(String key) {
    getClient(key).hlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hlen(byte[] key) {
    getClient(key).hlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> hmget(String key, String... fields) {
    getClient(key).hmget(key, fields);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> hmget(byte[] key, byte[]... fields) {
    getClient(key).hmget(key, fields);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> hmset(String key, Map<String, String> hash) {
    getClient(key).hmset(key, hash);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> hmset(byte[] key, Map<byte[], byte[]> hash) {
    getClient(key).hmset(key, hash);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> hset(String key, String field, String value) {
    getClient(key).hset(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hset(byte[] key, byte[] field, byte[] value) {
    getClient(key).hset(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hsetnx(String key, String field, String value) {
    getClient(key).hsetnx(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> hsetnx(byte[] key, byte[] field, byte[] value) {
    getClient(key).hsetnx(key, field, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> hvals(String key) {
    getClient(key).hvals(key);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> hvals(byte[] key) {
    getClient(key).hvals(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> incr(String key) {
    getClient(key).incr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> incr(byte[] key) {
    getClient(key).incr(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> incrBy(String key, long integer) {
    getClient(key).incrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> incrBy(byte[] key, long integer) {
    getClient(key).incrBy(key, integer);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> lindex(String key, long index) {
    getClient(key).lindex(key, index);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> lindex(byte[] key, long index) {
    getClient(key).lindex(key, index);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> linsert(String key, LIST_POSITION where, String pivot, String value) {
    getClient(key).linsert(key, where, pivot, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> linsert(byte[] key, LIST_POSITION where, byte[] pivot, byte[] value) {
    getClient(key).linsert(key, where, pivot, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> llen(String key) {
    getClient(key).llen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> llen(byte[] key) {
    getClient(key).llen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> lpop(String key) {
    getClient(key).lpop(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> lpop(byte[] key) {
    getClient(key).lpop(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> lpush(String key, String... string) {
    getClient(key).lpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lpush(byte[] key, byte[]... string) {
    getClient(key).lpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lpushx(String key, String... string) {
    getClient(key).lpushx(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lpushx(byte[] key, byte[]... bytes) {
    getClient(key).lpushx(key, bytes);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<List<String>> lrange(String key, long start, long end) {
    getClient(key).lrange(key, start, end);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> lrange(byte[] key, long start, long end) {
    getClient(key).lrange(key, start, end);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> lrem(String key, long count, String value) {
    getClient(key).lrem(key, count, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> lrem(byte[] key, long count, byte[] value) {
    getClient(key).lrem(key, count, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> lset(String key, long index, String value) {
    getClient(key).lset(key, index, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> lset(byte[] key, long index, byte[] value) {
    getClient(key).lset(key, index, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ltrim(String key, long start, long end) {
    getClient(key).ltrim(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ltrim(byte[] key, long start, long end) {
    getClient(key).ltrim(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> move(String key, int dbIndex) {
    getClient(key).move(key, dbIndex);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> move(byte[] key, int dbIndex) {
    getClient(key).move(key, dbIndex);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> persist(String key) {
    getClient(key).persist(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> persist(byte[] key) {
    getClient(key).persist(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpop(String key) {
    getClient(key).rpop(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpop(byte[] key) {
    getClient(key).rpop(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> rpush(String key, String... string) {
    getClient(key).rpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> rpush(byte[] key, byte[]... string) {
    getClient(key).rpush(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> rpushx(String key, String... string) {
    getClient(key).rpushx(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> rpushx(byte[] key, byte[]... string) {
    getClient(key).rpushx(key, string);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sadd(String key, String... member) {
    getClient(key).sadd(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sadd(byte[] key, byte[]... member) {
    getClient(key).sadd(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> scard(String key) {
    getClient(key).scard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> scard(byte[] key) {
    getClient(key).scard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> set(String key, String value) {
    getClient(key).set(key, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(byte[] key, byte[] value) {
    getClient(key).set(key, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Boolean> setbit(String key, long offset, boolean value) {
    getClient(key).setbit(key, offset, value);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> setbit(byte[] key, long offset, byte[] value) {
    getClient(key).setbit(key, offset, value);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<String> setex(String key, int seconds, String value) {
    getClient(key).setex(key, seconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> setex(byte[] key, int seconds, byte[] value) {
    getClient(key).setex(key, seconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> setnx(String key, String value) {
    getClient(key).setnx(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> setnx(byte[] key, byte[] value) {
    getClient(key).setnx(key, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> setrange(String key, long offset, String value) {
    getClient(key).setrange(key, offset, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> setrange(byte[] key, long offset, byte[] value) {
    getClient(key).setrange(key, offset, value);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Boolean> sismember(String key, String member) {
    getClient(key).sismember(key, member);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Boolean> sismember(byte[] key, byte[] member) {
    getClient(key).sismember(key, member);
    return getResponse(BuilderFactory.BOOLEAN);
  }

  public Response<Set<String>> smembers(String key) {
    getClient(key).smembers(key);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> smembers(byte[] key) {
    getClient(key).smembers(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> sort(String key) {
    getClient(key).sort(key);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> sort(byte[] key) {
    getClient(key).sort(key);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> sort(String key, SortingParams sortingParameters) {
    getClient(key).sort(key, sortingParameters);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> sort(byte[] key, SortingParams sortingParameters) {
    getClient(key).sort(key, sortingParameters);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> spop(String key) {
    getClient(key).spop(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> spop(byte[] key) {
    getClient(key).spop(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> srandmember(String key) {
    getClient(key).srandmember(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> srandmember(String key, int count) {
    getClient(key).srandmember(key, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<byte[]> srandmember(byte[] key) {
    getClient(key).srandmember(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<List<byte[]>> srandmember(byte[] key, int count) {
    getClient(key).srandmember(key, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<Long> srem(String key, String... member) {
    getClient(key).srem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> srem(byte[] key, byte[]... member) {
    getClient(key).srem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> strlen(String key) {
    getClient(key).strlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> strlen(byte[] key) {
    getClient(key).strlen(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> substr(String key, int start, int end) {
    getClient(key).substr(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> substr(byte[] key, int start, int end) {
    getClient(key).substr(key, start, end);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> ttl(String key) {
    getClient(key).ttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> ttl(byte[] key) {
    getClient(key).ttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> type(String key) {
    getClient(key).type(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> type(byte[] key) {
    getClient(key).type(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zadd(String key, double score, String member) {
    getClient(key).zadd(key, score, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zadd(String key, Map<String, Double> scoreMembers) {
    getClient(key).zadd(key, scoreMembers);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zadd(byte[] key, double score, byte[] member) {
    getClient(key).zadd(key, score, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcard(String key) {
    getClient(key).zcard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcard(byte[] key) {
    getClient(key).zcard(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcount(String key, double min, double max) {
    getClient(key).zcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcount(String key, String min, String max) {
    getClient(key).zcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zcount(byte[] key, double min, double max) {
    getClient(key).zcount(key, toByteArray(min), toByteArray(max));
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Double> zincrby(String key, double score, String member) {
    getClient(key).zincrby(key, score, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> zincrby(byte[] key, double score, byte[] member) {
    getClient(key).zincrby(key, score, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Set<String>> zrange(String key, long start, long end) {
    getClient(key).zrange(key, start, end);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrange(byte[] key, long start, long end) {
    getClient(key).zrange(key, start, end);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrangeByScore(String key, double min, double max) {
    getClient(key).zrangeByScore(key, min, max);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max));
  }

  public Response<Set<String>> zrangeByScore(String key, String min, String max) {
    getClient(key).zrangeByScore(key, min, max);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max) {
    getClient(key).zrangeByScore(key, min, max);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrangeByScore(String key, double min, double max, int offset,
      int count) {
    getClient(key).zrangeByScore(key, min, max, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<String>> zrangeByScore(String key, String min, String max, int offset,
      int count) {
    getClient(key).zrangeByScore(key, min, max, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset,
      int count) {
    return zrangeByScore(key, toByteArray(min), toByteArray(max), offset, count);
  }

  public Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset,
      int count) {
    getClient(key).zrangeByScore(key, min, max, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max) {
    getClient(key).zrangeByScoreWithScores(key, min, max);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min, String max) {
    getClient(key).zrangeByScoreWithScores(key, min, max);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max) {
    return zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max));
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max) {
    getClient(key).zrangeByScoreWithScores(key, min, max);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, double min, double max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(String key, String min, String max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, toByteArray(min), toByteArray(max), offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max,
      int offset, int count) {
    getClient(key).zrangeByScoreWithScores(key, min, max, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<String>> zrevrangeByScore(String key, double max, double min) {
    getClient(key).zrevrangeByScore(key, max, min);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min) {
    getClient(key).zrevrangeByScore(key, toByteArray(max), toByteArray(min));
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrevrangeByScore(String key, String max, String min) {
    getClient(key).zrevrangeByScore(key, max, min);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min) {
    getClient(key).zrevrangeByScore(key, max, min);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<String>> zrevrangeByScore(String key, double max, double min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, max, min, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<String>> zrevrangeByScore(String key, String max, String min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, max, min, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, toByteArray(max), toByteArray(min), offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset,
      int count) {
    getClient(key).zrevrangeByScore(key, max, min, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min) {
    getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min));
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, double max, double min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(String key, String max, String min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, toByteArray(max), toByteArray(min), offset,
      count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min,
      int offset, int count) {
    getClient(key).zrevrangeByScoreWithScores(key, max, min, offset, count);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Set<Tuple>> zrangeWithScores(String key, long start, long end) {
    getClient(key).zrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrangeWithScores(byte[] key, long start, long end) {
    getClient(key).zrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET_BINARY);
  }

  public Response<Long> zrank(String key, String member) {
    getClient(key).zrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrank(byte[] key, byte[] member) {
    getClient(key).zrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrem(String key, String... member) {
    getClient(key).zrem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrem(byte[] key, byte[]... member) {
    getClient(key).zrem(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByRank(String key, long start, long end) {
    getClient(key).zremrangeByRank(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByRank(byte[] key, long start, long end) {
    getClient(key).zremrangeByRank(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(String key, double start, double end) {
    getClient(key).zremrangeByScore(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(String key, String start, String end) {
    getClient(key).zremrangeByScore(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(byte[] key, double start, double end) {
    getClient(key).zremrangeByScore(key, toByteArray(start), toByteArray(end));
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end) {
    getClient(key).zremrangeByScore(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> zrevrange(String key, long start, long end) {
    getClient(key).zrevrange(key, start, end);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  public Response<Set<byte[]>> zrevrange(byte[] key, long start, long end) {
    getClient(key).zrevrange(key, start, end);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeWithScores(String key, long start, long end) {
    getClient(key).zrevrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start, long end) {
    getClient(key).zrevrangeWithScores(key, start, end);
    return getResponse(BuilderFactory.TUPLE_ZSET);
  }

  public Response<Long> zrevrank(String key, String member) {
    getClient(key).zrevrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zrevrank(byte[] key, byte[] member) {
    getClient(key).zrevrank(key, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Double> zscore(String key, String member) {
    getClient(key).zscore(key, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> zscore(byte[] key, byte[] member) {
    getClient(key).zscore(key, member);
    return getResponse(BuilderFactory.DOUBLE);
  }

  @Override
  public Response<Long> zlexcount(final byte[] key, final byte[] min, final byte[] max) {
    getClient(key).zlexcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> zlexcount(final String key, final String min, final String max) {
    getClient(key).zlexcount(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    getClient(key).zrangeByLex(key, min, max);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrangeByLex(final String key, final String min, final String max) {
    getClient(key).zrangeByLex(key, min, max);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      final int offset, final int count) {
    getClient(key).zrangeByLex(key, min, max, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrangeByLex(final String key, final String min, final String max,
      final int offset, final int count) {
    getClient(key).zrangeByLex(key, min, max, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min) {
    getClient(key).zrevrangeByLex(key, max, min);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrevrangeByLex(final String key, final String max, final String min) {
    getClient(key).zrevrangeByLex(key, max, min);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
      final int offset, final int count) {
    getClient(key).zrevrangeByLex(key, max, min, offset, count);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  @Override
  public Response<Set<String>> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count) {
    getClient(key).zrevrangeByLex(key, max, min, offset, count);
    return getResponse(BuilderFactory.STRING_ZSET);
  }

  @Override
  public Response<Long> zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
    getClient(key).zremrangeByLex(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> zremrangeByLex(final String key, final String min, final String max) {
    getClient(key).zremrangeByLex(key, min, max);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(String key) {
    getClient(key).bitcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(String key, long start, long end) {
    getClient(key).bitcount(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(byte[] key) {
    getClient(key).bitcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitcount(byte[] key, long start, long end) {
    getClient(key).bitcount(key, start, end);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<byte[]> dump(String key) {
    getClient(key).dump(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<byte[]> dump(byte[] key) {
    getClient(key).dump(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> migrate(String host, int port, String key, int destinationDb, int timeout) {
    getClient(key).migrate(host, port, key, destinationDb, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> migrate(byte[] host, int port, byte[] key, int destinationDb, int timeout) {
    getClient(key).migrate(host, port, key, destinationDb, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> objectRefcount(String key) {
    getClient(key).objectRefcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> objectRefcount(byte[] key) {
    getClient(key).objectRefcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> objectEncoding(String key) {
    getClient(key).objectEncoding(key);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> objectEncoding(byte[] key) {
    getClient(key).objectEncoding(key);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Long> objectIdletime(String key) {
    getClient(key).objectIdletime(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> objectIdletime(byte[] key) {
    getClient(key).objectIdletime(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpire(String key, long milliseconds) {
    getClient(key).pexpire(key, milliseconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpire(byte[] key, long milliseconds) {
    getClient(key).pexpire(key, milliseconds);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpireAt(String key, long millisecondsTimestamp) {
    getClient(key).pexpireAt(key, millisecondsTimestamp);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp) {
    getClient(key).pexpireAt(key, millisecondsTimestamp);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pttl(String key) {
    getClient(key).pttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> pttl(byte[] key) {
    getClient(key).pttl(key);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> restore(String key, int ttl, byte[] serializedValue) {
    getClient(key).restore(key, ttl, serializedValue);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> restore(byte[] key, int ttl, byte[] serializedValue) {
    getClient(key).restore(key, ttl, serializedValue);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Double> incrByFloat(String key, double increment) {
    getClient(key).incrByFloat(key, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> incrByFloat(byte[] key, double increment) {
    getClient(key).incrByFloat(key, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<String> psetex(String key, int milliseconds, String value) {
    getClient(key).psetex(key, milliseconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> psetex(byte[] key, int milliseconds, byte[] value) {
    getClient(key).psetex(key, milliseconds, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(String key, String value, String nxxx) {
    getClient(key).set(key, value, nxxx);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(byte[] key, byte[] value, byte[] nxxx) {
    getClient(key).set(key, value, nxxx);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(String key, String value, String nxxx, String expx, int time) {
    getClient(key).set(key, value, nxxx, expx, time);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, int time) {
    getClient(key).set(key, value, nxxx, expx, time);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Double> hincrByFloat(String key, String field, double increment) {
    getClient(key).hincrByFloat(key, field, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<Double> hincrByFloat(byte[] key, byte[] field, double increment) {
    getClient(key).hincrByFloat(key, field, increment);
    return getResponse(BuilderFactory.DOUBLE);
  }

  public Response<String> eval(String script) {
    return this.eval(script, 0);
  }

  public Response<String> eval(String script, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<String> eval(String script, int numKeys, String... args) {
    getClient(script).eval(script, numKeys, args);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> evalsha(String script) {
    return this.evalsha(script, 0);
  }

  public Response<String> evalsha(String sha1, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<String> evalsha(String sha1, int numKeys, String... args) {
    getClient(sha1).evalsha(sha1, numKeys, args);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<Long> pfadd(byte[] key, byte[]... elements) {
    getClient(key).pfadd(key, elements);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(byte[] key) {
    getClient(key).pfcount(key);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfadd(String key, String... elements) {
    getClient(key).pfadd(key, elements);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(String key) {
    getClient(key).pfcount(key);
    return getResponse(BuilderFactory.LONG);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/BuilderFactory.java;<<<<<<< MINE
    public static final Builder<Double> DOUBLE = new Builder<Double>() {
	public Double build(Object data) {
	    String asString = STRING.build(data);
	    return asString == null ? null : Double.valueOf(asString);
	}

	public String toString() {
	    return "double";
	}
    };
    
    public static final Builder<Boolean> BOOLEAN = new Builder<Boolean>() {
	public Boolean build(Object data) {
	    return ((Long) data) == 1;
	}

	public String toString() {
	    return "boolean";
	}
    };
    
    public static final Builder<byte[]> BYTE_ARRAY = new Builder<byte[]>() {
	public byte[] build(Object data) {
	    return ((byte[]) data); // deleted == 1
	}

	public String toString() {
	    return "byte[]";
	}
    };

    public static final Builder<Long> LONG = new Builder<Long>() {
	public Long build(Object data) {
	    return (Long) data;
	}

	public String toString() {
	    return "long";
	}

    };
    
    public static final Builder<String> STRING = new Builder<String>() {
	public String build(Object data) {
	    return data == null ? null : SafeEncoder.encode((byte[]) data);
	}

	public String toString() {
	    return "string";
	}

    };
    
    public static final Builder<List<String>> STRING_LIST = new Builder<List<String>>() {
	@SuppressWarnings("unchecked")
	public List<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final ArrayList<String> result = new ArrayList<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "List<String>";
	}

    };
    
    public static final Builder<Map<String, String>> STRING_MAP = new Builder<Map<String, String>>() {
	@SuppressWarnings("unchecked")
	public Map<String, String> build(Object data) {
	    final List<byte[]> flatHash = (List<byte[]>) data;
	    final Map<String, String> hash = new HashMap<String, String>();
	    final Iterator<byte[]> iterator = flatHash.iterator();
	    while (iterator.hasNext()) {
		hash.put(SafeEncoder.encode(iterator.next()),
			SafeEncoder.encode(iterator.next()));
	    }

	    return hash;
	}

	public String toString() {
	    return "Map<String, String>";
	}

    };

    public static final Builder<Set<String>> STRING_SET = new Builder<Set<String>>() {
	@SuppressWarnings("unchecked")
	public Set<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<String> result = new HashSet<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "Set<String>";
	}

    };

    public static final Builder<List<byte[]>> BYTE_ARRAY_LIST = new Builder<List<byte[]>>() {
	@SuppressWarnings("unchecked")
	public List<byte[]> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;

	    return l;
	}

	public String toString() {
	    return "List<byte[]>";
	}
    };

    public static final Builder<Set<byte[]>> BYTE_ARRAY_ZSET = new Builder<Set<byte[]>>() {
	@SuppressWarnings("unchecked")
	public Set<byte[]> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<byte[]> result = new LinkedHashSet<byte[]>(l);
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(barray);
		}
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<byte[]>";
	}
    };
    
    public static final Builder<Map<byte[], byte[]>> BYTE_ARRAY_MAP = new Builder<Map<byte[], byte[]>>() {
	@SuppressWarnings("unchecked")
	public Map<byte[], byte[]> build(Object data) {
	    final List<byte[]> flatHash = (List<byte[]>) data;
	    final Map<byte[], byte[]> hash = new HashMap<byte[], byte[]>();
	    final Iterator<byte[]> iterator = flatHash.iterator();
	    while (iterator.hasNext()) {
		hash.put(iterator.next(), iterator.next());
	    }

	    return hash;
	}

	public String toString() {
	    return "Map<byte[], byte[]>";
	}

    };

    public static final Builder<Set<String>> STRING_ZSET = new Builder<Set<String>>() {
	@SuppressWarnings("unchecked")
	public Set<String> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<String> result = new LinkedHashSet<String>(l.size());
	    for (final byte[] barray : l) {
		if (barray == null) {
		    result.add(null);
		} else {
		    result.add(SafeEncoder.encode(barray));
		}
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<String>";
	}

    };

    public static final Builder<Set<Tuple>> TUPLE_ZSET = new Builder<Set<Tuple>>() {
	@SuppressWarnings("unchecked")
	public Set<Tuple> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
	    Iterator<byte[]> iterator = l.iterator();
	    while (iterator.hasNext()) {
		result.add(new Tuple(SafeEncoder.encode(iterator.next()),
			Double.valueOf(SafeEncoder.encode(iterator.next()))));
	    }
	    return result;
	}

	public String toString() {
	    return "ZSet<Tuple>";
	}

    };

    public static final Builder<Set<Tuple>> TUPLE_ZSET_BINARY = new Builder<Set<Tuple>>() {
	@SuppressWarnings("unchecked")
	public Set<Tuple> build(Object data) {
	    if (null == data) {
		return null;
	    }
	    List<byte[]> l = (List<byte[]>) data;
	    final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
	    Iterator<byte[]> iterator = l.iterator();
	    while (iterator.hasNext()) {
		result.add(new Tuple(iterator.next(), Double
			.valueOf(SafeEncoder.encode(iterator.next()))));
	    }

	    return result;

	}

	public String toString() {
	    return "ZSet<Tuple>";
	}
    };
=======
  public static final Builder<Double> DOUBLE = new Builder<Double>() {
    public Double build(Object data) {
      String asString = STRING.build(data);
      return asString == null ? null : Double.valueOf(asString);
    }

    public String toString() {
      return "double";
    }
  };
  public static final Builder<Boolean> BOOLEAN = new Builder<Boolean>() {
    public Boolean build(Object data) {
      return ((Long) data) == 1;
    }

    public String toString() {
      return "boolean";
    }
  };
  public static final Builder<byte[]> BYTE_ARRAY = new Builder<byte[]>() {
    public byte[] build(Object data) {
      return ((byte[]) data); // deleted == 1
    }

    public String toString() {
      return "byte[]";
    }
  };

  public static final Builder<Long> LONG = new Builder<Long>() {
    public Long build(Object data) {
      return (Long) data;
    }

    public String toString() {
      return "long";
    }

  };
  public static final Builder<String> STRING = new Builder<String>() {
    public String build(Object data) {
      return data == null ? null : SafeEncoder.encode((byte[]) data);
    }

    public String toString() {
      return "string";
    }

  };
  public static final Builder<List<String>> STRING_LIST = new Builder<List<String>>() {
    @SuppressWarnings("unchecked")
    public List<String> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final ArrayList<String> result = new ArrayList<String>(l.size());
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(SafeEncoder.encode(barray));
        }
      }
      return result;
    }

    public String toString() {
      return "List<String>";
    }

  };
  public static final Builder<Map<String, String>> STRING_MAP = new Builder<Map<String, String>>() {
    @SuppressWarnings("unchecked")
    public Map<String, String> build(Object data) {
      final List<byte[]> flatHash = (List<byte[]>) data;
      final Map<String, String> hash = new HashMap<String, String>();
      final Iterator<byte[]> iterator = flatHash.iterator();
      while (iterator.hasNext()) {
        hash.put(SafeEncoder.encode(iterator.next()), SafeEncoder.encode(iterator.next()));
      }

      return hash;
    }

    public String toString() {
      return "Map<String, String>";
    }

  };

  public static final Builder<Map<String, String>> PUBSUB_NUMSUB_MAP = new Builder<Map<String, String>>() {
    @SuppressWarnings("unchecked")
    public Map<String, String> build(Object data) {
      final List<Object> flatHash = (List<Object>) data;
      final Map<String, String> hash = new HashMap<String, String>();
      final Iterator<Object> iterator = flatHash.iterator();
      while (iterator.hasNext()) {
        hash.put(SafeEncoder.encode((byte[]) iterator.next()),
          String.valueOf((Long) iterator.next()));
      }

      return hash;
    }

    public String toString() {
      return "PUBSUB_NUMSUB_MAP<String, String>";
    }

  };

  public static final Builder<Set<String>> STRING_SET = new Builder<Set<String>>() {
    @SuppressWarnings("unchecked")
    public Set<String> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<String> result = new HashSet<String>(l.size());
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(SafeEncoder.encode(barray));
        }
      }
      return result;
    }

    public String toString() {
      return "Set<String>";
    }

  };

  public static final Builder<List<byte[]>> BYTE_ARRAY_LIST = new Builder<List<byte[]>>() {
    @SuppressWarnings("unchecked")
    public List<byte[]> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;

      return l;
    }

    public String toString() {
      return "List<byte[]>";
    }
  };

  public static final Builder<Set<byte[]>> BYTE_ARRAY_ZSET = new Builder<Set<byte[]>>() {
    @SuppressWarnings("unchecked")
    public Set<byte[]> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<byte[]> result = new LinkedHashSet<byte[]>(l);
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(barray);
        }
      }
      return result;
    }

    public String toString() {
      return "ZSet<byte[]>";
    }
  };
  public static final Builder<Map<byte[], byte[]>> BYTE_ARRAY_MAP = new Builder<Map<byte[], byte[]>>() {
    @SuppressWarnings("unchecked")
    public Map<byte[], byte[]> build(Object data) {
      final List<byte[]> flatHash = (List<byte[]>) data;
      final Map<byte[], byte[]> hash = new JedisByteHashMap();
      final Iterator<byte[]> iterator = flatHash.iterator();
      while (iterator.hasNext()) {
        hash.put(iterator.next(), iterator.next());
      }

      return hash;
    }

    public String toString() {
      return "Map<byte[], byte[]>";
    }

  };

  public static final Builder<Set<String>> STRING_ZSET = new Builder<Set<String>>() {
    @SuppressWarnings("unchecked")
    public Set<String> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<String> result = new LinkedHashSet<String>(l.size());
      for (final byte[] barray : l) {
        if (barray == null) {
          result.add(null);
        } else {
          result.add(SafeEncoder.encode(barray));
        }
      }
      return result;
    }

    public String toString() {
      return "ZSet<String>";
    }

  };

  public static final Builder<Set<Tuple>> TUPLE_ZSET = new Builder<Set<Tuple>>() {
    @SuppressWarnings("unchecked")
    public Set<Tuple> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
      Iterator<byte[]> iterator = l.iterator();
      while (iterator.hasNext()) {
        result.add(new Tuple(SafeEncoder.encode(iterator.next()), Double.valueOf(SafeEncoder
            .encode(iterator.next()))));
      }
      return result;
    }

    public String toString() {
      return "ZSet<Tuple>";
    }

  };

  public static final Builder<Set<Tuple>> TUPLE_ZSET_BINARY = new Builder<Set<Tuple>>() {
    @SuppressWarnings("unchecked")
    public Set<Tuple> build(Object data) {
      if (null == data) {
        return null;
      }
      List<byte[]> l = (List<byte[]>) data;
      final Set<Tuple> result = new LinkedHashSet<Tuple>(l.size());
      Iterator<byte[]> iterator = l.iterator();
      while (iterator.hasNext()) {
        result.add(new Tuple(iterator.next(), Double.valueOf(SafeEncoder.encode(iterator.next()))));
      }

      return result;

    }

    public String toString() {
      return "ZSet<Tuple>";
    }
  };
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/MultiKeyPipelineBase.java;<<<<<<< MINE
abstract class MultiKeyPipelineBase extends PipelineBase implements
	MultiKeyBinaryRedisPipeline, MultiKeyCommandsPipeline, 
	ClusterPipeline, BinaryScriptingCommandsPipeline, ScriptingCommandsPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }
    
    public Response<Object> eval(String script) {
	return this.eval(script, 0, new String[0]);
    }

    public Response<Object> eval(String script, List<String> keys,
	    List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.eval(script, keys.size(), argv);
    }
    
    public Response<Object> eval(String script, int keyCount, String... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_RESULT);
    }

    public Response<Object> evalsha(String script) {
	return this.evalsha(script, 0, new String[0]);
    }

    public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.evalsha(sha1, keys.size(), argv);
    }

    public Response<Object> evalsha(String sha1, int keyCount, String... params) {
	getClient(sha1).evalsha(sha1, keyCount, params);
	return getResponse(BuilderFactory.EVAL_RESULT);
    }

    public Response<Object> eval(byte[] script) {
	return this.eval(script, 0);
    }
    
    public Response<Object> eval(byte[] script, byte[] keyCount, byte[]... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
    
    public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
	return this.eval(script, keys.size(), argv);
    }
    
    public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
    
    public Response<Object> evalsha(byte[] sha1) {
	return this.evalsha(sha1, 0);
    }
    
    public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
	byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
	return this.evalsha(sha1, keys.size(), argv);
    }
    
    public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
	getClient(sha1).evalsha(sha1, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
=======
abstract class MultiKeyPipelineBase extends PipelineBase implements BasicRedisPipeline,
    MultiKeyBinaryRedisPipeline, MultiKeyCommandsPipeline, ClusterPipeline {

  protected Client client = null;

  public Response<List<String>> brpop(String... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(int timeout, String... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(String... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> brpop(byte[]... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> brpop(int timeout, byte[]... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> blpop(byte[]... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> blpop(int timeout, byte[]... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> del(String... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[]... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> keys(String pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> keys(byte[] pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> mget(String... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> mget(byte[]... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> mset(String... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> mset(byte[]... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> msetnx(String... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> msetnx(byte[]... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rename(String oldkey, String newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> rename(byte[] oldkey, byte[] newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> renamenx(String oldkey, String newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpoplpush(String srckey, String dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Set<String>> sdiff(String... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sdiff(byte[]... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sdiffstore(String dstkey, String... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sinter(String... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sinter(byte[]... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sinterstore(String dstkey, String... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(String srckey, String dstkey, String member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, SortingParams sortingParameters, String dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, String dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, byte[] dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sunion(String... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sunion(byte[]... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sunionstore(String dstkey, String... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> watch(String... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> watch(byte[]... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zinterstore(String dstkey, String... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(String dstkey, ZParams params, String... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, String... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, ZParams params, String... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> bgrewriteaof() {
    client.bgrewriteaof();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> bgsave() {
    client.bgsave();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> configGet(String pattern) {
    client.configGet(pattern);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> configSet(String parameter, String value) {
    client.configSet(parameter, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> brpoplpush(String source, String destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> configResetStat() {
    client.configResetStat();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> save() {
    client.save();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> lastsave() {
    client.lastsave();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(String channel, String message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> randomKey() {
    client.randomKey();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> randomKeyBinary() {
    client.randomKey();
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> flushDB() {
    client.flushDB();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> flushAll() {
    client.flushAll();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info() {
    client.info();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> time() {
    client.time();
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> dbSize() {
    client.dbSize();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> shutdown() {
    client.shutdown();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ping() {
    client.ping();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> select(int index) {
    client.select(index);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> clusterNodes() {
    client.clusterNodes();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterMeet(final String ip, final int port) {
    client.clusterMeet(ip, port);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterAddSlots(final int... slots) {
    client.clusterAddSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterDelSlots(final int... slots) {
    client.clusterDelSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterInfo() {
    client.clusterInfo();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> clusterGetKeysInSlot(final int slot, final int count) {
    client.clusterGetKeysInSlot(slot, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> clusterSetSlotNode(final int slot, final String nodeId) {
    client.clusterSetSlotNode(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotMigrating(final int slot, final String nodeId) {
    client.clusterSetSlotMigrating(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotImporting(final int slot, final String nodeId) {
    client.clusterSetSlotImporting(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(String destkey, String... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<Long> pfcount(String... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(final byte[]... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/test/java/redis/clients/jedis/tests/commands/ScriptingCommandsTest.java;<<<<<<< MINE
    @SuppressWarnings("unchecked")
    @Test
    public void evalMultiBulk() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");
	keys.add("key2");

	List<String> args = new ArrayList<String>();
	args.add("first");
	args.add("second");
	args.add("third");

	List<String> response = (List<String>) jedis.eval(script, keys, args);

	assertEquals(5, response.size());
	assertEquals("key1", response.get(0));
	assertEquals("key2", response.get(1));
	assertEquals("first", response.get(2));
	assertEquals("second", response.get(3));
	assertEquals("third", response.get(4));
    }

    @SuppressWarnings("unchecked")
    @Test
    public void evalMultiBulkWithBinaryJedis() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
	List<byte[]> keys = new ArrayList<byte[]>();
	keys.add("key1".getBytes());
	keys.add("key2".getBytes());

	List<byte[]> args = new ArrayList<byte[]>();
	args.add("first".getBytes());
	args.add("second".getBytes());
	args.add("third".getBytes());

	BinaryJedis binaryJedis = new BinaryJedis(hnp.getHost(), hnp.getPort(),
		500);
	binaryJedis.connect();
	binaryJedis.auth("foobared");

	List<byte[]> responses = (List<byte[]>) binaryJedis.eval(
		script.getBytes(), keys, args);
	assertEquals(5, responses.size());
	assertEquals("key1", new String(responses.get(0)));
	assertEquals("key2", new String(responses.get(1)));
	assertEquals("first", new String(responses.get(2)));
	assertEquals("second", new String(responses.get(3)));
	assertEquals("third", new String(responses.get(4)));
	
	binaryJedis.close();
    }

    @Test
    public void evalBulk() {
	String script = "return KEYS[1]";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");

	List<String> args = new ArrayList<String>();
	args.add("first");

	String response = (String) jedis.eval(script, keys, args);

	assertEquals("key1", response);
    }

    @Test
    public void evalInt() {
	String script = "return 2";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");

	Long response = (Long) jedis
		.eval(script, keys, new ArrayList<String>());

	assertEquals(new Long(2), response);
    }

    @SuppressWarnings("unchecked")
    @Test
    public void evalNestedLists() {
	String script = "return { {KEYS[1]} , {2} }";
	List<?> results = (List<?>) jedis.eval(script, 1, "key1");

	assertThat((List<String>) results.get(0), listWithItem("key1"));
	assertThat((List<Long>) results.get(1), listWithItem(2L));
    }

    @Test
    public void evalNoArgs() {
	String script = "return KEYS[1]";
	List<String> keys = new ArrayList<String>();
	keys.add("key1");
	String response = (String) jedis.eval(script, keys,
		new ArrayList<String>());

	assertEquals("key1", response);
    }

    @Test
    public void evalsha() {
	jedis.set("foo", "bar");
	jedis.eval("return redis.call('get','foo')");
	String result = (String) jedis
		.evalsha("6b1bf486c81ceb7edf3c093f4c48582e38c0e791");

	assertEquals("bar", result);
    }

    @Test(expected = JedisDataException.class)
    public void evalshaShaNotFound() {
	jedis.evalsha("ffffffffffffffffffffffffffffffffffffffff");
    }

    @Test
    public void scriptFlush() {
	jedis.set("foo", "bar");
	jedis.eval("return redis.call('get','foo')");
	jedis.scriptFlush();
	assertFalse(jedis
		.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    }

    @Test
    public void scriptExists() {
	jedis.scriptLoad("return redis.call('get','foo')");
	List<Boolean> exists = jedis.scriptExists(
		"ffffffffffffffffffffffffffffffffffffffff",
		"6b1bf486c81ceb7edf3c093f4c48582e38c0e791");
	assertFalse(exists.get(0));
	assertTrue(exists.get(1));
    }

    @Test
    public void scriptExistsBinary() {
	jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
	List<Long> exists = jedis.scriptExists(
		SafeEncoder.encode("ffffffffffffffffffffffffffffffffffffffff"),
		SafeEncoder.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
	assertEquals(new Long(0), exists.get(0));
	assertEquals(new Long(1), exists.get(1));
    }

    @Test
    public void scriptLoad() {
	jedis.scriptLoad("return redis.call('get','foo')");
	assertTrue(jedis
		.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    }

    @Test
    public void scriptLoadBinary() {
	jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
	byte[][] scripts = new byte[1][];
	scripts[0] = SafeEncoder.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791");
	List<Long> exists = jedis.scriptExists(scripts);
	assertEquals(new Long(1), exists.get(0));
    }

    @Test
    public void scriptKill() {
	try {
	    jedis.scriptKill();
	} catch (JedisDataException e) {
	    assertTrue(e.getMessage().contains(
		    "No scripts in execution right now."));
	}
    }

    @Test
    @SuppressWarnings("unchecked")
    public void scriptEvalReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	
	List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }

    @Test
    @SuppressWarnings("unchecked")
    public void scriptEvalShaReturnNullValues() {
	String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
	String sha = jedis.scriptLoad(script);
	List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
	assertEquals("key1", results.get(0));
	assertEquals("key2", results.get(1));
	assertEquals("1", results.get(2));
	assertEquals("2", results.get(3));
    }

    private <T> Matcher<Iterable<? super T>> listWithItem(T expected) {
	return CoreMatchers.<T>hasItem(equalTo(expected));
    }
=======
  @SuppressWarnings("unchecked")
  @Test
  public void evalMultiBulk() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");
    keys.add("key2");

    List<String> args = new ArrayList<String>();
    args.add("first");
    args.add("second");
    args.add("third");

    List<String> response = (List<String>) jedis.eval(script, keys, args);

    assertEquals(5, response.size());
    assertEquals("key1", response.get(0));
    assertEquals("key2", response.get(1));
    assertEquals("first", response.get(2));
    assertEquals("second", response.get(3));
    assertEquals("third", response.get(4));
  }

  @SuppressWarnings("unchecked")
  @Test
  public void evalMultiBulkWithBinaryJedis() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2],ARGV[3]}";
    List<byte[]> keys = new ArrayList<byte[]>();
    keys.add("key1".getBytes());
    keys.add("key2".getBytes());

    List<byte[]> args = new ArrayList<byte[]>();
    args.add("first".getBytes());
    args.add("second".getBytes());
    args.add("third".getBytes());

    BinaryJedis binaryJedis = new BinaryJedis(hnp.getHost(), hnp.getPort(), 500);
    binaryJedis.connect();
    binaryJedis.auth("foobared");

    List<byte[]> responses = (List<byte[]>) binaryJedis.eval(script.getBytes(), keys, args);
    assertEquals(5, responses.size());
    assertEquals("key1", new String(responses.get(0)));
    assertEquals("key2", new String(responses.get(1)));
    assertEquals("first", new String(responses.get(2)));
    assertEquals("second", new String(responses.get(3)));
    assertEquals("third", new String(responses.get(4)));
  }

  @Test
  public void evalBulk() {
    String script = "return KEYS[1]";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");

    List<String> args = new ArrayList<String>();
    args.add("first");

    String response = (String) jedis.eval(script, keys, args);

    assertEquals("key1", response);
  }

  @Test
  public void evalInt() {
    String script = "return 2";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");

    Long response = (Long) jedis.eval(script, keys, new ArrayList<String>());

    assertEquals(new Long(2), response);
  }

  @Test
  public void evalNestedLists() {
    String script = "return { {KEYS[1]} , {2} }";
    List<?> results = (List<?>) jedis.eval(script, 1, "key1");

    assertThat((List<String>) results.get(0), listWithItem("key1"));
    assertThat((List<Long>) results.get(1), listWithItem(2L));
  }

  @Test
  public void evalNoArgs() {
    String script = "return KEYS[1]";
    List<String> keys = new ArrayList<String>();
    keys.add("key1");
    String response = (String) jedis.eval(script, keys, new ArrayList<String>());

    assertEquals("key1", response);
  }

  @Test
  public void evalsha() {
    jedis.set("foo", "bar");
    jedis.eval("return redis.call('get','foo')");
    String result = (String) jedis.evalsha("6b1bf486c81ceb7edf3c093f4c48582e38c0e791");

    assertEquals("bar", result);
  }

  @Test(expected = JedisDataException.class)
  public void evalshaShaNotFound() {
    jedis.evalsha("ffffffffffffffffffffffffffffffffffffffff");
  }

  @Test
  public void scriptFlush() {
    jedis.set("foo", "bar");
    jedis.eval("return redis.call('get','foo')");
    jedis.scriptFlush();
    assertFalse(jedis.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
  }

  @Test
  public void scriptExists() {
    jedis.scriptLoad("return redis.call('get','foo')");
    List<Boolean> exists = jedis.scriptExists("ffffffffffffffffffffffffffffffffffffffff",
      "6b1bf486c81ceb7edf3c093f4c48582e38c0e791");
    assertFalse(exists.get(0));
    assertTrue(exists.get(1));
  }

  @Test
  public void scriptExistsBinary() {
    jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
    List<Long> exists = jedis.scriptExists(
      SafeEncoder.encode("ffffffffffffffffffffffffffffffffffffffff"),
      SafeEncoder.encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    assertEquals(new Long(0), exists.get(0));
    assertEquals(new Long(1), exists.get(1));
  }

  @Test
  public void scriptLoad() {
    jedis.scriptLoad("return redis.call('get','foo')");
    assertTrue(jedis.scriptExists("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
  }

  @Test
  public void scriptLoadBinary() {
    jedis.scriptLoad(SafeEncoder.encode("return redis.call('get','foo')"));
    List<Long> exists = jedis.scriptExists(SafeEncoder
        .encode("6b1bf486c81ceb7edf3c093f4c48582e38c0e791"));
    assertEquals(new Long(1), exists.get(0));
  }

  @Test
  public void scriptKill() {
    try {
      jedis.scriptKill();
    } catch (JedisDataException e) {
      assertTrue(e.getMessage().contains("No scripts in execution right now."));
    }
  }

  @Test
  public void scriptEvalReturnNullValues() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
    List<String> results = (List<String>) jedis.eval(script, 2, "key1", "key2", "1", "2");
    assertEquals("key1", results.get(0));
    assertEquals("key2", results.get(1));
    assertEquals("1", results.get(2));
    assertEquals("2", results.get(3));
  }

  @Test
  public void scriptEvalShaReturnNullValues() {
    String script = "return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}";
    String sha = jedis.scriptLoad(script);
    List<String> results = (List<String>) jedis.evalsha(sha, 2, "key1", "key2", "1", "2");
    assertEquals("key1", results.get(0));
    assertEquals("key2", results.get(1));
    assertEquals("1", results.get(2));
    assertEquals("2", results.get(3));
  }

  private <T> Matcher<Iterable<? super T>> listWithItem(T expected) {
    return CoreMatchers.<T> hasItem(equalTo(expected));
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/test/java/redis/clients/jedis/tests/PipeliningTest.java;<<<<<<< MINE
    @Before
    public void setUp() throws Exception {
	jedis = new Jedis(hnp.getHost(), hnp.getPort(), 500);
	jedis.connect();
	jedis.auth("foobared");
	jedis.flushAll();
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
	Pipeline p = jedis.pipelined();
	p.set("foo", "bar");
	p.get("foo");
	List<Object> results = p.syncAndReturnAll();

	assertEquals(2, results.size());
	assertEquals("OK", results.get(0));
	assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
	jedis.set("string", "foo");
	jedis.lpush("list", "foo");
	jedis.hset("hash", "foo", "bar");
	jedis.zadd("zset", 1, "foo");
	jedis.sadd("set", "foo");

	Pipeline p = jedis.pipelined();
	Response<String> string = p.get("string");
	Response<String> list = p.lpop("list");
	Response<String> hash = p.hget("hash", "foo");
	Response<Set<String>> zset = p.zrange("zset", 0, -1);
	Response<String> set = p.spop("set");
	Response<Boolean> blist = p.exists("list");
	Response<Double> zincrby = p.zincrby("zset", 1, "foo");
	Response<Long> zcard = p.zcard("zset");
	p.lpush("list", "bar");
	Response<List<String>> lrange = p.lrange("list", 0, -1);
	Response<Map<String, String>> hgetAll = p.hgetAll("hash");
	p.sadd("set", "foo");
	Response<Set<String>> smembers = p.smembers("set");
	Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
		-1);
	p.sync();

	assertEquals("foo", string.get());
	assertEquals("foo", list.get());
	assertEquals("bar", hash.get());
	assertEquals("foo", zset.get().iterator().next());
	assertEquals("foo", set.get());
	assertEquals(false, blist.get());
	assertEquals(Double.valueOf(2), zincrby.get());
	assertEquals(Long.valueOf(1), zcard.get());
	assertEquals(1, lrange.get().size());
	assertNotNull(hgetAll.get().get("foo"));
	assertEquals(1, smembers.get().size());
	assertEquals(1, zrangeWithScores.get().size());
    }

    @Test
    public void pipelineResponseWithData() {
	jedis.zadd("zset", 1, "foo");

	Pipeline p = jedis.pipelined();
	Response<Double> score = p.zscore("zset", "foo");
	p.sync();

	assertNotNull(score.get());
    }

    @Test
    public void pipelineBinarySafeHashCommands() {
	jedis.hset("key".getBytes(), "f1".getBytes(), "v111".getBytes());
	jedis.hset("key".getBytes(), "f22".getBytes(), "v2222".getBytes());

	Pipeline p = jedis.pipelined();
	Response<Map<byte[], byte[]>> fmap = p.hgetAll("key".getBytes());
	Response<Set<byte[]>> fkeys = p.hkeys("key".getBytes());
	Response<List<byte[]>> fordered = p.hmget("key".getBytes(),
		"f22".getBytes(), "f1".getBytes());
	Response<List<byte[]>> fvals = p.hvals("key".getBytes());
	p.sync();

	assertNotNull(fmap.get());
	// we have to do these strange contortions because byte[] is not a very
	// good key
	// for a java Map. It only works with equality (you need the exact key
	// object to retrieve
	// the value) I recommend we switch to using ByteBuffer or something
	// similar:
	// http://stackoverflow.com/questions/1058149/using-a-byte-array-as-hashmap-key-java
	Map<byte[], byte[]> map = fmap.get();
	Set<byte[]> mapKeys = map.keySet();
	Iterator<byte[]> iterMap = mapKeys.iterator();
	byte[] firstMapKey = iterMap.next();
	byte[] secondMapKey = iterMap.next();
	assertFalse(iterMap.hasNext());
	verifyHasBothValues(firstMapKey, secondMapKey, "f1".getBytes(),
		"f22".getBytes());
	byte[] firstMapValue = map.get(firstMapKey);
	byte[] secondMapValue = map.get(secondMapKey);
	verifyHasBothValues(firstMapValue, secondMapValue, "v111".getBytes(),
		"v2222".getBytes());

	assertNotNull(fkeys.get());
	Iterator<byte[]> iter = fkeys.get().iterator();
	byte[] firstKey = iter.next();
	byte[] secondKey = iter.next();
	assertFalse(iter.hasNext());
	verifyHasBothValues(firstKey, secondKey, "f1".getBytes(),
		"f22".getBytes());

	assertNotNull(fordered.get());
	assertArrayEquals("v2222".getBytes(), fordered.get().get(0));
	assertArrayEquals("v111".getBytes(), fordered.get().get(1));

	assertNotNull(fvals.get());
	assertEquals(2, fvals.get().size());
	byte[] firstValue = fvals.get().get(0);
	byte[] secondValue = fvals.get().get(1);
	verifyHasBothValues(firstValue, secondValue, "v111".getBytes(),
		"v2222".getBytes());
    }

    private void verifyHasBothValues(byte[] firstKey, byte[] secondKey,
	    byte[] value1, byte[] value2) {
	assertFalse(Arrays.equals(firstKey, secondKey));
	assertTrue(Arrays.equals(firstKey, value1)
		|| Arrays.equals(firstKey, value2));
	assertTrue(Arrays.equals(secondKey, value1)
		|| Arrays.equals(secondKey, value2));
    }

    @Test
    public void pipelineSelect() {
	Pipeline p = jedis.pipelined();
	p.select(1);
	p.sync();
    }

    @Test
    public void pipelineResponseWithoutData() {
	jedis.zadd("zset", 1, "foo");

	Pipeline p = jedis.pipelined();
	Response<Double> score = p.zscore("zset", "bar");
	p.sync();

	assertNull(score.get());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
	jedis.set("string", "foo");

	Pipeline p = jedis.pipelined();
	Response<String> string = p.get("string");
	string.get();
	p.sync();
    }

    @Test
    public void pipelineWithPubSub() {
	Pipeline pipelined = jedis.pipelined();
	Response<Long> p1 = pipelined.publish("foo", "bar");
	Response<Long> p2 = pipelined.publish("foo".getBytes(),
		"bar".getBytes());
	pipelined.sync();
	assertEquals(0, p1.get().longValue());
	assertEquals(0, p2.get().longValue());
    }

    @Test
    public void canRetrieveUnsetKey() {
	Pipeline p = jedis.pipelined();
	Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
	p.sync();
	assertNull(shouldNotExist.get());
    }

    @Test
    public void piplineWithError() {
	Pipeline p = jedis.pipelined();
	p.set("foo", "bar");
	Response<Set<String>> error = p.smembers("foo");
	Response<String> r = p.get("foo");
	p.sync();
	try {
	    error.get();
	    fail();
	} catch (JedisDataException e) {
	    // that is fine we should be here
	}
	assertEquals(r.get(), "bar");
    }

    @Test
    public void multi() {
	Pipeline p = jedis.pipelined();
	p.multi();
	Response<Long> r1 = p.hincrBy("a", "f1", -1);
	Response<Long> r2 = p.hincrBy("a", "f1", -2);
	Response<List<Object>> r3 = p.exec();
	List<Object> result = p.syncAndReturnAll();

	assertEquals(new Long(-1), r1.get());
	assertEquals(new Long(-3), r2.get());

	assertEquals(4, result.size());

	assertEquals("OK", result.get(0));
	assertEquals("QUEUED", result.get(1));
	assertEquals("QUEUED", result.get(2));

	// 4th result is a list with the results from the multi
	@SuppressWarnings("unchecked")
	List<Object> multiResult = (List<Object>) result.get(3);
	assertEquals(new Long(-1), multiResult.get(0));
	assertEquals(new Long(-3), multiResult.get(1));

	assertEquals(new Long(-1), r3.get().get(0));
	assertEquals(new Long(-3), r3.get().get(1));

    }

    @Test
    public void multiWithSync() {
	jedis.set("foo", "314");
	jedis.set("bar", "foo");
	jedis.set("hello", "world");
	Pipeline p = jedis.pipelined();
	Response<String> r1 = p.get("bar");
	p.multi();
	Response<String> r2 = p.get("foo");
	p.exec();
	Response<String> r3 = p.get("hello");
	p.sync();
	
	// before multi
	assertEquals("foo", r1.get());
	// It should be readable whether exec's response was built or not
	assertEquals("314", r2.get());
	// after multi
	assertEquals("world", r3.get());
    }

    @Test
    public void testDiscardInPipeline() {
	Pipeline pipeline = jedis.pipelined();
	pipeline.multi();
	pipeline.set("foo", "bar");
	Response<String> discard = pipeline.discard();
	Response<String> get = pipeline.get("foo");
	pipeline.sync();
	discard.get();
	get.get();
    }

    @Test
    public void testEval() {
	String script = "return 'success!'";

	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(script);
	p.sync();

	assertEquals("success!", result.get());
    }
    
    @Test
    public void testEvalWithBinary() {
	String script = "return 'success!'";

	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(SafeEncoder.encode(script));
	p.sync();

	assertArrayEquals(SafeEncoder.encode("success!"), (byte[]) result.get());
    }

    @Test
    public void testEvalKeyAndArg() {
	String key = "test";
	String arg = "3";
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";

	Pipeline p = jedis.pipelined();
	p.set(key, "0");
	Response<Object> result0 = p.eval(script, Arrays.asList(key),
		Arrays.asList(arg));
	p.incr(key);
	Response<Object> result1 = p.eval(script, Arrays.asList(key),
		Arrays.asList(arg));
	Response<String> result2 = p.get(key);
	p.sync();

	assertNull(result0.get());
	assertNull(result1.get());
	assertEquals("13", result2.get());
    }
    
    @Test
    public void testEvalKeyAndArgWithBinary() {
	// binary
	byte[] bKey = SafeEncoder.encode("test");
	byte[] bArg = SafeEncoder.encode("3");
	byte[] bScript = SafeEncoder.encode("redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])");
	
	Pipeline bP = jedis.pipelined();
	bP.set(bKey, SafeEncoder.encode("0"));
	Response<Object> bResult0 = bP.eval(bScript, Arrays.asList(bKey),
		Arrays.asList(bArg));
	bP.incr(bKey);
	Response<Object> bResult1 = bP.eval(bScript, Arrays.asList(bKey),
		Arrays.asList(bArg));
	Response<byte[]> bResult2 = bP.get(bKey);
	bP.sync();

	assertNull(bResult0.get());
	assertNull(bResult1.get());
	assertArrayEquals(SafeEncoder.encode("13"), bResult2.get());
    }
    
    @Test
    public void testEvalNestedLists() {
	String script = "return { {KEYS[1]} , {2} }";
	
	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(script, 1, "key1");
	p.sync();
	
	List<?> results = (List<?>) result.get();
	assertThat((List<String>) results.get(0), listWithItem("key1"));
	assertThat((List<Long>) results.get(1), listWithItem(2L));
    }
    
    @Test
    public void testEvalNestedListsWithBinary() {
	byte[] bScript = SafeEncoder.encode("return { {KEYS[1]} , {2} }");
	byte[] bKey = SafeEncoder.encode("key1"); 
	
	Pipeline p = jedis.pipelined();
	Response<Object> result = p.eval(bScript, 1, bKey);
	p.sync();
	
	List<?> results = (List<?>) result.get();
	assertThat((List<byte[]>) results.get(0), listWithItem(bKey));
	assertThat((List<Long>) results.get(1), listWithItem(2L));
    }

    @Test
    public void testEvalsha() {
	String script = "return 'success!'";
	String sha1 = jedis.scriptLoad(script);

	assertTrue(jedis.scriptExists(sha1));

	Pipeline p = jedis.pipelined();
	Response<Object> result = p.evalsha(sha1);
	p.sync();

	assertEquals("success!", result.get());
    }

    @Test
    public void testEvalshaKeyAndArg() {
	String key = "test";
	String arg = "3";
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
	String sha1 = jedis.scriptLoad(script);

	assertTrue(jedis.scriptExists(sha1));

	Pipeline p = jedis.pipelined();
	p.set(key, "0");
	Response<Object> result0 = p.evalsha(sha1, Arrays.asList(key),
		Arrays.asList(arg));
	p.incr(key);
	Response<Object> result1 = p.evalsha(sha1, Arrays.asList(key),
		Arrays.asList(arg));
	Response<String> result2 = p.get(key);
	p.sync();

	assertNull(result0.get());
	assertNull(result1.get());
	assertEquals("13", result2.get());
    }
    
    @Test
    public void testEvalshaKeyAndArgWithBinary() {
	byte[] bKey = SafeEncoder.encode("test");
	byte[] bArg = SafeEncoder.encode("3");
	String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
	byte[] bScript = SafeEncoder.encode(script);
	byte[] bSha1 = jedis.scriptLoad(bScript);
	
	assertTrue(jedis.scriptExists(bSha1) == 1);
	
	Pipeline p = jedis.pipelined();
	p.set(bKey, SafeEncoder.encode("0"));
	Response<Object> result0 = p.evalsha(bSha1, Arrays.asList(bKey),
		Arrays.asList(bArg));
	p.incr(bKey);
	Response<Object> result1 = p.evalsha(bSha1, Arrays.asList(bKey),
		Arrays.asList(bArg));
	Response<byte[]> result2 = p.get(bKey);
	p.sync();
	
	assertNull(result0.get());
	assertNull(result1.get());
	assertArrayEquals(SafeEncoder.encode("13"), result2.get());
    }
    
    private <T> Matcher<Iterable<? super T>> listWithItem(T expected) {
	return CoreMatchers.<T>hasItem(equalTo(expected));
    }
=======
  @Before
  public void setUp() throws Exception {
    jedis = new Jedis(hnp.getHost(), hnp.getPort(), 500);
    jedis.connect();
    jedis.auth("foobared");
    jedis.flushAll();
  }

  @Test
  public void pipeline() throws UnsupportedEncodingException {
    Pipeline p = jedis.pipelined();
    p.set("foo", "bar");
    p.get("foo");
    List<Object> results = p.syncAndReturnAll();

    assertEquals(2, results.size());
    assertEquals("OK", results.get(0));
    assertEquals("bar", results.get(1));

  }

  @Test
  public void pipelineResponse() {
    jedis.set("string", "foo");
    jedis.lpush("list", "foo");
    jedis.hset("hash", "foo", "bar");
    jedis.zadd("zset", 1, "foo");
    jedis.sadd("set", "foo");
    jedis.setrange("setrange", 0, "0123456789");
    byte[] bytesForSetRange = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    jedis.setrange("setrangebytes".getBytes(), 0, bytesForSetRange);

    Pipeline p = jedis.pipelined();
    Response<String> string = p.get("string");
    Response<String> list = p.lpop("list");
    Response<String> hash = p.hget("hash", "foo");
    Response<Set<String>> zset = p.zrange("zset", 0, -1);
    Response<String> set = p.spop("set");
    Response<Boolean> blist = p.exists("list");
    Response<Double> zincrby = p.zincrby("zset", 1, "foo");
    Response<Long> zcard = p.zcard("zset");
    p.lpush("list", "bar");
    Response<List<String>> lrange = p.lrange("list", 0, -1);
    Response<Map<String, String>> hgetAll = p.hgetAll("hash");
    p.sadd("set", "foo");
    Response<Set<String>> smembers = p.smembers("set");
    Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0, -1);
    Response<String> getrange = p.getrange("setrange", 1, 3);
    Response<byte[]> getrangeBytes = p.getrange("setrangebytes".getBytes(), 6, 8);
    p.sync();

    assertEquals("foo", string.get());
    assertEquals("foo", list.get());
    assertEquals("bar", hash.get());
    assertEquals("foo", zset.get().iterator().next());
    assertEquals("foo", set.get());
    assertEquals(false, blist.get());
    assertEquals(Double.valueOf(2), zincrby.get());
    assertEquals(Long.valueOf(1), zcard.get());
    assertEquals(1, lrange.get().size());
    assertNotNull(hgetAll.get().get("foo"));
    assertEquals(1, smembers.get().size());
    assertEquals(1, zrangeWithScores.get().size());
    assertEquals("123", getrange.get());
    byte[] expectedGetRangeBytes = { 6, 7, 8 };
    assertArrayEquals(expectedGetRangeBytes, getrangeBytes.get());
  }

  @Test
  public void pipelineResponseWithData() {
    jedis.zadd("zset", 1, "foo");

    Pipeline p = jedis.pipelined();
    Response<Double> score = p.zscore("zset", "foo");
    p.sync();

    assertNotNull(score.get());
  }

  @Test
  public void pipelineBinarySafeHashCommands() {
    jedis.hset("key".getBytes(), "f1".getBytes(), "v111".getBytes());
    jedis.hset("key".getBytes(), "f22".getBytes(), "v2222".getBytes());

    Pipeline p = jedis.pipelined();
    Response<Map<byte[], byte[]>> fmap = p.hgetAll("key".getBytes());
    Response<Set<byte[]>> fkeys = p.hkeys("key".getBytes());
    Response<List<byte[]>> fordered = p.hmget("key".getBytes(), "f22".getBytes(), "f1".getBytes());
    Response<List<byte[]>> fvals = p.hvals("key".getBytes());
    p.sync();

    assertNotNull(fmap.get());
    // we have to do these strange contortions because byte[] is not a very
    // good key
    // for a java Map. It only works with equality (you need the exact key
    // object to retrieve
    // the value) I recommend we switch to using ByteBuffer or something
    // similar:
    // http://stackoverflow.com/questions/1058149/using-a-byte-array-as-hashmap-key-java
    Map<byte[], byte[]> map = fmap.get();
    Set<byte[]> mapKeys = map.keySet();
    Iterator<byte[]> iterMap = mapKeys.iterator();
    byte[] firstMapKey = iterMap.next();
    byte[] secondMapKey = iterMap.next();
    assertFalse(iterMap.hasNext());
    verifyHasBothValues(firstMapKey, secondMapKey, "f1".getBytes(), "f22".getBytes());
    byte[] firstMapValue = map.get(firstMapKey);
    byte[] secondMapValue = map.get(secondMapKey);
    verifyHasBothValues(firstMapValue, secondMapValue, "v111".getBytes(), "v2222".getBytes());

    assertNotNull(fkeys.get());
    Iterator<byte[]> iter = fkeys.get().iterator();
    byte[] firstKey = iter.next();
    byte[] secondKey = iter.next();
    assertFalse(iter.hasNext());
    verifyHasBothValues(firstKey, secondKey, "f1".getBytes(), "f22".getBytes());

    assertNotNull(fordered.get());
    assertArrayEquals("v2222".getBytes(), fordered.get().get(0));
    assertArrayEquals("v111".getBytes(), fordered.get().get(1));

    assertNotNull(fvals.get());
    assertEquals(2, fvals.get().size());
    byte[] firstValue = fvals.get().get(0);
    byte[] secondValue = fvals.get().get(1);
    verifyHasBothValues(firstValue, secondValue, "v111".getBytes(), "v2222".getBytes());
  }

  private void verifyHasBothValues(byte[] firstKey, byte[] secondKey, byte[] value1, byte[] value2) {
    assertFalse(Arrays.equals(firstKey, secondKey));
    assertTrue(Arrays.equals(firstKey, value1) || Arrays.equals(firstKey, value2));
    assertTrue(Arrays.equals(secondKey, value1) || Arrays.equals(secondKey, value2));
  }

  @Test
  public void pipelineSelect() {
    Pipeline p = jedis.pipelined();
    p.select(1);
    p.sync();
  }

  @Test
  public void pipelineResponseWithoutData() {
    jedis.zadd("zset", 1, "foo");

    Pipeline p = jedis.pipelined();
    Response<Double> score = p.zscore("zset", "bar");
    p.sync();

    assertNull(score.get());
  }

  @Test(expected = JedisDataException.class)
  public void pipelineResponseWithinPipeline() {
    jedis.set("string", "foo");

    Pipeline p = jedis.pipelined();
    Response<String> string = p.get("string");
    string.get();
    p.sync();
  }

  @Test
  public void pipelineWithPubSub() {
    Pipeline pipelined = jedis.pipelined();
    Response<Long> p1 = pipelined.publish("foo", "bar");
    Response<Long> p2 = pipelined.publish("foo".getBytes(), "bar".getBytes());
    pipelined.sync();
    assertEquals(0, p1.get().longValue());
    assertEquals(0, p2.get().longValue());
  }

  @Test
  public void canRetrieveUnsetKey() {
    Pipeline p = jedis.pipelined();
    Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
    p.sync();
    assertNull(shouldNotExist.get());
  }

  @Test
  public void piplineWithError() {
    Pipeline p = jedis.pipelined();
    p.set("foo", "bar");
    Response<Set<String>> error = p.smembers("foo");
    Response<String> r = p.get("foo");
    p.sync();
    try {
      error.get();
      fail();
    } catch (JedisDataException e) {
      // that is fine we should be here
    }
    assertEquals(r.get(), "bar");
  }

  @Test
  public void multi() {
    Pipeline p = jedis.pipelined();
    p.multi();
    Response<Long> r1 = p.hincrBy("a", "f1", -1);
    Response<Long> r2 = p.hincrBy("a", "f1", -2);
    Response<List<Object>> r3 = p.exec();
    List<Object> result = p.syncAndReturnAll();

    assertEquals(new Long(-1), r1.get());
    assertEquals(new Long(-3), r2.get());

    assertEquals(4, result.size());

    assertEquals("OK", result.get(0));
    assertEquals("QUEUED", result.get(1));
    assertEquals("QUEUED", result.get(2));

    // 4th result is a list with the results from the multi
    @SuppressWarnings("unchecked")
    List<Object> multiResult = (List<Object>) result.get(3);
    assertEquals(new Long(-1), multiResult.get(0));
    assertEquals(new Long(-3), multiResult.get(1));

    assertEquals(new Long(-1), r3.get().get(0));
    assertEquals(new Long(-3), r3.get().get(1));

  }

  @Test
  public void multiWithSync() {
    jedis.set("foo", "314");
    jedis.set("bar", "foo");
    jedis.set("hello", "world");
    Pipeline p = jedis.pipelined();
    Response<String> r1 = p.get("bar");
    p.multi();
    Response<String> r2 = p.get("foo");
    p.exec();
    Response<String> r3 = p.get("hello");
    p.sync();

    // before multi
    assertEquals("foo", r1.get());
    // It should be readable whether exec's response was built or not
    assertEquals("314", r2.get());
    // after multi
    assertEquals("world", r3.get());
  }

  @Test(expected = JedisDataException.class)
  public void pipelineExecShoudThrowJedisDataExceptionWhenNotInMulti() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.exec();
  }

  @Test(expected = JedisDataException.class)
  public void pipelineDiscardShoudThrowJedisDataExceptionWhenNotInMulti() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.discard();
  }

  @Test(expected = JedisDataException.class)
  public void pipelineMultiShoudThrowJedisDataExceptionWhenAlreadyInMulti() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.multi();
    pipeline.set("foo", "3");
    pipeline.multi();
  }

  @Test
  public void testDiscardInPipeline() {
    Pipeline pipeline = jedis.pipelined();
    pipeline.multi();
    pipeline.set("foo", "bar");
    Response<String> discard = pipeline.discard();
    Response<String> get = pipeline.get("foo");
    pipeline.sync();
    discard.get();
    get.get();
  }

  @Test
  public void testEval() {
    String script = "return 'success!'";

    Pipeline p = jedis.pipelined();
    Response<String> result = p.eval(script);
    p.sync();

    assertEquals("success!", result.get());
  }

  @Test
  public void testEvalKeyAndArg() {
    String key = "test";
    String arg = "3";
    String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";

    Pipeline p = jedis.pipelined();
    p.set(key, "0");
    Response<String> result0 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
    p.incr(key);
    Response<String> result1 = p.eval(script, Arrays.asList(key), Arrays.asList(arg));
    Response<String> result2 = p.get(key);
    p.sync();

    assertNull(result0.get());
    assertNull(result1.get());
    assertEquals("13", result2.get());
  }

  @Test
  public void testEvalsha() {
    String script = "return 'success!'";
    String sha1 = jedis.scriptLoad(script);

    assertTrue(jedis.scriptExists(sha1));

    Pipeline p = jedis.pipelined();
    Response<String> result = p.evalsha(sha1);
    p.sync();

    assertEquals("success!", result.get());
  }

  @Test
  public void testEvalshaKeyAndArg() {
    String key = "test";
    String arg = "3";
    String script = "redis.call('INCRBY', KEYS[1], ARGV[1]) redis.call('INCRBY', KEYS[1], ARGV[1])";
    String sha1 = jedis.scriptLoad(script);

    assertTrue(jedis.scriptExists(sha1));

    Pipeline p = jedis.pipelined();
    p.set(key, "0");
    Response<String> result0 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
    p.incr(key);
    Response<String> result1 = p.evalsha(sha1, Arrays.asList(key), Arrays.asList(arg));
    Response<String> result2 = p.get(key);
    p.sync();

    assertNull(result0.get());
    assertNull(result1.get());
    assertEquals("13", result2.get());
  }

  @Test
  public void testPipelinedTransactionResponse() {

    String key1 = "key1";
    String val1 = "val1";

    String key2 = "key2";
    String val2 = "val2";

    String key3 = "key3";
    String field1 = "field1";
    String field2 = "field2";
    String field3 = "field3";
    String field4 = "field4";

    String value1 = "value1";
    String value2 = "value2";
    String value3 = "value3";
    String value4 = "value4";

    Map<String, String> hashMap = new HashMap<String, String>();
    hashMap.put(field1, value1);
    hashMap.put(field2, value2);

    String key4 = "key4";
    Map<String, String> hashMap1 = new HashMap<String, String>();
    hashMap1.put(field3, value3);
    hashMap1.put(field4, value4);

    jedis.set(key1, val1);
    jedis.set(key2, val2);
    jedis.hmset(key3, hashMap);
    jedis.hmset(key4, hashMap1);

    Pipeline pipeline = jedis.pipelined();
    pipeline.multi();

    pipeline.get(key1);
    pipeline.hgetAll(key2);
    pipeline.hgetAll(key3);
    pipeline.get(key4);

    Response<List<Object>> response = pipeline.exec();
    pipeline.sync();

    List<Object> result = response.get();

    assertEquals(4, result.size());

    assertEquals("val1", result.get(0));

    assertTrue(result.get(1) instanceof JedisDataException);

    Map<String, String> hashMapReceived = (Map<String, String>) result.get(2);
    Iterator<String> iterator = hashMapReceived.keySet().iterator();
    String mapKey1 = iterator.next();
    String mapKey2 = iterator.next();
    assertFalse(iterator.hasNext());
    verifyHasBothValues(mapKey1, mapKey2, field1, field2);
    String mapValue1 = hashMapReceived.get(mapKey1);
    String mapValue2 = hashMapReceived.get(mapKey2);
    verifyHasBothValues(mapValue1, mapValue2, value1, value2);

    assertTrue(result.get(3) instanceof JedisDataException);
  }

  @Test
  public void testSyncWithNoCommandQueued() {
    // we need to test with fresh instance of Jedis
    Jedis jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);

    Pipeline pipeline = jedis2.pipelined();
    pipeline.sync();

    jedis2.close();

    jedis2 = new Jedis(hnp.getHost(), hnp.getPort(), 500);

    pipeline = jedis2.pipelined();
    List<Object> resp = pipeline.syncAndReturnAll();
    assertTrue(resp.isEmpty());

    jedis2.close();
  }

  private void verifyHasBothValues(String firstKey, String secondKey, String value1, String value2) {
    assertFalse(firstKey.equals(secondKey));
    assertTrue(firstKey.equals(value1) || firstKey.equals(value2));
    assertTrue(secondKey.equals(value1) || secondKey.equals(value2));
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/main/java/org/junit/experimental/theories/DataPoint.java;<<<<<<< MINE
    String[] value() default {};
=======
    String[] value() default {};
    Class<? extends Throwable>[] ignoredExceptions() default {};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/internal/AllMembersSupplierTest.java;<<<<<<< MINE
    
    public static class HasDataPointsArrayField {
=======
    @Rule
    public ExpectedException expected = ExpectedException.none();
    
    public static class HasDataPoints {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/internal/AllMembersSupplierTest.java;<<<<<<< MINE
    public void dataPointsArrayShouldBeRecognizedOnValueTypeNotFieldType() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointsArrayWithMatchingButInaccurateTypes.class.getMethod("theory", Integer.class));
        
        assertEquals(2, assignments.size());
    }
    
    public static class HasDataPointMethodWithOverlyGeneralTypes {
        @DataPoint
        public static Integer object() {
            return 1;
        }

        @Theory
        public void theory(Object param) {
        }
    }

    @Test
    public void dataPointMethodShouldBeRecognizedForOverlyGeneralParameters() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointMethodWithOverlyGeneralTypes.class.getMethod("theory", Object.class));
        
        assertEquals(1, assignments.size());
    }
    
    public static class HasDataPointsWithObjectParameter {
        @DataPoints
        public static Object[] objectField = {1, 2};

        @Theory
        public void theory(Object obj) {
        }
    }

    @Test
    public void dataPointsAnnotationMeansTreatAsArrayOnly() throws Exception {
        List<PotentialAssignment> assignments = potentialAssignments(
                HasDataPointsWithObjectParameter.class.getMethod("theory", Object.class));
        
        assertEquals(2, assignments.size());
        for (PotentialAssignment assignment : assignments) {
            assertNotEquals(HasDataPointsWithObjectParameter.objectField, assignment.getValue());
        }
=======
    public void dataPointsAnnotationMeansTreatAsArrayOnly() throws Throwable {
        List<PotentialAssignment> valueSources = allMemberValuesFor(
                HasDataPoints.class, Object.class);
        assertThat(valueSources.size(), is(2));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;<<<<<<< MINE
=======
import static org.junit.tests.experimental.theories.TheoryTestUtils.runTheoryClass;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;<<<<<<< MINE
import org.junit.runner.JUnitCore;
import org.junit.runner.Request;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;<<<<<<< MINE
import org.junit.runner.Runner;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;<<<<<<< MINE
    @Test
    public void noTheoryAnnotationMeansAssumeShouldIgnore() {
        Assume.assumeTrue(false);
    }

    @Test
    public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
        Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
        Assert.assertEquals(1, result.getFailureCount());
    }

    /**
     * Simple class that SHOULD fail because no parameters are met.
     */
    public static class TheoryWithNoUnassumedParameters {

        @DataPoint
        public final static boolean FALSE = false;

        @Theory
        public void theoryWithNoUnassumedParameters(boolean value) {
            Assume.assumeTrue(value);
        }
    }
=======
	@Test
	public void noTheoryAnnotationMeansAssumeShouldIgnore() {
		Assume.assumeTrue(false);
	}

	@Test
	public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
		Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
		Assert.assertEquals(1, result.getFailureCount());
	}

	/**
	 * Simple class that SHOULD fail because no parameters are met.
	 */
	public static class TheoryWithNoUnassumedParameters {
		
		@DataPoint 
		public final static boolean FALSE = false;
		
		@Theory
		public void theoryWithNoUnassumedParameters(boolean value) {
			Assume.assumeTrue(value);
		}
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/TheoryTestUtils.java;<<<<<<< MINE
=======
import org.junit.experimental.theories.Theories;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/TheoryTestUtils.java;<<<<<<< MINE
=======
import org.junit.runner.JUnitCore;
import org.junit.runner.Request;
import org.junit.runner.Result;
import org.junit.runner.Runner;
import org.junit.runners.model.InitializationError;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/TheoryTestUtils.java;<<<<<<< MINE
=======
    
    public static Result runTheoryClass(Class<?> testClass) throws InitializationError {
        Runner theoryRunner = new Theories(testClass);
        Request request = Request.runner(theoryRunner);
        return new JUnitCore().run(request);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_508d079_7fad9fb/rev_508d079-7fad9fb/src/test/java/redis/clients/jedis/tests/JedisPoolTest.java;<<<<<<< MINE
import java.net.SocketTimeoutException;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3032c94_f6ff78a/rev_3032c94-f6ff78a/src/main/java/redis/clients/jedis/JedisShardInfo.java;<<<<<<< MINE
import java.util.logging.Logger;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_364c6d9_7e24eac/rev_364c6d9-7e24eac/src/test/java/redis/clients/jedis/tests/commands/ObjectCommandsTest.java;<<<<<<< MINE
    assertEquals("ziplist", encoding);
=======
    assertEquals("quicklist", encoding);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_364c6d9_7e24eac/rev_364c6d9-7e24eac/src/test/java/redis/clients/jedis/tests/commands/ObjectCommandsTest.java;<<<<<<< MINE
    assertEquals("ziplist", encoding);
=======
    assertEquals("quicklist", encoding);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_b09a1e2_ffbca78/rev_b09a1e2-ffbca78/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
public abstract class PipelineBase extends Queable implements BinaryRedisPipeline,
	RedisPipeline {
=======
abstract class PipelineBase extends Queable implements BinaryRedisPipeline, RedisPipeline {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_b09a1e2_ffbca78/rev_b09a1e2-ffbca78/src/main/java/redis/clients/jedis/MultiKeyPipelineBase.java;<<<<<<< MINE
public abstract class MultiKeyPipelineBase extends PipelineBase implements
	BasicRedisPipeline, MultiKeyBinaryRedisPipeline,
	MultiKeyCommandsPipeline, ClusterPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> time() {
	client.time();
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(String destkey, String... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<Long> pfcount(String... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }

    @Override
    public Response<Long> pfcount(final byte[]... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }
=======
abstract class MultiKeyPipelineBase extends PipelineBase implements MultiKeyBinaryRedisPipeline,
    MultiKeyCommandsPipeline, ClusterPipeline, BinaryScriptingCommandsPipeline,
    ScriptingCommandsPipeline {

  protected Client client = null;

  public Response<List<String>> brpop(String... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(int timeout, String... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(String... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> brpop(byte[]... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> brpop(int timeout, byte[]... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> blpop(byte[]... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> blpop(int timeout, byte[]... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> del(String... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[]... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> keys(String pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> keys(byte[] pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> mget(String... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> mget(byte[]... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> mset(String... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> mset(byte[]... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> msetnx(String... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> msetnx(byte[]... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rename(String oldkey, String newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> rename(byte[] oldkey, byte[] newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> renamenx(String oldkey, String newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpoplpush(String srckey, String dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Set<String>> sdiff(String... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sdiff(byte[]... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sdiffstore(String dstkey, String... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sinter(String... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sinter(byte[]... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sinterstore(String dstkey, String... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(String srckey, String dstkey, String member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, SortingParams sortingParameters, String dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, String dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, byte[] dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sunion(String... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sunion(byte[]... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sunionstore(String dstkey, String... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> watch(String... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> watch(byte[]... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zinterstore(String dstkey, String... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(String dstkey, ZParams params, String... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, String... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, ZParams params, String... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> bgrewriteaof() {
    client.bgrewriteaof();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> bgsave() {
    client.bgsave();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> configGet(String pattern) {
    client.configGet(pattern);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> configSet(String parameter, String value) {
    client.configSet(parameter, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> brpoplpush(String source, String destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> configResetStat() {
    client.configResetStat();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> save() {
    client.save();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> lastsave() {
    client.lastsave();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(String channel, String message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> randomKey() {
    client.randomKey();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> randomKeyBinary() {
    client.randomKey();
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> flushDB() {
    client.flushDB();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> flushAll() {
    client.flushAll();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info() {
    client.info();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info(final String section) {
    client.info(section);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> dbSize() {
    client.dbSize();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> shutdown() {
    client.shutdown();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ping() {
    client.ping();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> select(int index) {
    client.select(index);
    Response<String> response = getResponse(BuilderFactory.STRING);
    client.setDb(index);

    return response;
  }

  public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> clusterNodes() {
    client.clusterNodes();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterMeet(final String ip, final int port) {
    client.clusterMeet(ip, port);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterAddSlots(final int... slots) {
    client.clusterAddSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterDelSlots(final int... slots) {
    client.clusterDelSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterInfo() {
    client.clusterInfo();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> clusterGetKeysInSlot(final int slot, final int count) {
    client.clusterGetKeysInSlot(slot, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> clusterSetSlotNode(final int slot, final String nodeId) {
    client.clusterSetSlotNode(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotMigrating(final int slot, final String nodeId) {
    client.clusterSetSlotMigrating(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotImporting(final int slot, final String nodeId) {
    client.clusterSetSlotImporting(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Object> eval(String script) {
    return this.eval(script, 0, new String[0]);
  }

  public Response<Object> eval(String script, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<Object> eval(String script, int keyCount, String... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_RESULT);
  }

  public Response<Object> evalsha(String script) {
    return this.evalsha(script, 0, new String[0]);
  }

  public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<Object> evalsha(String sha1, int keyCount, String... params) {
    getClient(sha1).evalsha(sha1, keyCount, params);
    return getResponse(BuilderFactory.EVAL_RESULT);
  }

  public Response<Object> eval(byte[] script) {
    return this.eval(script, 0);
  }

  public Response<Object> eval(byte[] script, byte[] keyCount, byte[]... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
    byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  public Response<Object> evalsha(byte[] sha1) {
    return this.evalsha(sha1, 0);
  }

  public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
    byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
    getClient(sha1).evalsha(sha1, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  @Override
  public Response<Long> pfcount(String... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(final byte[]... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(String destkey, String... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_d56c729_55d591e/rev_d56c729-55d591e/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
=======
            if (filtered.testCount() == 0) {
                throw new NoTestsRemainException();
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
  protected void returnBrokenResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnBrokenResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisPool.java;<<<<<<< MINE
   protected void returnResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
  protected void returnBrokenResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  public void returnBrokenResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_00faaba_b42a861/rev_00faaba-b42a861/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
  protected void returnResource(final Jedis resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  public void returnResource(final Jedis resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public String set(final String key, final String value, final SetParams params) {
    return new JedisClusterCommand<String>(connectionHandler, timeout, maxRedirections) {
=======
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
=======
import java.net.URI;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import redis.clients.jedis.params.set.SetParams;
import redis.clients.util.Pool;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_6e2706b_7196dc6/rev_6e2706b-7196dc6/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
import java.net.URI;
import java.util.*;
import java.util.Map.Entry;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
    JedisClusterScriptingCommands {
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 2000;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public JedisCluster(Set<HostAndPort> nodes) {
    this(nodes, DEFAULT_TIMEOUT);
  }
=======
  private int maxRedirections;

  private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
=======
  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String ping() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.ping();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String quit() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.quit();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String flushDB() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.flushDB();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public Long dbSize() {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.dbSize();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String select(final int index) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.select(index);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String flushAll() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.flushAll();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String auth(final String password) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.auth(password);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String save() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.save();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String bgsave() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.bgsave();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String bgrewriteaof() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.bgrewriteaof();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public Long lastsave() {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.lastsave();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String shutdown() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.shutdown();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String info() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.info();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String info(final String section) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.info(section);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String slaveof(final String host, final int port) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.slaveof(host, port);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String slaveofNoOne() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.slaveofNoOne();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public int getDB() {
    return new JedisClusterCommand<Integer>(connectionHandler, maxRedirections) {
      @Override
      public Integer execute(Jedis connection) {
        return connection.getDB();
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String debug(final DebugParams params) {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.debug(params);
      }
    }.run(null);
  }

  /**
   * Deprecated, BasicCommands is not fit to JedisCluster, so it'll be removed
   */
  @Deprecated
  @Override
  public String configResetStat() {
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.configResetStat();
      }
    }.run(null);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }.run(null);
=======
    }.run(key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }.run(null);
=======
    }.run(key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }.run(null);
=======
    }.run(key);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
   * Test for "Issue - BinaryShardedJedis.disconnect() may occur memory leak".
   * You can find more detailed information at https://github.com/xetorthio/jedis/issues/808
   *
=======
   * Test for "Issue - BinaryShardedJedis.disconnect() may occur memory leak". You can find more
   * detailed information at https://github.com/xetorthio/jedis/issues/808
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
    
    //We set a name to the instance so it's easy to find it
=======

    // We set a name to the instance so it's easy to find it
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE

    for (String clientInfo : deadClient.clientList().split("\n")) {
      if (clientInfo.contains("DEAD")) {
        // Ugly, but cmon, it's a test.
        String[] hostAndPort = clientInfo.split(" ")[1].split("=")[1].split(":");
        // It would be better if we kill the client by Id as it's safer but jedis doesn't implement
        // the command yet.
        deadClient.clientKill(hostAndPort[0] + ":" + hostAndPort[1]);
      }
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/test/java/redis/clients/jedis/tests/ShardedJedisTest.java;<<<<<<< MINE
    assertEquals(true, deadClient.isConnected());
    assertEquals(false, deadClient.getClient().getSocket().isClosed());
    assertEquals(false, deadClient.getClient().isBroken()); // normal - not found

    shardedJedis.disconnect();

    assertEquals(false, deadClient.isConnected());
    assertEquals(true, deadClient.getClient().getSocket().isClosed());
    assertEquals(true, deadClient.getClient().isBroken());

    Jedis jedis2 = it.next();
    assertEquals(false, jedis2.isConnected());
    assertEquals(true, jedis2.getClient().getSocket().isClosed());
    assertEquals(false, jedis2.getClient().isBroken());

=======
    ClientKillerUtil.killClient(deadClient, "DEAD");

    assertEquals(true, deadClient.isConnected());
    assertEquals(false, deadClient.getClient().getSocket().isClosed());
    assertEquals(false, deadClient.getClient().isBroken()); // normal - not found

    shardedJedis.disconnect();

    assertEquals(false, deadClient.isConnected());
    assertEquals(true, deadClient.getClient().getSocket().isClosed());
    assertEquals(true, deadClient.getClient().isBroken());

    Jedis jedis2 = it.next();
    assertEquals(false, jedis2.isConnected());
    assertEquals(true, jedis2.getClient().getSocket().isClosed());
    assertEquals(false, jedis2.getClient().isBroken());

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
	MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}
=======
    JedisClusterScriptingCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    public JedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
	    int maxRedirections) {
        this(nodes, timeout, maxRedirections,
                new GenericObjectPoolConfig());
    }

    public JedisCluster(Set<HostAndPort> nodes,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, DEFAULT_TIMEOUT, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> nodes, int timeout,
        final GenericObjectPoolConfig poolConfig) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, poolConfig);
    }

    public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
        int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	super(jedisClusterNode, timeout, maxRedirections, poolConfig);
    }
    
    @Override
    public String set(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.set(key, value);
	    }
	}.run(key);
    }

    @Override
    public String set(final String key, final String value, final String nxxx,
                      final String expx, final long time) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.set(key, value, nxxx, expx, time);
            }
        }.run(key);
    }

    @Override
    public String get(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.get(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean exists(final String key) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.exists(key);
	    }
	}.run(key);
    }

    @Override
    public Long persist(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.persist(key);
	    }
	}.run(key);
    }

    @Override
    public String type(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.type(key);
	    }
	}.run(key);
    }

    @Override
    public Long expire(final String key, final int seconds) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.expire(key, seconds);
	    }
	}.run(key);
    }

    @Override
    public Long expireAt(final String key, final long unixTime) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.expireAt(key, unixTime);
	    }
	}.run(key);
    }

    @Override
    public Long ttl(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.ttl(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final boolean value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean setbit(final String key, final long offset,
	    final String value) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.setbit(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean getbit(final String key, final long offset) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.getbit(key, offset);
	    }
	}.run(key);
    }

    @Override
    public Long setrange(final String key, final long offset, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setrange(key, offset,
			value);
	    }
	}.run(key);
    }

    @Override
    public String getrange(final String key, final long startOffset,
	    final long endOffset) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getrange(key,
			startOffset, endOffset);
	    }
	}.run(key);
    }

    @Override
    public String getSet(final String key, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.getSet(key, value);
	    }
	}.run(key);
    }

    @Override
    public Long setnx(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.setnx(key, value);
	    }
	}.run(key);
    }

    @Override
    public String setex(final String key, final int seconds, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.setex(key, seconds,
			value);
	    }
	}.run(key);
    }

    @Override
    public Long decrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long decr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.decr(key);
	    }
	}.run(key);
    }

    @Override
    public Long incrBy(final String key, final long integer) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incrBy(key, integer);
	    }
	}.run(key);
    }

    @Override
    public Long incr(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.incr(key);
	    }
	}.run(key);
    }

    @Override
    public Long append(final String key, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.append(key, value);
	    }
	}.run(key);
    }

    @Override
    public String substr(final String key, final int start, final int end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.substr(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long hset(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.hset(key, field, value);
	    }
	}.run(key);
    }

    @Override
    public String hget(final String key, final String field) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hget(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hsetnx(final String key, final String field, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hsetnx(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public String hmset(final String key, final Map<String, String> hash) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.hmset(key, hash);
	    }
	}.run(key);
    }

    @Override
    public List<String> hmget(final String key, final String... fields) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hmget(key, fields);
	    }
	}.run(key);
    }

    @Override
    public Long hincrBy(final String key, final String field, final long value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hincrBy(key, field,
			value);
	    }
	}.run(key);
    }

    @Override
    public Boolean hexists(final String key, final String field) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.hexists(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hdel(final String key, final String... field) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hdel(key, field);
	    }
	}.run(key);
    }

    @Override
    public Long hlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.hlen(key);
	    }
	}.run(key);
    }

    @Override
    public Set<String> hkeys(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.hkeys(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> hvals(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.hvals(key);
	    }
	}.run(key);
    }

    @Override
    public Map<String, String> hgetAll(final String key) {
	return new JedisClusterCommand<Map<String, String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public Map<String, String> execute(Jedis connection) {
		return connection.hgetAll(key);
	    }
	}.run(key);
    }

    @Override
    public Long rpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long lpush(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpush(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long llen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.llen(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> lrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection
			.lrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String ltrim(final String key, final long start, final long end) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.ltrim(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public String lindex(final String key, final long index) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lindex(key, index);
	    }
	}.run(key);
    }

    @Override
    public String lset(final String key, final long index, final String value) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection
			.lset(key, index, value);
	    }
	}.run(key);
    }

    @Override
    public Long lrem(final String key, final long count, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.lrem(key, count, value);
	    }
	}.run(key);
    }

    @Override
    public String lpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.lpop(key);
	    }
	}.run(key);
    }

    @Override
    public String rpop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpop(key);
	    }
	}.run(key);
    }

    @Override
    public Long sadd(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sadd(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> smembers(final String key) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.smembers(key);
	    }
	}.run(key);
    }

    @Override
    public Long srem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.srem(key, member);
	    }
	}.run(key);
    }

    @Override
    public String spop(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.spop(key);
	    }
	}.run(key);
    }

    @Override
    public Long scard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.scard(key);
	    }
	}.run(key);
    }

    @Override
    public Boolean sismember(final String key, final String member) {
	return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Boolean execute(Jedis connection) {
		return connection.sismember(key, member);
	    }
	}.run(key);
    }

    @Override
    public String srandmember(final String key) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.srandmember(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> srandmember(final String key, final int count) {
        return new JedisClusterCommand<List<String>>(connectionHandler, timeout,
            maxRedirections) {
            @Override
            public List<String> execute(Jedis connection) {
            return connection.srandmember(key, count);
            }
        }.run(key);
    }

    @Override
    public Long strlen(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.strlen(key);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final double score, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zadd(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zadd(final String key, final Map<String, Double> scoreMembers) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection
			.zadd(key, scoreMembers);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrange(final String key, final long start, final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection
			.zrange(key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zrem(final String key, final String... member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrem(key, member);
	    }
	}.run(key);
    }

    @Override
    public Double zincrby(final String key, final double score,
	    final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zincrby(key, score,
			member);
	    }
	}.run(key);
    }

    @Override
    public Long zrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Long zrevrank(final String key, final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zrevrank(key, member);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrange(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrange(key, start,
			end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrangeWithScores(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection.zrevrangeWithScores(
			key, start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zcard(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcard(key);
	    }
	}.run(key);
    }

    @Override
    public Double zscore(final String key, final String member) {
	return new JedisClusterCommand<Double>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Double execute(Jedis connection) {
		return connection.zscore(key, member);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key);
	    }
	}.run(key);
    }

    @Override
    public List<String> sort(final String key,
	    final SortingParams sortingParameters) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.sort(key,
			sortingParameters);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final double min, final double max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long zcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final double min,
	    final double max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByScore(final String key, final String min,
	    final String max, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final double max,
	    final double min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final double min, final double max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrevrangeByScore(final String key, final String max,
	    final String min, final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrevrangeByScore(key,
			min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final String key,
	    final String min, final String max, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrangeByScoreWithScores(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final double max, final double min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final String key,
	    final String max, final String min, final int offset,
	    final int count) {
	return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<Tuple> execute(Jedis connection) {
		return connection
			.zrevrangeByScoreWithScores(key, max, min, offset,
				count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByRank(final String key, final long start,
	    final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByRank(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final double start,
	    final double end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByScore(final String key, final String start,
	    final String end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByScore(key,
			start, end);
	    }
	}.run(key);
    }
    
    @Override
    public Long zlexcount(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Set<String> zrangeByLex(final String key, final String min, final String max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.run(key);
    }

    @Override
    public Long zremrangeByLex(final String key, final String min, final String max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout, 
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.run(key);
    }

    @Override
    public Long linsert(final String key, final LIST_POSITION where,
	    final String pivot, final String value) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.linsert(key, where,
			pivot, value);
	    }
	}.run(key);
    }

    @Override
    public Long lpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.lpushx(key, string);
	    }
	}.run(key);
    }

    @Override
    public Long rpushx(final String key, final String... string) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.rpushx(key, string);
	    }
	}.run(key);
    }
    
    @Override
    public List<String> blpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, key);
	    }
	}.run(key);
    }

    @Override
    public List<String> brpop(final int timeout, final String key) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, key);
	    }
	}.run(key);
    }


    @Override
    public List<String> blpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(arg);
	    }
	}.run(arg);
    }

    @Override
    public List<String> brpop(final String arg) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(arg);
	    }
	}.run(arg);
    }

    @Override
    public Long del(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(key);
	    }
	}.run(key);
    }

    @Override
    public String echo(final String string) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.echo(string);
	    }
	}.run(null);
    }

    @Override
    public Long move(final String key, final int dbIndex) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.move(key, dbIndex);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long bitcount(final String key, final long start, final long end) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitcount(key, start,
			end);
	    }
	}.run(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
	return connectionHandler.getNodes();
    }

    @Override
    public ScanResult<Entry<String, String>> hscan(final String key,
	    final String cursor) {
	return new JedisClusterCommand<ScanResult<Entry<String, String>>>(
		connectionHandler, timeout, maxRedirections) {
	    @Override
	    public ScanResult<Entry<String, String>> execute(Jedis connection) {
		return connection.hscan(key, cursor);
	    }
	}.run(key);
    }
    
    @Override
    public ScanResult<String> sscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<String> execute(Jedis connection) {
		return connection.sscan(key, cursor);
	    }
	}.run(key);
    }
    
    @Override
    public ScanResult<Tuple> zscan(final String key, final String cursor) {
	return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public ScanResult<Tuple> execute(Jedis connection) {
		return connection.zscan(key, cursor);
	    }
	}.run(key);
    }

    @Override
    public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler,
        timeout, maxRedirections) {
        @Override
        public Object execute(Jedis connection) {
=======
  public static enum Reset {
    SOFT, HARD
  }

  public JedisCluster(Set<HostAndPort> nodes) {
    this(nodes, DEFAULT_TIMEOUT);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout) {
    this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, int maxRedirections) {
    this(nodes, timeout, maxRedirections, new GenericObjectPoolConfig());
  }

  public JedisCluster(Set<HostAndPort> nodes, final GenericObjectPoolConfig poolConfig) {
    this(nodes, DEFAULT_TIMEOUT, DEFAULT_MAX_REDIRECTIONS, poolConfig);
  }

  public JedisCluster(Set<HostAndPort> nodes, int timeout, final GenericObjectPoolConfig poolConfig) {
    this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, poolConfig);
  }

  public JedisCluster(Set<HostAndPort> jedisClusterNode, int timeout, int maxRedirections,
      final GenericObjectPoolConfig poolConfig) {
    super(jedisClusterNode, timeout, maxRedirections, poolConfig);
  }

  public Map<String, JedisPool> getClusterNodes() {
    return connectionHandler.getNodes();
  }

  @Override
  public Object eval(final String script, final int keyCount, final String... params) {
    return new JedisClusterCommand<Object>(connectionHandler, maxRedirections) {
      @Override
      public Object execute(Jedis connection) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
    }
    
    @Override
    public String scriptLoad(final String script, final String key) {
        return new JedisClusterCommand<String>(connectionHandler,
                timeout, maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.scriptLoad(script);
            }
        }.run(key);
    }

    @Override
    public Long pfadd(final String key, final String... elements) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfadd(key, elements);
	    }
	}.run(key);
    }

    @Override
    public long pfcount(final String key) {
	return new JedisClusterCommand<Long>(connectionHandler, 
		timeout, maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(key);
	    }
	}.run(key);
    }

    @Override
    public Long del(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> blpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.run(keys.length, keys);

    }
    
    @Override
    public List<String> brpop(final int timeout, final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public List<String> mget(final String... keys) {
	return new JedisClusterCommand<List<String>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<String> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.run(keys.length - 1, keys);
    }

    @Override
    public String mset(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long msetnx(final String... keysvalues) {
	String[] keys = new String[keysvalues.length / 2];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public String rename(final String oldkey, final String newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final String oldkey, final String newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.run(2, oldkey, newkey);
    }

    @Override
    public String rpoplpush(final String srckey, final String dstkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Set<String> sdiff(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Set<String> sinter(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sinterstore(final String dstkey, final String... keys) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long smove(final String srckey, final String dstkey,
	    final String member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.run(2, srckey, dstkey);
    }

    @Override
    public Long sort(final String key, final SortingParams sortingParameters,
	    final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Long sort(final String key, final String dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.run(2, key, dstkey);
    }

    @Override
    public Set<String> sunion(final String... keys) {
	return new JedisClusterCommand<Set<String>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<String> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.run(keys.length, keys);
    }

    @Override
    public Long sunionstore(final String dstkey, final String... keys) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final String... sets) {
	String[] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.run(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public Long zunionstore(final String dstkey, final ZParams params,
	    final String... sets) {
	String[] mergedKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String brpoplpush(final String source, final String destination,
	    final int timeout) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.run(2, source, destination);
    }

    @Override
    public Long publish(final String channel, final String message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final JedisPubSub jedisPubSub,
	    final String... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final JedisPubSub jedisPubSub,
	    final String... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final String destKey,
	    final String... srcKeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public String pfmerge(final String destkey, final String... sourcekeys) {
	String[] mergedKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.run(mergedKeys.length, mergedKeys);
    }

    @Override
    public long pfcount(final String... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.run(keys.length, keys);
    }

=======
  }

  @Override
  public Set<String> zrevrangeByScore(final String key, final String max, final String min,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByScore(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrangeByScoreWithScores(final String key, final String min, final String max) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrangeByScoreWithScores(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final String max, final String min) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrangeByScoreWithScores(key, min, max, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final double max,
      final double min, final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<Tuple> zrevrangeByScoreWithScores(final String key, final String max,
      final String min, final int offset, final int count) {
    return new JedisClusterCommand<Set<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public Set<Tuple> execute(Jedis connection) {
        return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByRank(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByRank(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByScore(final String key, final double start, final double end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByScore(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByScore(final String key, final String start, final String end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByScore(key, start, end);
      }
    }.run(key);
  }

  @Override
  public Long zlexcount(final String key, final String min, final String max) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zlexcount(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrangeByLex(final String key, final String min, final String max) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrangeByLex(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrangeByLex(final String key, final String min, final String max,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrangeByLex(key, min, max, offset, count);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrevrangeByLex(final String key, final String max, final String min) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByLex(key, max, min);
      }
    }.run(key);
  }

  @Override
  public Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count) {
    return new JedisClusterCommand<Set<String>>(connectionHandler, maxRedirections) {
      @Override
      public Set<String> execute(Jedis connection) {
        return connection.zrevrangeByLex(key, max, min, offset, count);
      }
    }.run(key);
  }

  @Override
  public Long zremrangeByLex(final String key, final String min, final String max) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.zremrangeByLex(key, min, max);
      }
    }.run(key);
  }

  @Override
  public Long linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.linsert(key, where, pivot, value);
      }
    }.run(key);
  }

  @Override
  public Long lpushx(final String key, final String... string) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.lpushx(key, string);
      }
    }.run(key);
  }

  @Override
  public Long rpushx(final String key, final String... string) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.rpushx(key, string);
      }
    }.run(key);
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Override
  @Deprecated
  public List<String> blpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.blpop(arg);
      }
    }.run(arg);
  }

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Override
  @Deprecated
  public List<String> brpop(final String arg) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.brpop(arg);
      }
    }.run(arg);
  }

  @Override
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.del(key);
      }
    }.run(key);
  }

  @Override
  public String echo(final String string) {
    // note that it'll be run from arbitary node
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.echo(string);
      }
    }.run(string);
  }

  @Override
  public Long move(final String key, final int dbIndex) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.move(key, dbIndex);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key, start, end);
      }
    }.run(key);
  }

  @Override
  public ScanResult<Entry<String, String>> hscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<Entry<String, String>>>(connectionHandler,
        maxRedirections) {
      @Override
      public ScanResult<Entry<String, String>> execute(Jedis connection) {
        return connection.hscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public ScanResult<String> sscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<String>>(connectionHandler, maxRedirections) {
      @Override
      public ScanResult<String> execute(Jedis connection) {
        return connection.sscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public ScanResult<Tuple> zscan(final String key, final String cursor) {
    return new JedisClusterCommand<ScanResult<Tuple>>(connectionHandler, maxRedirections) {
      @Override
      public ScanResult<Tuple> execute(Jedis connection) {
        return connection.zscan(key, cursor);
      }
    }.run(key);
  }

  @Override
  public Long pfadd(final String key, final String... elements) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.pfadd(key, elements);
      }
    }.run(key);
  }

  @Override
  public long pfcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.pfcount(key);
      }
    }.run(key);
  }

  @Override
  public List<String> blpop(final int timeout, final String key) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.blpop(timeout, key);
      }
    }.run(key);
  }

  @Override
  public List<String> brpop(final int timeout, final String key) {
    return new JedisClusterCommand<List<String>>(connectionHandler, maxRedirections) {
      @Override
      public List<String> execute(Jedis connection) {
        return connection.brpop(timeout, key);
      }
    }.run(key);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/JedisClusterCommand.java;<<<<<<< MINE
        
        return runWithRetries(keys[0], this.redirections, false, false);
    }
    
    public T runWithAnyNode() {
	Jedis connection = null;
	try {
	    connection = connectionHandler.getConnection();
	    return execute(connection);
	} catch (JedisConnectionException e) {
	    releaseConnection(connection, true);
	    throw e;
	} finally {
	    releaseConnection(connection, false);
	}
    }
=======
      }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
	MultiKeyBinaryJedisClusterCommands, JedisClusterBinaryScriptingCommands, 
	Closeable {
    
    public static final short HASHSLOTS = 16384;
    protected static final int DEFAULT_TIMEOUT = 1;
    protected static final int DEFAULT_MAX_REDIRECTIONS = 5;

    protected int timeout;
    protected int maxRedirections;

    protected JedisClusterConnectionHandler connectionHandler;
    
    public BinaryJedisCluster(Set<HostAndPort> nodes, int timeout) {
	this(nodes, timeout, DEFAULT_MAX_REDIRECTIONS, new GenericObjectPoolConfig());
    }

    public BinaryJedisCluster(Set<HostAndPort> nodes) {
	this(nodes, DEFAULT_TIMEOUT);
    }

    public BinaryJedisCluster(Set<HostAndPort> jedisClusterNode, int timeout,
	    int maxRedirections, final GenericObjectPoolConfig poolConfig) {
	this.connectionHandler = new JedisSlotBasedConnectionHandler(
		jedisClusterNode, poolConfig);
	this.timeout = timeout;
	this.maxRedirections = maxRedirections;
    }

    @Override
    public String set(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
        maxRedirections) {
            @Override
            public String execute(Jedis connection) {
            return connection.set(key, value);
            }
        }.runBinary(key);
    }
 
    @Override
    public byte[] get(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.get(key);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean exists(final byte[] key) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.exists(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long persist(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.persist(key);
            }
        }.runBinary(key);
    }

    @Override
    public String type(final byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.type(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long expire(final byte[] key, final int seconds) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expire(key, seconds);
            }
        }.runBinary(key);
    }

    @Override
    public Long expireAt(final byte[] key, final long unixTime) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.expireAt(key, unixTime);
            }
        }.runBinary(key);
    }

    @Override
    public Long ttl(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.ttl(key);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean setbit(final byte[] key, final long offset, final boolean value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }
    
    @Override
    public Boolean setbit(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.setbit(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean getbit(final byte[] key, final long offset) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.getbit(key, offset);
            }
        }.runBinary(key);
    }

    @Override
    public Long setrange(final byte[] key, final long offset, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setrange(key, offset, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getrange(final byte[] key, final long startOffset, final long endOffset) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getrange(key, startOffset, endOffset);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] getSet(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.getSet(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long setnx(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.setnx(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public String setex(final byte[] key, final int seconds, final byte[] value) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.setex(key, seconds, value);
            }
        }.runBinary(key);
    }

    @Override
    public Long decrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Long decr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.decr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long incrBy(final byte[] key, final long integer) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incrBy(key, integer);
            }
        }.runBinary(key);
    }

    @Override
    public Double incrByFloat(final byte[] key, final double value) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) { return connection.incrByFloat(key, value); }
        }.runBinary(key);
    }

    @Override
    public Long incr(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.incr(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long append(final byte[] key, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.append(key, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] substr(final byte[] key, final int start, final int end) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.substr(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long hset(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hset(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] hget(final byte[] key, final byte[] field) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.hget(key, field);
            }
        }.runBinary(key);
    }

    @Override
    public Long hsetnx(final byte[] key, final byte[] field, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.hsetnx(key, field, value);
            }
        }.runBinary(key);
    }

    @Override
    public String hmset(final byte[] key, final Map<byte[], byte[]> hash) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public String execute(Jedis connection) {
                return connection.hmset(key, hash);
            }
        }.runBinary(key);
    }

    @Override
    public List<byte[]> hmget(final byte[] key, final byte[]... fields) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.hmget(key, fields);
            }
        }.runBinary(key);
    }
=======
    JedisClusterBinaryScriptingCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_4a9b82a_18308d1/rev_4a9b82a-18308d1/src/main/java/redis/clients/jedis/BinaryJedisCluster.java;<<<<<<< MINE
    @Override
    public Long lrem(final byte[] key, final long count, final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.lrem(key, count, value);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] lpop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.lpop(key);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] rpop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.rpop(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long sadd(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.sadd(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> smembers(final byte[] key) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.smembers(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long srem(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.srem(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] spop(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.spop(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long scard(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.scard(key);
            }
        }.runBinary(key);
    }

    @Override
    public Boolean sismember(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Boolean>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Boolean execute(Jedis connection) {
                return connection.sismember(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public byte[] srandmember(final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public byte[] execute(Jedis connection) {
                return connection.srandmember(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long strlen(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.strlen(key);
            }
        }.runBinary(key);
    }

    @Override
    public Long zadd(final byte[] key, final double score, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zadd(key, score, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zadd(final byte[] key, final Map<byte[], Double> scoreMembers) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zadd(key, scoreMembers);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrange(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrange(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrem(final byte[] key, final byte[]... member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrem(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Double zincrby(final byte[] key, final double score, final byte[] member) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) {
                return connection.zincrby(key, score, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrank(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrank(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Long zrevrank(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zrevrank(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrange(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrevrange(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeWithScores(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<Tuple> execute(Jedis connection) {
                return connection.zrangeWithScores(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeWithScores(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<Tuple> execute(Jedis connection) {
                return connection.zrevrangeWithScores(key, start, end);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcard(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcard(key);
            }
        }.runBinary(key);
    }

    @Override
    public Double zscore(final byte[] key, final byte[] member) {
        return new JedisClusterCommand<Double>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Double execute(Jedis connection) {
                return connection.zscore(key, member);
            }
        }.runBinary(key);
    }

    @Override
    public List<byte[]> sort(final byte[] key) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.sort(key);
            }
        }.runBinary(key);
    }

    
    @Override
    public List<byte[]> sort(final byte[] key, final SortingParams sortingParameters) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public List<byte[]> execute(Jedis connection) {
                return connection.sort(key, sortingParameters);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcount(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcount(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Long zcount(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) {
                return connection.zcount(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrangeByScore(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Set<byte[]> execute(Jedis connection) {
                return connection.zrangeByScore(key, min, max);
            }
        }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max,min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final double min, final double max, final int offset,
	    final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrangeByScore(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByScore(final byte[] key, final byte[] min, final byte[] max, final int offset,
	    final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrangeByScore(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final double max, final double min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final double min, final double max,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<byte[]> zrevrangeByScore(final byte[] key, final byte[] max, final byte[] min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<byte[]> execute(Jedis connection) {
             return connection.zrevrangeByScore(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrangeByScoreWithScores(final byte[] key, final byte[] min, final byte[] max,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrangeByScoreWithScores(key, min, max, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final double max, final double min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
             }
         }.runBinary(key);
    }

    @Override
    public Set<Tuple> zrevrangeByScoreWithScores(final byte[] key, final byte[] max, final byte[] min,
	    final int offset, final int count) {
        return new JedisClusterCommand<Set<Tuple>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Set<Tuple> execute(Jedis connection) {
             return connection.zrevrangeByScoreWithScores(key, max, min, offset, count);
             }
         }.runBinary(key);
    }
	    
    @Override
    public Long zremrangeByRank(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByRank(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long zremrangeByScore(final byte[] key, final double start, final double end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByScore(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long zremrangeByScore(final byte[] key, final byte[] start, final byte[] end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.zremrangeByScore(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long linsert(final byte[] key, final Client.LIST_POSITION where, final byte[] pivot,
	    final byte[] value) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.linsert(key, where, pivot, value);
             }
         }.runBinary(key);
    }

    @Override
    public Long lpushx(final byte[] key, final byte[]... arg) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.lpushx(key, arg);
             }
         }.runBinary(key);
    }

    @Override
    public Long rpushx(final byte[] key, final byte[]... arg) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.rpushx(key, arg);
             }
         }.runBinary(key);
    }

    @Override
    public List<byte[]> blpop(final byte[] arg) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public List<byte[]> execute(Jedis connection) {
             return connection.blpop(arg);
             }
         }.runBinary(arg);
    }

    @Override
    public List<byte[]> brpop(final byte[] arg) {
        return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public List<byte[]> execute(Jedis connection) {
             return connection.brpop(arg);
             }
         }.runBinary(arg);
    }

    @Override
    public Long del(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.del(key);
             }
         }.runBinary(key);
    }

    @Override
    public byte[] echo(final byte[] arg) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public byte[] execute(Jedis connection) {
             return connection.echo(arg);
             }
         }.runBinary(null);
    }

    @Override 
    public Long move(final byte[] key, final int dbIndex) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.move(key, dbIndex);
             }
         }.runBinary(null);
    }

    @Override
    public Long bitcount(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.bitcount(key);
             }
         }.runBinary(key);
    }

    @Override
    public Long bitcount(final byte[] key, final long start, final long end) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
             @Override
             public Long execute(Jedis connection) {
             return connection.bitcount(key, start, end);
             }
         }.runBinary(key);
    }

    @Override
    public Long pfadd(final byte[] key, final byte[]... elements) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) { return connection.pfadd(key, elements); }
        }.runBinary(key);
    }

    @Override
    public long pfcount(final byte[] key) {
        return new JedisClusterCommand<Long>(connectionHandler, timeout,
                maxRedirections) {
            @Override
            public Long execute(Jedis connection) { return connection.pfcount(key); }
        }.runBinary(key);
    }
    
    @Override
    public List<byte[]> srandmember(final byte[] key, final int count) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.srandmember(key, count);
	    }
	}.runBinary(key);
    }

    @Override
    public Long zlexcount(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zlexcount(key, min, max);
	    }
	}.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max);
	    }
	}.runBinary(key);
    }

    @Override
    public Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
	    final int offset, final int count) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.zrangeByLex(key, min, max, offset, count);
	    }
	}.runBinary(key);
    }

    @Override
    public Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zremrangeByLex(key, min, max);
	    }
	}.runBinary(key);
    }

    public Map<String, JedisPool> getClusterNodes() {
        return connectionHandler.getNodes();
    }
    
    @Override
    public Object eval(final byte[] script, final byte[] keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keyCount, params);
                }
            }.runBinary(Integer.parseInt(SafeEncoder.encode(keyCount)), params);
    }

    @Override
    public Object eval(final byte[] script, final int keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keyCount, params);
                }
            }.runBinary(keyCount, params);
    }

    @Override
    public Object eval(final byte[] script, final List<byte[]> keys, final List<byte[]> args) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script, keys, args);
                }
            }.runBinary(keys.size(), keys.toArray(new byte[keys.size()][]));
    }

    @Override
    public Object eval(final byte[] script, byte[] key) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.eval(script);
                }
            }.runBinary(key);
    }

    @Override
    public Object evalsha(final byte[] script, byte[] key) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(script);
                }
            }.runBinary(key);
    }

    @Override
    public Object evalsha(final byte[] sha1, final List<byte[]> keys, final List<byte[]> args) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(sha1, keys, args);
                }
            }.runBinary(keys.size(), keys.toArray(new byte[keys.size()][]));
    }

    @Override
    public Object evalsha(final byte[] sha1, final int keyCount, final byte[]... params) {
        return new JedisClusterCommand<Object>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public Object execute(Jedis connection) {
                return connection.evalsha(sha1, keyCount, params);
                }
            }.runBinary(keyCount, params);
    }
    
    @Override
    public List<Long> scriptExists(final byte[] key, final byte[][] sha1) {
        return new JedisClusterCommand<List<Long>>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public List<Long> execute(Jedis connection) {
                return connection.scriptExists(sha1);
                }
            }.runBinary(key);
    }
    
    @Override
    public byte[] scriptLoad(final byte[] script, final byte[] key) {
        return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public byte[] execute(Jedis connection) {
                return connection.scriptLoad(script);
                }
            }.runBinary(key);
    }
    
    @Override
    public String scriptFlush(final byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public String execute(Jedis connection) {
                return connection.scriptFlush();
                }
            }.runBinary(key);
    }
    
    @Override
    public String scriptKill(byte[] key) {
        return new JedisClusterCommand<String>(connectionHandler, timeout,
                maxRedirections) {
                @Override
                public String execute(Jedis connection) {
                return connection.scriptKill();
                }
            }.runBinary(key);
    }
    
    @Override
    public Long del(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.del(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> blpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.blpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> brpop(final int timeout, final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.brpop(timeout, keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public List<byte[]> mget(final byte[]... keys) {
	return new JedisClusterCommand<List<byte[]>>(connectionHandler,
		timeout, maxRedirections) {
	    @Override
	    public List<byte[]> execute(Jedis connection) {
		return connection.mget(keys);
	    }
	}.runBinary(keys.length - 1, keys);
    }

    @Override
    public String mset(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.mset(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long msetnx(final byte[]... keysvalues) {
	byte[][] keys = new byte[keysvalues.length / 2][];

	for (int keyIdx = 0; keyIdx < keys.length; keyIdx++) {
	    keys[keyIdx] = keysvalues[keyIdx * 2];
	}

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.msetnx(keysvalues);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public String rename(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.rename(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public Long renamenx(final byte[] oldkey, final byte[] newkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.renamenx(oldkey, newkey);
	    }
	}.runBinary(2, oldkey, newkey);
    }

    @Override
    public byte[] rpoplpush(final byte[] srckey, final byte[] dstkey) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.rpoplpush(srckey, dstkey);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Set<byte[]> sdiff(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sdiff(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sdiffstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sdiffstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Set<byte[]> sinter(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sinter(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sinterstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sinterstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long smove(final byte[] srckey, final byte[] dstkey,
	    final byte[] member) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.smove(srckey, dstkey, member);
	    }
	}.runBinary(2, srckey, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final SortingParams sortingParameters,
	    final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, sortingParameters, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Long sort(final byte[] key, final byte[] dstkey) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sort(key, dstkey);
	    }
	}.runBinary(2, key, dstkey);
    }

    @Override
    public Set<byte[]> sunion(final byte[]... keys) {
	return new JedisClusterCommand<Set<byte[]>>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Set<byte[]> execute(Jedis connection) {
		return connection.sunion(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public Long sunionstore(final byte[] dstkey, final byte[]... keys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, keys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.sunionstore(dstkey, keys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zinterstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zinterstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long zunionstore(final byte[] dstkey, final ZParams params,
	    final byte[]... sets) {
	byte[][] wholeKeys = KeyMergeUtil.merge(dstkey, sets);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.zunionstore(dstkey, params, sets);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public byte[] brpoplpush(final byte[] source, final byte[] destination,
	    final int timeout) {
	return new JedisClusterCommand<byte[]>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public byte[] execute(Jedis connection) {
		return connection.brpoplpush(source, destination, timeout);
	    }
	}.runBinary(2, source, destination);
    }

    @Override
    public Long publish(final byte[] channel, final byte[] message) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.publish(channel, message);
	    }
	}.runWithAnyNode();
    }

    @Override
    public void subscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... channels) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, channels);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public void psubscribe(final BinaryJedisPubSub jedisPubSub,
	    final byte[]... patterns) {
	new JedisClusterCommand<Integer>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Integer execute(Jedis connection) {
		connection.subscribe(jedisPubSub, patterns);
		return 0;
	    }
	}.runWithAnyNode();
    }

    @Override
    public Long bitop(final BitOP op, final byte[] destKey,
	    final byte[]... srcKeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destKey, srcKeys);

	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.bitop(op, destKey, srcKeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public String pfmerge(final byte[] destkey, final byte[]... sourcekeys) {
	byte[][] wholeKeys = KeyMergeUtil.merge(destkey, sourcekeys);

	return new JedisClusterCommand<String>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public String execute(Jedis connection) {
		return connection.pfmerge(destkey, sourcekeys);
	    }
	}.runBinary(wholeKeys.length, wholeKeys);
    }

    @Override
    public Long pfcount(final byte[]... keys) {
	return new JedisClusterCommand<Long>(connectionHandler, timeout,
		maxRedirections) {
	    @Override
	    public Long execute(Jedis connection) {
		return connection.pfcount(keys);
	    }
	}.runBinary(keys.length, keys);
    }

    @Override
    public void close() throws IOException {
	if (connectionHandler != null) {
	    for (JedisPool pool : connectionHandler.getNodes().values()) {
		try {
		    if (pool != null) {
			pool.destroy();
		    }
		} catch (Exception e) {
		    // pass
		}
	    }
	}	
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8558487_ca59f9b/rev_8558487-ca59f9b/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
=======
   * @deprecated use BinaryJedis.pexpire(byte[], long) or Jedis.pexpire(String,long) Set a timeout
   *             on the specified key. After the timeout the key will be automatically deleted by
   *             the server. A key with an associated timeout is said to be volatile in Redis
   *             terminology.
   *             <p>
   *             Voltile keys are stored on disk like the other keys, the timeout is persistent too
   *             like all the other aspects of the dataset. Saving a dataset containing expires and
   *             stopping the server does not stop the flow of time as Redis stores on disk the time
   *             when the key will no longer be available as Unix time, and not the remaining
   *             milliseconds.
   *             <p>
   *             Since Redis 2.1.3 you can update the value of the timeout of a key already having
   *             an expire set. It is also possible to undo the expire at all turning the key into a
   *             normal key using the {@link #persist(byte[]) PERSIST} command.
   *             <p>
   *             Time complexity: O(1)
   * @see <ahref="http://redis.io/commands/pexpire">PEXPIRE Command</a>
   * @param key
   * @param milliseconds
   * @return Integer reply, specifically: 1: the timeout was set. 0: the timeout was not set since
   *         the key already has an associated timeout (this may happen only in Redis versions <
   *         2.1.3, Redis >= 2.1.3 will happily update the timeout), or the key does not exist.
   */
  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8558487_ca59f9b/rev_8558487-ca59f9b/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, timeout, maxRedirections) {
=======
  public Long del(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.del(key);
      }
    }.run(key);
  }

  @Override
  public String echo(final String string) {
    // note that it'll be run from arbitary node
    return new JedisClusterCommand<String>(connectionHandler, maxRedirections) {
      @Override
      public String execute(Jedis connection) {
        return connection.echo(string);
      }
    }.run(string);
  }

  @Override
  public Long bitcount(final String key) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
      @Override
      public Long execute(Jedis connection) {
        return connection.bitcount(key);
      }
    }.run(key);
  }

  @Override
  public Long bitcount(final String key, final long start, final long end) {
    return new JedisClusterCommand<Long>(connectionHandler, maxRedirections) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8558487_ca59f9b/rev_8558487-ca59f9b/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE
=======

  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    Jedis j = getShard(key);
    return j.pexpire(key, milliseconds);
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/main/java/org/junit/internal/runners/rules/RuleFieldValidator.java;<<<<<<< MINE
    @SuppressWarnings("deprecation")
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.hasItem;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.hasItem;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
import java.lang.annotation.Annotation;
import java.util.ArrayList;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
    	@Rule
    	public String fieldThatShouldBeMatched = "andromeda";

    	@Rule
    	public boolean fieldThatShouldNotBeMachted;
=======
        @Rule
        public String fieldC= "andromeda";

        @Rule
        public boolean fieldA;
    	
        @Rule
        public boolean fieldB;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
    	@Ignore
    	@Test
    	public String methodToBeMatched() {
    		return "jupiter";
    	}

    	@Ignore
    	@Test
    	public int methodOfWrongType() {
    		return 0;
=======
        @Ignore
        @Test
        public int methodC() {
            return 0;
        }

        @Ignore
        @Test
        public String methodA() {
            return "jupiter";
        }
    	
        @Ignore
        @Test
        public int methodB() {
            return 0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE

    @Test
    public void annotationToMethods() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        assertThat(methods.size(), is(2));
    }

    @Test
    public void annotationToMethodsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        exception.expect(UnsupportedOperationException.class);
        annotationToMethods.put(Ignore.class, null);
    }

    @Test
    public void annotationToMethodsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        exception.expect(UnsupportedOperationException.class);
        methods.add(null);
    }

    @Test
    public void annotationToFields() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        assertThat(fields.size(), is(2));
    }

    @Test
    public void annotationToFieldsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        exception.expect(UnsupportedOperationException.class);
        annotationToFields.put(Rule.class, null);
    }

    @Test
    public void annotationToFieldsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        exception.expect(UnsupportedOperationException.class);
        fields.add(null);
    }

    public static class MultipleFieldsAnnotated {
        @DataPoint
        public String a = "testing a";

        @Rule
        public boolean b;

        @DataPoint
        public String c = "testing c";

        @Rule
        public boolean d;
    }

    @Test
    public void annotationToFieldsReturnsKeysInADeterministicOrder() {
        TestClass tc = new TestClass(MultipleFieldsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<Class<? extends Annotation>> keys = new ArrayList<Class<? extends Annotation>>();
        for (Class<? extends Annotation> annotation : annotationToFields.keySet()) {
            keys.add(annotation);
        }
        assertThat(keys.get(0), CoreMatchers.<Class<? extends Annotation>>is(DataPoint.class));
        assertThat(keys.get(1), CoreMatchers.<Class<? extends Annotation>>is(Rule.class));
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f03bc79_eb8b5ee/rev_f03bc79-eb8b5ee/src/test/java/org/junit/tests/AllTests.java;<<<<<<< MINE
        JUnitCoreTest.class,
        FailOnTimeoutTest.class
=======
        FrameworkFieldTest.class,
        FrameworkMethodTest.class,
        JUnitCoreTest.class
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_60c1bdf_8851c49/rev_60c1bdf-8851c49/src/main/java/redis/clients/util/Pool.java;<<<<<<< MINE
  protected void returnResourceObject(final T resource) {
=======
  /**
   * @deprecated starting from Jedis 3.0 this method won't exist. Resouce cleanup should be done
   *             using @see {@link redis.clients.jedis.Jedis#close()}
   */
  @Deprecated
  public void returnResourceObject(final T resource) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
   * @param nxxx NX|XX, NX -- Only set the key if it does not already exist. XX -- Only set the key
   *          if it already exist.
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of <code>expx</code>
=======
   * @param params
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final long time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
=======
  public String set(final byte[] key, final byte[] value, final SetParams params) {
    checkIsInMulti();
    client.set(key, value, params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  public String set(final byte[] key, final byte[] value, final byte[] nxxx) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx);
    return client.getStatusCodeReply();
  }

  public String set(final byte[] key, final byte[] value, final byte[] nxxx, final byte[] expx,
      final int time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
    return client.getStatusCodeReply();
  }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryClient.java;<<<<<<< MINE

  public void readonly() {
    sendCommand(READONLY);
  }
=======
  
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisClusterCommands,
    MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.jedis.params.set.SetParams;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 2000;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
   * @param expx EX|PX, expire time units: EX = seconds; PX = milliseconds
   * @param time expire time in the units of <code>expx</code>
=======
   *          EX|PX, expire time units: EX = seconds; PX = milliseconds
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
  @Override
  public String set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    checkIsInMultiOrPipeline();
    client.set(key, value, nxxx, expx, time);
=======
  public String set(final String key, final String value, final SetParams params) {
    checkIsInMulti();
    client.set(key, value, params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time) {
    set(SafeEncoder.encode(key), SafeEncoder.encode(value), SafeEncoder.encode(nxxx),
      SafeEncoder.encode(expx), time);
=======
  public void set(final String key, final String value, final SetParams params) {
    set(SafeEncoder.encode(key), SafeEncoder.encode(value), params);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE
  @Override
  public String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time) {
=======
  public String set(byte[] key, byte[] value, SetParams params) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryJedisClusterCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

public interface BinaryJedisClusterCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Double zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

/**
 * Common interface for sharded and non-sharded Jedis
 */
public interface JedisCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Long pttl(final String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  String psetex(final String key, final long milliseconds, final String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Double hincrByFloat(final String key, final String field, final double value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, double score, String member, ZAddParams params);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Long zadd(String key, Map<String, Double> scoreMembers, ZAddParams params);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Double zincrby(String key, double score, String member, ZIncrByParams params);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long move(String key, int dbIndex);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  Long bitpos(final String key, final boolean value);

  Long bitpos(final String key, final boolean value, final BitPosParams params);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor,
      final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor, final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor, final ScanParams params);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryRedisPipeline.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.List;
import java.util.Map;
import java.util.Set;

public interface BinaryRedisPipeline {
  Response<Long> append(byte[] key, byte[] value);

  Response<List<byte[]>> blpop(byte[] arg);

  Response<List<byte[]>> brpop(byte[] arg);

  Response<Long> decr(byte[] key);

  Response<Long> decrBy(byte[] key, long integer);

  Response<Long> del(byte[] keys);

  Response<byte[]> echo(byte[] string);

  Response<Boolean> exists(byte[] key);

  Response<Long> expire(byte[] key, int seconds);

  Response<Long> pexpire(byte[] key, long milliseconds);

  Response<Long> expireAt(byte[] key, long unixTime);

  Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp);

  Response<byte[]> get(byte[] key);

  Response<Boolean> getbit(byte[] key, long offset);

  Response<byte[]> getSet(byte[] key, byte[] value);

  Response<byte[]> getrange(byte[] key, long startOffset, long endOffset);

  Response<Long> hdel(byte[] key, byte[]... field);

  Response<Boolean> hexists(byte[] key, byte[] field);

  Response<byte[]> hget(byte[] key, byte[] field);

  Response<Map<byte[], byte[]>> hgetAll(byte[] key);

  Response<Long> hincrBy(byte[] key, byte[] field, long value);

  Response<Set<byte[]>> hkeys(byte[] key);

  Response<Long> hlen(byte[] key);

  Response<List<byte[]>> hmget(byte[] key, byte[]... fields);

  Response<String> hmset(byte[] key, Map<byte[], byte[]> hash);

  Response<Long> hset(byte[] key, byte[] field, byte[] value);

  Response<Long> hsetnx(byte[] key, byte[] field, byte[] value);

  Response<List<byte[]>> hvals(byte[] key);

  Response<Long> incr(byte[] key);

  Response<Long> incrBy(byte[] key, long integer);

  Response<byte[]> lindex(byte[] key, long index);

  Response<Long> linsert(byte[] key, BinaryClient.LIST_POSITION where, byte[] pivot, byte[] value);

  Response<Long> llen(byte[] key);

  Response<byte[]> lpop(byte[] key);

  Response<Long> lpush(byte[] key, byte[]... string);

  Response<Long> lpushx(byte[] key, byte[]... bytes);

  Response<List<byte[]>> lrange(byte[] key, long start, long end);

  Response<Long> lrem(byte[] key, long count, byte[] value);

  Response<String> lset(byte[] key, long index, byte[] value);

  Response<String> ltrim(byte[] key, long start, long end);

  Response<Long> move(byte[] key, int dbIndex);

  Response<Long> persist(byte[] key);

  Response<byte[]> rpop(byte[] key);

  Response<Long> rpush(byte[] key, byte[]... string);

  Response<Long> rpushx(byte[] key, byte[]... string);

  Response<Long> sadd(byte[] key, byte[]... member);

  Response<Long> scard(byte[] key);

  Response<String> set(byte[] key, byte[] value);

  Response<Boolean> setbit(byte[] key, long offset, byte[] value);

  Response<Long> setrange(byte[] key, long offset, byte[] value);

  Response<String> setex(byte[] key, int seconds, byte[] value);

  Response<Long> setnx(byte[] key, byte[] value);

  Response<Long> setrange(String key, long offset, String value);

  Response<Set<byte[]>> smembers(byte[] key);

  Response<Boolean> sismember(byte[] key, byte[] member);

  Response<List<byte[]>> sort(byte[] key);

  Response<List<byte[]>> sort(byte[] key, SortingParams sortingParameters);

  Response<byte[]> spop(byte[] key);

  Response<Set<byte[]>> spop(byte[] key, long count);

  Response<byte[]> srandmember(byte[] key);

  Response<Long> srem(byte[] key, byte[]... member);

  Response<Long> strlen(byte[] key);

  Response<String> substr(byte[] key, int start, int end);

  Response<Long> ttl(byte[] key);

  Response<String> type(byte[] key);

  Response<Long> zadd(byte[] key, double score, byte[] member);

  Response<Long> zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Response<Long> zcard(byte[] key);

  Response<Long> zcount(byte[] key, double min, double max);

  Response<Double> zincrby(byte[] key, double score, byte[] member);

  Response<Double> zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Response<Set<byte[]>> zrange(byte[] key, long start, long end);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max, int offset,
      int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset,
      int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset,
      int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset,
      int count);

  Response<Set<Tuple>> zrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrank(byte[] key, byte[] member);

  Response<Long> zrem(byte[] key, byte[]... member);

  Response<Long> zremrangeByRank(byte[] key, long start, long end);

  Response<Long> zremrangeByScore(byte[] key, double start, double end);

  Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Response<Set<byte[]>> zrevrange(byte[] key, long start, long end);

  Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrevrank(byte[] key, byte[] member);

  Response<Double> zscore(byte[] key, byte[] member);

  Response<Long> zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      int offset, int count);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
      int offset, int count);

  Response<Long> zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Long> bitcount(byte[] key);

  Response<Long> bitcount(byte[] key, long start, long end);

  Response<Long> pfadd(final byte[] key, final byte[]... elements);

  Response<Long> pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;
=======
import redis.clients.jedis.commands.JedisClusterCommands;
import redis.clients.jedis.commands.JedisClusterScriptingCommands;
import redis.clients.jedis.commands.MultiKeyJedisClusterCommands;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisClusterCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.List;
import java.util.Map;
import java.util.Set;

public interface JedisClusterCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, double score, String member, ZAddParams params);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Long zadd(String key, Map<String, Double> scoreMembers, ZAddParams params);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Double zincrby(String key, double score, String member, ZIncrByParams params);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Double zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, SetParams params);

  public void get(final String key);

  public void exists(final String key);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final double score, final String member,
      final ZAddParams params);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zadd(final String key, final Map<String, Double> scoreMembers, final ZAddParams params);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zincrby(final String key, final double score, final String member,
      final ZIncrByParams params);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryJedisClusterCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryJedisClusterCommands {
  Long del(byte[]... keys);

  Long exists(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyCommandsPipeline.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyCommandsPipeline {
  Response<Long> del(String... keys);

  Response<Long> exists(String... keys);

  Response<List<String>> blpop(String... args);

  Response<List<String>> brpop(String... args);

  Response<Set<String>> keys(String pattern);

  Response<List<String>> mget(String... keys);

  Response<String> mset(String... keysvalues);

  Response<Long> msetnx(String... keysvalues);

  Response<String> rename(String oldkey, String newkey);

  Response<Long> renamenx(String oldkey, String newkey);

  Response<String> rpoplpush(String srckey, String dstkey);

  Response<Set<String>> sdiff(String... keys);

  Response<Long> sdiffstore(String dstkey, String... keys);

  Response<Set<String>> sinter(String... keys);

  Response<Long> sinterstore(String dstkey, String... keys);

  Response<Long> smove(String srckey, String dstkey, String member);

  Response<Long> sort(String key, SortingParams sortingParameters, String dstkey);

  Response<Long> sort(String key, String dstkey);

  Response<Set<String>> sunion(String... keys);

  Response<Long> sunionstore(String dstkey, String... keys);

  Response<String> watch(String... keys);

  Response<Long> zinterstore(String dstkey, String... sets);

  Response<Long> zinterstore(String dstkey, ZParams params, String... sets);

  Response<Long> zunionstore(String dstkey, String... sets);

  Response<Long> zunionstore(String dstkey, ZParams params, String... sets);

  Response<String> brpoplpush(String source, String destination, int timeout);

  Response<Long> publish(String channel, String message);

  Response<String> randomKey();

  Response<Long> bitop(BitOP op, final String destKey, String... srcKeys);

  Response<String> pfmerge(final String destkey, final String... sourcekeys);

  Response<Long> pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyJedisClusterCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyJedisClusterCommands {
  Long del(String... keys);

  Long exists(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
  @Override
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyCommands {
  Long del(String... keys);

  Long exists(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> blpop(String... args);

  List<String> brpop(String... args);

  Set<String> keys(String pattern);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  String watch(String... keys);

  String unwatch();

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  String randomKey();

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  ScanResult<String> scan(final String cursor);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryCommands {
  Long del(byte[]... keys);

  Long exists(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> blpop(byte[]... args);

  List<byte[]> brpop(byte[]... args);

  Set<byte[]> keys(byte[] pattern);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  String watch(byte[]... keys);

  String unwatch();

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  byte[] randomBinaryKey();

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryRedisPipeline.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyBinaryRedisPipeline {

  Response<Long> del(byte[]... keys);

  Response<Long> exists(byte[]... keys);

  Response<List<byte[]>> blpop(byte[]... args);

  Response<List<byte[]>> brpop(byte[]... args);

  Response<Set<byte[]>> keys(byte[] pattern);

  Response<List<byte[]>> mget(byte[]... keys);

  Response<String> mset(byte[]... keysvalues);

  Response<Long> msetnx(byte[]... keysvalues);

  Response<String> rename(byte[] oldkey, byte[] newkey);

  Response<Long> renamenx(byte[] oldkey, byte[] newkey);

  Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey);

  Response<Set<byte[]>> sdiff(byte[]... keys);

  Response<Long> sdiffstore(byte[] dstkey, byte[]... keys);

  Response<Set<byte[]>> sinter(byte[]... keys);

  Response<Long> sinterstore(byte[] dstkey, byte[]... keys);

  Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member);

  Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Response<Long> sort(byte[] key, byte[] dstkey);

  Response<Set<byte[]>> sunion(byte[]... keys);

  Response<Long> sunionstore(byte[] dstkey, byte[]... keys);

  Response<String> watch(byte[]... keys);

  Response<Long> zinterstore(byte[] dstkey, byte[]... sets);

  Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout);

  Response<Long> publish(byte[] channel, byte[] message);

  Response<byte[]> randomKeyBinary();

  Response<Long> bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  Response<String> pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Response<Long> pfcount(final byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
=======
  @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Client.java;<<<<<<< MINE
  @Override
=======
  public void exists(final String... keys) {
    final byte[][] bkeys = SafeEncoder.encodeMany(keys);
    exists(bkeys);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time);

  public void get(final String key);

  @Deprecated
  public void exists(final String key);

  public void exists(final String... keys);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
=======
   * Set a timeout on the specified key. After the timeout the key will be automatically deleted by
   * the server. A key with an associated timeout is said to be volatile in Redis terminology.
   * <p>
   * Voltile keys are stored on disk like the other keys, the timeout is persistent too like all the
   * other aspects of the dataset. Saving a dataset containing expires and stopping the server does
   * not stop the flow of time as Redis stores on disk the time when the key will no longer be
   * available as Unix time, and not the remaining milliseconds.
   * <p>
   * Since Redis 2.1.3 you can update the value of the timeout of a key already having an expire
   * set. It is also possible to undo the expire at all turning the key into a normal key using the
   * {@link #persist(byte[]) PERSIST} command.
   * <p>
   * Time complexity: O(1)
   * @see <ahref="http://redis.io/commands/pexpire">PEXPIRE Command</a>
   * @param key
   * @param milliseconds
   * @return Integer reply, specifically: 1: the timeout was set. 0: the timeout was not set since
   *         the key already has an associated timeout (this may happen only in Redis versions <
   *         2.1.3, Redis >= 2.1.3 will happily update the timeout), or the key does not exist.
   */
  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMulti();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryJedis.java;<<<<<<< MINE
  @Override
  public Long pexpire(final byte[] key, final long milliseconds) {
    checkIsInMultiOrPipeline();
    client.pexpire(key, milliseconds);
    return client.getIntegerReply();
  }

  @Override
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> blpop(byte[] arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> brpop(byte[] arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryShardedJedis.java;<<<<<<< MINE
  @Deprecated
  public Long pexpire(String key, final long milliseconds) {
    Jedis j = getShard(key);
    return j.pexpire(key, milliseconds);
  }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_fe17537_45f2265/rev_fe17537-45f2265/src/main/java/org/junit/rules/Timeout.java;<<<<<<< MINE
 *  public Timeout globalTimeout= new Timeout(20);
=======
 *  public Timeout globalTimeout = Timeout.millis(20);
>>>>>>> YOURS
