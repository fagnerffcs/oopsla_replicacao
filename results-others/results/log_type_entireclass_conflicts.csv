/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_d61f4d7_f9e7887/rev_d61f4d7-f9e7887/src/test/java/redis/clients/jedis/tests/FragmentedByteArrayInputStream.java;<<<<<<< MINE
=======
package redis.clients.jedis.tests;

import java.io.ByteArrayInputStream;

/**
 * Test class the fragment a byte array for testing purpose.
 */
public class FragmentedByteArrayInputStream extends ByteArrayInputStream {
	private int readMethodCallCount = 0;
	public FragmentedByteArrayInputStream(final byte[] buf) {
		super(buf);
	}

	@Override
	public synchronized int read(final byte[] b, final int off, final int len) {
		readMethodCallCount++;
		if (len <= 10) {
			// if the len <= 10, return as usual ..
			return super.read(b, off, len);
		} else {
			// else return the first half ..
			return super.read(b, off, len / 2);
		}
	}
	
	public int getReadMethodCallCount() {
		return readMethodCallCount;
	}

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/internal/runners/JUnit38ClassRunner.java;<<<<<<< MINE
	private static final class OldTestClassAdaptingListener implements
=======
	private final class OldTestClassAdaptingListener implements
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE
// TODO (Nov 18, 2008 1:40:42 PM): Is this doing too much?
public class MaxCore implements Serializable {
	private static final long serialVersionUID= 1L;

	public static MaxCore forFolder(String folder) throws CouldNotReadCoreException {
		if (new File(folder + ".ser").exists())
			return readCore(folder);
		return new MaxCore(folder);
	}

	private static MaxCore readCore(String folder) throws CouldNotReadCoreException {
		// TODO: rule of three
		// TODO: Really?
		ObjectInputStream stream;
		try {
			stream= new ObjectInputStream(new FileInputStream(folder + ".ser"));
		} catch (IOException e) {
			throw new CouldNotReadCoreException(e);
		}
		try {
			return (MaxCore) stream.readObject();
		} catch (Exception e) {
			throw new CouldNotReadCoreException(e); //TODO think about what we can do better here
		} finally {
			try {
				stream.close();
			} catch (IOException e) {
				throw new CouldNotReadCoreException(e);
			}
		}
=======
public class MaxCore {
	public static MaxCore storedLocally(File storedResults) {
		return new MaxCore(storedResults);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxCore.java;<<<<<<< MINE

	private final class RememberingListener extends RunListener {
		private Map<Description, Long> starts= new HashMap<Description, Long>();

		@Override
		public void testStarted(Description description) throws Exception {
			starts.put(description, System.nanoTime()); // Get most accurate possible time
		}

		@Override
		public void testFinished(Description description) throws Exception {
			long end= System.nanoTime();
			long start= starts.get(description);
			putTestDuration(description, end - start);
		}

		@Override
		public void testFailure(Failure failure) throws Exception {
			long end= System.currentTimeMillis(); // This needs to be comparable across tests
			putTestFailureTimestamp(failure.getDescription(), end);
		}
	}

	private class TestComparator implements Comparator<Description> {
		public int compare(Description o1, Description o2) {
			// Always prefer new tests
			if (isNewTest(o1))
				return -1;
			if (isNewTest(o2))
				return 1;
			// Then most recently failed first
			int result= getFailure(o2).compareTo(getFailure(o1)); 
			return result != 0
				? result
				// Then shorter tests first
				: getTestDuration(o1).compareTo(getTestDuration(o2));
		}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/max/MaxHistory.java;<<<<<<< MINE
=======
package org.junit.experimental.max;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Map;

import org.junit.runner.Description;
import org.junit.runner.notification.Failure;
import org.junit.runner.notification.RunListener;

public class MaxHistory implements Serializable {
	private static final long serialVersionUID= 1L;


	public static MaxHistory forFolder(File storedResults) {
		try {
			if (storedResults.exists())
				return readHistory(storedResults);
		} catch (CouldNotReadCoreException e) {
			e.printStackTrace();
			storedResults.delete();
		}
		return new MaxHistory(storedResults);
	}
	
//	public static MaxHistory forFolder(String folder) {
//		File serializedFile= new File(folder + ".ser");
//		try {
//			if (serializedFile.exists())
//				return readHistory(folder);
//		} catch (CouldNotReadCoreException e) {
//			e.printStackTrace();
//			serializedFile.delete();
//		}
//		return new MaxHistory(folder);
//	}

	private static MaxHistory readHistory(File storedResults) throws CouldNotReadCoreException {
		// TODO: rule of three
		// TODO: Really?
		ObjectInputStream stream;
		try {
			stream= new ObjectInputStream(new FileInputStream(storedResults));
		} catch (IOException e) {
			throw new CouldNotReadCoreException(e);
		}
		try {
			return (MaxHistory) stream.readObject();
		} catch (Exception e) {
			throw new CouldNotReadCoreException(e); //TODO think about what we can do better here
		} finally {
			try {
				stream.close();
			} catch (IOException e) {
				throw new CouldNotReadCoreException(e);
			}
		}
	}
	public final Map<String, Long> fDurations= new HashMap<String, Long>();

	public final Map<String, Long> fFailureTimestamps= new HashMap<String, Long>();

	public final File fFolder;

	public MaxHistory(File storedResults) {
		fFolder= storedResults;
	}

	public File getFile() {
		return fFolder;
	}

	public void save() throws IOException {
		ObjectOutputStream stream= new ObjectOutputStream(new FileOutputStream(
				fFolder));
		stream.writeObject(this);
		stream.close();
	}

	Long getFailureTimestamp(Description key) {
		return fFailureTimestamps.get(key.toString());
	}

	void putTestFailureTimestamp(Description key, long end) {
		fFailureTimestamps.put(key.toString(), end);
	}

	boolean isNewTest(Description key) {
		return !fDurations.containsKey(key.toString());
	}

	Long getTestDuration(Description key) {
		return fDurations.get(key.toString());
	}

	void putTestDuration(Description description, long duration) {
		fDurations.put(description.toString(), duration);
	}

	private final class RememberingListener extends RunListener {
		private long overallStart= System.currentTimeMillis();

		private Map<Description, Long> starts= new HashMap<Description, Long>();

		@Override
		public void testStarted(Description description) throws Exception {
			starts.put(description, System.nanoTime()); // Get most accurate
														// possible time
		}

		@Override
		public void testFinished(Description description) throws Exception {
			long end= System.nanoTime();
			long start= starts.get(description);
			putTestDuration(description, end - start);
		}

		@Override
		public void testFailure(Failure failure) throws Exception {
			putTestFailureTimestamp(failure.getDescription(), overallStart);
		}
	}

	private class TestComparator implements Comparator<Description> {
		public int compare(Description o1, Description o2) {
			// Always prefer new tests
			if (isNewTest(o1))
				return -1;
			if (isNewTest(o2))
				return 1;
			// Then most recently failed first
			int result= getFailure(o2).compareTo(getFailure(o1)); 
			return result != 0
				? result
				// Then shorter tests first
				: getTestDuration(o1).compareTo(getTestDuration(o2));
		}
	
		private Long getFailure(Description key) {
			Long result= getFailureTimestamp(key);
			if (result == null) 
				return 0L; // 0 = "never failed (that I know about)"
			return result;
		}
	}


	public RememberingListener listener() {
		return new RememberingListener();
	}

	// TODO (Feb 23, 2009 10:41:36 PM): V
	public Comparator<Description> testComparator() {
		return new TestComparator();
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
=======
package org.junit.experimental;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import org.junit.runner.Computer;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.Suite;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;

public class ParallelComputer extends Computer {
	private final boolean fClasses;
	private final boolean fMethods;

	public ParallelComputer(boolean classes, boolean methods) {
		fClasses= classes;
		fMethods= methods;
	}

	public static Computer classes() {
		return new ParallelComputer(true, false);
	}
	
//TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
		}
		private ExecutorService fService= Executors.newCachedThreadPool();
		private List<Future<Object>> fResults= new ArrayList<Future<Object>>();
	
		@Override
		protected void runChild(final Runner runner, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(runner, notifier);
					return null;
				}
			};
			fResults.add(fService.submit(callable));
		}
		
		protected void superRunChild(Runner runner, RunNotifier notifier) {
			super.runChild(runner, notifier);
		}
		
		@Override
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fResults)
				try {
					each.get(2000, TimeUnit.MILLISECONDS);
				} catch (Exception e) {
					e.printStackTrace();
				} 
		}
	}

	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		private ExecutorService fService= Executors.newCachedThreadPool();
		private List<Future<Object>> fResults= new ArrayList<Future<Object>>();
	
		@Override
		protected void runChild(final FrameworkMethod method, final RunNotifier notifier) {
			Callable<Object> callable= new Callable<Object>() {
				public Object call() throws Exception {
					superRunChild(method, notifier);
					return null;
				}
			};
			fResults.add(fService.submit(callable));
		}
		
		protected void superRunChild(FrameworkMethod method, RunNotifier notifier) {
			super.runChild(method, notifier);
		}
		
		@Override
		public void run(RunNotifier notifier) {
			super.run(notifier);
			for (Future<Object> each : fResults)
				try {
					each.get(2000, TimeUnit.MILLISECONDS); // TODO(parallel) what should this really be?
				} catch (Exception e) {
					e.printStackTrace();
				} 
		}
	}

	@Override
	public Suite getSuite(RunnerBuilder builder, java.lang.Class<?>[] classes) throws InitializationError {
		return fClasses
			? new ParallelSuite(builder, classes)
			: super.getSuite(builder, classes);
	}
	
	@Override
	protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
			throws Throwable {
		return fMethods
			? new ParallelRunner(testClass)
			: super.getRunner(builder, testClass);
	}

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxStarterTest.java;<<<<<<< MINE
=======
	private static class MalformedJUnit38Test {
		private MalformedJUnit38Test() {
		}

		public void testSucceeds() {
		}
	}

	@Test
	public void maxShouldSkipMalformedJUnit38Classes() {
		Request request= Request.aClass(MalformedJUnit38Test.class);
		fMax.run(request);
	}

	public static class MalformedJUnit38TestMethod extends TestCase {
		@SuppressWarnings("unused")
		private void testNothing() {
		}
	}

	String fMessage= null;

	@Test
	public void correctErrorFromMalformedTest() {
		Request request= Request.aClass(MalformedJUnit38TestMethod.class);
		JUnitCore core= new JUnitCore();
		Request sorted= fMax.sortRequest(request);
		Runner runner= sorted.getRunner();
		Result result= core.run(runner);
		Failure failure= result.getFailures().get(0);

		assertThat(failure.toString(),
				containsString("MalformedJUnit38TestMethod"));
		assertThat(failure.toString(), containsString("testNothing"));
		assertThat(failure.toString(), containsString("isn't public"));
	}

	public static class HalfMalformedJUnit38TestMethod extends TestCase {
		public void testSomething() {
		}

		@SuppressWarnings("unused")
		private void testNothing() {
		}
	}

	@Test
	public void halfMalformed() {
		assertThat(JUnitCore.runClasses(HalfMalformedJUnit38TestMethod.class)
				.getFailureCount(), is(1));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_f3c2114_8e20f52/rev_f3c2114-8e20f52/src/test/java/org/junit/tests/experimental/max/MaxComputerTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.max;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

import junit.framework.TestCase;
import org.junit.Test;
import org.junit.experimental.max.MaxHistory;
import org.junit.internal.builders.JUnit3Builder;
import org.junit.runner.Computer;
import org.junit.runner.Description;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.Runner;
import org.junit.runner.notification.RunListener;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerBuilder;

public class MaxComputerTest {
	private static class MaxComputer extends Computer {
		// TODO (Mar 2, 2009 11:21:28 PM): configure somehow
		MaxHistory fMax= new MaxHistory(new File("MaxCore.max"));

		@Override
		protected Runner getRunner(RunnerBuilder builder, Class<?> testClass)
				throws Throwable {
			Runner junit3Runner= new JUnit3Builder().runnerForClass(testClass);
			if (junit3Runner != null)
				return junit3Runner;
			return new MaxRunner(testClass, fMax);
		}
	}

	private static class MaxRunner extends BlockJUnit4ClassRunner {
		private final MaxHistory fMax;

		// TODO (Mar 2, 2009 10:59:15 PM): this grows without bound.
		private List<FrameworkMethod> methods= new ArrayList<FrameworkMethod>();

		public MaxRunner(Class<?> klass, MaxHistory max)
				throws InitializationError {
			super(klass);
			fMax= max;
		}

		@Override
		protected void runChild(FrameworkMethod method, RunNotifier notifier) {
			methods.add(method);
		}

		@Override
		public void run(RunNotifier notifier) {
			notifier.addListener(fMax.listener());
			super.run(notifier);
			sortMethods();
			for (FrameworkMethod each : methods) {
				super.runChild(each, notifier);
			}
		}

		private void sortMethods() {
			Collections.sort(methods, new Comparator<FrameworkMethod>() {
				public int compare(FrameworkMethod o1, FrameworkMethod o2) {
					return fMax.testComparator().compare(describe(o1),
							describe(o2));
				}

				private Description describe(FrameworkMethod o1) {
					return Description.createTestDescription(o1.getMethod()
							.getDeclaringClass(), o1.getName());
				}
			});
		}
	}

	public static class TwoTests {
		@Test
		public void succeed() {
		}

		@Test
		public void dontSucceed() {
			fail();
		}
	}

	@Test
	public void twoTestsNotRunComeBackInRandomOrder() {
		Result result= new JUnitCore().run(new MaxComputer(), TwoTests.class);
		assertEquals(2, result.getRunCount());
		assertEquals(1, result.getFailureCount());
		assertEquals("dontSucceed", result.getFailures().get(0)
				.getDescription().getMethodName());
	}

	@Test
	public void failedTestFirstOnSecondRun() {
		MaxComputer computer= new MaxComputer();
		new JUnitCore().run(computer, TwoTests.class);
		JUnitCore core= new JUnitCore();
		final List<Description> testOrder= new ArrayList<Description>();
		core.addListener(new RunListener() {
			@Override
			public void testStarted(Description description) throws Exception {
				testOrder.add(description);
			}
		});
		core.run(computer, TwoTests.class);
		assertEquals("dontSucceed", testOrder.get(0).getMethodName());
		assertEquals(2, testOrder.size());
	}
	
	public static class TwoOldTests extends TestCase {
		public void testSucceed() {
		}

		public void testDontSucceed() {
			fail();
		}
	}

	@Test
	public void junit3TestsAreRunOnce() throws Exception {
		Result result= new JUnitCore().run(new MaxComputer(), TwoOldTests.class);
		assertEquals(2, result.getRunCount());
		assertEquals(1, result.getFailureCount());
		assertEquals("testDontSucceed", result.getFailures().get(0)
				.getDescription().getMethodName());
	}

	// Description succeed= Description.createTestDescription(TwoTests.class,
	// "succeed");
	// Description dontSucceed= Description.createTestDescription(
	// TwoTests.class, "dontSucceed");
	// assertTrue(things.contains(succeed));
	// assertTrue(things.contains(dontSucceed));
	// assertEquals(2, things.size());
	// }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
public class ShardedJedis extends Sharded<Jedis> {
    public ShardedJedis(List<ShardInfo> shards) {
=======
public class ShardedJedis extends Sharded<Jedis,JedisShardInfo> {
    public ShardedJedis(List<JedisShardInfo> shards) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/jedis/JedisShardInfo.java;<<<<<<< MINE
=======
/*
 * Copyright 2009-2010 MBTE Sweden AB.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package redis.clients.jedis;

import redis.clients.util.ShardInfo;
import redis.clients.util.Sharded;

public class JedisShardInfo extends ShardInfo<Jedis> {
    @Override
    public String toString() {
        return "JedisShardInfo [host=" + host + ", port=" + port + ", weight="
                + getWeight() + "]";
    }

    private int timeout;
    private String host;
    private int port;
    private String password = null;

    public String getHost() {
        return host;
    }

    public int getPort() {
        return port;
    }

    public JedisShardInfo(String host) {
        this(host, Protocol.DEFAULT_PORT);
    }

    public JedisShardInfo(String host, int port) {
        this(host, port, 2000);
    }

    public JedisShardInfo(String host, int port, int timeout) {
        this(host, port, timeout, Sharded.DEFAULT_WEIGHT);
    }

    public JedisShardInfo(String host, int port, int timeout, int weight) {
        super(weight);
        this.host = host;
        this.port = port;
        this.timeout = timeout;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String auth) {
        this.password = auth;
    }

    public int getTimeout() {
        return timeout;
    }

    public void setTimeout(int timeout) {
        this.timeout = timeout;
    }

    @Override
    public Jedis createResource() {
        return new Jedis(this);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/Sharded.java;<<<<<<< MINE
public abstract class Sharded<T> {
=======
public class Sharded<R, S extends ShardInfo<R>> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
import redis.clients.jedis.Protocol;
=======
public abstract class ShardInfo<T> {
    private T resource;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_592bc69_330135e/rev_592bc69-330135e/src/main/java/redis/clients/util/ShardInfo.java;<<<<<<< MINE
public class ShardInfo {
    @Override
    public String toString() {
	return "ShardInfo [host=" + host + ", port=" + port + ", weight="
		+ weight + "]";
    }

    private String host;
    private int port;
    private int timeout;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f625489_d3362da/rev_f625489-d3362da/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis implements JedisCommands {
    private Client client = null;
    private String password = null;

    public Jedis(String host) {
        client = new Client(host);
=======
public class Jedis extends BinaryJedis implements JedisCommands {
    public Jedis(final String host) {
        super(host);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/Interceptors.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import java.lang.reflect.Field;

import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.Statement;

public class Interceptors extends BlockJUnit4ClassRunner {
	public Interceptors(Class<?> klass) throws InitializationError {
		super(klass);
	}

	@Override
	protected Statement withAfters(FrameworkMethod method, Object target,
			Statement statement) {
		// TODO Auto-generated method stub
		// TODO (Apr 28, 2009 10:55:21 PM): parameter clump?
		return super.withAfters(method, target, intercept(statement, target, method));
	}

	private Statement intercept(Statement statement, Object target, FrameworkMethod method) {
		Class<?> javaClass= getTestClass().getJavaClass();
		Field[] fields= javaClass.getFields();
		Statement result= statement;
		for (Field each : fields) {
			if (each.getAnnotation(Interceptor.class) != null) {
				try {
					StatementInterceptor interceptor= (StatementInterceptor) each
							.get(target);
					result= interceptor.intercept(result, method);
				} catch (IllegalAccessException e) {
					throw new RuntimeException(
							"How did getFields return a field we couldn't access?");
				}
			}
		}
		return result;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/StatementInterceptor.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public interface StatementInterceptor {
	Statement intercept(Statement base, FrameworkMethod method);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class TestWatchman implements StatementInterceptor {
	public Statement intercept(final Statement base,
			final FrameworkMethod method) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				try {
					base.evaluate();
					succeeded(method);
				} catch (Throwable t) {
					failed(t, method);
					throw t;
				}
			}
		};
	}

	public void succeeded(FrameworkMethod method) {
		return;
	}

	// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
	// FrameworkMethod too powerful?
	public void failed(Throwable e, FrameworkMethod method) {
		return;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/experimental/InterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental;

import static org.junit.Assert.*;
import static org.junit.matchers.JUnitMatchers.containsString;

import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	@RunWith(Interceptors.class)
	public static class ExampleTest {
		@Interceptor
		public StatementInterceptor example= new StatementInterceptor() {
			// TODO (Apr 28, 2009 10:31:18 PM): much better error if
			// @Interceptor
			// annotates a non-public field.
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAnEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	@RunWith(Interceptors.class)
	public static class MultipleInterceptorTest {
		private static class Incrementor implements StatementInterceptor {
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Interceptor
		public StatementInterceptor interceptor1= new Incrementor();

		@Interceptor
		public StatementInterceptor interceptor2= new Incrementor();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	@RunWith(Interceptors.class)
	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	@RunWith(Interceptors.class)
	public static class OnFailureTest {
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
			// FrameworkMethod too powerful?
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	@RunWith(Interceptors.class)
	public static class WatchmanTest {
		private static String watchedLog;

		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28d40d9_6c942ae/rev_28d40d9-6c942ae/src/test/java/org/junit/tests/running/classes/SuiteTest.java;<<<<<<< MINE
=======
	}	
	
	public static class InheritsAll extends All {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/ExactComparisonCriteria.java;<<<<<<< MINE
=======
package org.junit.internal;

import org.junit.Assert;

// TODO (Apr 29, 2009 4:17:49 PM): where should this live?
public class ExactComparisonCriteria extends ComparisonCriteria {
	@Override
	protected void assertElementsEqual(Object expected, Object actual) {
		Assert.assertEquals(expected, actual);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/ComparisonCriteria.java;<<<<<<< MINE
=======
package org.junit.internal;

import java.lang.reflect.Array;

import org.junit.Assert;

public abstract class ComparisonCriteria {
	// TODO (Sep 8, 2008 4:36:12 PM): check structure
	
	/**
	 * Asserts that two arrays are equal. If they are not, an
	 * {@link AssertionError} is thrown with the given message. If
	 * <code>expecteds</code> and <code>actuals</code> are <code>null</code>,
	 * they are considered equal.
	 * 
	 * @param message
	 *            the identifying message for the {@link AssertionError} (<code>null</code>
	 *            okay)
	 * @param expecteds
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            expected values.
	 * @param actuals
	 *            Object array or array of arrays (multi-dimensional array) with
	 *            actual values
	 * @param criteria TODO
	 */
	public void arrayEquals(String message, Object expecteds,
			Object actuals) throws ArrayComparisonFailure {
		// TODO: DUP above
		// TODO (Sep 8, 2008 4:32:50 PM): Test that this fails sometimes
		// TODO (Sep 8, 2008 4:33:04 PM): Update javadoc
		
		if (expecteds == actuals)
			return;
		String header= message == null ? "" : message + ": ";
		
		int expectedsLength= Assert.assertArraysAreSameLength(expecteds, actuals,
				header);

		for (int i= 0; i < expectedsLength; i++) {
			Object expected= Array.get(expecteds, i);
			Object actual= Array.get(actuals, i);
			
			if (Assert.isArray(expected) && Assert.isArray(actual)) {
				try {
					arrayEquals(message, expected, actual);
				} catch (ArrayComparisonFailure e) {
					e.addDimension(i);
					throw e;
				}
			} else
				try {
					assertElementsEqual(expected, actual);
				} catch (AssertionError e) {
					throw new ArrayComparisonFailure(header, e, i);
				}
		}
	}

	protected abstract void assertElementsEqual(Object expected, Object actual);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/internal/InexactComparisonCriteria.java;<<<<<<< MINE
public class InexactComparisonCriteria {
=======
public class InexactComparisonCriteria extends ComparisonCriteria {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}

	private static <T> Runner parallelize(ParentRunner<T> runner)
			throws InitializationError {
		return new ParallelParentRunner<T>(runner);
	}

	private static class ParallelParentRunner<T> extends ParentRunner<T> {
		private final ParentRunner<T> fDelegate;

		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

		private final ExecutorService fService= Executors.newCachedThreadPool();

		public ParallelParentRunner(ParentRunner<T> delegate)
				throws InitializationError {
			super(delegate.getTestClass().getJavaClass());
			fDelegate= delegate;
=======
	
	// TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_219beb3_b77d9de/rev_219beb3-b77d9de/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
=======
	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/interceptor/Timeout.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.internal.runners.statements.FailOnTimeout;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class Timeout implements StatementInterceptor {
	private final int fMillis;

	public Timeout(int millis) {
		fMillis= millis;
	}

	public Statement intercept(Statement base, FrameworkMethod method) {
		return new FailOnTimeout(base, fMillis);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	
	// TODO(parallel) extract commonality from ParallelSuite and ParallelRunner
	public static class ParallelSuite extends Suite {
		public ParallelSuite(RunnerBuilder builder, Class<?>[] classes) throws InitializationError {
			super(builder, classes);
=======

	public static Computer methods() {
		return new ParallelComputer(false, true);
	}

	private static <T> Runner parallelize(ParentRunner<T> runner)
			throws InitializationError {
		return new ParallelParentRunner<T>(runner);
	}

	private static class ParallelParentRunner<T> extends ParentRunner<T> {
		private final ParentRunner<T> fDelegate;

		private final List<Future<Object>> fResults= new ArrayList<Future<Object>>();

		private final ExecutorService fService= Executors.newCachedThreadPool();

		public ParallelParentRunner(ParentRunner<T> delegate)
				throws InitializationError {
			super(delegate.getTestClass().getJavaClass());
			fDelegate= delegate;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/main/java/org/junit/experimental/ParallelComputer.java;<<<<<<< MINE
	public static class ParallelRunner extends BlockJUnit4ClassRunner {
		public ParallelRunner(Class<?> klass) throws InitializationError {
			super(klass);
		}
		
		private final ParallelCollator fCollator = new ParallelCollator();
	
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/InterceptorTest.java;<<<<<<< MINE
=======

	@RunWith(Interceptors.class)
	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_2527d9a_2386579/rev_2527d9a-2386579/src/test/java/org/junit/tests/experimental/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.containsString;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;

public class TimeoutInterceptorTest {
	@RunWith(Interceptors.class)
	public static class HasGlobalTimeout {
		public static String log;
		
		@Interceptor public StatementInterceptor globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b737131_ff2ff91/rev_b737131-ff2ff91/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
package org.junit.tests;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerInterceptor;

public class ParentRunnerTest {
	public static String log= "";

	public static class FruitTest {
		@Test
		public void apple() {
			log+= "apple ";
		}

		@Test
		public void banana() {
			log+= "banana ";
		}
	}

	@Test
	public void useChildHarvester() throws InitializationError {
		log= "";
		ParentRunner<?> runner= new BlockJUnit4ClassRunner(FruitTest.class);
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			public void runChild(Runnable childStatement) {
				log+= "before ";
				childStatement.run();
				log+= "after ";
			}

			public void finished() {
				log+= "afterAll ";
			}
		});

		runner.run(new RunNotifier());
		assertEquals("before apple after before banana after afterAll ", log);
	}
}=======
package org.junit.tests;

import static org.junit.Assert.assertEquals;

import java.util.Comparator;

import org.junit.Test;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Sorter;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.FrameworkMethod;

// TODO (May 11, 2009 2:42:38 PM): move package

public class ParentRunnerTest {
	private static StringBuffer log= new StringBuffer();

	public static class FruitTests {
		@Test
		public void apple() {
			log.append("apple ");
		}

		@Test
		public void banana() {
			log.append("banana ");
		}

		@Test
		public void pear() {
			log.append("pear ");
		}
	}

	@Test
	public void installDecorator() throws Throwable {
		log.setLength(0);
		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
				true).runnerForClass(FruitTests.class);
		// TODO (May 11, 2009 2:58:11 PM): DUP?
		runner.sort(new Sorter(new Comparator<Description>() {
			public int compare(Description o1, Description o2) {
				return o1.toString().compareTo(o2.toString());
			}
		}));
		runner.installDecorator(new ParentRunner.Decorator() {
			public void runChild(SafeStatement statement) {
				log.append("before ");
				statement.execute();
				log.append("after ");
			}

			public void runAll(SafeStatement statement) {
				log.append("beforeAll ");
				statement.execute();
				log.append("afterAll ");
			}
		});

		runner.run(new RunNotifier());
		assertEquals(
				"beforeAll before apple after before banana after before pear after afterAll ",
				log.toString());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_9577910_f2594e3/rev_9577910-f2594e3/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
package org.junit.tests;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.InitializationError;
import org.junit.runners.model.RunnerInterceptor;

public class ParentRunnerTest {
	public static String log= "";

	public static class FruitTest {
		@Test
		public void apple() {
			log+= "apple ";
		}

		@Test
		public void banana() {
			log+= "banana ";
		}
	}

	@Test
	public void useChildHarvester() throws InitializationError {
		log= "";
		ParentRunner<?> runner= new BlockJUnit4ClassRunner(FruitTest.class);
		runner.setRunnerInterceptor(new RunnerInterceptor() {
			public void runChild(Runnable childStatement) {
				log+= "before ";
				childStatement.run();
				log+= "after ";
			}

			public void finished() {
				log+= "afterAll ";
			}
		});

		runner.run(new RunNotifier());
		assertEquals("before apple after before banana after afterAll ", log);
	}
}=======
package org.junit.tests;

import static org.junit.Assert.assertEquals;

import java.util.Comparator;

import org.junit.Test;
import org.junit.internal.builders.AllDefaultPossibilitiesBuilder;
import org.junit.runner.Description;
import org.junit.runner.manipulation.Sorter;
import org.junit.runner.notification.RunNotifier;
import org.junit.runners.BlockJUnit4ClassRunner;
import org.junit.runners.ParentRunner;
import org.junit.runners.model.FrameworkMethod;

// TODO (May 11, 2009 2:42:38 PM): move package

public class ParentRunnerTest {
	private static StringBuffer log= new StringBuffer();

	public static class FruitTests {
		@Test
		public void apple() {
			log.append("apple ");
		}

		@Test
		public void banana() {
			log.append("banana ");
		}

		@Test
		public void pear() {
			log.append("pear ");
		}
	}

	@Test
	public void installDecorator() throws Throwable {
		log.setLength(0);
		ParentRunner<FrameworkMethod> runner= (BlockJUnit4ClassRunner) new AllDefaultPossibilitiesBuilder(
				true).runnerForClass(FruitTests.class);
		// TODO (May 11, 2009 2:58:11 PM): DUP?
		runner.sort(new Sorter(new Comparator<Description>() {
			public int compare(Description o1, Description o2) {
				return o1.toString().compareTo(o2.toString());
			}
		}));
		runner.installDecorator(new ParentRunner.Decorator() {
			public void runChild(SafeStatement statement) {
				log.append("before ");
				statement.execute();
				log.append("after ");
			}

			public void runAll(SafeStatement statement) {
				log.append("beforeAll ");
				statement.execute();
				log.append("afterAll ");
			}
		});

		runner.run(new RunNotifier());
		assertEquals(
				"beforeAll before apple after before banana after before pear after afterAll ",
				log.toString());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_8aa25eb_58aa95c/rev_8aa25eb-58aa95c/src/main/java/redis/clients/jedis/PipelineBlock.java;<<<<<<< MINE
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

import java.util.Map;

public abstract class PipelineBlock implements Commands {
    private Client client;

    public void setClient(Client client) {
        this.client = client;
    }

    public void append(String key, String value) {
        client.append(key, value);
    }

    public void blpop(String[] args) {
        client.blpop(args);
    }

    public void brpop(String[] args) {
        client.brpop(args);
    }

    public void decr(String key) {
        client.decr(key);
    }

    public void decrBy(String key, long integer) {
        client.decrBy(key, integer);
    }

    public void del(String... keys) {
        client.del(keys);
    }

    public void echo(String string) {
        client.echo(string);
    }

    public void exists(String key) {
        client.exists(key);
    }

    public void expire(String key, int seconds) {
        client.expire(key, seconds);
    }

    public void expireAt(String key, long unixTime) {
        client.expireAt(key, unixTime);
    }

    public void get(String key) {
        client.get(key);
    }

    public void getbit(String key, long offset) {
        client.getbit(key, offset);
    }

    public void getrange(String key, long startOffset, long endOffset) {
        client.getrange(key, startOffset, endOffset);
    }

    public void getSet(String key, String value) {
        client.getSet(key, value);
    }

    public void hdel(String key, String field) {
        client.hdel(key, field);
    }

    public void hexists(String key, String field) {
        client.hexists(key, field);
    }

    public void hget(String key, String field) {
        client.hget(key, field);
    }

    public void hgetAll(String key) {
        client.hgetAll(key);
    }

    public void hincrBy(String key, String field, long value) {
        client.hincrBy(key, field, value);
    }

    public void hkeys(String key) {
        client.hkeys(key);
    }

    public void hlen(String key) {
        client.hlen(key);
    }

    public void hmget(String key, String... fields) {
        client.hmget(key, fields);
    }

    public void hmset(String key, Map<String, String> hash) {
        client.hmset(key, hash);
    }

    public void hset(String key, String field, String value) {
        client.hset(key, field, value);
    }

    public void hsetnx(String key, String field, String value) {
        client.hsetnx(key, field, value);
    }

    public void hvals(String key) {
        client.hvals(key);
    }

    public void incr(String key) {
        client.incr(key);
    }

    public void incrBy(String key, long integer) {
        client.incrBy(key, integer);
    }

    public void keys(String pattern) {
        client.keys(pattern);
    }

    public void lindex(String key, int index) {
        client.lindex(key, index);
    }

    public void linsert(String key, LIST_POSITION where, String pivot,
            String value) {
        client.linsert(key, where, pivot, value);
    }

    public void llen(String key) {
        client.llen(key);
    }

    public void lpop(String key) {
        client.lpop(key);
    }

    public void lpush(String key, String string) {
        client.lpush(key, string);
    }

    public void lpushx(String key, String string) {
        client.lpushx(key, string);
    }

    public void lrange(String key, int start, int end) {
        client.lrange(key, start, end);
    }

    public void lrem(String key, int count, String value) {
        client.lrem(key, count, value);
    }

    public void lset(String key, int index, String value) {
        client.lset(key, index, value);
    }

    public void ltrim(String key, int start, int end) {
        client.ltrim(key, start, end);
    }

    public void mget(String... keys) {
        client.mget(keys);
    }

    public void move(String key, int dbIndex) {
        client.move(key, dbIndex);
    }

    public void mset(String... keysvalues) {
        client.mset(keysvalues);
    }

    public void msetnx(String... keysvalues) {
        client.msetnx(keysvalues);
    }

    public void persist(String key) {
        client.persist(key);
    }

    public void rename(String oldkey, String newkey) {
        client.rename(oldkey, newkey);
    }

    public void renamenx(String oldkey, String newkey) {
        client.renamenx(oldkey, newkey);
    }

    public void rpop(String key) {
        client.rpop(key);
    }

    public void rpoplpush(String srckey, String dstkey) {
        client.rpoplpush(srckey, dstkey);
    }

    public void rpush(String key, String string) {
        client.rpush(key, string);
    }

    public void rpushx(String key, String string) {
        client.rpushx(key, string);
    }

    public void sadd(String key, String member) {
        client.sadd(key, member);
    }

    public void scard(String key) {
        client.scard(key);
    }

    public void sdiff(String... keys) {
        client.sdiff(keys);
    }

    public void sdiffstore(String dstkey, String... keys) {
        client.sdiffstore(dstkey, keys);
    }

    public void set(String key, String value) {
        client.set(key, value);
    }

    public void setbit(String key, long offset, boolean value) {
        client.setbit(key, offset, value);
    }

    public void setex(String key, int seconds, String value) {
        client.setex(key, seconds, value);
    }

    public void setnx(String key, String value) {
        client.setnx(key, value);
    }

    public void setrange(String key, long offset, String value) {
        client.setrange(key, offset, value);
    }

    public void sinter(String... keys) {
        client.sinter(keys);
    }

    public void sinterstore(String dstkey, String... keys) {
        client.sinterstore(dstkey, keys);
    }

    public void sismember(String key, String member) {
        client.sismember(key, member);
    }

    public void smembers(String key) {
        client.smembers(key);
    }

    public void smove(String srckey, String dstkey, String member) {
        client.smove(srckey, dstkey, member);
    }

    public void sort(String key) {
        client.sort(key);
    }

    public void sort(String key, SortingParams sortingParameters) {
        client.sort(key, sortingParameters);
    }

    public void sort(String key, SortingParams sortingParameters, String dstkey) {
        client.sort(key, sortingParameters, dstkey);
    }

    public void sort(String key, String dstkey) {
        client.sort(key, dstkey);
    }

    public void spop(String key) {
        client.spop(key);
    }

    public void srandmember(String key) {
        client.srandmember(key);
    }

    public void srem(String key, String member) {
        client.srem(key, member);
    }

    public void strlen(String key) {
        client.strlen(key);
    }

    public void substr(String key, int start, int end) {
        client.substr(key, start, end);
    }

    public void sunion(String... keys) {
        client.sunion(keys);
    }

    public void sunionstore(String dstkey, String... keys) {
        client.sunionstore(dstkey, keys);
    }

    public void ttl(String key) {
        client.ttl(key);
    }

    public void type(String key) {
        client.type(key);
    }

    public void watch(String... keys) {
        client.watch(keys);
    }

    public void zadd(String key, double score, String member) {
        client.zadd(key, score, member);
    }

    public void zcard(String key) {
        client.zcard(key);
    }

    public void zcount(String key, double min, double max) {
        client.zcount(key, min, max);
    }

    public void zincrby(String key, double score, String member) {
        client.zincrby(key, score, member);
    }

    public void zinterstore(String dstkey, String... sets) {
        client.zinterstore(dstkey, sets);
    }

    public void zinterstore(String dstkey, ZParams params, String... sets) {
        client.zinterstore(dstkey, params, sets);
    }

    public void zrange(String key, int start, int end) {
        client.zrange(key, start, end);
    }

    public void zrangeByScore(String key, double min, double max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, String min, String max) {
        client.zrangeByScore(key, min, max);
    }

    public void zrangeByScore(String key, double min, double max, int offset,
            int count) {
        client.zrangeByScore(key, min, max, offset, count);
    }

    public void zrangeByScoreWithScores(String key, double min, double max) {
        client.zrangeByScoreWithScores(key, min, max);
    }

    public void zrangeByScoreWithScores(String key, double min, double max,
            int offset, int count) {
        client.zrangeByScoreWithScores(key, min, max, offset, count);
    }

    public void zrevrangeByScore(String key, double max, double min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, String max, String min) {
        client.zrevrangeByScore(key, max, min);
    }

    public void zrevrangeByScore(String key, double max, double min, int offset,
            int count) {
        client.zrevrangeByScore(key, max, min, offset, count);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min) {
        client.zrevrangeByScoreWithScores(key, max, min);
    }

    public void zrevrangeByScoreWithScores(String key, double max, double min,
            int offset, int count) {
        client.zrevrangeByScoreWithScores(key, max, min, offset, count);
    }

    public void zrangeWithScores(String key, int start, int end) {
        client.zrangeWithScores(key, start, end);
    }

    public void zrank(String key, String member) {
        client.zrank(key, member);
    }

    public void zrem(String key, String member) {
        client.zrem(key, member);
    }

    public void zremrangeByRank(String key, int start, int end) {
        client.zremrangeByRank(key, start, end);
    }

    public void zremrangeByScore(String key, double start, double end) {
        client.zremrangeByScore(key, start, end);
    }

    public void zrevrange(String key, int start, int end) {
        client.zrevrange(key, start, end);
    }

    public void zrevrangeWithScores(String key, int start, int end) {
        client.zrevrangeWithScores(key, start, end);
    }

    public void zrevrank(String key, String member) {
        client.zrevrank(key, member);
    }

    public void zscore(String key, String member) {
        client.zscore(key, member);
    }

    public void zunionstore(String dstkey, String... sets) {
        client.zunionstore(dstkey, sets);
    }

    public void zunionstore(String dstkey, ZParams params, String... sets) {
        client.zunionstore(dstkey, params, sets);
    }

    public void bgrewriteaof() {
        client.bgrewriteaof();
    }

    public void bgsave() {
        client.bgsave();
    }

    public void configGet(String pattern) {
        client.configGet(pattern);
    }

    public void configSet(String parameter, String value) {
        client.configSet(parameter, value);
    }

    public void brpoplpush(String source, String destination, int timeout) {
        client.brpoplpush(source, destination, timeout);
    }

    public void configResetStat() {
        client.configResetStat();
    }

    public void save() {
        client.save();
    }

    public void lastsave() {
        client.lastsave();
    }

    public void discard() {
        client.discard();
    }

    public void exec() {
        client.exec();
    }

    public void multi() {
        client.multi();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/main/java/org/junit/experimental/interceptor/TestName.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;

public class TestName extends TestWatchman {
	private String fName;

	@Override
	public void starting(FrameworkMethod method) throws Exception {
		fName = method.getName();
	}
	
	public String getMethodName() {
		return fName;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.matchers.JUnitMatchers.containsString;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	@RunWith(Interceptors.class)
	public static class ExampleTest {
		@Interceptor
		public StatementInterceptor example= new StatementInterceptor() {
			// TODO (Apr 28, 2009 10:31:18 PM): much better error if
			// @Interceptor
			// annotates a non-public field.
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAndEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	@RunWith(Interceptors.class)
	public static class MultipleInterceptorTest {
		private static class Incrementor implements StatementInterceptor {
			public Statement intercept(final Statement base,
					FrameworkMethod method) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Interceptor
		public StatementInterceptor interceptor1= new Incrementor();

		@Interceptor
		public StatementInterceptor interceptor2= new Incrementor();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	@RunWith(Interceptors.class)
	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	@RunWith(Interceptors.class)
	public static class OnFailureTest {
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			// TODO (Apr 28, 2009 10:50:47 PM): is this right? Is
			// FrameworkMethod too powerful?
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	@RunWith(Interceptors.class)
	public static class WatchmanTest {
		private static String watchedLog;

		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}

	@RunWith(Interceptors.class)
	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Interceptor
		public StatementInterceptor watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.containsString;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.StatementInterceptor;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runner.RunWith;

public class TimeoutInterceptorTest {
	@RunWith(Interceptors.class)
	public static class HasGlobalTimeout {
		public static String log;
		
		@Interceptor public StatementInterceptor globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	// TODO (May 6, 2009 11:30:19 AM): Make a separate build that makes gump happy
	@Ignore("For gump, for now")
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b3ee106_5eaf0fb/rev_b3ee106-5eaf0fb/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.experimental.interceptor.Interceptor;
import org.junit.experimental.interceptor.Interceptors;
import org.junit.experimental.interceptor.TestName;
import org.junit.runner.RunWith;

@RunWith(Interceptors.class)
public class NameInterceptorTest {
	@Interceptor public TestName name = new TestName();
	
	@Test public void testA() {
		assertEquals("testA", name.getMethodName());
	}
	
	@Test public void testB() {
		assertEquals("testB", name.getMethodName());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMember.java;<<<<<<< MINE
=======
package org.junit.runners.model;

import java.lang.annotation.Annotation;

public interface FrameworkMember<T extends FrameworkMember<T>> {
	/**
	 * Returns the annotations on this method
	 */
	public Annotation[] getAnnotations();

	public boolean isShadowedBy(T otherMember);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
public class FrameworkMethod {
	private final Method fMethod;
=======
public class FrameworkMethod implements FrameworkMember<FrameworkMethod> {
	final Method fMethod;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
=======
package org.junit.runners.model;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;

public class FrameworkField implements FrameworkMember<FrameworkField> {
	private final Field fField;

	public FrameworkField(Field field) {
		fField= field;
	}

	public Annotation[] getAnnotations() {
		return fField.getAnnotations();
	}

	// TODO (May 25, 2009 9:45:43 PM): faking it
	public boolean isShadowedBy(FrameworkField otherMember) {
		// TODO Auto-generated method stub
		return false;
	}

	public Field getField() {
		return fField;
	}

	public Object get(Object target) throws IllegalArgumentException, IllegalAccessException {
		return fField.get(target);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class ExpectedException implements StatementInterceptor {
	private Class<? extends Throwable> fType;
	private String fMessage;

	public Statement intercept(Statement base, FrameworkMethod method) {
		return new ExpectedExceptionStatement(base);
	}

	public void expect(Class<? extends Throwable> type) {
		fType= type;
	}

	public void expectMessage(String message) {
		fMessage= message;
	}

	private boolean noExpectedException() {
		return fType == null && fMessage == null;
	}
	
	public class ExpectedExceptionStatement extends Statement {

		private final Statement fNext;

		public ExpectedExceptionStatement(Statement base) {
			fNext= base;
		}

		@Override
		public void evaluate() throws Throwable {
			boolean complete = false;
			try {
				fNext.evaluate();
				complete = true;
			} catch (Throwable e) {
				if (noExpectedException())
					throw e;
				// TODO (May 26, 2009 11:46:31 PM): isInstance?
				if (fType != null && !fType.isAssignableFrom(e.getClass())) {
					String message= "Unexpected exception, expected<"
								+ fType.getName() + "> but was<"
								+ e.getClass().getName() + ">";
					throw new Exception(message, e);
				}
				if (fMessage != null && !getMessage(e).contains(fMessage)) {
					String message= "Unexpected exception message, expected<"
								+ fMessage + "> but was<"
								+ getMessage(e) + ">";
					throw new Exception(message, e);
				}
			}
			// TODO (May 26, 2009 11:54:22 PM): do I need complete
			if (complete && !noExpectedException()) {
				if (fType != null)
					throw new AssertionError("Expected exception: "
							+ fType.getName());
				else if (fMessage != null)
					throw new AssertionError("Expected exception with message: "
							+ fMessage);
				else
					throw new RuntimeException("How'd we get here?");
			}
		}

		private String getMessage(Throwable e) {
			return e.getMessage() == null ? "" : e.getMessage();
		}
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
	
	public static class WrongTypedField {
		@Interceptor public int x = 5;
		@Test public void foo() {}
	}
	
	@Test public void validateWrongTypedField() {
		assertThat(testResult(WrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}
	
	public static class SonOfWrongTypedField extends WrongTypedField {
		
	}

	@Test public void validateWrongTypedFieldInSuperclass() {
		assertThat(testResult(SonOfWrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}

	public static class PrivateInterceptor {
		@SuppressWarnings("unused")
		@Interceptor private StatementInterceptor interceptor = new TestName();
		@Test public void foo() {}
	}
	
	@Test public void validatePrivateInterceptor() {
		assertThat(testResult(PrivateInterceptor.class), 
				hasSingleFailureContaining("must be public"));
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_618d9ac_26a9910/rev_618d9ac-26a9910/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExpectedException;
import org.junit.experimental.interceptor.Interceptor;

public class ExpectedExceptionInterceptorTest {
	public static class HasExpectedException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Unexpected exception, expected<java.lang.NullPointerException> but was<java.lang.IllegalArgumentException>"));
	}

	public static class HasWrongMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class),
				hasSingleFailureContaining("Unexpected exception message, expected<expectedMessage> but was<actualMessage>"));
	}

	public static class WronglyExpectsException {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected exception: java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected exception with message: anything!"));
	}

	public static class ExpectsSubstring {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Interceptor
		public ExpectedException thrown= new ExpectedException();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(
				testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("Unexpected exception message, expected<anything!> but was<>"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/IsCollectionContaining.java;<<<<<<< MINE
public class IsCollectionContaining<T> extends TypeSafeMatcher<Iterable<T>> {
    private final Matcher<? extends T> elementMatcher;

    public IsCollectionContaining(Matcher<? extends T> elementMatcher) {
        this.elementMatcher = elementMatcher;
    }

    @Override
	public boolean matchesSafely(Iterable<T> collection) {
        for (T item : collection) {
            if (elementMatcher.matches(item)){
                return true;
            }
        }
        return false;
    }

    public void describeTo(Description description) {
        description
        	.appendText("a collection containing ")
        	.appendDescriptionOf(elementMatcher);
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItem(Matcher<? extends T> elementMatcher) {
        return new IsCollectionContaining<T>(elementMatcher);
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItem(T element) {
        return hasItem(equalTo(element));
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItems(Matcher<? extends T>... elementMatchers) {
        Collection<Matcher<? extends Iterable<T>>> all
                = new ArrayList<Matcher<? extends Iterable<T>>>(elementMatchers.length);
        for (Matcher<? extends T> elementMatcher : elementMatchers) {
            all.add(hasItem(elementMatcher));
        }
        return allOf(all);
    }

    @Factory
    public static <T> Matcher<Iterable<T>> hasItems(T... elements) {
        Collection<Matcher<? extends Iterable<T>>> all
                = new ArrayList<Matcher<? extends Iterable<T>>>(elements.length);
        for (T element : elements) {
            all.add(hasItem(element));
        }
        return allOf(all);
    }

=======
/**
 * @deprecated use org.hamcrest.core.IsCollectionContaining directly
 */
@Deprecated 
public class IsCollectionContaining<T> extends org.hamcrest.core.IsCollectionContaining<T> {
	// Client code should just use static factories, so this should be OK
	private IsCollectionContaining(Matcher<? super T> elementMatcher) {
		super(elementMatcher);
		// TODO Auto-generated constructor stub
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/internal/matchers/CombinableMatcher.java;<<<<<<< MINE
public class CombinableMatcher<T> extends BaseMatcher<T> {

	private final Matcher<? extends T> fMatcher;

	public CombinableMatcher(Matcher<? extends T> matcher) {
		fMatcher= matcher;
	}

	public boolean matches(Object item) {
		return fMatcher.matches(item);
	}

	public void describeTo(Description description) {
		description.appendDescriptionOf(fMatcher);
	}
	
	@SuppressWarnings("unchecked")
	public CombinableMatcher<T> and(Matcher<? extends T> matcher) {
		return new CombinableMatcher<T>(allOf(matcher, fMatcher));
	}

	@SuppressWarnings("unchecked")
	public CombinableMatcher<T> or(Matcher<? extends T> matcher) {
		return new CombinableMatcher<T>(anyOf(matcher, fMatcher));
=======
/**
 * @deprectated Use org.hamcrest.core.CombinableMatcher directly
 */
@Deprecated
public class CombinableMatcher<T> extends org.hamcrest.core.CombinableMatcher<T> {
	// should only be using static factories
	private CombinableMatcher(Matcher<? super T> matcher) {
		super(matcher);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e35fb32_52e61a5/rev_e35fb32-52e61a5/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
=======
 * @deprecated as of JUnit 4.7, all of these matchers are found in the org.hamcrest.CoreMatchers
 *             class instead.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_a402014_3f05aac/rev_a402014-3f05aac/src/main/java/org/junit/matchers/JUnitMatchers.java;<<<<<<< MINE
 * @deprecated as of JUnit 4.7, all of these matchers are found in the org.hamcrest.CoreMatchers
 *             class instead.
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
	
	public class ExpectedExceptionStatement extends Statement {
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_20dd074_2e9a239/rev_20dd074-2e9a239/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
	private class ExpectedExceptionStatement extends Statement {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMember.java;<<<<<<< MINE
public interface FrameworkMember<T extends FrameworkMember<T>> {
=======
abstract class FrameworkMember<T extends FrameworkMember<T>> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkMethod.java;<<<<<<< MINE
public class FrameworkMethod implements FrameworkMember<FrameworkMethod> {
=======
public class FrameworkMethod extends FrameworkMember<FrameworkMethod> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/runners/model/FrameworkField.java;<<<<<<< MINE
import org.junit.runners.BlockJUnit4ClassRunner;

/**
 * Represents a field on a test class (currently used only for Rules in
 * {@link BlockJUnit4ClassRunner}, but custom runners can make other uses)
 */
public class FrameworkField extends FrameworkMember<FrameworkField> {
=======
import org.junit.runners.BlockJUnit4ClassRunner;

/**
 * Represents a field on a test class (currently used only for Interceptors in
 * {@link BlockJUnit4ClassRunner}, but custom runners can make other uses)
 */
public class FrameworkField extends FrameworkMember<FrameworkField> {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/results/FailureList.java;<<<<<<< MINE
public class FailureList {
=======
class FailureList {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TestName.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;

/**
 * The TestName Rule makes the current test name available inside test methods:
 * 
 * <pre>
 * public class TestNameTest {
 * 	&#064;Rule
 * 	public TestName name= new TestName();
 * 
 * 	&#064;Test
 * 	public void testA() {
 * 		assertEquals(&quot;testA&quot;, name.getMethodName());
 * 	}
 * 
 * 	&#064;Test
 * 	public void testB() {
 * 		assertEquals(&quot;testB&quot;, name.getMethodName());
 * 	}
 * }
 * </pre>
 */
public class TestName extends TestWatchman {
	private String fName;

	@Override
	public void starting(FrameworkMethod method) {
		fName= method.getName();
	}

	public String getMethodName() {
		return fName;
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/ExternalResource.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * A base class for Rules (like TemporaryFolder) that set up an external
 * resource before a test (a file, socket, server, database connection, etc.),
 * and guarantee to tear it down afterward:
 * 
 * <pre>
 * public static class UsesExternalResource {
 * 	Server myServer= new Server();
 * 
 * 	&#064;Rule
 * 	public ExternalResource resource= new ExternalResource() {
 * 		&#064;Override
 * 		protected void before() throws Throwable {
 * 			myServer.connect();
 * 		};
 * 
 * 		&#064;Override
 * 		protected void after() {
 * 			myServer.disconnect();
 * 		};
 * 	};
 * 
 * 	&#064;Test
 * 	public void testFoo() {
 * 		new Client().run(myServer);
 * 	}
 * }
 * </pre>
 */
public abstract class ExternalResource implements MethodRule {
	public final Statement apply(final Statement base,
			FrameworkMethod method, Object target) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				before();
				try {
					base.evaluate();
				} finally {
					after();
				}
			}
		};
	}

	/**
	 * Override to set up your specific external resource.
	 * @throws if setup fails (which will disable {@code after}
	 */
	protected void before() throws Throwable {
		// do nothing
	}

	/**
	 * Override to tear down your specific external resource.
	 * @throws if setup fails (which will disable {@code after}
	 */
	protected void after() {
		// do nothing
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/ExpectedException.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.matches;
import org.hamcrest.FeatureMatcher;
import org.hamcrest.Matcher;
import org.hamcrest.StringDescription;
import org.junit.Assert;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * The ExpectedException Rule allows in-test specification of expected exception
 * types and messages:
 * 
 * <pre>
 * // These tests all pass.
 * public static class HasExpectedException {
 * 	&#064;Rule
 * 	public ExpectedException thrown= new ExpectedException();
 * 
 * 	&#064;Test
 * 	public void throwsNothing() {
 *    // no exception expected, none thrown: passes.
 * 	}
 * 
 * 	&#064;Test
 * 	public void throwsNullPointerException() {
 * 		thrown.expect(NullPointerException.class);
 * 		throw new NullPointerException();
 * 	}
 * 
 * 	&#064;Test
 * 	public void throwsNullPointerExceptionWithMessage() {
 * 		thrown.expect(NullPointerException.class);
 * 		thrown.expectMessage(&quot;happened?&quot;);
 * 		thrown.expectMessage(startsWith(&quot;What&quot;));
 * 		throw new NullPointerException(&quot;What happened?&quot;);
 * 	}
 * }
 * </pre>
 */
public class ExpectedException implements MethodRule {
	public static ExpectedException none() {
		return new ExpectedException();
	}

	private Matcher<?> fMatcher= null;

	private ExpectedException() {
		
	}
	
	public Statement apply(Statement base, FrameworkMethod method, Object target) {
		return new ExpectedExceptionStatement(base);
	}

	/**
	 * Adds {@code matcher} to the list of requirements for any thrown exception.
	 */
	public void expect(Matcher<?> matcher) {
		if (fMatcher == null)
			fMatcher= matcher;
		else
			fMatcher= both(fMatcher).and(matches(matcher));
	}

	/**
	 * Adds to the list of requirements for any thrown exception that it
	 * should be an instance of {@code type}
	 */
	public void expect(Class<? extends Throwable> type) {
		expect(instanceOf(type));
	}

	/**
	 * Adds to the list of requirements for any thrown exception that it
	 * should <em>contain</em> string {@code substring}
	 */
	public void expectMessage(String substring) {
		expectMessage(containsString(substring));
	}

	/**
	 * Adds {@code matcher} to the list of requirements for the message 
	 * returned from any thrown exception.
	 */
	public void expectMessage(Matcher<String> matcher) {
		expect(hasMessage(matcher));
	}

	private class ExpectedExceptionStatement extends Statement {
		private final Statement fNext;

		public ExpectedExceptionStatement(Statement base) {
			fNext= base;
		}

		@Override
		public void evaluate() throws Throwable {
			try {
				fNext.evaluate();
			} catch (Throwable e) {
				if (fMatcher == null)
					throw e;
				Assert.assertThat(e, matches(fMatcher));
				return;
			}
			if (fMatcher != null)
				throw new AssertionError("Expected test to throw "
						+ StringDescription.toString(fMatcher));
		}
	}

	private Matcher<Throwable> hasMessage(Matcher<String> matcher) {
		return new FeatureMatcher<Throwable, String>(matcher,
				"exception with message", "getMessage()") {
			@Override
			protected String featureValueOf(Throwable actual) {
				return actual.getMessage();
			}
		};
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/Timeout.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.interceptor;

import org.junit.internal.runners.statements.FailOnTimeout;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * The Timeout Rule applies the same timeout to all test methods in a class:
 * 
 * <pre>
 * public static class HasGlobalTimeout {
 * 	public static String log;
 * 
 * 	&#064;Rule
 * 	public MethodRule globalTimeout= new Timeout(20);
 * 
 * 	&#064;Test
 * 	public void testInfiniteLoop1() {
 * 		log+= &quot;ran1&quot;;
 * 		for (;;) {
 * 		}
 * 	}
 * 
 * 	&#064;Test
 * 	public void testInfiniteLoop2() {
 * 		log+= &quot;ran2&quot;;
 * 		for (;;) {
 * 		}
 * 	}
 * }
 * </pre>
 */
public class Timeout implements MethodRule {
	private final int fMillis;

	public Timeout(int millis) {
		fMillis= millis;
	}

	public Statement apply(Statement base, FrameworkMethod method, Object target) {
		return new FailOnTimeout(base, fMillis);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TestWatchman.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

/**
 * TestWatchman is a base class for Rules that take note of the testing
 * action, without modifying it. For example, this class will keep a log of each
 * passing and failing test:
 * 
 * <pre>
 * public static class WatchmanTest {
 * 	private static String watchedLog;
 * 
 * 	&#064;Rule
 * 	public MethodRule watchman= new TestWatchman() {
 * 		&#064;Override
 * 		public void failed(Throwable e, FrameworkMethod method) {
 * 			watchedLog+= method.getName() + &quot; &quot; + e.getClass().getSimpleName()
 * 					+ &quot;\n&quot;;
 * 		}
 * 
 * 		&#064;Override
 * 		public void succeeded(FrameworkMethod method) {
 * 			watchedLog+= method.getName() + &quot; &quot; + &quot;success!\n&quot;;
 * 		}
 * 	};
 * 
 * 	&#064;Test
 * 	public void fails() {
 * 		fail();
 * 	}
 * 
 * 	&#064;Test
 * 	public void succeeds() {
 * 	}
 * }
 * </pre>
 */
public class TestWatchman implements MethodRule {
	public Statement apply(final Statement base, final FrameworkMethod method,
			Object target) {
		return new Statement() {
			@Override
			public void evaluate() throws Throwable {
				starting(method);
				try {
					base.evaluate();
					succeeded(method);
				} catch (Throwable t) {
					failed(t, method);
					throw t;
				} finally {
					finished(method);
				}
			}
		};
	}

	/**
	 * Invoked when a test method succeeds
	 * 
	 * @param method
	 */
	public void succeeded(FrameworkMethod method) {
	}

	/**
	 * Invoked when a test method fails
	 * 
	 * @param e 
	 * @param method
	 */
	public void failed(Throwable e, FrameworkMethod method) {
	}

	/**
	 * Invoked when a test method is about to start
	 * 
	 * @param method  
	 */
	public void starting(FrameworkMethod method) {
	}


	/**
	 * Invoked when a test method finishes (whether passing or failing)
	 * 
	 * @param method  
	 */
	public void finished(FrameworkMethod method) {
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/main/java/org/junit/experimental/interceptor/TemporaryFolder.java;<<<<<<< MINE
=======
package org.junit.experimental.interceptor;

import java.io.File;
import java.io.IOException;

/**
 * The TemporaryFolder Rule allows creation of files and folders that are
 * guaranteed to be deleted when the test method finishes (whether it passes or
 * fails):
 * 
 * <pre>
 * public static class HasTempFolder {
 * 	&#064;Rule
 * 	public TemporaryFolder folder= new TemporaryFolder();
 * 
 * 	&#064;Test
 * 	public void testUsingTempFolder() throws IOException {
 * 		File createdFile= folder.newFile(&quot;myfile.txt&quot;);
 * 		File createdFolder= folder.newFolder(&quot;subfolder&quot;);
 * 		// ...
 * 	}
 * }
 * </pre>
 */
public class TemporaryFolder extends ExternalResource {
	private File folder;

	@Override
	protected void before() throws Throwable {
		create();
	}

	@Override
	protected void after() {
		delete();
	}

	// testing purposes only
	public void create() throws IOException {
		folder= File.createTempFile("junit", "");
		folder.delete();
		folder.mkdir();
	}

	public File newFile(String fileName) throws IOException {
		File file= new File(folder, fileName);
		file.createNewFile();
		return file;
	}

	public File newFolder(String folderName) {
		File file= new File(folder, folderName);
		file.mkdir();
		return file;
	}

	public File getRoot() {
		return folder;
	}

	public void delete() {
		recursiveDelete(folder);
	}

	private void recursiveDelete(File file) {
		File[] files= file.listFiles();
		if (files != null)
			for (File each : files)
				recursiveDelete(each);
		file.delete();
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/InterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
import org.junit.experimental.interceptor.TestName;
import org.junit.experimental.interceptor.TestWatchman;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;
import org.junit.runners.model.FrameworkMethod;
import org.junit.runners.model.Statement;

public class InterceptorTest {
	private static boolean wasRun;

	public static class ExampleTest {
		@Rule
		public MethodRule example= new MethodRule() {
			public Statement apply(final Statement base,
					FrameworkMethod method, Object target) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						wasRun= true;
						base.evaluate();
					};
				};
			}
		};

		@Test
		public void nothing() {

		}
	}

	@Test
	public void interceptorIsIntroducedAndEvaluated() {
		wasRun= false;
		JUnitCore.runClasses(ExampleTest.class);
		assertTrue(wasRun);
	}

	private static int runCount;

	public static class MultipleInterceptorTest {
		private static class Increment implements MethodRule {
			public Statement apply(final Statement base,
					FrameworkMethod method, Object target) {
				return new Statement() {
					@Override
					public void evaluate() throws Throwable {
						runCount++;
						base.evaluate();
					};
				};
			}
		}

		@Rule
		public MethodRule incrementor1= new Increment();

		@Rule
		public MethodRule incrementor2= new Increment();

		@Test
		public void nothing() {

		}
	}

	@Test
	public void multipleInterceptorsAreRun() {
		runCount= 0;
		JUnitCore.runClasses(MultipleInterceptorTest.class);
		assertEquals(2, runCount);
	}

	public static class NoInterceptorsTest {
		public int x;

		@Test
		public void nothing() {

		}
	}

	@Test
	public void ignoreNonInterceptors() {
		Result result= JUnitCore.runClasses(NoInterceptorsTest.class);
		assertEquals(0, result.getFailureCount());
	}

	private static String log;

	public static class OnFailureTest {
		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				log+= method.getName() + " " + e.getClass().getSimpleName();
			}
		};

		@Test
		public void nothing() {
			fail();
		}
	}

	@Test
	public void onFailure() {
		log= "";
		Result result= JUnitCore.runClasses(OnFailureTest.class);
		assertEquals("nothing AssertionError", log);
		assertEquals(1, result.getFailureCount());
	}

	public static class WatchmanTest {
		private static String watchedLog;

		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void failed(Throwable e, FrameworkMethod method) {
				watchedLog+= method.getName() + " "
						+ e.getClass().getSimpleName() + "\n";
			}

			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= method.getName() + " " + "success!\n";
			}
		};

		@Test
		public void fails() {
			fail();
		}

		@Test
		public void succeeds() {
		}
	}

	@Test
	public void succeeded() {
		WatchmanTest.watchedLog= "";
		JUnitCore.runClasses(WatchmanTest.class);
		assertThat(WatchmanTest.watchedLog, containsString("fails AssertionError"));
		assertThat(WatchmanTest.watchedLog, containsString("succeeds success!"));
	}

	public static class BeforesAndAfters {
		private static String watchedLog;

		@Before public void before() {
			watchedLog+= "before ";
		}
		
		@Rule
		public MethodRule watchman= new TestWatchman() {
			@Override
			public void starting(FrameworkMethod method) {
				watchedLog+= "starting ";
			}
			
			@Override
			public void finished(FrameworkMethod method) {
				watchedLog+= "finished ";
			}
			
			@Override
			public void succeeded(FrameworkMethod method) {
				watchedLog+= "succeeded ";
			}
		};
		
		@After public void after() {
			watchedLog+= "after ";
		}

		@Test
		public void succeeds() {
			watchedLog+= "test ";
		}
	}

	@Test
	public void beforesAndAfters() {
		BeforesAndAfters.watchedLog= "";
		JUnitCore.runClasses(BeforesAndAfters.class);
		assertThat(BeforesAndAfters.watchedLog, is("before starting test succeeded finished after "));
	}
	
	public static class WrongTypedField {
		@Rule public int x = 5;
		@Test public void foo() {}
	}
	
	@Test public void validateWrongTypedField() {
		assertThat(testResult(WrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}
	
	public static class SonOfWrongTypedField extends WrongTypedField {
		
	}

	@Test public void validateWrongTypedFieldInSuperclass() {
		assertThat(testResult(SonOfWrongTypedField.class), 
				hasSingleFailureContaining("must implement StatementInterceptor"));
	}

	public static class PrivateInterceptor {
		@SuppressWarnings("unused")
		@Rule private MethodRule interceptor = new TestName();
		@Test public void foo() {}
	}
	
	@Test public void validatePrivateInterceptor() {
		assertThat(testResult(PrivateInterceptor.class), 
				hasSingleFailureContaining("must be public"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/TempFolderInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.assertTrue;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;

import java.io.File;
import java.io.IOException;

import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.TemporaryFolder;

public class TempFolderInterceptorTest {
	private static File createdFile;

	public static class HasTempFolder {
		@Rule
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFile("myfile.txt");
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void tempFolderIsDeleted() {
		assertThat(testResult(HasTempFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	public static class CreatesSubFolder {
		@Rule
		public TemporaryFolder folder= new TemporaryFolder();

		@Test
		public void testUsingTempFolder() throws IOException {
			createdFile= folder.newFolder("subfolder");
			new File(createdFile, "a.txt").createNewFile();
			assertTrue(createdFile.exists());
		}
	}

	@Test
	public void subFolderIsDeleted() {
		assertThat(testResult(CreatesSubFolder.class), isSuccessful());
		assertFalse(createdFile.exists());
	}

	@Test
	public void recursiveDeleteFolderWithOneElement() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		File file= folder.newFile("a");
		folder.delete();
		assertFalse(file.exists());
		assertFalse(folder.getRoot().exists());
	}

	@Test
	public void recursiveDeleteFolderWithZeroElements() throws IOException {
		TemporaryFolder folder= new TemporaryFolder();
		folder.create();
		folder.delete();
		assertFalse(folder.getRoot().exists());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/ExpectedExceptionInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExpectedException;
import org.junit.experimental.interceptor.Rule;

public class ExpectedExceptionInterceptorTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class),
				hasSingleFailureContaining("\"expectedMessage\"\n     but: getMessage() was \"actualMessage\""));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("but: getMessage() was null"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/ExternalResourceInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Test;
import org.junit.experimental.interceptor.ExternalResource;
import org.junit.experimental.interceptor.Rule;

public class ExternalResourceInterceptorTest {
	private static String callSequence;
	
	public static class UsesExternalResource {
		@Rule public ExternalResource resource = new ExternalResource() {
			@Override
			protected void before() throws Throwable {
				callSequence += "before ";
			};
			
			@Override
			protected void after() {
				callSequence += "after ";
			};
		};
		
		@Test public void testFoo() {
			callSequence += "test ";
		}
	}

	@Test public void externalResourceGeneratesCorrectSequence() {
		callSequence= "";
		assertThat(testResult(UsesExternalResource.class), isSuccessful());
		assertEquals("before test after ", callSequence);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/TimeoutInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertThat;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.MethodRule;
import org.junit.experimental.interceptor.Timeout;
import org.junit.runner.JUnitCore;
import org.junit.runner.Result;

public class TimeoutInterceptorTest {
	public static class HasGlobalTimeout {
		public static String log;
		
		@Rule public MethodRule globalTimeout = new Timeout(20);
		
		@Test public void testInfiniteLoop1() {
			log+= "ran1";
			for(;;) {}
		}
		
		@Test public void testInfiniteLoop2() {
			log+= "ran2";
			for(;;) {}
		}
	}
	
	@Ignore("For gump, for now")
	@Test(timeout=100) public void globalTimeoutAvoidsInfiniteLoop() {
		HasGlobalTimeout.log = "";
		Result result= JUnitCore.runClasses(HasGlobalTimeout.class);
		assertEquals(2, result.getFailureCount());
		assertThat(HasGlobalTimeout.log, containsString("ran1"));
		assertThat(HasGlobalTimeout.log, containsString("ran2"));
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/experimental/interceptor/NameInterceptorTest.java;<<<<<<< MINE
=======
package org.junit.tests.experimental.interceptor;

import static org.junit.Assert.assertEquals;
import org.junit.Test;
import org.junit.experimental.interceptor.Rule;
import org.junit.experimental.interceptor.TestName;

public class NameInterceptorTest {
	@Rule public TestName name = new TestName();
	
	@Test public void testA() {
		assertEquals("testA", name.getMethodName());
	}
	
	@Test public void testB() {
		assertEquals("testB", name.getMethodName());
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_99a84a5_c865737/rev_99a84a5-c865737/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE
		@Test public void a() {}
		@Before public void b() {}
		@Ignore @Test public void c() {}
		@Ignore @After public void d() {}
		public void e() {}
		@BeforeClass public void f() {}
		public void g() {}
		@AfterClass public void h() {}
		@Test public void i() {}
		@Test public void j() {}
=======
		@Test
		public void a() {
		}

		@Before
		public void b() {
		}

		@Ignore
		@Test
		public void c() {
		}

		@Ignore
		@After
		public void d() {
		}

		public void e() {
		}

		@BeforeClass
		public void f() {
		}

		public void g() {
		}

		@AfterClass
		public void h() {
		}

		@Test
		public void i() {
		}

		@Test
		public void j() {
		}
	}

	public static class SuperclassWithField {
		@Rule
		public MethodRule x;
	}

	public static class SubclassWithField extends SuperclassWithField {
		@Rule
		public MethodRule x;
	}

	@Test
	public void fieldsOnSubclassesShadowSuperclasses() {
		assertThat(new TestClass(SubclassWithField.class).getAnnotatedFields(
				Rule.class).size(), is(1));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/CategoryType.java;<<<<<<< MINE
=======
package org.junit.experimental.categories;

/**
 * Super-interface for all interface classes that are used to represent
 * categories.  Representing categories as types allows compile-time
 * checking of typos in category names, preventing accidental test
 * exclusion.
 */
public interface CategoryType {

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_4a678cd_46036e7/rev_4a678cd-46036e7/src/main/java/org/junit/experimental/categories/CategoryClass.java;<<<<<<< MINE
=======
/**
 * 
 */
package org.junit.experimental.categories;

public interface CategoryClass {

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_b33b4b0_c3873cf/rev_b33b4b0-c3873cf/src/main/java/org/junit/runner/Plan.java;<<<<<<< MINE
package org.junit.runner;

import java.util.ArrayList;
import java.util.List;

public abstract class Plan {
	public abstract Description getDescription();
	public abstract List<Plan> getChildren();

	public static Plan fromDescription(final Description description) {
		return new Plan() {
			@Override
			public Description getDescription() {
				return description;
			}
			
			@Override
			public List<Plan> getChildren() {
				List<Description> childrenDescs= description.getChildrenInternal();
				ArrayList<Plan> children= new ArrayList<Plan>();
				for (Description each : childrenDescs)
					children.add(Plan.fromDescription(each));
				return children;
			}
		};
	}
	
	public boolean isSuite() {
		return getChildren().size() > 0;
	}
	
	public boolean isTest() {
		return !isSuite();
	}
}=======
package org.junit.runner;

import java.util.ArrayList;
import java.util.List;

public class Plan {
	private final Description fDescription;

	private Plan(Description description) {
		fDescription= description;
	}

	public Description getDescription() {
		return fDescription;
	}

	public List<Plan> getChildren() {
		ArrayList<Plan> results= new ArrayList<Plan>();
		ArrayList<Description> children= fDescription.getChildren();
		for (Description each : children)
			results.add(Plan.fromDescription(each));
		return results;
	}

	static Plan fromDescription(Description description) {
		return new Plan(description);
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_25fa1d5_2de4d6f/rev_25fa1d5-2de4d6f/src/test/java/junit/tests/framework/ThreeTestCases.java;<<<<<<< MINE
=======
package junit.tests.framework;

/**
 * Test class used in SuiteTest
 */
import junit.framework.TestCase;

public class ThreeTestCases extends TestCase {
	public void testCase() {
	}
	public void testCase2() {
	}
	public void testCase3thisTimeItsPersonal() {
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/main/java/org/junit/experimental/theories/Theories.java;<<<<<<< MINE
	// TODO: this should be static
	public class TheoryAnchor extends Statement {
=======
	public static class TheoryAnchor extends Statement {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/junit/tests/framework/ThreeTestCases.java;<<<<<<< MINE
=======
package junit.tests.framework;

/**
 * Test class used in SuiteTest
 */
import junit.framework.TestCase;

public class ThreeTestCases extends TestCase {
	public void testCase() {
	}
	public void testCase2() {
	}
	public void testCase3thisTimeItsPersonal() {
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/theories/extendingwithstubs/StubbedTheories.java;<<<<<<< MINE
	public class StubbedTheoryAnchor extends TheoryAnchor {
		public StubbedTheoryAnchor(FrameworkMethod method) {
			super(method);
=======
	public static class StubbedTheoryAnchor extends TheoryAnchor {
		public StubbedTheoryAnchor(FrameworkMethod method, TestClass testClass) {
			super(method, testClass);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE

	public static class Category1 {
	}

	public static class Category2 {
	}

=======
	
	public static class Category1 {}
	public static class Category2 {}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/experimental/categories/CategoryTest.java;<<<<<<< MINE
	
	public static class LeafClass {
		@Test public void a() {}
	}
	
	@RunWith(Suite.class)
	@Category(String.class)
	@SuiteClasses({LeafClass.class})
	public static class CategorizedSuite {
	}
	
	@RunWith(Categories.class)
	@IncludeCategory(String.class)
	@SuiteClasses({CategorizedSuite.class})
	public static class ParentSuite {
	}
	
	@Ignore @Test public void categoriesOnSuiteTrickleDown() {
		assertThat(testResult(ParentSuite.class), isSuccessful());
		Result result= new JUnitCore().run(ParentSuite.class);
		assertEquals(1, result.getRunCount());
		assertEquals(0, result.getFailureCount());
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_592b71c_5695469/rev_592b71c-5695469/src/test/java/org/junit/tests/ParentRunnerTest.java;<<<<<<< MINE
	
	@RunWith(Suite.class)
	@SuiteClasses({FruitTest.class})
	public static class FruitSuite {
		
	}
	
	@Test public void saneBehaviorWhenNoTestsShouldRun() {
		Filter nothing= new Filter() {			
			@Override
			public boolean shouldRun(Description description) {
				return false;
			}
			
			@Override
			public String describe() {
				return "nothing";
			}
		};
		assertNotNull(Request.aClass(FruitSuite.class).filterWith(nothing).getRunner());
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/main/java/org/junit/rules/ClassRule.java;<<<<<<< MINE
=======
/**
 * Created Oct 19, 2009
 */
package org.junit.rules;

import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;

/**
 * A ClassRule is the class-level analogue to a
 * {@link org.junit.rules.MethodRule}.
 * 
 * @author Alistair A. Israel
 */
public interface ClassRule {

	/**
	 * Modifies the class-running {@link Statement} to implement an additional,
	 * class-level test-running rule.
	 * 
	 * @param base
	 *            The {@link Statement} to be modified
	 * @param method
	 *            The {@link TestClass} to be run
	 * @return a new statement, which may be the same as {@code base}, a wrapper
	 *         around {@code base}, or a completely new Statement.
	 */
	Statement apply(Statement base, TestClass testClass);

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_28ef5cb_74bb7d8/rev_28ef5cb-74bb7d8/src/test/java/org/junit/tests/experimental/rules/ClassRulesTest.java;<<<<<<< MINE
=======
/**
 * Created Oct 19, 2009
 */
package org.junit.tests.experimental.rules;

import static org.junit.Assert.assertFalse;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ClassRule;
import org.junit.runner.JUnitCore;
import org.junit.runners.model.Statement;
import org.junit.runners.model.TestClass;

/**
 * Tests to exercise class-level rules.
 */
public class ClassRulesTest {

	private static int runCount;

	public static class ExampleTestWithClassRule {

		@Rule
		public static ClassRule classRule= new ClassRule() {

			public Statement apply(final Statement base,
					final TestClass testClass) {
				return new Statement() {

					@Override
					public void evaluate() throws Throwable {
						++runCount;
						base.evaluate();
					}
				};
			}
		};

		@Test
		public void firstTest() {
			assertFalse("ClassRule was not applied!", runCount == 0);
			assertFalse("ClassRule was applied more than once!", runCount > 1);
		}

		@Test
		public void secondTest() {
			assertFalse("ClassRule was not applied!", runCount == 0);
			assertFalse("ClassRule was applied more than once!", runCount > 1);
		}
	}

	@Test
	public void ruleIsAppliedOnce() {
		runCount= 0;
		JUnitCore.runClasses(ExampleTestWithClassRule.class);
		assertFalse("ClassRule was not applied!", runCount == 0);
		assertFalse("ClassRule was applied more than once!", runCount > 1);
	}

	public static class SubclassOfTestWithClassRule extends
			ExampleTestWithClassRule {

	}

	@Test
	public void ruleIsIntroducedAndEvaluatedOnSubclass() {
		runCount= 0;
		JUnitCore.runClasses(SubclassOfTestWithClassRule.class);
		assertFalse("ClassRule was not applied!", runCount == 0);
		assertFalse("ClassRule was applied more than once!", runCount > 1);
	}

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_f27f809_d97f30a/rev_f27f809-d97f30a/src/test/java/redis/clients/jedis/tests/SharedJedisPipelineTest.java;<<<<<<< MINE
=======
package redis.clients.jedis.tests;

import org.junit.Before;
import org.junit.Test;
import redis.clients.jedis.*;
import redis.clients.jedis.exceptions.JedisDataException;

import java.io.UnsupportedEncodingException;
import java.util.*;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.auth("foobared");
        jedis.flushAll();
        jedis.disconnect();

        JedisShardInfo shardInfo1 = new JedisShardInfo(redis1.host, redis1.port);
        JedisShardInfo shardInfo2 = new JedisShardInfo(redis2.host, redis2.port);
        shardInfo1.setPassword("foobared");
        shardInfo2.setPassword("foobared");
        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(shardInfo1);
        shards.add(shardInfo2);
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));
    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(new Double(2), zincrby.get());
        assertEquals(new Long(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_cb1b19b_04f6038/rev_cb1b19b-04f6038/src/test/java/redis/clients/jedis/tests/SharedJedisPipelineTest.java;<<<<<<< MINE
=======
package redis.clients.jedis.tests;

import static junit.framework.Assert.assertEquals;
import static junit.framework.Assert.assertNull;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;

import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import org.junit.Before;
import org.junit.Test;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.Response;
import redis.clients.jedis.ShardedJedis;
import redis.clients.jedis.ShardedJedisPipeline;
import redis.clients.jedis.Tuple;
import redis.clients.jedis.exceptions.JedisDataException;

public class SharedJedisPipelineTest {
    private static HostAndPortUtil.HostAndPort redis1 = HostAndPortUtil.getRedisServers()
            .get(0);
    private static HostAndPortUtil.HostAndPort redis2 = HostAndPortUtil.getRedisServers()
            .get(1);

    private ShardedJedis jedis;

    @Before
    public void setUp() throws Exception {
        Jedis jedis = new Jedis(redis1.host, redis1.port);
        jedis.flushAll();
        jedis.disconnect();
        jedis = new Jedis(redis2.host, redis2.port);
        jedis.flushAll();
        jedis.disconnect();

        List<JedisShardInfo> shards = new ArrayList<JedisShardInfo>();
        shards.add(new JedisShardInfo(redis1.host, redis1.port));
        shards.add(new JedisShardInfo(redis2.host, redis2.port));
        this.jedis = new ShardedJedis(shards);
    }

    @Test
    public void pipeline() throws UnsupportedEncodingException {
        ShardedJedisPipeline p = jedis.pipelined();
        p.set("foo", "bar");
        p.get("foo");
        List<Object> results = p.syncAndReturnAll();

        assertEquals(2, results.size());
        assertEquals("OK", results.get(0));
        assertEquals("bar", results.get(1));

    }

    @Test
    public void pipelineResponse() {
        jedis.set("string", "foo");
        jedis.lpush("list", "foo");
        jedis.hset("hash", "foo", "bar");
        jedis.zadd("zset", 1, "foo");
        jedis.sadd("set", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        Response<String> list = p.lpop("list");
        Response<String> hash = p.hget("hash", "foo");
        Response<Set<String>> zset = p.zrange("zset", 0, -1);
        Response<String> set = p.spop("set");
        Response<Boolean> blist = p.exists("list");
        Response<Double> zincrby = p.zincrby("zset", 1, "foo");
        Response<Long> zcard = p.zcard("zset");
        p.lpush("list", "bar");
        Response<List<String>> lrange = p.lrange("list", 0, -1);
        Response<Map<String, String>> hgetAll = p.hgetAll("hash");
        p.sadd("set", "foo");
        Response<Set<String>> smembers = p.smembers("set");
        Response<Set<Tuple>> zrangeWithScores = p.zrangeWithScores("zset", 0,
                -1);
        p.sync();

        assertEquals("foo", string.get());
        assertEquals("foo", list.get());
        assertEquals("bar", hash.get());
        assertEquals("foo", zset.get().iterator().next());
        assertEquals("foo", set.get());
        assertFalse(blist.get());
        assertEquals(Double.valueOf(2), zincrby.get());
        assertEquals(Long.valueOf(1), zcard.get());
        assertEquals(1, lrange.get().size());
        assertNotNull(hgetAll.get().get("foo"));
        assertEquals(1, smembers.get().size());
        assertEquals(1, zrangeWithScores.get().size());
    }

    @Test(expected = JedisDataException.class)
    public void pipelineResponseWithinPipeline() {
        jedis.set("string", "foo");

        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> string = p.get("string");
        string.get();
        p.sync();
    }

    @Test
    public void canRetrieveUnsetKey() {
        ShardedJedisPipeline p = jedis.pipelined();
        Response<String> shouldNotExist = p.get(UUID.randomUUID().toString());
        p.sync();
        assertNull(shouldNotExist.get());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e857122_9d8bb06/rev_e857122-9d8bb06/src/main/java/org/junit/rules/TestWatcher.java;<<<<<<< MINE
public abstract class TestWatcher extends TestRule {
	@Override
	protected Statement apply(final Statement base, final Description description) {
=======
public class TestWatcher implements TestRule {
	public Statement apply(final Statement base, final Description description) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_46734e6_6c8d7a5/rev_46734e6-6c8d7a5/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, BasicCommands {
=======
import java.net.URI;
import java.util.*;

public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, ClusterCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_68356eb_2d04a38/rev_68356eb-2d04a38/src/main/java/redis/clients/jedis/Jedis.java;<<<<<<< MINE
public class Jedis extends BinaryJedis implements JedisCommands, MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands, BasicCommands, ClusterCommands, SentinelCommands {
=======
public class Jedis extends BinaryJedis implements JedisCommands,
	MultiKeyCommands, AdvancedJedisCommands, ScriptingCommands,
	BasicCommands, ClusterCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_c2bdb1a_34d2943/rev_c2bdb1a-34d2943/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.both;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}

	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6b943e5_34d2943/rev_6b943e5-34d2943/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import org.hamcrest.CoreMatchers;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}

        @Test
        public void throwsIllegalArgumentExceptionWithCause() {
            NullPointerException expectedCause = new NullPointerException("expected cause");

            thrown.expect(IllegalArgumentException.class);
            thrown.expectMessage("Ack!");
            thrown.expectCause(is(expectedCause));

            throw new IllegalArgumentException("Ack!", expectedCause);
        }

        @Test
        public void throwsIllegalArgumentExceptionWithCauseExplicitlyNull() {
            thrown.expect(IllegalArgumentException.class);
            thrown.expectMessage("Ack!");
            thrown.expectCause(CoreMatchers.<Throwable>nullValue());

            throw new IllegalArgumentException("Ack!");
        }
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}

	public static class HasWrongCause {
        public static final NullPointerException EXPECTED_CAUSE = new NullPointerException("expected cause");

        @Rule
		public ExpectedException thrown= ExpectedException.none();

        @Test
		public void throwWithCause() {
            thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
            thrown.expectCause(is(EXPECTED_CAUSE));

			throw new IllegalArgumentException("Ack!", new NullPointerException("an unexpected cause"));
		}
	}

	@Test
	public void failsWithWrongCause() {
		assertThat(testResult(HasWrongCause.class),
            hasSingleFailureContaining(HasWrongCause.EXPECTED_CAUSE.toString()));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_e381886_3f6e3ef/rev_e381886-3f6e3ef/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionRuleTest.java;<<<<<<< MINE
package org.junit.tests.experimental.rules;

import static org.hamcrest.CoreMatchers.any;
import static org.hamcrest.CoreMatchers.instanceOf;
import static org.junit.Assert.assertThat;
import static org.junit.experimental.results.PrintableResult.testResult;
import static org.junit.experimental.results.ResultMatchers.failureIs;
import static org.junit.experimental.results.ResultMatchers.hasSingleFailureContaining;
import static org.junit.experimental.results.ResultMatchers.isSuccessful;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.causedBy;
import org.hamcrest.Description;
import org.hamcrest.Matcher;
import org.junit.Rule;
import org.junit.Test;
import org.junit.internal.matchers.TypeSafeMatcher;
import org.junit.rules.ExpectedException;

public class ExpectedExceptionRuleTest {
	public static class HasExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNothing() {

		}

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new NullPointerException();
		}

		@Test
		public void throwsNullPointerExceptionWithMessage() {
			thrown.expect(NullPointerException.class);
			thrown.expectMessage("happened?");
			throw new NullPointerException("What happened?");
		}
	}

	@Test
	public void expectedExceptionPasses() {
		assertThat(testResult(HasExpectedException.class), isSuccessful());
	}

	public static class HasWrongExpectedException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expect(NullPointerException.class);
			throw new IllegalArgumentException();
		}
	}

	@Test
	public void unExpectedExceptionFails() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				hasSingleFailureContaining("Expected: an instance of java.lang.NullPointerException"));
	}
	
	@Test
	public void expectedExceptionClauseExists() {
		assertThat(
				testResult(HasWrongExpectedException.class),
				failureIs(causedBy(instanceOf(IllegalArgumentException.class))));
	}

	public static class HasWrongMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsNullPointerException() {
			thrown.expectMessage("expectedMessage");
			throw new IllegalArgumentException("actualMessage");
		}
	}

	@Test
	public void wrongMessageFails() {
		assertThat(
				testResult(HasWrongMessage.class), both(
				hasSingleFailureContaining("expectedMessage")).and(
				hasSingleFailureContaining("actualMessage")));
	}

	public static class WronglyExpectsException {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowNullPointerException() {
			thrown.expect(NullPointerException.class);
		}
	}

	@Test
	public void failsIfExceptionNeverComes() {
		assertThat(
				testResult(WronglyExpectsException.class),
				hasSingleFailureContaining("Expected test to throw an instance of java.lang.NullPointerException"));
	}

	public static class WronglyExpectsExceptionMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void doesntThrowAnything() {
			thrown.expectMessage("anything!");
		}
	}

	@Test
	public void failsIfExceptionMessageNeverComes() {
		assertThat(
				testResult(WronglyExpectsExceptionMessage.class),
				hasSingleFailureContaining("Expected test to throw exception with message a string containing \"anything!\""));
	}

	public static class ExpectsSubstring {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException(
					"This could throw anything! (as long as it has the right substring)");
		}
	}

	@Test
	public void passesWithSubstringMethod() {
		assertThat(testResult(ExpectsSubstring.class), isSuccessful());
	}

	public static class ExpectsSubstringNullMessage {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage("anything!");
			throw new NullPointerException();
		}
	}

	@Test
	public void failsWithNullExceptionMessage() {
		assertThat(testResult(ExpectsSubstringNullMessage.class),
				hasSingleFailureContaining("NullPointerException"));
	}

	public static class ExpectsMessageMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Ack"));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMessageMatcher() {
		assertThat(testResult(ExpectsMessageMatcher.class), isSuccessful());
	}

	public static class ExpectedMessageMatcherFails {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expectMessage(startsWith("Wrong start"));
			throw new NullPointerException("Back!");
		}
	}



	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}
		
			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
	
	@Test
	public void failsWithMatcher() {
		assertThat(testResult(ExpectedMessageMatcherFails.class),
				hasSingleFailureContaining("Wrong start"));
	}

	public static class ExpectsMatcher {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(any(Throwable.class));
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void succeedsWithMatcher() {
		assertThat(testResult(ExpectsMatcher.class), isSuccessful());
	}

	public static class ExpectsMultipleMatchers {
		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwsMore() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			throw new NullPointerException("Ack!");
		}
	}

	@Test
	public void failsWithMultipleMatchers() {
		assertThat(testResult(ExpectsMultipleMatchers.class),
				hasSingleFailureContaining("IllegalArgumentException"));
	}
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_c2cf79c_ac53759/rev_c2cf79c-ac53759/src/test/java/redis/clients/jedis/tests/commands/HyperLogLogCommandsTest.java;<<<<<<< MINE
package redis.clients.jedis.tests.commands;

import org.junit.Test;

import redis.clients.util.SafeEncoder;

public class HyperLogLogCommandsTest extends JedisCommandTestBase {


    @Test
    public void pfadd() {
	long status = jedis.pfadd("foo", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("foo", "a");
	assertEquals(0, status);
    }
    
    @Test
    public void pfaddBinary() {
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bBar2 = SafeEncoder.encode("bar2");
	
	long status = jedis.pfadd(bFoo, bBar, bBar2);
	assertEquals(1, status);
	
	status = jedis.pfadd(bFoo, bBar, bBar2);
	assertEquals(0, status);
    }
    
    @Test
    public void pfcount() {
	long status = jedis.pfadd("hll", "foo", "bar", "zap");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll", "zap", "zap", "zap");
	assertEquals(0, status);
	
	status = jedis.pfadd("hll", "foo", "bar");
	assertEquals(0, status);
	
	status = jedis.pfcount("hll");
	assertEquals(3, status);
    }
    
    @Test
    public void pfcountBinary() {
	byte[] bHll = SafeEncoder.encode("hll");
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bZap = SafeEncoder.encode("zap");
	
	long status = jedis.pfadd(bHll, bFoo, bBar, bZap);
	assertEquals(1, status);
	
	status = jedis.pfadd(bHll, bZap, bZap, bZap);
	assertEquals(0, status);
	
	status = jedis.pfadd(bHll, bFoo, bBar);
	assertEquals(0, status);
	
	status = jedis.pfcount(bHll);
	assertEquals(3, status);
    }
    
    @Test
    public void pfmerge() {
	long status = jedis.pfadd("hll1", "foo", "bar", "zap", "a");
	assertEquals(1, status);
	
	status = jedis.pfadd("hll2", "a", "b", "c", "foo");
	assertEquals(1, status);
	
	String mergeStatus = jedis.pfmerge("hll3", "hll1", "hll2");
	assertEquals("OK", mergeStatus);
	
	status = jedis.pfcount("hll3");
	assertEquals(6, status);
    }
    
    @Test
    public void pfmergeBinary() {
	byte[] bHll1 = SafeEncoder.encode("hll1");
	byte[] bHll2 = SafeEncoder.encode("hll2");
	byte[] bHll3 = SafeEncoder.encode("hll3");
	byte[] bFoo = SafeEncoder.encode("foo");
	byte[] bBar = SafeEncoder.encode("bar");
	byte[] bZap = SafeEncoder.encode("zap");
	byte[] bA = SafeEncoder.encode("a");
	byte[] bB = SafeEncoder.encode("b");
	byte[] bC = SafeEncoder.encode("c");
	
	long status = jedis.pfadd(bHll1, bFoo, bBar, bZap, bA);
	assertEquals(1, status);
	
	status = jedis.pfadd(bHll2, bA, bB, bC, bFoo);
	assertEquals(1, status);
	
	String mergeStatus = jedis.pfmerge(bHll3, bHll1, bHll2);
	assertEquals("OK", mergeStatus);
	
	status = jedis.pfcount("hll3");
	assertEquals(6, status);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d783ef_28938e9/rev_8d783ef-28938e9/src/test/java/org/junit/tests/experimental/rules/ExpectedExceptionTest.java;<<<<<<< MINE
=======

	public static class ThrowExceptionWithMatchingCause {
		@Rule
		public ExpectedException thrown = none();

		@Test
		public void throwExceptionWithMatchingCause() {
			NullPointerException expectedCause = new NullPointerException("expected cause");

			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(is(expectedCause));

			throw new IllegalArgumentException("Ack!", expectedCause);
		}
	}

	public static class ThrowExpectedNullCause {
		@Rule
		public ExpectedException thrown = none();

		@Test
		public void throwExpectedNullCause() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(CoreMatchers.<Throwable>nullValue());

			throw new IllegalArgumentException("Ack!");
		}
	}

	public static class ThrowUnexpectedCause {

		@Rule
		public ExpectedException thrown= ExpectedException.none();

		@Test
		public void throwWithCause() {
			thrown.expect(IllegalArgumentException.class);
			thrown.expectMessage("Ack!");
			thrown.expectCause(is(new NullPointerException("expected cause")));

			throw new IllegalArgumentException("Ack!", new NullPointerException("an unexpected cause"));
		}
	}


	private static Matcher<String> startsWith(final String prefix) {
		return new TypeSafeMatcher<String>() {
			public void describeTo(Description description) {
				description.appendText("starts with ");
				description.appendText(prefix);
			}

			@Override
			public boolean matchesSafely(String item) {
				return item.startsWith(prefix);
			}
		};
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_670e019_0a8aa7a/rev_670e019-0a8aa7a/src/main/java/redis/clients/jedis/ShardedJedis.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.util.Hashing;
import redis.clients.util.Pool;

public class ShardedJedis extends BinaryShardedJedis implements JedisCommands,
	Closeable {

    protected Pool<ShardedJedis> dataSource = null;

=======
public class ShardedJedis extends BinaryShardedJedis implements JedisCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_737112a_79d27ef/rev_737112a-79d27ef/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster implements JedisCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
=======
public class JedisCluster extends BinaryJedisCluster implements JedisCommands, 
        JedisClusterScriptingCommands {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_5939d5b_76df52e/rev_5939d5b-76df52e/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
=======
public class JedisCluster implements JedisCommands, BasicCommands {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_6fb53a7_2f879b9/rev_6fb53a7-2f879b9/src/test/java/org/junit/tests/experimental/rules/TestWatcherTest.java;<<<<<<< MINE
		@Test
		public void succeeds() {
			assumeTrue(false);
		}
	}

	@Test
	public void neitherLogSuccessNorFailedForViolatedAssumption() {
		ViolatedAssumptionTest.watchedLog= new StringBuilder();
		runClasses(ViolatedAssumptionTest.class);
		assertThat(ViolatedAssumptionTest.watchedLog.toString(),
				is("starting finished "));
	}

	public static class TestWatcherSkippedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void skipped(AssumptionViolatedException e, Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new AssumptionViolatedException("test failure");
		}
	}

	@Test
	public void testWatcherSkippedThrowsException() {
		PrintableResult result= testResult(TestWatcherSkippedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}

	public static class FailingTest {
		private static StringBuilder watchedLog= new StringBuilder();

		@Rule
		public TestRule watcher= new LoggingTestWatcher(watchedLog);

		@Test
		public void succeeds() {
			fail();
		}
	}

	@Test
	public void logFailingTest() {
		FailingTest.watchedLog= new StringBuilder();
		runClasses(FailingTest.class);
		assertThat(FailingTest.watchedLog.toString(),
				is("starting failed finished "));
	}
	
	public static class TestWatcherFailedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable e, Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherStartingThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void starting(Description description) {
				throw new RuntimeException("watcher failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherStartingThrowsException() {
		PrintableResult result= testResult(TestWatcherStartingThrowsExceptionTest.class);
		assertThat(result, failureCountIs(2));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failure"));
	}
	
	public static class TestWatcherFailedAndFinishedThrowsExceptionTest {
		@Rule
		public TestRule watcher= new TestWatcher() {
			@Override
			protected void failed(Throwable t, Description description) {
				throw new RuntimeException("watcher failed failure");
			}
			
			@Override
			protected void finished(Description description) {
				throw new RuntimeException("watcher finished failure");
			}
		};

		@Test
		public void fails() {
			throw new IllegalArgumentException("test failure");
		}
	}
	
	@Test
	public void testWatcherFailedAndFinishedThrowsException() {
		PrintableResult result= testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
		assertThat(result, failureCountIs(3));
		assertThat(result, hasFailureContaining("test failure"));
		assertThat(result, hasFailureContaining("watcher failed failure"));
		assertThat(result, hasFailureContaining("watcher finished failure"));
	}	
=======
        @Test
        public void succeeds() {
            assumeTrue(false);
        }
    }

    @Test
    public void neitherLogSuccessNorFailedForViolatedAssumption() {
        ViolatedAssumptionTest.watchedLog = new StringBuilder();
        runClasses(ViolatedAssumptionTest.class);
        assertThat(ViolatedAssumptionTest.watchedLog.toString(),
                is("starting finished "));
    }

    public static class FailingTest {
        private static StringBuilder watchedLog = new StringBuilder();

        @Rule
        public TestRule watcher = new LoggingTestWatcher(watchedLog);

        @Test
        public void succeeds() {
            fail();
        }
    }

    @Test
    public void logFailingTest() {
        FailingTest.watchedLog = new StringBuilder();
        runClasses(FailingTest.class);
        assertThat(FailingTest.watchedLog.toString(),
                is("starting failed finished "));
    }

    public static class TestWatcherFailedThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void failed(Throwable e, Description description) {
                throw new RuntimeException("watcher failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherFailedThrowsException() {
        PrintableResult result = testResult(TestWatcherFailedThrowsExceptionTest.class);
        assertThat(result, failureCountIs(2));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failure"));
    }

    public static class TestWatcherStartingThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void starting(Description description) {
                throw new RuntimeException("watcher failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherStartingThrowsException() {
        PrintableResult result = testResult(TestWatcherStartingThrowsExceptionTest.class);
        assertThat(result, failureCountIs(2));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failure"));
    }

    public static class TestWatcherFailedAndFinishedThrowsExceptionTest {
        @Rule
        public TestRule watcher = new TestWatcher() {
            @Override
            protected void failed(Throwable t, Description description) {
                throw new RuntimeException("watcher failed failure");
            }

            @Override
            protected void finished(Description description) {
                throw new RuntimeException("watcher finished failure");
            }
        };

        @Test
        public void fails() {
            throw new IllegalArgumentException("test failure");
        }
    }

    @Test
    public void testWatcherFailedAndFinishedThrowsException() {
        PrintableResult result = testResult(TestWatcherFailedAndFinishedThrowsExceptionTest.class);
        assertThat(result, failureCountIs(3));
        assertThat(result, hasFailureContaining("test failure"));
        assertThat(result, hasFailureContaining("watcher failed failure"));
        assertThat(result, hasFailureContaining("watcher finished failure"));
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53c9344_ab2f43b/rev_53c9344-ab2f43b/src/main/java/redis/clients/jedis/JedisSentinelPool.java;<<<<<<< MINE
    @Override
    public Jedis getResource() {
	while (true) {
	    Jedis jedis = super.getResource();
	    jedis.setDataSource(this);

	    // get a reference because it can change concurrently
	    final HostAndPort master = currentHostMaster;
	    final HostAndPort connection = new HostAndPort(jedis.getClient().getHost(),
	       jedis.getClient().getPort());

	    if (master.equals(connection)) {
	        // connected to the correct master
	        return jedis;
	    } else {
	        returnBrokenResource(jedis);
	    }
	}
    }

    public void returnBrokenResource(final Jedis resource) {
	if (resource != null) {
	    returnBrokenResourceObject(resource);
	}
    }

    public void returnResource(final Jedis resource) {
	if (resource != null) {
	    resource.resetState();
	    returnResourceObject(resource);
	}
    }

    protected class JedisPubSubAdapter extends JedisPubSub {
	@Override
	public void onMessage(String channel, String message) {
	}
=======
		@Override
		public void onPUnsubscribe(String pattern, int subscribedChannels) {
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_19fc1f8_fc594db/rev_19fc1f8-fc594db/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

public class JedisCluster implements JedisCommands, BasicCommands {
=======
public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3b31ae7_7836531/rev_3b31ae7-7836531/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
=======
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
    public static final short HASHSLOTS = 16384;
    private static final int DEFAULT_TIMEOUT = 1;
    private static final int DEFAULT_MAX_REDIRECTIONS = 5;
    
    public static enum Reset {SOFT, HARD}

    private int timeout;
    private int maxRedirections;

    private JedisClusterConnectionHandler connectionHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3495402_3ebc25e/rev_3495402-3ebc25e/src/main/java/redis/clients/jedis/PipelineBlock.java;<<<<<<< MINE
package redis.clients.jedis;

@Deprecated
/**
 * This method is deprecated due to its error prone with multi
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class PipelineBlock extends Pipeline {
    // For shadowing
    @SuppressWarnings("unused")
    private Client client;

    public abstract void execute();
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_3495402_3ebc25e/rev_3495402-3ebc25e/src/main/java/redis/clients/jedis/TransactionBlock.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.exceptions.JedisException;

@Deprecated
/**
 * This class is deprecated due to its error prone
 * and will be removed on next major release
 * @see https://github.com/xetorthio/jedis/pull/498
 */
public abstract class TransactionBlock extends Transaction {
    // For shadowing
    @SuppressWarnings("unused")
    private Client client;

    public TransactionBlock(Client client) {
	super(client);
    }

    public TransactionBlock() {
    }

    public abstract void execute() throws JedisException;

    public void setClient(Client client) {
	super.setClient(client);
    }
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_53e7dc2_d33bd40/rev_53e7dc2-d33bd40/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
        JedisClusterScriptingCommands {
    public static enum Reset {SOFT, HARD}
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 1;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

  public static enum Reset {
    SOFT, HARD
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_2510e34_d33bd40/rev_2510e34-d33bd40/src/main/java/redis/clients/jedis/MultiKeyPipelineBase.java;<<<<<<< MINE
abstract class MultiKeyPipelineBase extends PipelineBase implements
	MultiKeyBinaryRedisPipeline, MultiKeyCommandsPipeline, 
	ClusterPipeline, BinaryScriptingCommandsPipeline, ScriptingCommandsPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }
    
    public Response<Object> eval(String script) {
	return this.eval(script, 0, new String[0]);
    }

    public Response<Object> eval(String script, List<String> keys,
	    List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.eval(script, keys.size(), argv);
    }
    
    public Response<Object> eval(String script, int keyCount, String... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_RESULT);
    }

    public Response<Object> evalsha(String script) {
	return this.evalsha(script, 0, new String[0]);
    }

    public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
	String[] argv = Jedis.getParams(keys, args);
	return this.evalsha(sha1, keys.size(), argv);
    }

    public Response<Object> evalsha(String sha1, int keyCount, String... params) {
	getClient(sha1).evalsha(sha1, keyCount, params);
	return getResponse(BuilderFactory.EVAL_RESULT);
    }

    public Response<Object> eval(byte[] script) {
	return this.eval(script, 0);
    }
    
    public Response<Object> eval(byte[] script, byte[] keyCount, byte[]... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
    
    public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
	byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
	return this.eval(script, keys.size(), argv);
    }
    
    public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
	getClient(script).eval(script, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
    
    public Response<Object> evalsha(byte[] sha1) {
	return this.evalsha(sha1, 0);
    }
    
    public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
	byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
	return this.evalsha(sha1, keys.size(), argv);
    }
    
    public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
	getClient(sha1).evalsha(sha1, keyCount, params);
	return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
    }
=======
abstract class MultiKeyPipelineBase extends PipelineBase implements BasicRedisPipeline,
    MultiKeyBinaryRedisPipeline, MultiKeyCommandsPipeline, ClusterPipeline {

  protected Client client = null;

  public Response<List<String>> brpop(String... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(int timeout, String... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(String... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> brpop(byte[]... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> brpop(int timeout, byte[]... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> blpop(byte[]... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> blpop(int timeout, byte[]... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> del(String... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[]... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> keys(String pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> keys(byte[] pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> mget(String... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> mget(byte[]... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> mset(String... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> mset(byte[]... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> msetnx(String... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> msetnx(byte[]... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rename(String oldkey, String newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> rename(byte[] oldkey, byte[] newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> renamenx(String oldkey, String newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpoplpush(String srckey, String dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Set<String>> sdiff(String... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sdiff(byte[]... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sdiffstore(String dstkey, String... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sinter(String... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sinter(byte[]... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sinterstore(String dstkey, String... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(String srckey, String dstkey, String member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, SortingParams sortingParameters, String dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, String dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, byte[] dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sunion(String... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sunion(byte[]... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sunionstore(String dstkey, String... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> watch(String... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> watch(byte[]... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zinterstore(String dstkey, String... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(String dstkey, ZParams params, String... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, String... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, ZParams params, String... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> bgrewriteaof() {
    client.bgrewriteaof();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> bgsave() {
    client.bgsave();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> configGet(String pattern) {
    client.configGet(pattern);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> configSet(String parameter, String value) {
    client.configSet(parameter, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> brpoplpush(String source, String destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> configResetStat() {
    client.configResetStat();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> save() {
    client.save();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> lastsave() {
    client.lastsave();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(String channel, String message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> randomKey() {
    client.randomKey();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> randomKeyBinary() {
    client.randomKey();
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> flushDB() {
    client.flushDB();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> flushAll() {
    client.flushAll();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info() {
    client.info();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> time() {
    client.time();
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> dbSize() {
    client.dbSize();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> shutdown() {
    client.shutdown();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ping() {
    client.ping();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> select(int index) {
    client.select(index);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> clusterNodes() {
    client.clusterNodes();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterMeet(final String ip, final int port) {
    client.clusterMeet(ip, port);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterAddSlots(final int... slots) {
    client.clusterAddSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterDelSlots(final int... slots) {
    client.clusterDelSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterInfo() {
    client.clusterInfo();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> clusterGetKeysInSlot(final int slot, final int count) {
    client.clusterGetKeysInSlot(slot, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> clusterSetSlotNode(final int slot, final String nodeId) {
    client.clusterSetSlotNode(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotMigrating(final int slot, final String nodeId) {
    client.clusterSetSlotMigrating(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotImporting(final int slot, final String nodeId) {
    client.clusterSetSlotImporting(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(String destkey, String... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<Long> pfcount(String... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(final byte[]... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/internal/AllMembersSupplierTest.java;<<<<<<< MINE
    
    public static class HasDataPointsArrayField {
=======
    @Rule
    public ExpectedException expected = ExpectedException.none();
    
    public static class HasDataPoints {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_8d7f5cc_38d9130/rev_8d7f5cc-38d9130/src/test/java/org/junit/tests/experimental/theories/AssumingInTheoriesTest.java;<<<<<<< MINE
    @Test
    public void noTheoryAnnotationMeansAssumeShouldIgnore() {
        Assume.assumeTrue(false);
    }

    @Test
    public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
        Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
        Assert.assertEquals(1, result.getFailureCount());
    }

    /**
     * Simple class that SHOULD fail because no parameters are met.
     */
    public static class TheoryWithNoUnassumedParameters {

        @DataPoint
        public final static boolean FALSE = false;

        @Theory
        public void theoryWithNoUnassumedParameters(boolean value) {
            Assume.assumeTrue(value);
        }
    }
=======
	@Test
	public void noTheoryAnnotationMeansAssumeShouldIgnore() {
		Assume.assumeTrue(false);
	}

	@Test
	public void theoryMeansOnlyAssumeShouldFail() throws InitializationError {
		Result result = runTheoryClass(TheoryWithNoUnassumedParameters.class);
		Assert.assertEquals(1, result.getFailureCount());
	}

	/**
	 * Simple class that SHOULD fail because no parameters are met.
	 */
	public static class TheoryWithNoUnassumedParameters {
		
		@DataPoint 
		public final static boolean FALSE = false;
		
		@Theory
		public void theoryWithNoUnassumedParameters(boolean value) {
			Assume.assumeTrue(value);
		}
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_b09a1e2_ffbca78/rev_b09a1e2-ffbca78/src/main/java/redis/clients/jedis/PipelineBase.java;<<<<<<< MINE
public abstract class PipelineBase extends Queable implements BinaryRedisPipeline,
	RedisPipeline {
=======
abstract class PipelineBase extends Queable implements BinaryRedisPipeline, RedisPipeline {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_b09a1e2_ffbca78/rev_b09a1e2-ffbca78/src/main/java/redis/clients/jedis/MultiKeyPipelineBase.java;<<<<<<< MINE
public abstract class MultiKeyPipelineBase extends PipelineBase implements
	BasicRedisPipeline, MultiKeyBinaryRedisPipeline,
	MultiKeyCommandsPipeline, ClusterPipeline {

    protected Client client = null;

    public Response<List<String>> brpop(String... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> brpop(int timeout, String... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(String... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<String>> blpop(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> brpop(byte[]... args) {
	client.brpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> brpop(int timeout, byte[]... keys) {
	client.brpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_MAP);
    }

    public Response<List<byte[]>> blpop(byte[]... args) {
	client.blpop(args);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<List<String>> blpop(int timeout, byte[]... keys) {
	client.blpop(timeout, keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> del(String... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> del(byte[]... keys) {
	client.del(keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> keys(String pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> keys(byte[] pattern) {
	getClient(pattern).keys(pattern);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<List<String>> mget(String... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<List<byte[]>> mget(byte[]... keys) {
	client.mget(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
    }

    public Response<String> mset(String... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> mset(byte[]... keysvalues) {
	client.mset(keysvalues);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> msetnx(String... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> msetnx(byte[]... keysvalues) {
	client.msetnx(keysvalues);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rename(String oldkey, String newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> rename(byte[] oldkey, byte[] newkey) {
	client.rename(oldkey, newkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> renamenx(String oldkey, String newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
	client.renamenx(oldkey, newkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> rpoplpush(String srckey, String dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
	client.rpoplpush(srckey, dstkey);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<Set<String>> sdiff(String... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sdiff(byte[]... keys) {
	client.sdiff(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sdiffstore(String dstkey, String... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
	client.sdiffstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sinter(String... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sinter(byte[]... keys) {
	client.sinter(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sinterstore(String dstkey, String... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
	client.sinterstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(String srckey, String dstkey, String member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
	client.smove(srckey, dstkey, member);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, SortingParams sortingParameters,
	    String dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, SortingParams sortingParameters,
	    byte[] dstkey) {
	client.sort(key, sortingParameters, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(String key, String dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sort(byte[] key, byte[] dstkey) {
	client.sort(key, dstkey);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Set<String>> sunion(String... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.STRING_SET);
    }

    public Response<Set<byte[]>> sunion(byte[]... keys) {
	client.sunion(keys);
	return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
    }

    public Response<Long> sunionstore(String dstkey, String... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
	client.sunionstore(dstkey, keys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> watch(String... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> watch(byte[]... keys) {
	client.watch(keys);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> zinterstore(String dstkey, String... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
	client.zinterstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(String dstkey, ZParams params,
	    String... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zinterstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zinterstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, String... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
	client.zunionstore(dstkey, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(String dstkey, ZParams params,
	    String... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> zunionstore(byte[] dstkey, ZParams params,
	    byte[]... sets) {
	client.zunionstore(dstkey, params, sets);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> bgrewriteaof() {
	client.bgrewriteaof();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> bgsave() {
	client.bgsave();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configGet(String pattern) {
	client.configGet(pattern);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> configSet(String parameter, String value) {
	client.configSet(parameter, value);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> brpoplpush(String source, String destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> brpoplpush(byte[] source, byte[] destination,
	    int timeout) {
	client.brpoplpush(source, destination, timeout);
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> configResetStat() {
	client.configResetStat();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> save() {
	client.save();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> lastsave() {
	client.lastsave();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(String channel, String message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> publish(byte[] channel, byte[] message) {
	client.publish(channel, message);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> randomKey() {
	client.randomKey();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<byte[]> randomKeyBinary() {
	client.randomKey();
	return getResponse(BuilderFactory.BYTE_ARRAY);
    }

    public Response<String> flushDB() {
	client.flushDB();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> flushAll() {
	client.flushAll();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> info() {
	client.info();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> time() {
	client.time();
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<Long> dbSize() {
	client.dbSize();
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> shutdown() {
	client.shutdown();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> ping() {
	client.ping();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> select(int index) {
	client.select(index);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
	client.bitop(op, destKey, srcKeys);
	return getResponse(BuilderFactory.LONG);
    }

    public Response<String> clusterNodes() {
	client.clusterNodes();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterMeet(final String ip, final int port) {
	client.clusterMeet(ip, port);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterAddSlots(final int... slots) {
	client.clusterAddSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterDelSlots(final int... slots) {
	client.clusterDelSlots(slots);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterInfo() {
	client.clusterInfo();
	return getResponse(BuilderFactory.STRING);
    }

    public Response<List<String>> clusterGetKeysInSlot(final int slot,
	    final int count) {
	client.clusterGetKeysInSlot(slot, count);
	return getResponse(BuilderFactory.STRING_LIST);
    }

    public Response<String> clusterSetSlotNode(final int slot,
	    final String nodeId) {
	client.clusterSetSlotNode(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotMigrating(final int slot,
	    final String nodeId) {
	client.clusterSetSlotMigrating(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    public Response<String> clusterSetSlotImporting(final int slot,
	    final String nodeId) {
	client.clusterSetSlotImporting(slot, nodeId);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<String> pfmerge(String destkey, String... sourcekeys) {
	client.pfmerge(destkey, sourcekeys);
	return getResponse(BuilderFactory.STRING);
    }

    @Override
    public Response<Long> pfcount(String... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }

    @Override
    public Response<Long> pfcount(final byte[]... keys) {
	client.pfcount(keys);
	return getResponse(BuilderFactory.LONG);
    }
=======
abstract class MultiKeyPipelineBase extends PipelineBase implements MultiKeyBinaryRedisPipeline,
    MultiKeyCommandsPipeline, ClusterPipeline, BinaryScriptingCommandsPipeline,
    ScriptingCommandsPipeline {

  protected Client client = null;

  public Response<List<String>> brpop(String... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> brpop(int timeout, String... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(String... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<String>> blpop(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> blpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> brpop(byte[]... args) {
    client.brpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> brpop(int timeout, byte[]... keys) {
    client.brpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Map<String, String>> brpopMap(int timeout, String... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_MAP);
  }

  public Response<List<byte[]>> blpop(byte[]... args) {
    client.blpop(args);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<List<String>> blpop(int timeout, byte[]... keys) {
    client.blpop(timeout, keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<Long> del(String... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> del(byte[]... keys) {
    client.del(keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> keys(String pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> keys(byte[] pattern) {
    getClient(pattern).keys(pattern);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<List<String>> mget(String... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<List<byte[]>> mget(byte[]... keys) {
    client.mget(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_LIST);
  }

  public Response<String> mset(String... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> mset(byte[]... keysvalues) {
    client.mset(keysvalues);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> msetnx(String... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> msetnx(byte[]... keysvalues) {
    client.msetnx(keysvalues);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rename(String oldkey, String newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> rename(byte[] oldkey, byte[] newkey) {
    client.rename(oldkey, newkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> renamenx(String oldkey, String newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> renamenx(byte[] oldkey, byte[] newkey) {
    client.renamenx(oldkey, newkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> rpoplpush(String srckey, String dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey) {
    client.rpoplpush(srckey, dstkey);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<Set<String>> sdiff(String... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sdiff(byte[]... keys) {
    client.sdiff(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sdiffstore(String dstkey, String... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sdiffstore(byte[] dstkey, byte[]... keys) {
    client.sdiffstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sinter(String... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sinter(byte[]... keys) {
    client.sinter(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sinterstore(String dstkey, String... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sinterstore(byte[] dstkey, byte[]... keys) {
    client.sinterstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(String srckey, String dstkey, String member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member) {
    client.smove(srckey, dstkey, member);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, SortingParams sortingParameters, String dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey) {
    client.sort(key, sortingParameters, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(String key, String dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sort(byte[] key, byte[] dstkey) {
    client.sort(key, dstkey);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Set<String>> sunion(String... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.STRING_SET);
  }

  public Response<Set<byte[]>> sunion(byte[]... keys) {
    client.sunion(keys);
    return getResponse(BuilderFactory.BYTE_ARRAY_ZSET);
  }

  public Response<Long> sunionstore(String dstkey, String... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> sunionstore(byte[] dstkey, byte[]... keys) {
    client.sunionstore(dstkey, keys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> watch(String... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> watch(byte[]... keys) {
    client.watch(keys);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> zinterstore(String dstkey, String... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, byte[]... sets) {
    client.zinterstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(String dstkey, ZParams params, String... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zinterstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, String... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, byte[]... sets) {
    client.zunionstore(dstkey, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(String dstkey, ZParams params, String... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets) {
    client.zunionstore(dstkey, params, sets);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> bgrewriteaof() {
    client.bgrewriteaof();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> bgsave() {
    client.bgsave();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> configGet(String pattern) {
    client.configGet(pattern);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> configSet(String parameter, String value) {
    client.configSet(parameter, value);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> brpoplpush(String source, String destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout) {
    client.brpoplpush(source, destination, timeout);
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> configResetStat() {
    client.configResetStat();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> save() {
    client.save();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> lastsave() {
    client.lastsave();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(String channel, String message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> publish(byte[] channel, byte[] message) {
    client.publish(channel, message);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> randomKey() {
    client.randomKey();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<byte[]> randomKeyBinary() {
    client.randomKey();
    return getResponse(BuilderFactory.BYTE_ARRAY);
  }

  public Response<String> flushDB() {
    client.flushDB();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> flushAll() {
    client.flushAll();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info() {
    client.info();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> info(final String section) {
    client.info(section);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Long> dbSize() {
    client.dbSize();
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> shutdown() {
    client.shutdown();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> ping() {
    client.ping();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> select(int index) {
    client.select(index);
    Response<String> response = getResponse(BuilderFactory.STRING);
    client.setDb(index);

    return response;
  }

  public Response<Long> bitop(BitOP op, byte[] destKey, byte[]... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<Long> bitop(BitOP op, String destKey, String... srcKeys) {
    client.bitop(op, destKey, srcKeys);
    return getResponse(BuilderFactory.LONG);
  }

  public Response<String> clusterNodes() {
    client.clusterNodes();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterMeet(final String ip, final int port) {
    client.clusterMeet(ip, port);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterAddSlots(final int... slots) {
    client.clusterAddSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterDelSlots(final int... slots) {
    client.clusterDelSlots(slots);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterInfo() {
    client.clusterInfo();
    return getResponse(BuilderFactory.STRING);
  }

  public Response<List<String>> clusterGetKeysInSlot(final int slot, final int count) {
    client.clusterGetKeysInSlot(slot, count);
    return getResponse(BuilderFactory.STRING_LIST);
  }

  public Response<String> clusterSetSlotNode(final int slot, final String nodeId) {
    client.clusterSetSlotNode(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotMigrating(final int slot, final String nodeId) {
    client.clusterSetSlotMigrating(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<String> clusterSetSlotImporting(final int slot, final String nodeId) {
    client.clusterSetSlotImporting(slot, nodeId);
    return getResponse(BuilderFactory.STRING);
  }

  public Response<Object> eval(String script) {
    return this.eval(script, 0, new String[0]);
  }

  public Response<Object> eval(String script, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<Object> eval(String script, int keyCount, String... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_RESULT);
  }

  public Response<Object> evalsha(String script) {
    return this.evalsha(script, 0, new String[0]);
  }

  public Response<Object> evalsha(String sha1, List<String> keys, List<String> args) {
    String[] argv = Jedis.getParams(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<Object> evalsha(String sha1, int keyCount, String... params) {
    getClient(sha1).evalsha(sha1, keyCount, params);
    return getResponse(BuilderFactory.EVAL_RESULT);
  }

  public Response<Object> eval(byte[] script) {
    return this.eval(script, 0);
  }

  public Response<Object> eval(byte[] script, byte[] keyCount, byte[]... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  public Response<Object> eval(byte[] script, List<byte[]> keys, List<byte[]> args) {
    byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
    return this.eval(script, keys.size(), argv);
  }

  public Response<Object> eval(byte[] script, int keyCount, byte[]... params) {
    getClient(script).eval(script, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  public Response<Object> evalsha(byte[] sha1) {
    return this.evalsha(sha1, 0);
  }

  public Response<Object> evalsha(byte[] sha1, List<byte[]> keys, List<byte[]> args) {
    byte[][] argv = BinaryJedis.getParamsWithBinary(keys, args);
    return this.evalsha(sha1, keys.size(), argv);
  }

  public Response<Object> evalsha(byte[] sha1, int keyCount, byte[]... params) {
    getClient(sha1).evalsha(sha1, keyCount, params);
    return getResponse(BuilderFactory.EVAL_BINARY_RESULT);
  }

  @Override
  public Response<Long> pfcount(String... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<Long> pfcount(final byte[]... keys) {
    client.pfcount(keys);
    return getResponse(BuilderFactory.LONG);
  }

  @Override
  public Response<String> pfmerge(byte[] destkey, byte[]... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

  @Override
  public Response<String> pfmerge(String destkey, String... sourcekeys) {
    client.pfmerge(destkey, sourcekeys);
    return getResponse(BuilderFactory.STRING);
  }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_80d2827_d1842a2/rev_80d2827-d1842a2/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisCommands,
    JedisClusterScriptingCommands {
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 2000;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/junit/revisions/rev_ae1ffc9_6dd24ff/rev_ae1ffc9-6dd24ff/src/test/java/org/junit/tests/running/classes/TestClassTest.java;<<<<<<< MINE

    @Test
    public void annotationToMethods() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        assertThat(methods.size(), is(2));
    }

    @Test
    public void annotationToMethodsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        exception.expect(UnsupportedOperationException.class);
        annotationToMethods.put(Ignore.class, null);
    }

    @Test
    public void annotationToMethodsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(MethodsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkMethod>> annotationToMethods = tc.getAnnotationToMethods();
        List<FrameworkMethod> methods = annotationToMethods.get(Ignore.class);
        exception.expect(UnsupportedOperationException.class);
        methods.add(null);
    }

    @Test
    public void annotationToFields() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        assertThat(fields.size(), is(2));
    }

    @Test
    public void annotationToFieldsReturnsUnmodifiableMap() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        exception.expect(UnsupportedOperationException.class);
        annotationToFields.put(Rule.class, null);
    }

    @Test
    public void annotationToFieldsReturnsValuesInTheMapThatAreUnmodifiable() {
        TestClass tc = new TestClass(FieldAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<FrameworkField> fields = annotationToFields.get(Rule.class);
        exception.expect(UnsupportedOperationException.class);
        fields.add(null);
    }

    public static class MultipleFieldsAnnotated {
        @DataPoint
        public String a = "testing a";

        @Rule
        public boolean b;

        @DataPoint
        public String c = "testing c";

        @Rule
        public boolean d;
    }

    @Test
    public void annotationToFieldsReturnsKeysInADeterministicOrder() {
        TestClass tc = new TestClass(MultipleFieldsAnnotated.class);
        Map<Class<? extends Annotation>, List<FrameworkField>> annotationToFields = tc.getAnnotationToFields();
        List<Class<? extends Annotation>> keys = new ArrayList<Class<? extends Annotation>>();
        for (Class<? extends Annotation> annotation : annotationToFields.keySet()) {
            keys.add(annotation);
        }
        assertThat(keys.get(0), CoreMatchers.<Class<? extends Annotation>>is(DataPoint.class));
        assertThat(keys.get(1), CoreMatchers.<Class<? extends Annotation>>is(Rule.class));
    }
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_adeec7e_454f783/rev_adeec7e-454f783/src/main/java/redis/clients/jedis/JedisCluster.java;<<<<<<< MINE
public class JedisCluster extends BinaryJedisCluster implements JedisClusterCommands,
    MultiKeyJedisClusterCommands, JedisClusterScriptingCommands {
=======
import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.jedis.params.set.SetParams;

public class JedisCluster implements JedisCommands, BasicCommands, Closeable {
  public static final short HASHSLOTS = 16384;
  private static final int DEFAULT_TIMEOUT = 2000;
  private static final int DEFAULT_MAX_REDIRECTIONS = 5;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryJedisClusterCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

public interface BinaryJedisClusterCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Double zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

/**
 * Common interface for sharded and non-sharded Jedis
 */
public interface JedisCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Long pttl(final String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  String psetex(final String key, final long milliseconds, final String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Double hincrByFloat(final String key, final String field, final double value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, double score, String member, ZAddParams params);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Long zadd(String key, Map<String, Double> scoreMembers, ZAddParams params);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Double zincrby(String key, double score, String member, ZIncrByParams params);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long move(String key, int dbIndex);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  Long bitpos(final String key, final boolean value);

  Long bitpos(final String key, final boolean value, final BitPosParams params);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor,
      final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor, final ScanParams params);

  ScanResult<String> sscan(final String key, final String cursor, final ScanParams params);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryRedisPipeline.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.List;
import java.util.Map;
import java.util.Set;

public interface BinaryRedisPipeline {
  Response<Long> append(byte[] key, byte[] value);

  Response<List<byte[]>> blpop(byte[] arg);

  Response<List<byte[]>> brpop(byte[] arg);

  Response<Long> decr(byte[] key);

  Response<Long> decrBy(byte[] key, long integer);

  Response<Long> del(byte[] keys);

  Response<byte[]> echo(byte[] string);

  Response<Boolean> exists(byte[] key);

  Response<Long> expire(byte[] key, int seconds);

  Response<Long> pexpire(byte[] key, long milliseconds);

  Response<Long> expireAt(byte[] key, long unixTime);

  Response<Long> pexpireAt(byte[] key, long millisecondsTimestamp);

  Response<byte[]> get(byte[] key);

  Response<Boolean> getbit(byte[] key, long offset);

  Response<byte[]> getSet(byte[] key, byte[] value);

  Response<byte[]> getrange(byte[] key, long startOffset, long endOffset);

  Response<Long> hdel(byte[] key, byte[]... field);

  Response<Boolean> hexists(byte[] key, byte[] field);

  Response<byte[]> hget(byte[] key, byte[] field);

  Response<Map<byte[], byte[]>> hgetAll(byte[] key);

  Response<Long> hincrBy(byte[] key, byte[] field, long value);

  Response<Set<byte[]>> hkeys(byte[] key);

  Response<Long> hlen(byte[] key);

  Response<List<byte[]>> hmget(byte[] key, byte[]... fields);

  Response<String> hmset(byte[] key, Map<byte[], byte[]> hash);

  Response<Long> hset(byte[] key, byte[] field, byte[] value);

  Response<Long> hsetnx(byte[] key, byte[] field, byte[] value);

  Response<List<byte[]>> hvals(byte[] key);

  Response<Long> incr(byte[] key);

  Response<Long> incrBy(byte[] key, long integer);

  Response<byte[]> lindex(byte[] key, long index);

  Response<Long> linsert(byte[] key, BinaryClient.LIST_POSITION where, byte[] pivot, byte[] value);

  Response<Long> llen(byte[] key);

  Response<byte[]> lpop(byte[] key);

  Response<Long> lpush(byte[] key, byte[]... string);

  Response<Long> lpushx(byte[] key, byte[]... bytes);

  Response<List<byte[]>> lrange(byte[] key, long start, long end);

  Response<Long> lrem(byte[] key, long count, byte[] value);

  Response<String> lset(byte[] key, long index, byte[] value);

  Response<String> ltrim(byte[] key, long start, long end);

  Response<Long> move(byte[] key, int dbIndex);

  Response<Long> persist(byte[] key);

  Response<byte[]> rpop(byte[] key);

  Response<Long> rpush(byte[] key, byte[]... string);

  Response<Long> rpushx(byte[] key, byte[]... string);

  Response<Long> sadd(byte[] key, byte[]... member);

  Response<Long> scard(byte[] key);

  Response<String> set(byte[] key, byte[] value);

  Response<Boolean> setbit(byte[] key, long offset, byte[] value);

  Response<Long> setrange(byte[] key, long offset, byte[] value);

  Response<String> setex(byte[] key, int seconds, byte[] value);

  Response<Long> setnx(byte[] key, byte[] value);

  Response<Long> setrange(String key, long offset, String value);

  Response<Set<byte[]>> smembers(byte[] key);

  Response<Boolean> sismember(byte[] key, byte[] member);

  Response<List<byte[]>> sort(byte[] key);

  Response<List<byte[]>> sort(byte[] key, SortingParams sortingParameters);

  Response<byte[]> spop(byte[] key);

  Response<Set<byte[]>> spop(byte[] key, long count);

  Response<byte[]> srandmember(byte[] key);

  Response<Long> srem(byte[] key, byte[]... member);

  Response<Long> strlen(byte[] key);

  Response<String> substr(byte[] key, int start, int end);

  Response<Long> ttl(byte[] key);

  Response<String> type(byte[] key);

  Response<Long> zadd(byte[] key, double score, byte[] member);

  Response<Long> zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Response<Long> zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Response<Long> zcard(byte[] key);

  Response<Long> zcount(byte[] key, double min, double max);

  Response<Double> zincrby(byte[] key, double score, byte[] member);

  Response<Double> zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Response<Set<byte[]>> zrange(byte[] key, long start, long end);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Response<Set<byte[]>> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Response<Set<byte[]>> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, double min, double max, int offset,
      int count);

  Response<Set<Tuple>> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset,
      int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Response<Set<byte[]>> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset,
      int count);

  Response<Set<Tuple>> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset,
      int count);

  Response<Set<Tuple>> zrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrank(byte[] key, byte[] member);

  Response<Long> zrem(byte[] key, byte[]... member);

  Response<Long> zremrangeByRank(byte[] key, long start, long end);

  Response<Long> zremrangeByScore(byte[] key, double start, double end);

  Response<Long> zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Response<Set<byte[]>> zrevrange(byte[] key, long start, long end);

  Response<Set<Tuple>> zrevrangeWithScores(byte[] key, long start, long end);

  Response<Long> zrevrank(byte[] key, byte[] member);

  Response<Double> zscore(byte[] key, byte[] member);

  Response<Long> zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Set<byte[]>> zrangeByLex(final byte[] key, final byte[] min, final byte[] max,
      int offset, int count);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Response<Set<byte[]>> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min,
      int offset, int count);

  Response<Long> zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Response<Long> bitcount(byte[] key);

  Response<Long> bitcount(byte[] key, long start, long end);

  Response<Long> pfadd(final byte[] key, final byte[]... elements);

  Response<Long> pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/JedisClusterCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

import java.util.List;
import java.util.Map;
import java.util.Set;

public interface JedisClusterCommands {
  String set(String key, String value);

  String set(String key, String value, SetParams params);

  String get(String key);

  Boolean exists(String key);

  Long persist(String key);

  String type(String key);

  Long expire(String key, int seconds);

  Long pexpire(String key, long milliseconds);

  Long expireAt(String key, long unixTime);

  Long pexpireAt(String key, long millisecondsTimestamp);

  Long ttl(String key);

  Boolean setbit(String key, long offset, boolean value);

  Boolean setbit(String key, long offset, String value);

  Boolean getbit(String key, long offset);

  Long setrange(String key, long offset, String value);

  String getrange(String key, long startOffset, long endOffset);

  String getSet(String key, String value);

  Long setnx(String key, String value);

  String setex(String key, int seconds, String value);

  Long decrBy(String key, long integer);

  Long decr(String key);

  Long incrBy(String key, long integer);

  Double incrByFloat(String key, double value);

  Long incr(String key);

  Long append(String key, String value);

  String substr(String key, int start, int end);

  Long hset(String key, String field, String value);

  String hget(String key, String field);

  Long hsetnx(String key, String field, String value);

  String hmset(String key, Map<String, String> hash);

  List<String> hmget(String key, String... fields);

  Long hincrBy(String key, String field, long value);

  Boolean hexists(String key, String field);

  Long hdel(String key, String... field);

  Long hlen(String key);

  Set<String> hkeys(String key);

  List<String> hvals(String key);

  Map<String, String> hgetAll(String key);

  Long rpush(String key, String... string);

  Long lpush(String key, String... string);

  Long llen(String key);

  List<String> lrange(String key, long start, long end);

  String ltrim(String key, long start, long end);

  String lindex(String key, long index);

  String lset(String key, long index, String value);

  Long lrem(String key, long count, String value);

  String lpop(String key);

  String rpop(String key);

  Long sadd(String key, String... member);

  Set<String> smembers(String key);

  Long srem(String key, String... member);

  String spop(String key);

  Set<String> spop(String key, long count);

  Long scard(String key);

  Boolean sismember(String key, String member);

  String srandmember(String key);

  List<String> srandmember(String key, int count);

  Long strlen(String key);

  Long zadd(String key, double score, String member);

  Long zadd(String key, double score, String member, ZAddParams params);

  Long zadd(String key, Map<String, Double> scoreMembers);

  Long zadd(String key, Map<String, Double> scoreMembers, ZAddParams params);

  Set<String> zrange(String key, long start, long end);

  Long zrem(String key, String... member);

  Double zincrby(String key, double score, String member);

  Double zincrby(String key, double score, String member, ZIncrByParams params);

  Long zrank(String key, String member);

  Long zrevrank(String key, String member);

  Set<String> zrevrange(String key, long start, long end);

  Set<Tuple> zrangeWithScores(String key, long start, long end);

  Set<Tuple> zrevrangeWithScores(String key, long start, long end);

  Long zcard(String key);

  Double zscore(String key, String member);

  List<String> sort(String key);

  List<String> sort(String key, SortingParams sortingParameters);

  Long zcount(String key, double min, double max);

  Long zcount(String key, String min, String max);

  Set<String> zrangeByScore(String key, double min, double max);

  Set<String> zrangeByScore(String key, String min, String max);

  Set<String> zrevrangeByScore(String key, double max, double min);

  Set<String> zrangeByScore(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min);

  Set<String> zrangeByScore(String key, String min, String max, int offset, int count);

  Set<String> zrevrangeByScore(String key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(String key, double min, double max, int offset, int count);

  Set<String> zrevrangeByScore(String key, String max, String min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min);

  Set<Tuple> zrangeByScoreWithScores(String key, String min, String max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(String key, String max, String min, int offset, int count);

  Long zremrangeByRank(String key, long start, long end);

  Long zremrangeByScore(String key, double start, double end);

  Long zremrangeByScore(String key, String start, String end);

  Long zlexcount(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max);

  Set<String> zrangeByLex(final String key, final String min, final String max, final int offset,
      final int count);

  Set<String> zrevrangeByLex(final String key, final String max, final String min);

  Set<String> zrevrangeByLex(final String key, final String max, final String min,
      final int offset, final int count);

  Long zremrangeByLex(final String key, final String min, final String max);

  Long linsert(String key, Client.LIST_POSITION where, String pivot, String value);

  Long lpushx(String key, String... string);

  Long rpushx(String key, String... string);

  List<String> blpop(int timeout, String key);

  List<String> brpop(int timeout, String key);

  Long del(String key);

  String echo(String string);

  Long bitcount(final String key);

  Long bitcount(final String key, long start, long end);

  ScanResult<Map.Entry<String, String>> hscan(final String key, final String cursor);

  ScanResult<String> sscan(final String key, final String cursor);

  ScanResult<Tuple> zscan(final String key, final String cursor);

  Long pfadd(final String key, final String... elements);

  long pfcount(final String key);

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, SetParams params);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Set<byte[]> spop(byte[] key, long count);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, double score, byte[] member, ZAddParams params);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers, ZAddParams params);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Double zincrby(byte[] key, double score, byte[] member, ZIncrByParams params);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_129ed2f_f5444b9/rev_129ed2f-f5444b9/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;
import redis.clients.jedis.params.set.SetParams;
import redis.clients.jedis.params.sortedset.ZAddParams;
import redis.clients.jedis.params.sortedset.ZIncrByParams;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, SetParams params);

  public void get(final String key);

  public void exists(final String key);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final double score, final String member,
      final ZAddParams params);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zadd(final String key, final Map<String, Double> scoreMembers, final ZAddParams params);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zincrby(final String key, final double score, final String member,
      final ZIncrByParams params);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryJedisClusterCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryJedisClusterCommands {
  Long del(byte[]... keys);

  Long exists(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyCommandsPipeline.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyCommandsPipeline {
  Response<Long> del(String... keys);

  Response<Long> exists(String... keys);

  Response<List<String>> blpop(String... args);

  Response<List<String>> brpop(String... args);

  Response<Set<String>> keys(String pattern);

  Response<List<String>> mget(String... keys);

  Response<String> mset(String... keysvalues);

  Response<Long> msetnx(String... keysvalues);

  Response<String> rename(String oldkey, String newkey);

  Response<Long> renamenx(String oldkey, String newkey);

  Response<String> rpoplpush(String srckey, String dstkey);

  Response<Set<String>> sdiff(String... keys);

  Response<Long> sdiffstore(String dstkey, String... keys);

  Response<Set<String>> sinter(String... keys);

  Response<Long> sinterstore(String dstkey, String... keys);

  Response<Long> smove(String srckey, String dstkey, String member);

  Response<Long> sort(String key, SortingParams sortingParameters, String dstkey);

  Response<Long> sort(String key, String dstkey);

  Response<Set<String>> sunion(String... keys);

  Response<Long> sunionstore(String dstkey, String... keys);

  Response<String> watch(String... keys);

  Response<Long> zinterstore(String dstkey, String... sets);

  Response<Long> zinterstore(String dstkey, ZParams params, String... sets);

  Response<Long> zunionstore(String dstkey, String... sets);

  Response<Long> zunionstore(String dstkey, ZParams params, String... sets);

  Response<String> brpoplpush(String source, String destination, int timeout);

  Response<Long> publish(String channel, String message);

  Response<String> randomKey();

  Response<Long> bitop(BitOP op, final String destKey, String... srcKeys);

  Response<String> pfmerge(final String destkey, final String... sourcekeys);

  Response<Long> pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyJedisClusterCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyJedisClusterCommands {
  Long del(String... keys);

  Long exists(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyCommands {
  Long del(String... keys);

  Long exists(String... keys);

  List<String> blpop(int timeout, String... keys);

  List<String> brpop(int timeout, String... keys);

  List<String> blpop(String... args);

  List<String> brpop(String... args);

  Set<String> keys(String pattern);

  List<String> mget(String... keys);

  String mset(String... keysvalues);

  Long msetnx(String... keysvalues);

  String rename(String oldkey, String newkey);

  Long renamenx(String oldkey, String newkey);

  String rpoplpush(String srckey, String dstkey);

  Set<String> sdiff(String... keys);

  Long sdiffstore(String dstkey, String... keys);

  Set<String> sinter(String... keys);

  Long sinterstore(String dstkey, String... keys);

  Long smove(String srckey, String dstkey, String member);

  Long sort(String key, SortingParams sortingParameters, String dstkey);

  Long sort(String key, String dstkey);

  Set<String> sunion(String... keys);

  Long sunionstore(String dstkey, String... keys);

  String watch(String... keys);

  String unwatch();

  Long zinterstore(String dstkey, String... sets);

  Long zinterstore(String dstkey, ZParams params, String... sets);

  Long zunionstore(String dstkey, String... sets);

  Long zunionstore(String dstkey, ZParams params, String... sets);

  String brpoplpush(String source, String destination, int timeout);

  Long publish(String channel, String message);

  void subscribe(JedisPubSub jedisPubSub, String... channels);

  void psubscribe(JedisPubSub jedisPubSub, String... patterns);

  String randomKey();

  Long bitop(BitOP op, final String destKey, String... srcKeys);

  ScanResult<String> scan(final String cursor);

  String pfmerge(final String destkey, final String... sourcekeys);

  long pfcount(final String... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

public interface MultiKeyBinaryCommands {
  Long del(byte[]... keys);

  Long exists(byte[]... keys);

  List<byte[]> blpop(int timeout, byte[]... keys);

  List<byte[]> brpop(int timeout, byte[]... keys);

  List<byte[]> blpop(byte[]... args);

  List<byte[]> brpop(byte[]... args);

  Set<byte[]> keys(byte[] pattern);

  List<byte[]> mget(byte[]... keys);

  String mset(byte[]... keysvalues);

  Long msetnx(byte[]... keysvalues);

  String rename(byte[] oldkey, byte[] newkey);

  Long renamenx(byte[] oldkey, byte[] newkey);

  byte[] rpoplpush(byte[] srckey, byte[] dstkey);

  Set<byte[]> sdiff(byte[]... keys);

  Long sdiffstore(byte[] dstkey, byte[]... keys);

  Set<byte[]> sinter(byte[]... keys);

  Long sinterstore(byte[] dstkey, byte[]... keys);

  Long smove(byte[] srckey, byte[] dstkey, byte[] member);

  Long sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Long sort(byte[] key, byte[] dstkey);

  Set<byte[]> sunion(byte[]... keys);

  Long sunionstore(byte[] dstkey, byte[]... keys);

  String watch(byte[]... keys);

  String unwatch();

  Long zinterstore(byte[] dstkey, byte[]... sets);

  Long zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Long zunionstore(byte[] dstkey, byte[]... sets);

  Long zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  byte[] brpoplpush(byte[] source, byte[] destination, int timeout);

  Long publish(byte[] channel, byte[] message);

  void subscribe(BinaryJedisPubSub jedisPubSub, byte[]... channels);

  void psubscribe(BinaryJedisPubSub jedisPubSub, byte[]... patterns);

  byte[] randomBinaryKey();

  Long bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  String pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Long pfcount(byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/MultiKeyBinaryRedisPipeline.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.List;
import java.util.Set;

/**
 * Multikey related commands (these are split out because they are non-shardable)
 */
public interface MultiKeyBinaryRedisPipeline {

  Response<Long> del(byte[]... keys);

  Response<Long> exists(byte[]... keys);

  Response<List<byte[]>> blpop(byte[]... args);

  Response<List<byte[]>> brpop(byte[]... args);

  Response<Set<byte[]>> keys(byte[] pattern);

  Response<List<byte[]>> mget(byte[]... keys);

  Response<String> mset(byte[]... keysvalues);

  Response<Long> msetnx(byte[]... keysvalues);

  Response<String> rename(byte[] oldkey, byte[] newkey);

  Response<Long> renamenx(byte[] oldkey, byte[] newkey);

  Response<byte[]> rpoplpush(byte[] srckey, byte[] dstkey);

  Response<Set<byte[]>> sdiff(byte[]... keys);

  Response<Long> sdiffstore(byte[] dstkey, byte[]... keys);

  Response<Set<byte[]>> sinter(byte[]... keys);

  Response<Long> sinterstore(byte[] dstkey, byte[]... keys);

  Response<Long> smove(byte[] srckey, byte[] dstkey, byte[] member);

  Response<Long> sort(byte[] key, SortingParams sortingParameters, byte[] dstkey);

  Response<Long> sort(byte[] key, byte[] dstkey);

  Response<Set<byte[]>> sunion(byte[]... keys);

  Response<Long> sunionstore(byte[] dstkey, byte[]... keys);

  Response<String> watch(byte[]... keys);

  Response<Long> zinterstore(byte[] dstkey, byte[]... sets);

  Response<Long> zinterstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, byte[]... sets);

  Response<Long> zunionstore(byte[] dstkey, ZParams params, byte[]... sets);

  Response<byte[]> brpoplpush(byte[] source, byte[] destination, int timeout);

  Response<Long> publish(byte[] channel, byte[] message);

  Response<byte[]> randomKeyBinary();

  Response<Long> bitop(BitOP op, final byte[] destKey, byte[]... srcKeys);

  Response<String> pfmerge(final byte[] destkey, final byte[]... sourcekeys);

  Response<Long> pfcount(final byte[]... keys);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_9e95ce1_b540775/rev_9e95ce1-b540775/src/main/java/redis/clients/jedis/Commands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.Map;

import redis.clients.jedis.BinaryClient.LIST_POSITION;

public interface Commands {

  public void set(final String key, final String value);

  public void set(final String key, final String value, final String nxxx, final String expx,
      final long time);

  public void get(final String key);

  @Deprecated
  public void exists(final String key);

  public void exists(final String... keys);

  public void del(final String... keys);

  public void type(final String key);

  public void keys(final String pattern);

  public void rename(final String oldkey, final String newkey);

  public void renamenx(final String oldkey, final String newkey);

  public void expire(final String key, final int seconds);

  public void expireAt(final String key, final long unixTime);

  public void ttl(final String key);

  public void setbit(String key, long offset, boolean value);

  public void setbit(String key, long offset, String value);

  public void getbit(String key, long offset);

  public void setrange(String key, long offset, String value);

  public void getrange(String key, long startOffset, long endOffset);

  public void move(final String key, final int dbIndex);

  public void getSet(final String key, final String value);

  public void mget(final String... keys);

  public void setnx(final String key, final String value);

  public void setex(final String key, final int seconds, final String value);

  public void mset(final String... keysvalues);

  public void msetnx(final String... keysvalues);

  public void decrBy(final String key, final long integer);

  public void decr(final String key);

  public void incrBy(final String key, final long integer);

  public void incrByFloat(final String key, final double value);

  public void incr(final String key);

  public void append(final String key, final String value);

  public void substr(final String key, final int start, final int end);

  public void hset(final String key, final String field, final String value);

  public void hget(final String key, final String field);

  public void hsetnx(final String key, final String field, final String value);

  public void hmset(final String key, final Map<String, String> hash);

  public void hmget(final String key, final String... fields);

  public void hincrBy(final String key, final String field, final long value);

  public void hincrByFloat(final String key, final String field, final double value);

  public void hexists(final String key, final String field);

  public void hdel(final String key, final String... fields);

  public void hlen(final String key);

  public void hkeys(final String key);

  public void hvals(final String key);

  public void hgetAll(final String key);

  public void rpush(final String key, final String... strings);

  public void lpush(final String key, final String... strings);

  public void llen(final String key);

  public void lrange(final String key, final long start, final long end);

  public void ltrim(final String key, final long start, final long end);

  public void lindex(final String key, final long index);

  public void lset(final String key, final long index, final String value);

  public void lrem(final String key, final long count, final String value);

  public void lpop(final String key);

  public void rpop(final String key);

  public void rpoplpush(final String srckey, final String dstkey);

  public void sadd(final String key, final String... members);

  public void smembers(final String key);

  public void srem(final String key, final String... member);

  public void spop(final String key);

  public void spop(final String key, final long count);

  public void smove(final String srckey, final String dstkey, final String member);

  public void scard(final String key);

  public void sismember(final String key, final String member);

  public void sinter(final String... keys);

  public void sinterstore(final String dstkey, final String... keys);

  public void sunion(final String... keys);

  public void sunionstore(final String dstkey, final String... keys);

  public void sdiff(final String... keys);

  public void sdiffstore(final String dstkey, final String... keys);

  public void srandmember(final String key);

  public void zadd(final String key, final double score, final String member);

  public void zadd(final String key, final Map<String, Double> scoreMembers);

  public void zrange(final String key, final long start, final long end);

  public void zrem(final String key, final String... members);

  public void zincrby(final String key, final double score, final String member);

  public void zrank(final String key, final String member);

  public void zrevrank(final String key, final String member);

  public void zrevrange(final String key, final long start, final long end);

  public void zrangeWithScores(final String key, final long start, final long end);

  public void zrevrangeWithScores(final String key, final long start, final long end);

  public void zcard(final String key);

  public void zscore(final String key, final String member);

  public void watch(final String... keys);

  public void sort(final String key);

  public void sort(final String key, final SortingParams sortingParameters);

  public void blpop(final String[] args);

  public void sort(final String key, final SortingParams sortingParameters, final String dstkey);

  public void sort(final String key, final String dstkey);

  public void brpop(final String[] args);

  public void brpoplpush(final String source, final String destination, final int timeout);

  public void zcount(final String key, final double min, final double max);

  public void zcount(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max);

  public void zrangeByScore(final String key, final String min, final String max);

  public void zrangeByScore(final String key, final double min, final double max, final int offset,
      int count);

  public void zrangeByScoreWithScores(final String key, final double min, final double max);

  public void zrangeByScoreWithScores(final String key, final double min, final double max,
      final int offset, final int count);

  public void zrangeByScoreWithScores(final String key, final String min, final String max);

  public void zrangeByScoreWithScores(final String key, final String min, final String max,
      final int offset, final int count);

  public void zrevrangeByScore(final String key, final double max, final double min);

  public void zrevrangeByScore(final String key, final String max, final String min);

  public void zrevrangeByScore(final String key, final double max, final double min,
      final int offset, int count);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min);

  public void zrevrangeByScoreWithScores(final String key, final double max, final double min,
      final int offset, final int count);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min);

  public void zrevrangeByScoreWithScores(final String key, final String max, final String min,
      final int offset, final int count);

  public void zremrangeByRank(final String key, final long start, final long end);

  public void zremrangeByScore(final String key, final double start, final double end);

  public void zremrangeByScore(final String key, final String start, final String end);

  public void zunionstore(final String dstkey, final String... sets);

  public void zunionstore(final String dstkey, final ZParams params, final String... sets);

  public void zinterstore(final String dstkey, final String... sets);

  public void zinterstore(final String dstkey, final ZParams params, final String... sets);

  public void strlen(final String key);

  public void lpushx(final String key, final String... string);

  public void persist(final String key);

  public void rpushx(final String key, final String... string);

  public void echo(final String string);

  public void linsert(final String key, final LIST_POSITION where, final String pivot,
      final String value);

  public void bgrewriteaof();

  public void bgsave();

  public void lastsave();

  public void save();

  public void configSet(final String parameter, final String value);

  public void configGet(final String pattern);

  public void configResetStat();

  public void multi();

  public void exec();

  public void discard();

  public void objectRefcount(String key);

  public void objectIdletime(String key);

  public void objectEncoding(String key);

  public void bitcount(final String key);

  public void bitcount(final String key, long start, long end);

  public void bitop(BitOP op, final String destKey, String... srcKeys);

  public void scan(final String cursor, final ScanParams params);

  public void hscan(final String key, final String cursor, final ScanParams params);

  public void sscan(final String key, final String cursor, final ScanParams params);

  public void zscan(final String key, final String cursor, final ScanParams params);

  public void waitReplicas(int replicas, long timeout);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/jedis/revisions/rev_1e5e10c_48170f7/rev_1e5e10c-48170f7/src/main/java/redis/clients/jedis/BinaryJedisCommands.java;<<<<<<< MINE
=======
package redis.clients.jedis;

import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Common interface for sharded and non-sharded BinaryJedis
 */
public interface BinaryJedisCommands {
  String set(byte[] key, byte[] value);

  String set(byte[] key, byte[] value, byte[] nxxx, byte[] expx, long time);

  byte[] get(byte[] key);

  Boolean exists(byte[] key);

  Long persist(byte[] key);

  String type(byte[] key);

  Long expire(byte[] key, int seconds);

  Long pexpire(byte[] key, final long milliseconds);

  Long expireAt(byte[] key, long unixTime);

  Long pexpireAt(byte[] key, long millisecondsTimestamp);

  Long ttl(byte[] key);

  Boolean setbit(byte[] key, long offset, boolean value);

  Boolean setbit(byte[] key, long offset, byte[] value);

  Boolean getbit(byte[] key, long offset);

  Long setrange(byte[] key, long offset, byte[] value);

  byte[] getrange(byte[] key, long startOffset, long endOffset);

  byte[] getSet(byte[] key, byte[] value);

  Long setnx(byte[] key, byte[] value);

  String setex(byte[] key, int seconds, byte[] value);

  Long decrBy(byte[] key, long integer);

  Long decr(byte[] key);

  Long incrBy(byte[] key, long integer);

  Double incrByFloat(byte[] key, double value);

  Long incr(byte[] key);

  Long append(byte[] key, byte[] value);

  byte[] substr(byte[] key, int start, int end);

  Long hset(byte[] key, byte[] field, byte[] value);

  byte[] hget(byte[] key, byte[] field);

  Long hsetnx(byte[] key, byte[] field, byte[] value);

  String hmset(byte[] key, Map<byte[], byte[]> hash);

  List<byte[]> hmget(byte[] key, byte[]... fields);

  Long hincrBy(byte[] key, byte[] field, long value);

  Double hincrByFloat(byte[] key, byte[] field, double value);

  Boolean hexists(byte[] key, byte[] field);

  Long hdel(byte[] key, byte[]... field);

  Long hlen(byte[] key);

  Set<byte[]> hkeys(byte[] key);

  Collection<byte[]> hvals(byte[] key);

  Map<byte[], byte[]> hgetAll(byte[] key);

  Long rpush(byte[] key, byte[]... args);

  Long lpush(byte[] key, byte[]... args);

  Long llen(byte[] key);

  List<byte[]> lrange(byte[] key, long start, long end);

  String ltrim(byte[] key, long start, long end);

  byte[] lindex(byte[] key, long index);

  String lset(byte[] key, long index, byte[] value);

  Long lrem(byte[] key, long count, byte[] value);

  byte[] lpop(byte[] key);

  byte[] rpop(byte[] key);

  Long sadd(byte[] key, byte[]... member);

  Set<byte[]> smembers(byte[] key);

  Long srem(byte[] key, byte[]... member);

  byte[] spop(byte[] key);

  Long scard(byte[] key);

  Boolean sismember(byte[] key, byte[] member);

  byte[] srandmember(byte[] key);

  List<byte[]> srandmember(final byte[] key, final int count);

  Long strlen(byte[] key);

  Long zadd(byte[] key, double score, byte[] member);

  Long zadd(byte[] key, Map<byte[], Double> scoreMembers);

  Set<byte[]> zrange(byte[] key, long start, long end);

  Long zrem(byte[] key, byte[]... member);

  Double zincrby(byte[] key, double score, byte[] member);

  Long zrank(byte[] key, byte[] member);

  Long zrevrank(byte[] key, byte[] member);

  Set<byte[]> zrevrange(byte[] key, long start, long end);

  Set<Tuple> zrangeWithScores(byte[] key, long start, long end);

  Set<Tuple> zrevrangeWithScores(byte[] key, long start, long end);

  Long zcard(byte[] key);

  Double zscore(byte[] key, byte[] member);

  List<byte[]> sort(byte[] key);

  List<byte[]> sort(byte[] key, SortingParams sortingParameters);

  Long zcount(byte[] key, double min, double max);

  Long zcount(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min);

  Set<byte[]> zrangeByScore(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min);

  Set<byte[]> zrangeByScore(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, double min, double max, int offset, int count);

  Set<byte[]> zrevrangeByScore(byte[] key, byte[] max, byte[] min, int offset, int count);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min);

  Set<Tuple> zrangeByScoreWithScores(byte[] key, byte[] min, byte[] max, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, double max, double min, int offset, int count);

  Set<Tuple> zrevrangeByScoreWithScores(byte[] key, byte[] max, byte[] min, int offset, int count);

  Long zremrangeByRank(byte[] key, long start, long end);

  Long zremrangeByScore(byte[] key, double start, double end);

  Long zremrangeByScore(byte[] key, byte[] start, byte[] end);

  Long zlexcount(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Set<byte[]> zrangeByLex(final byte[] key, final byte[] min, final byte[] max, int offset,
      int count);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min);

  Set<byte[]> zrevrangeByLex(final byte[] key, final byte[] max, final byte[] min, int offset,
      int count);

  Long zremrangeByLex(final byte[] key, final byte[] min, final byte[] max);

  Long linsert(byte[] key, Client.LIST_POSITION where, byte[] pivot, byte[] value);

  Long lpushx(byte[] key, byte[]... arg);

  Long rpushx(byte[] key, byte[]... arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> blpop(byte[] arg);

  /**
   * @deprecated unusable command, this command will be removed in 3.0.0.
   */
  @Deprecated
  List<byte[]> brpop(byte[] arg);

  Long del(byte[] key);

  byte[] echo(byte[] arg);

  Long move(byte[] key, int dbIndex);

  Long bitcount(final byte[] key);

  Long bitcount(final byte[] key, long start, long end);

  Long pfadd(final byte[] key, final byte[]... elements);

  long pfcount(final byte[] key);
}>>>>>>> YOURS
