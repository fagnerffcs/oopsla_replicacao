/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/elasticmapreduce/model/SetVisibleToAllUsersRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticmapreduce.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.elasticmapreduce.AmazonElasticMapReduce#setVisibleToAllUsers(SetVisibleToAllUsersRequest) SetVisibleToAllUsers operation}.
 * <p>
 * Sets whether all AWS Identity and Access Management (IAM) users under your account can access the specifed job flows. This action works on running job
 * flows. You can also set the visibility of a job flow when you launch it using the <code>VisibleToAllUsers</code> parameter of RunJobFlow. The
 * SetVisibleToAllUsers action can be called only by an IAM user who created the job flow or the AWS account that owns the job flow.
 * </p>
 *
 * @see com.amazonaws.services.elasticmapreduce.AmazonElasticMapReduce#setVisibleToAllUsers(SetVisibleToAllUsersRequest)
 */
public class SetVisibleToAllUsersRequest extends AmazonWebServiceRequest {

    /**
     * Identifiers of the job flows to receive the new visibility setting.
     */
    private java.util.List<String> jobFlowIds;

    /**
     * Whether the specified job flows are visible to all IAM users of the
     * AWS account associated with the job flow. If this value is set to
     * True, all IAM users of that AWS account can view and, if they have the
     * proper IAM policy permissions set, manage the job flows. If it is set
     * to False, only the IAM user that created a job flow can view and
     * manage it.
     */
    private Boolean visibleToAllUsers;

    /**
     * Identifiers of the job flows to receive the new visibility setting.
     *
     * @return Identifiers of the job flows to receive the new visibility setting.
     */
    public java.util.List<String> getJobFlowIds() {
        
        if (jobFlowIds == null) {
            jobFlowIds = new java.util.ArrayList<String>();
        }
        return jobFlowIds;
    }
    
    /**
     * Identifiers of the job flows to receive the new visibility setting.
     *
     * @param jobFlowIds Identifiers of the job flows to receive the new visibility setting.
     */
    public void setJobFlowIds(java.util.Collection<String> jobFlowIds) {
        if (jobFlowIds == null) {
            this.jobFlowIds = null;
            return;
        }

        java.util.List<String> jobFlowIdsCopy = new java.util.ArrayList<String>(jobFlowIds.size());
        jobFlowIdsCopy.addAll(jobFlowIds);
        this.jobFlowIds = jobFlowIdsCopy;
    }
    
    /**
     * Identifiers of the job flows to receive the new visibility setting.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobFlowIds Identifiers of the job flows to receive the new visibility setting.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public SetVisibleToAllUsersRequest withJobFlowIds(String... jobFlowIds) {
        if (getJobFlowIds() == null) setJobFlowIds(new java.util.ArrayList<String>(jobFlowIds.length));
        for (String value : jobFlowIds) {
            getJobFlowIds().add(value);
        }
        return this;
    }
    
    /**
     * Identifiers of the job flows to receive the new visibility setting.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param jobFlowIds Identifiers of the job flows to receive the new visibility setting.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public SetVisibleToAllUsersRequest withJobFlowIds(java.util.Collection<String> jobFlowIds) {
        if (jobFlowIds == null) {
            this.jobFlowIds = null;
        } else {
            java.util.List<String> jobFlowIdsCopy = new java.util.ArrayList<String>(jobFlowIds.size());
            jobFlowIdsCopy.addAll(jobFlowIds);
            this.jobFlowIds = jobFlowIdsCopy;
        }

        return this;
    }
    
    /**
     * Whether the specified job flows are visible to all IAM users of the
     * AWS account associated with the job flow. If this value is set to
     * True, all IAM users of that AWS account can view and, if they have the
     * proper IAM policy permissions set, manage the job flows. If it is set
     * to False, only the IAM user that created a job flow can view and
     * manage it.
     *
     * @return Whether the specified job flows are visible to all IAM users of the
     *         AWS account associated with the job flow. If this value is set to
     *         True, all IAM users of that AWS account can view and, if they have the
     *         proper IAM policy permissions set, manage the job flows. If it is set
     *         to False, only the IAM user that created a job flow can view and
     *         manage it.
     */
    public Boolean isVisibleToAllUsers() {
        return visibleToAllUsers;
    }
    
    /**
     * Whether the specified job flows are visible to all IAM users of the
     * AWS account associated with the job flow. If this value is set to
     * True, all IAM users of that AWS account can view and, if they have the
     * proper IAM policy permissions set, manage the job flows. If it is set
     * to False, only the IAM user that created a job flow can view and
     * manage it.
     *
     * @param visibleToAllUsers Whether the specified job flows are visible to all IAM users of the
     *         AWS account associated with the job flow. If this value is set to
     *         True, all IAM users of that AWS account can view and, if they have the
     *         proper IAM policy permissions set, manage the job flows. If it is set
     *         to False, only the IAM user that created a job flow can view and
     *         manage it.
     */
    public void setVisibleToAllUsers(Boolean visibleToAllUsers) {
        this.visibleToAllUsers = visibleToAllUsers;
    }
    
    /**
     * Whether the specified job flows are visible to all IAM users of the
     * AWS account associated with the job flow. If this value is set to
     * True, all IAM users of that AWS account can view and, if they have the
     * proper IAM policy permissions set, manage the job flows. If it is set
     * to False, only the IAM user that created a job flow can view and
     * manage it.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param visibleToAllUsers Whether the specified job flows are visible to all IAM users of the
     *         AWS account associated with the job flow. If this value is set to
     *         True, all IAM users of that AWS account can view and, if they have the
     *         proper IAM policy permissions set, manage the job flows. If it is set
     *         to False, only the IAM user that created a job flow can view and
     *         manage it.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public SetVisibleToAllUsersRequest withVisibleToAllUsers(Boolean visibleToAllUsers) {
        this.visibleToAllUsers = visibleToAllUsers;
        return this;
    }
    
    
    /**
     * Whether the specified job flows are visible to all IAM users of the
     * AWS account associated with the job flow. If this value is set to
     * True, all IAM users of that AWS account can view and, if they have the
     * proper IAM policy permissions set, manage the job flows. If it is set
     * to False, only the IAM user that created a job flow can view and
     * manage it.
     *
     * @return Whether the specified job flows are visible to all IAM users of the
     *         AWS account associated with the job flow. If this value is set to
     *         True, all IAM users of that AWS account can view and, if they have the
     *         proper IAM policy permissions set, manage the job flows. If it is set
     *         to False, only the IAM user that created a job flow can view and
     *         manage it.
     */
    public Boolean getVisibleToAllUsers() {
        return visibleToAllUsers;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (jobFlowIds != null) sb.append("JobFlowIds: " + jobFlowIds + ", ");
        if (visibleToAllUsers != null) sb.append("VisibleToAllUsers: " + visibleToAllUsers + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getJobFlowIds() == null) ? 0 : getJobFlowIds().hashCode()); 
        hashCode = prime * hashCode + ((isVisibleToAllUsers() == null) ? 0 : isVisibleToAllUsers().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof SetVisibleToAllUsersRequest == false) return false;
        SetVisibleToAllUsersRequest other = (SetVisibleToAllUsersRequest)obj;
        
        if (other.getJobFlowIds() == null ^ this.getJobFlowIds() == null) return false;
        if (other.getJobFlowIds() != null && other.getJobFlowIds().equals(this.getJobFlowIds()) == false) return false; 
        if (other.isVisibleToAllUsers() == null ^ this.isVisibleToAllUsers() == null) return false;
        if (other.isVisibleToAllUsers() != null && other.isVisibleToAllUsers().equals(this.isVisibleToAllUsers()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/elasticmapreduce/model/transform/SetVisibleToAllUsersRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.elasticmapreduce.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.services.elasticmapreduce.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Set Visible To All Users Request Marshaller
 */
public class SetVisibleToAllUsersRequestMarshaller implements Marshaller<Request<SetVisibleToAllUsersRequest>, SetVisibleToAllUsersRequest> {

    public Request<SetVisibleToAllUsersRequest> marshall(SetVisibleToAllUsersRequest setVisibleToAllUsersRequest) {

        if (setVisibleToAllUsersRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<SetVisibleToAllUsersRequest> request = new DefaultRequest<SetVisibleToAllUsersRequest>(setVisibleToAllUsersRequest, "AmazonElasticMapReduce");
        request.addParameter("Action", "SetVisibleToAllUsers");
        request.addParameter("Version", "2009-03-31");


        java.util.List<String> jobFlowIdsList = setVisibleToAllUsersRequest.getJobFlowIds();
        int jobFlowIdsListIndex = 1;

        for (String jobFlowIdsListValue : jobFlowIdsList) {
            if (jobFlowIdsListValue != null) {
                request.addParameter("JobFlowIds.member." + jobFlowIdsListIndex, StringUtils.fromString(jobFlowIdsListValue));
            }

            jobFlowIdsListIndex++;
        }
        if (setVisibleToAllUsersRequest.isVisibleToAllUsers() != null) {
            request.addParameter("VisibleToAllUsers", StringUtils.fromBoolean(setVisibleToAllUsersRequest.isVisibleToAllUsers()));
        }


        return request;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/RemoveTagsFromResourceRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.rds.AmazonRDS#removeTagsFromResource(RemoveTagsFromResourceRequest) RemoveTagsFromResource operation}.
 * <p>
 * Removes metadata tags from a DB Instance.
 * </p>
 * <p>
 * For an overview on tagging DB Instances, see <a href="http://docs.amazonwebservices.com/AmazonRDS/latest/UserGuide/Overview.Tagging.html"> DB Instance
 * Tags. </a>
 * </p>
 *
 * @see com.amazonaws.services.rds.AmazonRDS#removeTagsFromResource(RemoveTagsFromResourceRequest)
 */
public class RemoveTagsFromResourceRequest extends AmazonWebServiceRequest {

    /**
     * The DB Instance the tags will be removed from.
     */
    private String resourceName;

    /**
     * The tag key (name) of the tag to be removed.
     */
    private java.util.List<String> tagKeys;

    /**
     * The DB Instance the tags will be removed from.
     *
     * @return The DB Instance the tags will be removed from.
     */
    public String getResourceName() {
        return resourceName;
    }
    
    /**
     * The DB Instance the tags will be removed from.
     *
     * @param resourceName The DB Instance the tags will be removed from.
     */
    public void setResourceName(String resourceName) {
        this.resourceName = resourceName;
    }
    
    /**
     * The DB Instance the tags will be removed from.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param resourceName The DB Instance the tags will be removed from.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public RemoveTagsFromResourceRequest withResourceName(String resourceName) {
        this.resourceName = resourceName;
        return this;
    }
    
    
    /**
     * The tag key (name) of the tag to be removed.
     *
     * @return The tag key (name) of the tag to be removed.
     */
    public java.util.List<String> getTagKeys() {
        
        if (tagKeys == null) {
            tagKeys = new java.util.ArrayList<String>();
        }
        return tagKeys;
    }
    
    /**
     * The tag key (name) of the tag to be removed.
     *
     * @param tagKeys The tag key (name) of the tag to be removed.
     */
    public void setTagKeys(java.util.Collection<String> tagKeys) {
        if (tagKeys == null) {
            this.tagKeys = null;
            return;
        }

        java.util.List<String> tagKeysCopy = new java.util.ArrayList<String>(tagKeys.size());
        tagKeysCopy.addAll(tagKeys);
        this.tagKeys = tagKeysCopy;
    }
    
    /**
     * The tag key (name) of the tag to be removed.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tagKeys The tag key (name) of the tag to be removed.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public RemoveTagsFromResourceRequest withTagKeys(String... tagKeys) {
        if (getTagKeys() == null) setTagKeys(new java.util.ArrayList<String>(tagKeys.length));
        for (String value : tagKeys) {
            getTagKeys().add(value);
        }
        return this;
    }
    
    /**
     * The tag key (name) of the tag to be removed.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tagKeys The tag key (name) of the tag to be removed.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public RemoveTagsFromResourceRequest withTagKeys(java.util.Collection<String> tagKeys) {
        if (tagKeys == null) {
            this.tagKeys = null;
        } else {
            java.util.List<String> tagKeysCopy = new java.util.ArrayList<String>(tagKeys.size());
            tagKeysCopy.addAll(tagKeys);
            this.tagKeys = tagKeysCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (resourceName != null) sb.append("ResourceName: " + resourceName + ", ");
        if (tagKeys != null) sb.append("TagKeys: " + tagKeys + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getResourceName() == null) ? 0 : getResourceName().hashCode()); 
        hashCode = prime * hashCode + ((getTagKeys() == null) ? 0 : getTagKeys().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof RemoveTagsFromResourceRequest == false) return false;
        RemoveTagsFromResourceRequest other = (RemoveTagsFromResourceRequest)obj;
        
        if (other.getResourceName() == null ^ this.getResourceName() == null) return false;
        if (other.getResourceName() != null && other.getResourceName().equals(this.getResourceName()) == false) return false; 
        if (other.getTagKeys() == null ^ this.getTagKeys() == null) return false;
        if (other.getTagKeys() != null && other.getTagKeys().equals(this.getTagKeys()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/DBSubnetGroupDoesNotCoverEnoughAZsException.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Subnets in the DB subnet group should cover at least 2 availability zones unless there's'only 1 available zone.
 * </p>
 */        
public class DBSubnetGroupDoesNotCoverEnoughAZsException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new DBSubnetGroupDoesNotCoverEnoughAZsException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public DBSubnetGroupDoesNotCoverEnoughAZsException(String message) {
        super(message);
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/AddTagsToResourceRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.rds.AmazonRDS#addTagsToResource(AddTagsToResourceRequest) AddTagsToResource operation}.
 * <p>
 * Adds metadata tags to a DB Instance. These tags can also be used with cost allocation reporting to track cost associated with a DB Instance.
 * </p>
 * <p>
 * For an overview on tagging DB Instances, see <a href="http://docs.amazonwebservices.com/AmazonRDS/latest/UserGuide/Overview.Tagging.html"> DB Instance
 * Tags. </a>
 * </p>
 *
 * @see com.amazonaws.services.rds.AmazonRDS#addTagsToResource(AddTagsToResourceRequest)
 */
public class AddTagsToResourceRequest extends AmazonWebServiceRequest {

    /**
     * The DB Instance the tags will be added to.
     */
    private String resourceName;

    /**
     * The tags to be assigned to the DB Instance.
     */
    private java.util.List<Tag> tags;

    /**
     * The DB Instance the tags will be added to.
     *
     * @return The DB Instance the tags will be added to.
     */
    public String getResourceName() {
        return resourceName;
    }
    
    /**
     * The DB Instance the tags will be added to.
     *
     * @param resourceName The DB Instance the tags will be added to.
     */
    public void setResourceName(String resourceName) {
        this.resourceName = resourceName;
    }
    
    /**
     * The DB Instance the tags will be added to.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param resourceName The DB Instance the tags will be added to.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddTagsToResourceRequest withResourceName(String resourceName) {
        this.resourceName = resourceName;
        return this;
    }
    
    
    /**
     * The tags to be assigned to the DB Instance.
     *
     * @return The tags to be assigned to the DB Instance.
     */
    public java.util.List<Tag> getTags() {
        
        if (tags == null) {
            tags = new java.util.ArrayList<Tag>();
        }
        return tags;
    }
    
    /**
     * The tags to be assigned to the DB Instance.
     *
     * @param tags The tags to be assigned to the DB Instance.
     */
    public void setTags(java.util.Collection<Tag> tags) {
        if (tags == null) {
            this.tags = null;
            return;
        }

        java.util.List<Tag> tagsCopy = new java.util.ArrayList<Tag>(tags.size());
        tagsCopy.addAll(tags);
        this.tags = tagsCopy;
    }
    
    /**
     * The tags to be assigned to the DB Instance.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tags The tags to be assigned to the DB Instance.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddTagsToResourceRequest withTags(Tag... tags) {
        if (getTags() == null) setTags(new java.util.ArrayList<Tag>(tags.length));
        for (Tag value : tags) {
            getTags().add(value);
        }
        return this;
    }
    
    /**
     * The tags to be assigned to the DB Instance.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tags The tags to be assigned to the DB Instance.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddTagsToResourceRequest withTags(java.util.Collection<Tag> tags) {
        if (tags == null) {
            this.tags = null;
        } else {
            java.util.List<Tag> tagsCopy = new java.util.ArrayList<Tag>(tags.size());
            tagsCopy.addAll(tags);
            this.tags = tagsCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (resourceName != null) sb.append("ResourceName: " + resourceName + ", ");
        if (tags != null) sb.append("Tags: " + tags + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getResourceName() == null) ? 0 : getResourceName().hashCode()); 
        hashCode = prime * hashCode + ((getTags() == null) ? 0 : getTags().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof AddTagsToResourceRequest == false) return false;
        AddTagsToResourceRequest other = (AddTagsToResourceRequest)obj;
        
        if (other.getResourceName() == null ^ this.getResourceName() == null) return false;
        if (other.getResourceName() != null && other.getResourceName().equals(this.getResourceName()) == false) return false; 
        if (other.getTags() == null ^ this.getTags() == null) return false;
        if (other.getTags() != null && other.getTags().equals(this.getTags()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/PromoteReadReplicaRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.rds.AmazonRDS#promoteReadReplica(PromoteReadReplicaRequest) PromoteReadReplica operation}.
 * <p>
 * Promotes a Read Replica DB Instance to a standalone DB Instance.
 * </p>
 *
 * @see com.amazonaws.services.rds.AmazonRDS#promoteReadReplica(PromoteReadReplicaRequest)
 */
public class PromoteReadReplicaRequest extends AmazonWebServiceRequest {

    /**
     * The DB Instance identifier. This value is stored as a lowercase
     * string. <p>Constraints: <ul> <li>Must be the identifier for an
     * existing Read Replica DB Instance</li> <li>Must contain from 1 to 63
     * alphanumeric characters or hyphens</li> <li>First character must be a
     * letter</li> <li>Cannot end with a hyphen or contain two consecutive
     * hyphens</li> </ul> <p>Example: <copy>mydbinstance</copy>
     */
    private String dBInstanceIdentifier;

    /**
     * The number of days to retain automated backups. Setting this parameter
     * to a positive number enables backups. Setting this parameter to 0
     * disables automated backups. <p> Default: 1 <p>Constraints: <ul>
     * <li>Must be a value from 0 to 8</li> </ul>
     */
    private Integer backupRetentionPeriod;

    /**
     * The daily time range during which automated backups are created if
     * automated backups are enabled, using the
     * <code>BackupRetentionPeriod</code> parameter. <p> Default: A 30-minute
     * window selected at random from an 8-hour block of time per region. The
     * following list shows the time blocks for each region from which the
     * default backup windows are assigned. <ul> <li><b>US-East (Northern
     * Virginia) Region:</b> 03:00-11:00 UTC</li> <li><b>US-West (Northern
     * California) Region:</b> 06:00-14:00 UTC</li> <li><b>EU (Ireland)
     * Region:</b> 22:00-06:00 UTC</li> <li><b>Asia Pacific (Singapore)
     * Region:</b> 14:00-22:00 UTC</li> <li><b>Asia Pacific (Tokyo) Region:
     * </b> 17:00-03:00 UTC</li> </ul> <p> Constraints: Must be in the format
     * <code>hh24:mi-hh24:mi</code>. Times should be Universal Time
     * Coordinated (UTC). Must not conflict with the preferred maintenance
     * window. Must be at least 30 minutes.
     */
    private String preferredBackupWindow;

    /**
     * The DB Instance identifier. This value is stored as a lowercase
     * string. <p>Constraints: <ul> <li>Must be the identifier for an
     * existing Read Replica DB Instance</li> <li>Must contain from 1 to 63
     * alphanumeric characters or hyphens</li> <li>First character must be a
     * letter</li> <li>Cannot end with a hyphen or contain two consecutive
     * hyphens</li> </ul> <p>Example: <copy>mydbinstance</copy>
     *
     * @return The DB Instance identifier. This value is stored as a lowercase
     *         string. <p>Constraints: <ul> <li>Must be the identifier for an
     *         existing Read Replica DB Instance</li> <li>Must contain from 1 to 63
     *         alphanumeric characters or hyphens</li> <li>First character must be a
     *         letter</li> <li>Cannot end with a hyphen or contain two consecutive
     *         hyphens</li> </ul> <p>Example: <copy>mydbinstance</copy>
     */
    public String getDBInstanceIdentifier() {
        return dBInstanceIdentifier;
    }
    
    /**
     * The DB Instance identifier. This value is stored as a lowercase
     * string. <p>Constraints: <ul> <li>Must be the identifier for an
     * existing Read Replica DB Instance</li> <li>Must contain from 1 to 63
     * alphanumeric characters or hyphens</li> <li>First character must be a
     * letter</li> <li>Cannot end with a hyphen or contain two consecutive
     * hyphens</li> </ul> <p>Example: <copy>mydbinstance</copy>
     *
     * @param dBInstanceIdentifier The DB Instance identifier. This value is stored as a lowercase
     *         string. <p>Constraints: <ul> <li>Must be the identifier for an
     *         existing Read Replica DB Instance</li> <li>Must contain from 1 to 63
     *         alphanumeric characters or hyphens</li> <li>First character must be a
     *         letter</li> <li>Cannot end with a hyphen or contain two consecutive
     *         hyphens</li> </ul> <p>Example: <copy>mydbinstance</copy>
     */
    public void setDBInstanceIdentifier(String dBInstanceIdentifier) {
        this.dBInstanceIdentifier = dBInstanceIdentifier;
    }
    
    /**
     * The DB Instance identifier. This value is stored as a lowercase
     * string. <p>Constraints: <ul> <li>Must be the identifier for an
     * existing Read Replica DB Instance</li> <li>Must contain from 1 to 63
     * alphanumeric characters or hyphens</li> <li>First character must be a
     * letter</li> <li>Cannot end with a hyphen or contain two consecutive
     * hyphens</li> </ul> <p>Example: <copy>mydbinstance</copy>
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param dBInstanceIdentifier The DB Instance identifier. This value is stored as a lowercase
     *         string. <p>Constraints: <ul> <li>Must be the identifier for an
     *         existing Read Replica DB Instance</li> <li>Must contain from 1 to 63
     *         alphanumeric characters or hyphens</li> <li>First character must be a
     *         letter</li> <li>Cannot end with a hyphen or contain two consecutive
     *         hyphens</li> </ul> <p>Example: <copy>mydbinstance</copy>
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public PromoteReadReplicaRequest withDBInstanceIdentifier(String dBInstanceIdentifier) {
        this.dBInstanceIdentifier = dBInstanceIdentifier;
        return this;
    }
    
    
    /**
     * The number of days to retain automated backups. Setting this parameter
     * to a positive number enables backups. Setting this parameter to 0
     * disables automated backups. <p> Default: 1 <p>Constraints: <ul>
     * <li>Must be a value from 0 to 8</li> </ul>
     *
     * @return The number of days to retain automated backups. Setting this parameter
     *         to a positive number enables backups. Setting this parameter to 0
     *         disables automated backups. <p> Default: 1 <p>Constraints: <ul>
     *         <li>Must be a value from 0 to 8</li> </ul>
     */
    public Integer getBackupRetentionPeriod() {
        return backupRetentionPeriod;
    }
    
    /**
     * The number of days to retain automated backups. Setting this parameter
     * to a positive number enables backups. Setting this parameter to 0
     * disables automated backups. <p> Default: 1 <p>Constraints: <ul>
     * <li>Must be a value from 0 to 8</li> </ul>
     *
     * @param backupRetentionPeriod The number of days to retain automated backups. Setting this parameter
     *         to a positive number enables backups. Setting this parameter to 0
     *         disables automated backups. <p> Default: 1 <p>Constraints: <ul>
     *         <li>Must be a value from 0 to 8</li> </ul>
     */
    public void setBackupRetentionPeriod(Integer backupRetentionPeriod) {
        this.backupRetentionPeriod = backupRetentionPeriod;
    }
    
    /**
     * The number of days to retain automated backups. Setting this parameter
     * to a positive number enables backups. Setting this parameter to 0
     * disables automated backups. <p> Default: 1 <p>Constraints: <ul>
     * <li>Must be a value from 0 to 8</li> </ul>
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param backupRetentionPeriod The number of days to retain automated backups. Setting this parameter
     *         to a positive number enables backups. Setting this parameter to 0
     *         disables automated backups. <p> Default: 1 <p>Constraints: <ul>
     *         <li>Must be a value from 0 to 8</li> </ul>
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public PromoteReadReplicaRequest withBackupRetentionPeriod(Integer backupRetentionPeriod) {
        this.backupRetentionPeriod = backupRetentionPeriod;
        return this;
    }
    
    
    /**
     * The daily time range during which automated backups are created if
     * automated backups are enabled, using the
     * <code>BackupRetentionPeriod</code> parameter. <p> Default: A 30-minute
     * window selected at random from an 8-hour block of time per region. The
     * following list shows the time blocks for each region from which the
     * default backup windows are assigned. <ul> <li><b>US-East (Northern
     * Virginia) Region:</b> 03:00-11:00 UTC</li> <li><b>US-West (Northern
     * California) Region:</b> 06:00-14:00 UTC</li> <li><b>EU (Ireland)
     * Region:</b> 22:00-06:00 UTC</li> <li><b>Asia Pacific (Singapore)
     * Region:</b> 14:00-22:00 UTC</li> <li><b>Asia Pacific (Tokyo) Region:
     * </b> 17:00-03:00 UTC</li> </ul> <p> Constraints: Must be in the format
     * <code>hh24:mi-hh24:mi</code>. Times should be Universal Time
     * Coordinated (UTC). Must not conflict with the preferred maintenance
     * window. Must be at least 30 minutes.
     *
     * @return The daily time range during which automated backups are created if
     *         automated backups are enabled, using the
     *         <code>BackupRetentionPeriod</code> parameter. <p> Default: A 30-minute
     *         window selected at random from an 8-hour block of time per region. The
     *         following list shows the time blocks for each region from which the
     *         default backup windows are assigned. <ul> <li><b>US-East (Northern
     *         Virginia) Region:</b> 03:00-11:00 UTC</li> <li><b>US-West (Northern
     *         California) Region:</b> 06:00-14:00 UTC</li> <li><b>EU (Ireland)
     *         Region:</b> 22:00-06:00 UTC</li> <li><b>Asia Pacific (Singapore)
     *         Region:</b> 14:00-22:00 UTC</li> <li><b>Asia Pacific (Tokyo) Region:
     *         </b> 17:00-03:00 UTC</li> </ul> <p> Constraints: Must be in the format
     *         <code>hh24:mi-hh24:mi</code>. Times should be Universal Time
     *         Coordinated (UTC). Must not conflict with the preferred maintenance
     *         window. Must be at least 30 minutes.
     */
    public String getPreferredBackupWindow() {
        return preferredBackupWindow;
    }
    
    /**
     * The daily time range during which automated backups are created if
     * automated backups are enabled, using the
     * <code>BackupRetentionPeriod</code> parameter. <p> Default: A 30-minute
     * window selected at random from an 8-hour block of time per region. The
     * following list shows the time blocks for each region from which the
     * default backup windows are assigned. <ul> <li><b>US-East (Northern
     * Virginia) Region:</b> 03:00-11:00 UTC</li> <li><b>US-West (Northern
     * California) Region:</b> 06:00-14:00 UTC</li> <li><b>EU (Ireland)
     * Region:</b> 22:00-06:00 UTC</li> <li><b>Asia Pacific (Singapore)
     * Region:</b> 14:00-22:00 UTC</li> <li><b>Asia Pacific (Tokyo) Region:
     * </b> 17:00-03:00 UTC</li> </ul> <p> Constraints: Must be in the format
     * <code>hh24:mi-hh24:mi</code>. Times should be Universal Time
     * Coordinated (UTC). Must not conflict with the preferred maintenance
     * window. Must be at least 30 minutes.
     *
     * @param preferredBackupWindow The daily time range during which automated backups are created if
     *         automated backups are enabled, using the
     *         <code>BackupRetentionPeriod</code> parameter. <p> Default: A 30-minute
     *         window selected at random from an 8-hour block of time per region. The
     *         following list shows the time blocks for each region from which the
     *         default backup windows are assigned. <ul> <li><b>US-East (Northern
     *         Virginia) Region:</b> 03:00-11:00 UTC</li> <li><b>US-West (Northern
     *         California) Region:</b> 06:00-14:00 UTC</li> <li><b>EU (Ireland)
     *         Region:</b> 22:00-06:00 UTC</li> <li><b>Asia Pacific (Singapore)
     *         Region:</b> 14:00-22:00 UTC</li> <li><b>Asia Pacific (Tokyo) Region:
     *         </b> 17:00-03:00 UTC</li> </ul> <p> Constraints: Must be in the format
     *         <code>hh24:mi-hh24:mi</code>. Times should be Universal Time
     *         Coordinated (UTC). Must not conflict with the preferred maintenance
     *         window. Must be at least 30 minutes.
     */
    public void setPreferredBackupWindow(String preferredBackupWindow) {
        this.preferredBackupWindow = preferredBackupWindow;
    }
    
    /**
     * The daily time range during which automated backups are created if
     * automated backups are enabled, using the
     * <code>BackupRetentionPeriod</code> parameter. <p> Default: A 30-minute
     * window selected at random from an 8-hour block of time per region. The
     * following list shows the time blocks for each region from which the
     * default backup windows are assigned. <ul> <li><b>US-East (Northern
     * Virginia) Region:</b> 03:00-11:00 UTC</li> <li><b>US-West (Northern
     * California) Region:</b> 06:00-14:00 UTC</li> <li><b>EU (Ireland)
     * Region:</b> 22:00-06:00 UTC</li> <li><b>Asia Pacific (Singapore)
     * Region:</b> 14:00-22:00 UTC</li> <li><b>Asia Pacific (Tokyo) Region:
     * </b> 17:00-03:00 UTC</li> </ul> <p> Constraints: Must be in the format
     * <code>hh24:mi-hh24:mi</code>. Times should be Universal Time
     * Coordinated (UTC). Must not conflict with the preferred maintenance
     * window. Must be at least 30 minutes.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param preferredBackupWindow The daily time range during which automated backups are created if
     *         automated backups are enabled, using the
     *         <code>BackupRetentionPeriod</code> parameter. <p> Default: A 30-minute
     *         window selected at random from an 8-hour block of time per region. The
     *         following list shows the time blocks for each region from which the
     *         default backup windows are assigned. <ul> <li><b>US-East (Northern
     *         Virginia) Region:</b> 03:00-11:00 UTC</li> <li><b>US-West (Northern
     *         California) Region:</b> 06:00-14:00 UTC</li> <li><b>EU (Ireland)
     *         Region:</b> 22:00-06:00 UTC</li> <li><b>Asia Pacific (Singapore)
     *         Region:</b> 14:00-22:00 UTC</li> <li><b>Asia Pacific (Tokyo) Region:
     *         </b> 17:00-03:00 UTC</li> </ul> <p> Constraints: Must be in the format
     *         <code>hh24:mi-hh24:mi</code>. Times should be Universal Time
     *         Coordinated (UTC). Must not conflict with the preferred maintenance
     *         window. Must be at least 30 minutes.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public PromoteReadReplicaRequest withPreferredBackupWindow(String preferredBackupWindow) {
        this.preferredBackupWindow = preferredBackupWindow;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (dBInstanceIdentifier != null) sb.append("DBInstanceIdentifier: " + dBInstanceIdentifier + ", ");
        if (backupRetentionPeriod != null) sb.append("BackupRetentionPeriod: " + backupRetentionPeriod + ", ");
        if (preferredBackupWindow != null) sb.append("PreferredBackupWindow: " + preferredBackupWindow + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getDBInstanceIdentifier() == null) ? 0 : getDBInstanceIdentifier().hashCode()); 
        hashCode = prime * hashCode + ((getBackupRetentionPeriod() == null) ? 0 : getBackupRetentionPeriod().hashCode()); 
        hashCode = prime * hashCode + ((getPreferredBackupWindow() == null) ? 0 : getPreferredBackupWindow().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof PromoteReadReplicaRequest == false) return false;
        PromoteReadReplicaRequest other = (PromoteReadReplicaRequest)obj;
        
        if (other.getDBInstanceIdentifier() == null ^ this.getDBInstanceIdentifier() == null) return false;
        if (other.getDBInstanceIdentifier() != null && other.getDBInstanceIdentifier().equals(this.getDBInstanceIdentifier()) == false) return false; 
        if (other.getBackupRetentionPeriod() == null ^ this.getBackupRetentionPeriod() == null) return false;
        if (other.getBackupRetentionPeriod() != null && other.getBackupRetentionPeriod().equals(this.getBackupRetentionPeriod()) == false) return false; 
        if (other.getPreferredBackupWindow() == null ^ this.getPreferredBackupWindow() == null) return false;
        if (other.getPreferredBackupWindow() != null && other.getPreferredBackupWindow().equals(this.getPreferredBackupWindow()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/ProvisionedIopsNotAvailableInAZException.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;

import com.amazonaws.AmazonServiceException;

/**
 * <p>
 * Provisioned IOPS not available in the specified Availability Zone.
 * </p>
 */        
public class ProvisionedIopsNotAvailableInAZException extends AmazonServiceException {
    private static final long serialVersionUID = 1L;
    
    /**
     * Constructs a new ProvisionedIopsNotAvailableInAZException with the specified error
     * message.
     * 
     * @param message Describes the error encountered.
     */
    public ProvisionedIopsNotAvailableInAZException(String message) {
        super(message);
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/ListTagsForResourceRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.services.rds.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * List Tags For Resource Request Marshaller
 */
public class ListTagsForResourceRequestMarshaller implements Marshaller<Request<ListTagsForResourceRequest>, ListTagsForResourceRequest> {

    public Request<ListTagsForResourceRequest> marshall(ListTagsForResourceRequest listTagsForResourceRequest) {

        if (listTagsForResourceRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<ListTagsForResourceRequest> request = new DefaultRequest<ListTagsForResourceRequest>(listTagsForResourceRequest, "AmazonRDS");
        request.addParameter("Action", "ListTagsForResource");
        request.addParameter("Version", "2012-09-17");

        if (listTagsForResourceRequest.getResourceName() != null) {
            request.addParameter("ResourceName", StringUtils.fromString(listTagsForResourceRequest.getResourceName()));
        }


        return request;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/TagStaxUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.rds.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.rds.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;


/**
 * Tag StAX Unmarshaller
 */
public class TagStaxUnmarshaller implements Unmarshaller<Tag, StaxUnmarshallerContext> {

    public Tag unmarshall(StaxUnmarshallerContext context) throws Exception {
        Tag tag = new Tag();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        
        if (context.isStartOfDocument()) targetDepth += 2;
        

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return tag;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("Key", targetDepth)) {
                    tag.setKey(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
                if (context.testExpression("Value", targetDepth)) {
                    tag.setValue(StringStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return tag;
                }
            }
        }
    }

    private static TagStaxUnmarshaller instance;
    public static TagStaxUnmarshaller getInstance() {
        if (instance == null) instance = new TagStaxUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/DBSubnetGroupDoesNotCoverEnoughAZsExceptionUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.rds.model.DBSubnetGroupDoesNotCoverEnoughAZsException;

public class DBSubnetGroupDoesNotCoverEnoughAZsExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public DBSubnetGroupDoesNotCoverEnoughAZsExceptionUnmarshaller() {
        super(DBSubnetGroupDoesNotCoverEnoughAZsException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("DBSubnetGroupDoesNotCoverEnoughAZs"))
            return null;

        DBSubnetGroupDoesNotCoverEnoughAZsException e = (DBSubnetGroupDoesNotCoverEnoughAZsException)super.unmarshall(node);
        
        return e;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/ListTagsForResourceResultStaxUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.rds.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import javax.xml.stream.events.XMLEvent;

import com.amazonaws.services.rds.model.*;
import com.amazonaws.transform.Unmarshaller;
import com.amazonaws.transform.MapEntry;
import com.amazonaws.transform.StaxUnmarshallerContext;
import com.amazonaws.transform.SimpleTypeStaxUnmarshallers.*;


/**
 * List Tags For Resource Result StAX Unmarshaller
 */
public class ListTagsForResourceResultStaxUnmarshaller implements Unmarshaller<ListTagsForResourceResult, StaxUnmarshallerContext> {

    public ListTagsForResourceResult unmarshall(StaxUnmarshallerContext context) throws Exception {
        ListTagsForResourceResult listTagsForResourceResult = new ListTagsForResourceResult();
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        
        if (context.isStartOfDocument()) targetDepth += 2;
        

        while (true) {
            XMLEvent xmlEvent = context.nextEvent();
            if (xmlEvent.isEndDocument()) return listTagsForResourceResult;

            if (xmlEvent.isAttribute() || xmlEvent.isStartElement()) {
                if (context.testExpression("TagList/Tag", targetDepth)) {
                    listTagsForResourceResult.getTagList().add(TagStaxUnmarshaller.getInstance().unmarshall(context));
                    continue;
                }
            } else if (xmlEvent.isEndElement()) {
                if (context.getCurrentDepth() < originalDepth) {
                    return listTagsForResourceResult;
                }
            }
        }
    }

    private static ListTagsForResourceResultStaxUnmarshaller instance;
    public static ListTagsForResourceResultStaxUnmarshaller getInstance() {
        if (instance == null) instance = new ListTagsForResourceResultStaxUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/AddTagsToResourceRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.services.rds.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Add Tags To Resource Request Marshaller
 */
public class AddTagsToResourceRequestMarshaller implements Marshaller<Request<AddTagsToResourceRequest>, AddTagsToResourceRequest> {

    public Request<AddTagsToResourceRequest> marshall(AddTagsToResourceRequest addTagsToResourceRequest) {

        if (addTagsToResourceRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<AddTagsToResourceRequest> request = new DefaultRequest<AddTagsToResourceRequest>(addTagsToResourceRequest, "AmazonRDS");
        request.addParameter("Action", "AddTagsToResource");
        request.addParameter("Version", "2012-09-17");

        if (addTagsToResourceRequest.getResourceName() != null) {
            request.addParameter("ResourceName", StringUtils.fromString(addTagsToResourceRequest.getResourceName()));
        }

        java.util.List<Tag> tagsList = addTagsToResourceRequest.getTags();
        int tagsListIndex = 1;

        for (Tag tagsListValue : tagsList) {
            Tag tagMember = tagsListValue;
            if (tagMember != null) {
                if (tagMember.getKey() != null) {
                    request.addParameter("Tags.Tag." + tagsListIndex + ".Key", StringUtils.fromString(tagMember.getKey()));
                }
                if (tagMember.getValue() != null) {
                    request.addParameter("Tags.Tag." + tagsListIndex + ".Value", StringUtils.fromString(tagMember.getValue()));
                }
            }

            tagsListIndex++;
        }


        return request;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/RemoveTagsFromResourceRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.services.rds.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Remove Tags From Resource Request Marshaller
 */
public class RemoveTagsFromResourceRequestMarshaller implements Marshaller<Request<RemoveTagsFromResourceRequest>, RemoveTagsFromResourceRequest> {

    public Request<RemoveTagsFromResourceRequest> marshall(RemoveTagsFromResourceRequest removeTagsFromResourceRequest) {

        if (removeTagsFromResourceRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<RemoveTagsFromResourceRequest> request = new DefaultRequest<RemoveTagsFromResourceRequest>(removeTagsFromResourceRequest, "AmazonRDS");
        request.addParameter("Action", "RemoveTagsFromResource");
        request.addParameter("Version", "2012-09-17");

        if (removeTagsFromResourceRequest.getResourceName() != null) {
            request.addParameter("ResourceName", StringUtils.fromString(removeTagsFromResourceRequest.getResourceName()));
        }

        java.util.List<String> tagKeysList = removeTagsFromResourceRequest.getTagKeys();
        int tagKeysListIndex = 1;

        for (String tagKeysListValue : tagKeysList) {
            if (tagKeysListValue != null) {
                request.addParameter("TagKeys.member." + tagKeysListIndex, StringUtils.fromString(tagKeysListValue));
            }

            tagKeysListIndex++;
        }


        return request;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/PromoteReadReplicaRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model.transform;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.services.rds.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;

/**
 * Promote Read Replica Request Marshaller
 */
public class PromoteReadReplicaRequestMarshaller implements Marshaller<Request<PromoteReadReplicaRequest>, PromoteReadReplicaRequest> {

    public Request<PromoteReadReplicaRequest> marshall(PromoteReadReplicaRequest promoteReadReplicaRequest) {

        if (promoteReadReplicaRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<PromoteReadReplicaRequest> request = new DefaultRequest<PromoteReadReplicaRequest>(promoteReadReplicaRequest, "AmazonRDS");
        request.addParameter("Action", "PromoteReadReplica");
        request.addParameter("Version", "2012-09-17");

        if (promoteReadReplicaRequest.getDBInstanceIdentifier() != null) {
            request.addParameter("DBInstanceIdentifier", StringUtils.fromString(promoteReadReplicaRequest.getDBInstanceIdentifier()));
        }
        if (promoteReadReplicaRequest.getBackupRetentionPeriod() != null) {
            request.addParameter("BackupRetentionPeriod", StringUtils.fromInteger(promoteReadReplicaRequest.getBackupRetentionPeriod()));
        }
        if (promoteReadReplicaRequest.getPreferredBackupWindow() != null) {
            request.addParameter("PreferredBackupWindow", StringUtils.fromString(promoteReadReplicaRequest.getPreferredBackupWindow()));
        }


        return request;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/transform/ProvisionedIopsNotAvailableInAZExceptionUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model.transform;

import org.w3c.dom.Node;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.util.XpathUtils;
import com.amazonaws.transform.StandardErrorUnmarshaller;

import com.amazonaws.services.rds.model.ProvisionedIopsNotAvailableInAZException;

public class ProvisionedIopsNotAvailableInAZExceptionUnmarshaller extends StandardErrorUnmarshaller {

    public ProvisionedIopsNotAvailableInAZExceptionUnmarshaller() {
        super(ProvisionedIopsNotAvailableInAZException.class);
    }

    public AmazonServiceException unmarshall(Node node) throws Exception {
        // Bail out if this isn't the right error code that this
        // marshaller understands.
        String errorCode = parseErrorCode(node);
        if (errorCode == null || !errorCode.equals("ProvisionedIopsNotAvailableInAZFault"))
            return null;

        ProvisionedIopsNotAvailableInAZException e = (ProvisionedIopsNotAvailableInAZException)super.unmarshall(node);
        
        return e;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/ListTagsForResourceResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;

/**
 * <p>
 * </p>
 */
public class ListTagsForResourceResult {

    /**
     * List of tags returned by the ListTagsForResource operation.
     */
    private java.util.List<Tag> tagList;

    /**
     * List of tags returned by the ListTagsForResource operation.
     *
     * @return List of tags returned by the ListTagsForResource operation.
     */
    public java.util.List<Tag> getTagList() {
        
        if (tagList == null) {
            tagList = new java.util.ArrayList<Tag>();
        }
        return tagList;
    }
    
    /**
     * List of tags returned by the ListTagsForResource operation.
     *
     * @param tagList List of tags returned by the ListTagsForResource operation.
     */
    public void setTagList(java.util.Collection<Tag> tagList) {
        if (tagList == null) {
            this.tagList = null;
            return;
        }

        java.util.List<Tag> tagListCopy = new java.util.ArrayList<Tag>(tagList.size());
        tagListCopy.addAll(tagList);
        this.tagList = tagListCopy;
    }
    
    /**
     * List of tags returned by the ListTagsForResource operation.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tagList List of tags returned by the ListTagsForResource operation.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public ListTagsForResourceResult withTagList(Tag... tagList) {
        if (getTagList() == null) setTagList(new java.util.ArrayList<Tag>(tagList.length));
        for (Tag value : tagList) {
            getTagList().add(value);
        }
        return this;
    }
    
    /**
     * List of tags returned by the ListTagsForResource operation.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param tagList List of tags returned by the ListTagsForResource operation.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public ListTagsForResourceResult withTagList(java.util.Collection<Tag> tagList) {
        if (tagList == null) {
            this.tagList = null;
        } else {
            java.util.List<Tag> tagListCopy = new java.util.ArrayList<Tag>(tagList.size());
            tagListCopy.addAll(tagList);
            this.tagList = tagListCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (tagList != null) sb.append("TagList: " + tagList + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getTagList() == null) ? 0 : getTagList().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof ListTagsForResourceResult == false) return false;
        ListTagsForResourceResult other = (ListTagsForResourceResult)obj;
        
        if (other.getTagList() == null ^ this.getTagList() == null) return false;
        if (other.getTagList() != null && other.getTagList().equals(this.getTagList()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/Tag.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;

/**
 * <p>
 * Metadata assigned to a DB Instance consisting of a key-value pair.
 * </p>
 */
public class Tag {

    /**
     * A key is the required name of the tag. The string value can be from 1
     * to 128 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     */
    private String key;

    /**
     * A value is the optional value of the tag. The string value can be from
     * 1 to 256 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     */
    private String value;

    /**
     * A key is the required name of the tag. The string value can be from 1
     * to 128 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     *
     * @return A key is the required name of the tag. The string value can be from 1
     *         to 128 Unicode characters in length and cannot be prefixed with
     *         "aws:". The string may only contain only the set of Unicode letters,
     *         digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     *         "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     */
    public String getKey() {
        return key;
    }
    
    /**
     * A key is the required name of the tag. The string value can be from 1
     * to 128 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     *
     * @param key A key is the required name of the tag. The string value can be from 1
     *         to 128 Unicode characters in length and cannot be prefixed with
     *         "aws:". The string may only contain only the set of Unicode letters,
     *         digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     *         "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     */
    public void setKey(String key) {
        this.key = key;
    }
    
    /**
     * A key is the required name of the tag. The string value can be from 1
     * to 128 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param key A key is the required name of the tag. The string value can be from 1
     *         to 128 Unicode characters in length and cannot be prefixed with
     *         "aws:". The string may only contain only the set of Unicode letters,
     *         digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     *         "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public Tag withKey(String key) {
        this.key = key;
        return this;
    }
    
    
    /**
     * A value is the optional value of the tag. The string value can be from
     * 1 to 256 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     *
     * @return A value is the optional value of the tag. The string value can be from
     *         1 to 256 Unicode characters in length and cannot be prefixed with
     *         "aws:". The string may only contain only the set of Unicode letters,
     *         digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     *         "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     */
    public String getValue() {
        return value;
    }
    
    /**
     * A value is the optional value of the tag. The string value can be from
     * 1 to 256 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     *
     * @param value A value is the optional value of the tag. The string value can be from
     *         1 to 256 Unicode characters in length and cannot be prefixed with
     *         "aws:". The string may only contain only the set of Unicode letters,
     *         digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     *         "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     */
    public void setValue(String value) {
        this.value = value;
    }
    
    /**
     * A value is the optional value of the tag. The string value can be from
     * 1 to 256 Unicode characters in length and cannot be prefixed with
     * "aws:". The string may only contain only the set of Unicode letters,
     * digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     * "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param value A value is the optional value of the tag. The string value can be from
     *         1 to 256 Unicode characters in length and cannot be prefixed with
     *         "aws:". The string may only contain only the set of Unicode letters,
     *         digits, white-space, '_', '.', '/', '=', '+', '-' (Java regex:
     *         "^([\\p{L}\\p{Z}\\p{N}_.:/=+\\-]*)$").
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public Tag withValue(String value) {
        this.value = value;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (key != null) sb.append("Key: " + key + ", ");
        if (value != null) sb.append("Value: " + value + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getKey() == null) ? 0 : getKey().hashCode()); 
        hashCode = prime * hashCode + ((getValue() == null) ? 0 : getValue().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof Tag == false) return false;
        Tag other = (Tag)obj;
        
        if (other.getKey() == null ^ this.getKey() == null) return false;
        if (other.getKey() != null && other.getKey().equals(this.getKey()) == false) return false; 
        if (other.getValue() == null ^ this.getValue() == null) return false;
        if (other.getValue() != null && other.getValue().equals(this.getValue()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/model/ListTagsForResourceRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.rds.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.rds.AmazonRDS#listTagsForResource(ListTagsForResourceRequest) ListTagsForResource operation}.
 * <p>
 * Lists all tags on a DB Instance.
 * </p>
 * <p>
 * For an overview on tagging DB Instances, see <a href="http://docs.amazonwebservices.com/AmazonRDS/latest/UserGuide/Overview.Tagging.html"> DB Instance
 * Tags. </a>
 * </p>
 *
 * @see com.amazonaws.services.rds.AmazonRDS#listTagsForResource(ListTagsForResourceRequest)
 */
public class ListTagsForResourceRequest extends AmazonWebServiceRequest {

    /**
     * The DB Instance with tags to be listed.
     */
    private String resourceName;

    /**
     * The DB Instance with tags to be listed.
     *
     * @return The DB Instance with tags to be listed.
     */
    public String getResourceName() {
        return resourceName;
    }
    
    /**
     * The DB Instance with tags to be listed.
     *
     * @param resourceName The DB Instance with tags to be listed.
     */
    public void setResourceName(String resourceName) {
        this.resourceName = resourceName;
    }
    
    /**
     * The DB Instance with tags to be listed.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param resourceName The DB Instance with tags to be listed.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public ListTagsForResourceRequest withResourceName(String resourceName) {
        this.resourceName = resourceName;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (resourceName != null) sb.append("ResourceName: " + resourceName + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getResourceName() == null) ? 0 : getResourceName().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof ListTagsForResourceRequest == false) return false;
        ListTagsForResourceRequest other = (ListTagsForResourceRequest)obj;
        
        if (other.getResourceName() == null ^ this.getResourceName() == null) return false;
        if (other.getResourceName() != null && other.getResourceName().equals(this.getResourceName()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/rds/AmazonRDSAsync.java;<<<<<<< MINE
=======
     *
     * @param describeDBParametersRequest Container for the necessary
     *           parameters to execute the DescribeDBParameters operation on AmazonRDS.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         DescribeDBParameters service method, as returned by AmazonRDS.
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AmazonRDS indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<DescribeDBParametersResult> describeDBParametersAsync(DescribeDBParametersRequest describeDBParametersRequest,
            AsyncHandler<DescribeDBParametersRequest, DescribeDBParametersResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/internal/SQSRequestHandler.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.sqs.internal;

import java.net.URI;
import java.util.HashMap;
import java.util.Map;

import com.amazonaws.Request;
import com.amazonaws.handlers.AbstractRequestHandler;

public class SQSRequestHandler extends AbstractRequestHandler {

	private static final Map<String, String> nonstandardEndpointMap = new HashMap<String, String>();
	static {
		nonstandardEndpointMap.put("queue.amazonaws.com",                "sqs.us-east-1.amazonaws.com");
		nonstandardEndpointMap.put("us-west-1.queue.amazonaws.com",      "sqs.us-west-1.amazonaws.com");
		nonstandardEndpointMap.put("us-west-2.queue.amazonaws.com",      "sqs.us-west-2.amazonaws.com");
		nonstandardEndpointMap.put("eu-west-1.queue.amazonaws.com",      "sqs.eu-west-1.amazonaws.com");
		nonstandardEndpointMap.put("ap-southeast-1.queue.amazonaws.com", "sqs.ap-southeast-1.amazonaws.com");
		nonstandardEndpointMap.put("ap-northeast-1.queue.amazonaws.com", "sqs.ap-northeast-1.amazonaws.com");
		nonstandardEndpointMap.put("sa-east-1.queue.amazonaws.com",      "sqs.sa-east-1.amazonaws.com");
	}
	
	@Override
	public void beforeRequest(Request<?> request) {
		URI endpoint = request.getEndpoint();

		// If the request is using a non-standard endpoint, then
		// alter it to use the corresponding, standard endpoint
		if (nonstandardEndpointMap.containsKey(endpoint.getHost())) {
			String newHost = nonstandardEndpointMap.get(endpoint.getHost());
			String newEndpoint = endpoint.toString().replaceFirst(endpoint.getHost(), newHost);
			request.setEndpoint(URI.create(newEndpoint));
		}
	}
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/QueueBufferConfig.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */



package com.amazonaws.services.sqs.buffered;

import com.amazonaws.AmazonClientException;

public class QueueBufferConfig {
    
    public static final int MAX_BATCH_SIZE_DEFAULT = 10;
    
    /** the maximum number of entries in a batch command */
    private int maxBatchSize;
    
    public static final long MAX_BATCH_SIZE_BYTES = 64 * 1024 - 1;
    
    /**
     * The maximum time (milliseconds) a send batch is held open for additional
     * outbound requests. The longer this timeout, the longer messages wait for
     * other messages to be added to the batch. Increasing this timeout reduces
     * the number of calls made and increases throughput, but also increases
     * average message latency.
     */
    private  long maxBatchOpenMs;
    
    /** 200 milliseconds */
    public static final long MAX_BATCH_OPEN_MS_DEFAULT = 200;
    
    /**
     * Should we use long polling or not?
     * */
    private boolean longPoll;
    
    /** true */
    private static final boolean LONG_POLL_DEFAULT = true;
    

    /**
     * The maximum number of concurrent batches for each type of outbound
     * request.  The greater the number, the greater the throughput that can be
     * achieved (at the expense of consuming more threads). 
     */
    private int maxInflightOutboundBatches;
    
    /** 5 batches */
    public static final int MAX_INFLIGHT_OUTBOUND_BATCHES_DEFAULT = 5;
    
    /**
     * The maximum number of concurrent receive message batches.  The greater 
     * this number, the faster the queue will be pulling messages from the SQS
     * servers (at the expense of consuming more threads).
     */
    private int maxInflightReceiveBatches;
    
    /** 10 batches */
    public static final int MAX_INFLIGHT_RECEIVE_BATCHES_DEFAULT = 10;

    /**
     * If more than that number of completed receive batches are waiting in the
     * buffer, the querying for new messages will stop.
     * 
     * The larger this number, the more messages the buffer queue will pre-fetch
     * and keep in the buffer on the client side, and the faster receive
     * requests will be satisfied. 
     *
     * The visibility timeout of a pre-fetched message starts at the point of
     * pre-fetch, which means that while the message is in the local buffer it
     * is unavailable for other clients to process, and when this client retrieves it,
     * part of the visibility timeout may have already expired.
     * 
     * The number of messages prefetched will not exceed 10 * maxDoneReceiveBatches,
     * as there can be a maximum of 10 messages per batch.
     *  
     * */
    private int maxDoneReceiveBatches;
    
    /** 10 batches */
    public static final int MAX_DONE_RECEIVE_BATCHES_DEFAULT = 10;
    
    /**
     * Maximum permitted size of a SendMessage or SendMessageBatch message, in
     * bytes
     */
    private long maxBatchSizeBytes;
    
    /** 64 kilobytes*/
    public static final long MAX_BATCH_SIZE_BYTES_DEFAULT = MAX_BATCH_SIZE_BYTES;
    
    /**
     * Custom visibility timeout to use when retrieving messages from SQS. If
     * set to a value greater than zero, this timeout will override the default
     * visibility timeout set on the SQS queue.  Set it to -1 to use the 
     * default visiblity timeout of the queue.  Visibility timeout of 0 seconds
     * is not supported.
     * */
    private int visibilityTimeoutSeconds;
    
    /** -1, which means use the visibility timeout of the queue */
    public static final int VISIBILITY_TIMEOUT_SECONDS_DEFAULT = -1;
    
    /**
     * Specifies the amount of time, in seconds, the receive call will block 
     * on the server waiting for messages to arrive if the queue is empty when 
     * the receive call is first made.
     * 
     * This setting has no effect if long polling is disabled.
     * */

    private int longPollWaitTimeoutSeconds;
    
    public static final int LONGPOLL_WAIT_TIMEOUT_SECONDS_DEFAULT = 20;
    
    public QueueBufferConfig( long maxBatchOpenMs, 
            int maxInflightOutboundBatches,
            int maxInflightReceiveBatches,
            int maxDoneReceiveBatches,
            boolean paramLongPoll,
            long maxBatchSizeBytes,
            int visibilityTimeout,
            int longPollTimeout,
            int maxBatch
            ) {
        super();
        this.maxBatchOpenMs = maxBatchOpenMs;
        this.maxInflightOutboundBatches = maxInflightOutboundBatches;
        this.maxInflightReceiveBatches = maxInflightReceiveBatches;
        this.maxDoneReceiveBatches = maxDoneReceiveBatches;
        this.longPoll = paramLongPoll;
        this.maxBatchSizeBytes = maxBatchSizeBytes;
        this.visibilityTimeoutSeconds = visibilityTimeout;
        this.longPollWaitTimeoutSeconds = longPollTimeout;
        this.maxBatchSize = maxBatch;
    }
    
    public QueueBufferConfig() {
        this( MAX_BATCH_OPEN_MS_DEFAULT, 
                MAX_INFLIGHT_OUTBOUND_BATCHES_DEFAULT,
                MAX_INFLIGHT_RECEIVE_BATCHES_DEFAULT,
                 MAX_DONE_RECEIVE_BATCHES_DEFAULT,
                LONG_POLL_DEFAULT,
                MAX_BATCH_SIZE_BYTES_DEFAULT,
                VISIBILITY_TIMEOUT_SECONDS_DEFAULT,
                LONGPOLL_WAIT_TIMEOUT_SECONDS_DEFAULT,
                MAX_BATCH_SIZE_DEFAULT
                );
    }
    
    /** copy constructor */
    public QueueBufferConfig( QueueBufferConfig other ) {
        longPoll = other.longPoll;
        longPollWaitTimeoutSeconds = other.longPollWaitTimeoutSeconds;
        maxBatchOpenMs = other.maxBatchOpenMs;
        maxBatchSize = other.maxBatchSize;
        maxBatchSizeBytes = other.maxBatchSizeBytes;
        maxDoneReceiveBatches = other.maxDoneReceiveBatches;
        maxInflightOutboundBatches = other.maxInflightOutboundBatches;
        maxInflightReceiveBatches = other.maxInflightReceiveBatches;
        visibilityTimeoutSeconds = other.visibilityTimeoutSeconds;
    }
    


    @Override
    public String toString() {
        return "QueueBufferConfig [maxBatchSize=" + maxBatchSize
                + ", maxBatchOpenMs=" + maxBatchOpenMs + ", longPoll="
                + longPoll + ", maxInflightOutboundBatches="
                + maxInflightOutboundBatches + ", maxInflightReceiveBatches="
                + maxInflightReceiveBatches + ", maxDoneReceiveBatches="
                + maxDoneReceiveBatches + ", maxBatchSizeBytes="
                + maxBatchSizeBytes + ", visibilityTimeoutSeconds="
                + visibilityTimeoutSeconds + ", longPollWaitTimeoutSeconds="
                + longPollWaitTimeoutSeconds + "]";
    }

    /**
     * The maximum time (milliseconds) a send batch is held open for additional
     * outbound requests. The longer this timeout, the longer messages wait for
     * other messages to be added to the batch. Increasing this timeout reduces
     * the number of calls made and increases throughput, but also increases
     * average message latency.
     */

    public long getMaxBatchOpenMs() {
        return maxBatchOpenMs;
    }

    /**
     * The maximum time (milliseconds) a send batch is held open for additional
     * outbound requests. The longer this timeout, the longer messages wait for
     * other messages to be added to the batch. Increasing this timeout reduces
     * the number of calls made and increases throughput, but also increases
     * average message latency.
     */

    public void setMaxBatchOpenMs(long maxBatchOpenMs) {
        this.maxBatchOpenMs = maxBatchOpenMs;
    }
    
    public QueueBufferConfig withMaxBatchOpenMs(long maxBatchOpenMs) {
        this.maxBatchOpenMs = maxBatchOpenMs;
        return this;
    }

    /**
     * @return true if the queue buffer will use long polling while retrieveing
     * messages from the SQS server, false otherwise. 
     * */

    public boolean isLongPoll() {
        return longPoll;
    }

    /**
     * Specify "true" for receive requests to use long polling. 
     * */

    public void setLongPoll(boolean longPoll) {
        this.longPoll = longPoll;
    }
    
    public QueueBufferConfig withLongPoll(boolean longPoll) {
        this.longPoll = longPoll;
        return this;
    }

    /**
     * The maximum number of concurrent batches for each type of outbound
     * request.  The greater the number, the greater the throughput that can be
     * achieved (at the expense of consuming more threads). 
     */

    public int getMaxInflightOutboundBatches() {
        return maxInflightOutboundBatches;
    }

    /**
     * The maximum number of concurrent batches for each type of outbound
     * request.  The greater the number, the greater the throughput that can be
     * achieved (at the expense of consuming more threads). 
     */

    public void setMaxInflightOutboundBatches(int maxInflightOutboundBatches) {
        this.maxInflightOutboundBatches = maxInflightOutboundBatches;
    }

    public QueueBufferConfig withMaxInflightOutboundBatches(int maxInflightOutboundBatches) {
        this.maxInflightOutboundBatches = maxInflightOutboundBatches;
        return this;
    }

    /**
     * The maximum number of concurrent receive message batches.  The greater 
     * this number, the faster the queue will be pulling messages from the SQS
     * servers (at the expense of consuming more threads).
     */

    public int getMaxInflightReceiveBatches() {
        return maxInflightReceiveBatches;
    }

    /**
     * The maximum number of concurrent receive message batches.  The greater 
     * this number, the faster the queue will be pulling messages from the SQS
     * servers (at the expense of consuming more threads).
     */
    public void setMaxInflightReceiveBatches(int maxInflightReceiveBatches) {
        this.maxInflightReceiveBatches = maxInflightReceiveBatches;
    }
    
    public QueueBufferConfig withMaxInflightReceiveBatches(int maxInflightReceiveBatches) {
        this.maxInflightReceiveBatches = maxInflightReceiveBatches;
        return this;
    }

    /**
     * If more than that number of completed receive batches are waiting in the
     * buffer, the querying for new messages will stop.<br>
     * 
     * The larger this number, the more messages the queue buffer will pre-fetch
     * and keep in the buffer on the client side, and the faster receive
     * requests will be satisfied. <br>
     *
     * The visibility timeout of a pre-fetched message starts at the point of
     * pre-fetch, which means that while the message is in the local buffer it
     * is unavailable for other clients to process, and when this client retrieves it,
     * part of the visibility timeout may have already expired.<br>
     * 
     * The number of messages prefetched will not exceed 10 * maxDoneReceiveBatches,
     * as there can be a maximum of 10 messages per batch.<br>
     *  
     * */
    public int getMaxDoneReceiveBatches() {
        return maxDoneReceiveBatches;
    }

    /**
     * If more than that number of completed receive batches are waiting in the
     * buffer, the querying for new messages will stop.<br>
     * 
     * The larger this number, the more messages the queue buffer will pre-fetch
     * and keep in the buffer on the client side, and the faster receive
     * requests will be satisfied. <br>
     *
     * The visibility timeout of a pre-fetched message starts at the point of
     * pre-fetch, which means that while the message is in the local buffer it
     * is unavailable for other clients to process, and when this client retrieves it,
     * part of the visibility timeout may have already expired.<br>
     * 
     * The number of messages prefetched will not exceed 10 * maxDoneReceiveBatches,
     * as there can be a maximum of 10 messages per batch.<br>
     *  
     * */
    public void setMaxDoneReceiveBatches(int maxDoneReceiveBatches) {
        this.maxDoneReceiveBatches = maxDoneReceiveBatches;
    }

    public QueueBufferConfig withMaxDoneReceiveBatches(int maxDoneReceiveBatches) {
        this.maxDoneReceiveBatches = maxDoneReceiveBatches;
        return this;
    }

    /**
     * Maximum permitted size of a SendMessage or SendMessageBatch message, in
     * bytes.  This setting is also enforced on the server, and if this client
     * submits a request of a size larger than the server can support, the server
     * will reject the request.
     */
    public long getMaxBatchSizeBytes() {
        return maxBatchSizeBytes;
    }

    /**
     * Maximum permitted size of a SendMessage or SendMessageBatch message, in
     * bytes.  This setting is also enforced on the server, and if this client
     * submits a request of a size larger than the server can support, the server
     * will reject the request.
     */
    public void setMaxBatchSizeBytes(long maxBatchSizeBytes) {
        this.maxBatchSizeBytes = maxBatchSizeBytes;
    }

    public QueueBufferConfig withMaxBatchSizeBytes(long maxBatchSizeBytes) {
        this.maxBatchSizeBytes = maxBatchSizeBytes;
        return this;
    }

    /**
     * Custom visibility timeout to use when retrieving messages from SQS. If
     * set to a value greater than zero, this timeout will override the default
     * visibility timeout set on the SQS queue.  Set it to -1 to use the 
     * default visiblity timeout of the queue.  Visibility timeout of 0 seconds
     * is not supported.
     * */
    public int getVisibilityTimeoutSeconds() {
        return visibilityTimeoutSeconds;
    }

    /**
     * Custom visibility timeout to use when retrieving messages from SQS. If
     * set to a value greater than zero, this timeout will override the default
     * visibility timeout set on the SQS queue.  Set it to -1 to use the 
     * default visiblity timeout of the queue.  Visibility timeout of 0 seconds
     * is not supported.
     * */
    public void setVisibilityTimeoutSeconds(int visibilityTimeoutSeconds) {
        this.visibilityTimeoutSeconds = visibilityTimeoutSeconds;
    }
    
    public QueueBufferConfig withVisibilityTimeoutSeconds(int visibilityTimeoutSeconds) {
        this.visibilityTimeoutSeconds = visibilityTimeoutSeconds;
        return this;
    }
    
    /**
     * Specifies the amount of time, in seconds, the receive call will block 
     * on the server waiting for messages to arrive if the queue is empty when 
     * the receive call is first made.
     * 
     * This setting has no effect if long polling is disabled.
     * */
    public void setLongPollWaitTimeoutSeconds(int longPollWaitTimeoutSeconds) {
        this.longPollWaitTimeoutSeconds = longPollWaitTimeoutSeconds;
    }

    /**
     * Specifies the amount of time, in seconds, the receive call will block 
     * on the server waiting for messages to arrive if the queue is empty when 
     * the receive call is first made.
     * 
     * This setting has no effect if long polling is disabled.
     * */
    public int getLongPollWaitTimeoutSeconds() {
        return longPollWaitTimeoutSeconds;
    }
    
    public QueueBufferConfig withLongPollWaitTimeoutSeconds(int longPollWaitTimeoutSeconds) {
        this.longPollWaitTimeoutSeconds = longPollWaitTimeoutSeconds;
        return this;
    }


    
    /**
     * Specifies the maximum number of entries the bufferinc client will
     * put in a single batch request.
     * */
    public int getMaxBatchSize() {
        return maxBatchSize;
    }

    /**
     * Specifies the maximum number of entries the bufferinc client will
     * put in a single batch request.
     * */
    public void setMaxBatchSize(int maxBatchSize) {
        this.maxBatchSize = maxBatchSize;
    }
    
    /**
     * Specifies the maximum number of entries the bufferinc client will
     * put in a single batch request.
     * */
    public QueueBufferConfig withMaxBatchSize(int maxBatchSize) {
        this.maxBatchSize = maxBatchSize;
        return this;
    }

    /**
     * this method checks the config for validity. If the config is deemed to be
     * invalid, an informative exception is thrown.
     * 
     * @throws AmazonClientException
     *             with a message explaining why the config was invalid
     */
    void validate() {
        if (visibilityTimeoutSeconds == 0 ) {
            throw new AmazonClientException("Visibility timeout value may not be equal to zero ");
        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/QueueBuffer.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */



package com.amazonaws.services.sqs.buffered;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.atomic.AtomicInteger;

import com.amazonaws.AmazonClientException;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.sqs.AmazonSQSAsync;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityRequest;
import com.amazonaws.services.sqs.model.DeleteMessageRequest;
import com.amazonaws.services.sqs.model.ReceiveMessageRequest;
import com.amazonaws.services.sqs.model.ReceiveMessageResult;
import com.amazonaws.services.sqs.model.SendMessageRequest;
import com.amazonaws.services.sqs.model.SendMessageResult;


/**
 * A buffer to operate on an SQS queue. The buffer batches outbound ( {@code
 * SendMessage}, {@code DeleteMessage}, {@code ChangeMessageVisibility})
 * requests to the queue and pre-fetches messages to receive.  In practice,
 * the buffer does almost no work itself, and delegates it to SendQueueBufer
 * and ReceiveQueueBuffer classes. 
 * <p>
 * Any errors encountered are passed through to the callers, either as the
 * appropriate Result objects or as exceptions.  
 * <p>
 * When the buffer is not used, all internal processing associated with the
 * buffer stops when any outstanding request to SQS completes. In that idle
 * state, the buffer uses neither connections nor threads.  
 * <p>
 * Instances of {@code QueueBuffer} are thread-safe.
 */

class QueueBuffer {
    
    private final SendQueueBuffer sendBuffer;
    private final ReceiveQueueBuffer receiveBuffer;
    private final AmazonSQSAsync realSqs;
    QueueBufferConfig config;
    
    /** This executor that will be shared among all queue buffers. Since a single JVM can 
     * access hundreds of queues, it won't do to have hundreds of executors spinning up 
     * hundreds of threads for each queue.
     * 
     *  The DaemonThreadFactory creates daemon threads, which means they won't block the JVM 
     *  from exiting if only they are still around.
     *  */
    static ExecutorService executor = Executors.newCachedThreadPool(new DaemonThreadFactory());;
    
    QueueBuffer( QueueBufferConfig paramConfig, String url, AmazonSQSAsync sqs) {
        realSqs = sqs;
        config = paramConfig;
        sendBuffer = new SendQueueBuffer(sqs, executor, paramConfig, url);
        receiveBuffer =  new ReceiveQueueBuffer(sqs, executor, paramConfig, url);
        
    }


    /**
     * asynchronously enqueues a message to SQS.
     * 
     * @return a Future object that will be notified when the operation is
     *         completed; never null
     */
    public Future< SendMessageResult> sendMessage(SendMessageRequest request, AsyncHandler<SendMessageRequest, SendMessageResult> handler) {
        QueueBufferCallback<SendMessageRequest,SendMessageResult> callback = null;
        if ( handler != null ) {
            callback = new QueueBufferCallback<SendMessageRequest,SendMessageResult> (handler, request);
        }
        QueueBufferFuture<SendMessageRequest, SendMessageResult> future =  sendBuffer.sendMessage(request, callback);
        future.setBuffer(this);
        return future;
    }
    
    /**
     * Sends a message to SQS and returns the SQS reply.
     * 
     * @return never null
     */
    public SendMessageResult sendMessageSync(SendMessageRequest request) {
        Future<SendMessageResult> future = sendMessage( request, null );
        return waitForFuture(future);
    }

    /**
     * Asynchronously deletes a message from SQS.
     * 
     * @return a Future object that will be notified when the operation is
     *         completed; never null
     */

    public Future<Void> deleteMessage(DeleteMessageRequest request, AsyncHandler<DeleteMessageRequest, Void> handler) {
        QueueBufferCallback<DeleteMessageRequest,Void> callback = null;
        if ( handler != null ) {
            callback = new QueueBufferCallback<DeleteMessageRequest,Void> (handler, request);
        }

        QueueBufferFuture<DeleteMessageRequest,Void> future = sendBuffer.deleteMessage(request, callback);
        future.setBuffer(this);
        return future;
    }
    
    /**
     * Deletes a message from SQS. Does not return until a confirmation from SQS
     * has been received
     * 
     * @return never null
     */
    public void deleteMessageSync(DeleteMessageRequest request) {
        Future<Void> future = deleteMessage(request, null);
        waitForFuture(future);
    }

    /**
     * asynchronously adjust a message's visibility timeout to SQS.
     * 
     * @return a Future object that will be notified when the operation is
     *         completed; never null
     */

    public Future<Void> changeMessageVisibility(ChangeMessageVisibilityRequest request, AsyncHandler<ChangeMessageVisibilityRequest,Void> handler) {
        QueueBufferCallback<ChangeMessageVisibilityRequest,Void> callback = null;
        if ( handler != null ) {
            callback = new QueueBufferCallback<ChangeMessageVisibilityRequest,Void> (handler, request);
        }

        QueueBufferFuture<ChangeMessageVisibilityRequest,Void> future =  sendBuffer.changeMessageVisibility(request, callback);
        future.setBuffer(this);
        return future;
    }
    
    /**
     * Changes visibility of a message in SQS. Does not return until a
     * confirmation from SQS has been received.
     */
    public void changeMessageVisibilitySync(ChangeMessageVisibilityRequest request) {
        Future<Void> future = sendBuffer.changeMessageVisibility(request, null);
        waitForFuture(future);
    }
    
    /**
     * Submits a request to receive some messages from SQS.
     * 
     * @return a Future object that will be notified when the operation is
     *         completed; never null; 
     */

    public Future<ReceiveMessageResult> receiveMessage(ReceiveMessageRequest rq, AsyncHandler<ReceiveMessageRequest, ReceiveMessageResult> handler) {
        //only handle simple requests, because these are the settings we pre-fetch with
        boolean noAttributes = (rq.getAttributeNames() == null) || rq.getAttributeNames().isEmpty();   
        boolean bufferngEnabled = (config.getMaxInflightReceiveBatches() > 0) && (config.getMaxDoneReceiveBatches() > 0);
        if (  noAttributes && bufferngEnabled && ( rq.getVisibilityTimeout() == null ) ) {
            QueueBufferCallback<ReceiveMessageRequest,ReceiveMessageResult> callback = null;
            if ( handler != null ) {
                callback = new QueueBufferCallback<ReceiveMessageRequest,ReceiveMessageResult> (handler, rq);
            }

            QueueBufferFuture<ReceiveMessageRequest, ReceiveMessageResult> future = receiveBuffer.receiveMessageAsync(rq, callback);
            future.setBuffer(this);
            return future;
        } else {
            return realSqs.receiveMessageAsync(rq); 
        }
    }
    
    /**
     * Retrieves messages from an SQS queue.
     * 
     * @return never null
     */
    public ReceiveMessageResult receiveMessageSync( ReceiveMessageRequest rq ) {
        Future<ReceiveMessageResult> future = receiveMessage(rq, null);
        return waitForFuture(future);
    }
    
    /**
     * Shuts down the queue buffer.  Once this method has been called, the 
     * queue buffer is not operational and all subsequent calls to it may fail
     * */
    public void shutdown() {
        //send buffer does not require shutdown, only
        //shut down receive buffer
        receiveBuffer.shutdown();
    }
    
    /**
     * this method carefully waits for futures. If waiting throws, it converts
     * the exceptions to the exceptions that SQS clients expect. This is what we
     * use to turn asynchronous calls into synchronous ones
     */
    private <ResultType>  ResultType waitForFuture( Future<ResultType> future ) {
        ResultType toReturn = null;
        try {
            toReturn = future.get();
        } catch ( InterruptedException ie ) {
            Thread.currentThread().interrupt();
            AmazonClientException ce = new AmazonClientException("Thread interrupted while waiting for execution result");
            ce.initCause(ie);
            throw ce;
        } catch (ExecutionException ee ) {
            //if the cause of the execution exception is an SQS exception, extract it 
            //and throw the extracted exception to the clients
            //otherwise, wrap ee in an SQS exception and throw that.
            Throwable cause = ee.getCause();

            if (cause instanceof AmazonClientException) {
                throw ( AmazonClientException ) cause;
            }
            
            AmazonClientException ce = new AmazonClientException("Caught an exception while waiting for request to complete...");
            ce.initCause(ee);
            throw ce;
        }
        
        return toReturn;
        
    }
    
    /**
     * We need daemon threads in our executor so that we don't keep the process
     * running if our executor threads are the only ones left in the process.
     * */
    private static class DaemonThreadFactory implements ThreadFactory {
        static AtomicInteger threadCount = new AtomicInteger( 0 );
        public Thread newThread( Runnable r) {
            int threadNumber = threadCount.addAndGet(1);
            Thread thread = new Thread( r );
            thread.setDaemon(true);
            thread.setName("SQSQueueBufferWorkerThread-" + threadNumber );
            return thread;
        }
        
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/ResultConverter.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */



package com.amazonaws.services.sqs.buffered;

import com.amazonaws.AmazonServiceException;
import com.amazonaws.AmazonWebServiceRequest;
import com.amazonaws.AmazonServiceException.ErrorType;
import com.amazonaws.services.sqs.model.BatchResultErrorEntry;
import com.amazonaws.services.sqs.model.SendMessageBatchResultEntry;
import com.amazonaws.services.sqs.model.SendMessageResult;

/** this class converts sqs batch entry results to individual results*/
class ResultConverter {
    
    static SendMessageResult convert( SendMessageBatchResultEntry br) {
        SendMessageResult toReturn = new SendMessageResult();
        toReturn.setMD5OfMessageBody(br.getMD5OfMessageBody());
        toReturn.setMessageId(br.getMessageId());
        return toReturn;
    } 
    
    static Exception convert ( BatchResultErrorEntry be)
    {
        AmazonServiceException toReturn = new AmazonServiceException( be.getMessage());
        
        toReturn.setErrorCode(be.getCode());
        toReturn.setErrorType(be.isSenderFault() ? ErrorType.Client : ErrorType.Service);
        toReturn.setServiceName("AmazonSQS");

        return toReturn;
        
    }
    
    public static <X extends AmazonWebServiceRequest> X appendUserAgent(X request, String userAgent ) {
        request.getRequestClientOptions().addClientMarker( userAgent );
        return request;
    }

    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/QueueBufferFuture.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */



package com.amazonaws.services.sqs.buffered;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import com.amazonaws.AmazonWebServiceRequest;
import com.amazonaws.handlers.AsyncHandler;

/**
 * QueueBufferFuture class is used to deliver asynchronous results of various
 * QueueBuffer operations.
 * 
 * QueueBufferFutures are not cancellable
 * */
class QueueBufferFuture<Req extends AmazonWebServiceRequest, Res> implements Future<Res> {
    private Res result = null;
    private Exception e = null;
    private boolean done = false;
    
    /** 
     * callback we should call after the future is done.  may be null 
     * */
    
    private final QueueBufferCallback<Req, Res> callback;
    
    /**
     * every future should hold a reference to the buffer that issued it. that
     * way, even if all other references to the buffer are lost, it will not be
     * garbage collected while at least one future it issued is still
     * outstanding.
     */
    private QueueBuffer issuingBuffer = null;
    
    public QueueBufferFuture() {
        this(null);
    }
    
    public QueueBufferFuture( QueueBufferCallback<Req, Res > cb  ) {
        callback = cb;
    }

    /**
     * Report that the task this future represents has succeeded.
     * */
    public synchronized void setSuccess(Res paramResult) {
        if (done) return;  //can't mark done twice
        result = paramResult;
        done = true;
        notifyAll();
        
        //if we have a callback to call, schedule
        //it on a different thread. Who knows what this
        //thread is doing.
        if ( callback != null && issuingBuffer != null ) {
            QueueBuffer.executor.submit(new Callable<Void>() {
                public Void call() throws Exception {
                    callback.onSuccess(result);
                    return null;
                }
            });

        }
    }

    /**
     * Report that the task this future represents has failed.
     * */
    public synchronized void setFailure(Exception paramE) {
        if (done) return;  //can't mark done twice
        e = paramE;
        done = true;
        notifyAll();
        
        //if we have a callback to call, schedule
        //it on a different thread. Who knows what this
        //thread is doing.
        if ( callback != null && issuingBuffer != null ) {
            QueueBuffer.executor.submit(new Callable<Void>() {
                public Void call() throws Exception {
                    callback.onError(e);
                    return null;
                }
            });

        }

    }

    @Override
    public boolean cancel(boolean arg0) {
        // not cancellable
        return false;
    }
    
    public void setBuffer ( QueueBuffer paramBuffer ) {
        issuingBuffer = paramBuffer;
    }
    

    @Override
    public Res get() throws InterruptedException, ExecutionException {
        while (true) {
            try {
                return get(Long.MAX_VALUE, TimeUnit.MILLISECONDS);
            } catch (TimeoutException te) {
                // shouldn't really happen, since we're specifying a very-very
                // long wait. but if it does, just loop
                // and wait more.
            }
        }
    }

    @Override
    public synchronized Res get(long timeout, TimeUnit tu)
            throws InterruptedException, ExecutionException,
            TimeoutException {

        long waitStartMs = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);
        long timeoutMs = TimeUnit.MILLISECONDS.convert(timeout, tu);
        long timeToWaitMs = timeoutMs;

        while (!done) {
            //if timeToWaitMs is zero, we don't call wait() at all, because wait(0) means 
            //"wait forever", which is the opposite of what we want.
            if ( timeToWaitMs <= 0 ) {
                throw new TimeoutException("Timed out waiting for results after " + timeout + " " + tu);
            }
            
            wait(timeToWaitMs);
            
            //compute how long to wait in the next loop
            long nowMs = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS);
            timeToWaitMs = timeoutMs - ( nowMs - waitStartMs  );

        }

        //if we got here, we are done.  Throw if there's anything to throw, 
        //otherwise return the result 
        if (e != null) {
            throw new ExecutionException(e);
        }

        // may be null, e.g. for Void futures 
        return result;
    }

    @Override
    public boolean isCancelled() {
        // not cancellable
        return false;
    }

    @Override
    public synchronized boolean isDone() {
        return done;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/QueueBufferCallback.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */


package com.amazonaws.services.sqs.buffered;

import com.amazonaws.AmazonWebServiceRequest;
import com.amazonaws.handlers.AsyncHandler;

/**
 * This class combines the handler we are supposed to call after the request is
 * completed and the original request object. The reason to hold on to the
 * original request is that we have to provide it to the async handler on
 * successful completion. Storing the request object here means we don't have to
 * store it in the classes that do actual work. Those classes tend to forget
 * about the request objects as soon as the required data was extracted from
 * them.
 * */
class QueueBufferCallback<RequestType extends AmazonWebServiceRequest, ResultType> {
    
    private final AsyncHandler<RequestType , ResultType > handler;
    private final RequestType request;
    public QueueBufferCallback(
            AsyncHandler<RequestType , ResultType> paramHandler,
            RequestType request) {
        this.handler = paramHandler;
        this.request = request;
    }
    
    public void onError(Exception e) {
        if ( null != handler )
            handler.onError(e);
    }
    
    public void onSuccess( ResultType result) {
        if ( null != handler )
            handler.onSuccess(request, result);
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/ReceiveQueueBuffer.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */



package com.amazonaws.services.sqs.buffered;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonWebServiceRequest;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.sqs.AmazonSQS;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchRequest;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchRequestEntry;
import com.amazonaws.services.sqs.model.GetQueueAttributesRequest;
import com.amazonaws.services.sqs.model.Message;
import com.amazonaws.services.sqs.model.ReceiveMessageRequest;
import com.amazonaws.services.sqs.model.ReceiveMessageResult;
/**
 * The ReceiveQueueBuffer class is responsible for dequeueing of messages from
 * a single SQS queue. It uses the provided executor to pre-fetch messages from the server
 * and keeps them in a buffer which it uses to satisfy incoming requests.  The number of requests
 * pre-fetched and kept in the buffer, as well as the maximum number of threads used to retrieve
 * the messages are configurable. <p>
 * 
 *  Synchronization strategy:
 *  - Threads must hold the TaskSpawnSyncPoint object monitor to spawn a new task or modify
 *    the number of inflight tasks
 *  - Threads must hold the monitor of the "futures" list to modify the list
 *  - Threads must hold the monitor of the "finishedTasks" list to modify the list
 *  - If you need to lock both futures and finishedTasks, lock futures first and
 *    finishedTasks second
 * */
public class ReceiveQueueBuffer {
    
    private static Log log = LogFactory.getLog(ReceiveQueueBuffer.class);
    
    private final QueueBufferConfig config;
    
    private final String qUrl;
    
    private final Executor executor;
    
    private final AmazonSQS sqsClient;
    
    private long bufferCounter = 0;
    
    /**
     * This buffer's queue visibility timeout. Used to detect expired message
     * that should not be returned by the {@code receiveMessage} call.
     * Synchronized by {@code receiveMessageLock}. -1 indicates that the time is
     * uninitialized.
     */
    private volatile long visibilityTimeoutNanos = -1;

    /**
     * Used as permits controlling the number of in flight receive batches.
     * Synchronized by {@code taskSpawnSyncPoint}.
     */
    private volatile int inflightReceiveMessageBatches;
    
    /**
     * synchronize on this object to create new receive batches or modify
     * inflight message count
     */
    private final Object taskSpawnSyncPoint = new Object();
    
    
    /** shutdown buffer does not retrieve any more messages from sqs */
    volatile boolean shutDown = false;
    
    /** message delivery futures we gave out */ 
    private final LinkedList< ReceiveMessageFuture > futures = new LinkedList<ReceiveMessageFuture>();
    
    /** finished batches are stored in this list. */
    private LinkedList<ReceiveMessageBatchTask> finishedTasks = new LinkedList<ReceiveMessageBatchTask>();
        
    ReceiveQueueBuffer( AmazonSQS paramSQS, Executor paramExecutor, QueueBufferConfig paramConfig, String url ) {
        config = paramConfig;
        executor = paramExecutor;
        sqsClient = paramSQS;
        qUrl = url;
        
    }
    
    /**
     * Prevents spawning of new retrieval batches and waits for all in-flight
     * retrieval batches to finish 
     * */
    public void shutdown() {
        shutDown = true;
        try {
        while ( inflightReceiveMessageBatches > 0 )
            Thread.sleep(100);
        } catch( InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    /**
     * Submits the request for retrieval of messages from the queue and returns
     * a future that will be signalled when the request is satisfied.  The future
     * may already be signalled by the time it is returned.
     * 
     * @return never null
     * */
    public QueueBufferFuture<ReceiveMessageRequest, ReceiveMessageResult > 
        receiveMessageAsync( ReceiveMessageRequest rq, QueueBufferCallback<ReceiveMessageRequest, ReceiveMessageResult > callback ) {
        
        if (shutDown) {
            throw new AmazonClientException("The client has been shut down.");
        }
        
        //issue the future...
        int numMessages = 10;
        if ( rq.getMaxNumberOfMessages() != null ) {
            numMessages = rq.getMaxNumberOfMessages();
        }
        QueueBufferFuture<ReceiveMessageRequest,ReceiveMessageResult> toReturn = issueFuture(numMessages, callback);
        
        //attempt to satisfy it right away...
        satisfyFuturesFromBuffer();
        
        //spawn more receive tasks if we need them...
        spawnMoreReceiveTasks();
        
        return toReturn;
    }
    
    /**
     * Creates and returns a new future object. Sleeps if the list of
     * already-issued but as yet unsatisfied futures is over a throttle limit.
     * 
     * @return never null
     */
    private ReceiveMessageFuture issueFuture( int size, QueueBufferCallback<ReceiveMessageRequest, ReceiveMessageResult> callback) {
        synchronized( futures )    {
            ReceiveMessageFuture theFuture = new ReceiveMessageFuture(callback, size);
            futures.addLast(theFuture);
            return theFuture;
        }
    }
    
    /**
     * Attempts to satisfy some or all of the already-issued futures from the
     * local buffer. If the buffer is empty or there are no futures, this method
     * won't do anything.
     * */
    private void satisfyFuturesFromBuffer()    {
        synchronized( futures )    {
            synchronized( finishedTasks ) {
                //attempt to satisfy futures until we run out of either futures or
                //finished tasks
                while ( (!futures.isEmpty())  &&  (!finishedTasks.isEmpty()) )    {
                    ReceiveMessageFuture currentFuture = futures.poll();
                    fillFuture( currentFuture);
                }
            }
        }
    }
    
    /** 
     * Fills the future with whatever results were received by the full batch 
     * currently at the head of the completed batch queue.  Those results may be retrieved
     * messages, or an exception.  
     * 
     * this method assumes that you are holding the finished tasks lock 
     * locks when invoking it.  violate this assumption at 
     * your own peril */
    private void fillFuture( ReceiveMessageFuture f ){
        ReceiveMessageResult r = new ReceiveMessageResult();
        LinkedList<Message> messages = new LinkedList<Message>();
        r.setMessages(messages);
        Exception exception = null;
        
        if ( !finishedTasks.isEmpty() ) {
            ReceiveMessageBatchTask t = finishedTasks.getFirst();
            
            exception = t.getException();
            int retrieved = 0;
            
            boolean batchDone = false;
            while (  retrieved < f.getRequestedSize() )  
            {
                Message m = t.removeMessage();
                
                // a non-empty batch can still give back a null 
                // message if the message expired.
                if ( null != m) {
                    messages.add(m);
                    ++retrieved;
                }
                else {
                    batchDone = true;
                    break;
                }
                
            }
            
            //we may have just drained the batch.
            batchDone = batchDone || t.isEmpty() || ( exception != null );
            
            if ( batchDone) {
                finishedTasks.removeFirst();
            }
            r.setMessages(messages);
        }
        
        //if after the above runs the exception is not null, 
        //the finished batch has encountered an error, and we will
        //report that in the Future.  Otherwise, we will fill
        //the future with the receive result
        
        if ( exception != null )
            f.setFailure(exception);
        else
            f.setSuccess(r);
        
        //now, a bit of maintenance.  remove empty non-exception-bearing 
        //batches so we can get new ones.
        
        while ( !finishedTasks.isEmpty() ) {
            ReceiveMessageBatchTask t = finishedTasks.getFirst();
            if ( (!t.isEmpty()) || (t.getException() != null) ) {
                //if we found a finished task that has useful content,
                //our cleanup is done
                break;
            }
            
            //throw away the empty batch.
            finishedTasks.removeFirst();
        }
    }
    
    /**
     * maybe create more receive tasks. extra receive tasks won't be created if
     * we are already at the maximum number of receive tasks, or if we are at
     * the maximum number of prefetched buffers
     */
    private void spawnMoreReceiveTasks() {
        
        if( shutDown )
            return;

        int desiredBatches = config.getMaxDoneReceiveBatches();
        desiredBatches = desiredBatches < 1 ? 1 : desiredBatches;
        
        synchronized( finishedTasks ) {
            if (  finishedTasks.size() >= desiredBatches )
                return;
            
            //if we have some finished batches already, and 
            //existing inflight batches will bring us to the limit, 
            //don't spawn more. if our finished tasks cache is empty, we will
            //always spawn a thread.
            if ( finishedTasks.size() > 0 && ( finishedTasks.size() + inflightReceiveMessageBatches ) >= desiredBatches )
                return;
        }

        synchronized (taskSpawnSyncPoint) {
            if (visibilityTimeoutNanos == -1) {
                GetQueueAttributesRequest request = new GetQueueAttributesRequest().
                        withQueueUrl(qUrl).
                        withAttributeNames("VisibilityTimeout");
                ResultConverter.appendUserAgent(request, AmazonSQSBufferedAsyncClient.USER_AGENT);
                long visibilityTimeoutSeconds = Long.parseLong(sqsClient.getQueueAttributes( request ).getAttributes().get("VisibilityTimeout"));
                visibilityTimeoutNanos = TimeUnit.NANOSECONDS.convert(visibilityTimeoutSeconds, TimeUnit.SECONDS);
            }

            int max = config.getMaxInflightReceiveBatches();
            //must allow at least one inflight receive task, or receive won't 
            //work at all.
            max = max > 0 ? max : 1; 
            int toSpawn =  max - inflightReceiveMessageBatches;
            if (toSpawn > 0) {
                ReceiveMessageBatchTask task = new ReceiveMessageBatchTask(this );
                ++inflightReceiveMessageBatches;
                ++bufferCounter;
                if (log.isTraceEnabled()) {
                    log.trace("Spawned receive batch #" + bufferCounter + " (" + inflightReceiveMessageBatches 
                            + " of " + max + " inflight) for queue " + qUrl);
                }
                executor.execute(task);
            }
        }
    }
    
    /**
     * This method is called by the batches after they have finished retrieving
     * the messages.
     * 
     * */
    void reportBatchFinished( ReceiveMessageBatchTask batch )
    {
        synchronized( finishedTasks ) {
            finishedTasks.addLast( batch );
            if ( log.isTraceEnabled() ) {
                log.info("Queue " + qUrl + " now has " + finishedTasks.size() + " receive results cached ");
            }
        }
        
        synchronized( taskSpawnSyncPoint )    {
            --inflightReceiveMessageBatches;
        }
        
        satisfyFuturesFromBuffer();
        
        spawnMoreReceiveTasks();
    }

    
    /**
     * Clears and nacks any pre-fetched messages in this buffer.
     */
    public void clear() {
        boolean done = false;
        while ( !done ) {
            ReceiveMessageBatchTask currentBatch = null;
            synchronized (finishedTasks) {
                currentBatch = finishedTasks.poll();
            }
            
            if ( currentBatch != null ) {
                currentBatch.clear();
            } else {
                //ran out of batches to clear
                done = true;
            }
        }
    }

    
    private class ReceiveMessageFuture extends QueueBufferFuture < ReceiveMessageRequest, ReceiveMessageResult >
    {
        /* how many messages did the request ask for*/
        private int requestedSize;
        
        ReceiveMessageFuture( int paramSize ) {
            this(null,paramSize);
        }
        
        ReceiveMessageFuture( QueueBufferCallback<ReceiveMessageRequest,ReceiveMessageResult> cb, int paramSize ) {
            super(cb);
            requestedSize = paramSize;
        }

        public int getRequestedSize() {
            return requestedSize;
        }
        
    }
    
    /**
     * Task to receive messages from SQS.
     * <p>
     * The batch task is constructed {@code !open} until the
     * {@code ReceiveMessage} completes. At that point, the batch opens and its
     * messages (if any) become available to read.
     */
    private class ReceiveMessageBatchTask implements Runnable {
        private Exception exception = null;
        private List<Message> messages;
        private long visibilityDeadlineNano;
        private boolean open = false;
        private ReceiveQueueBuffer parentBuffer;
        

        /**
         * Constructs a receive task waiting the specified time before calling
         * SQS.
         * 
         * @param waitTimeMs
         *            the time to wait before calling SQS
         */
        ReceiveMessageBatchTask(ReceiveQueueBuffer paramParentBuffer) {
            parentBuffer = paramParentBuffer;
            messages = Collections.emptyList();
        }
        
        synchronized int getSize()    {
            if (!open)
                throw new IllegalStateException("batch is not open");

            return messages.size();
            
        }

        synchronized boolean isEmpty() {
            if (!open)
                throw new IllegalStateException("batch is not open");

            return messages.isEmpty();
        }
        
        /** @return the exception that was thrown during execution, or null
         * if there was no exception */ 
        synchronized Exception getException() {
            if (!open)
                throw new IllegalStateException("batch is not open");
            
            return exception;
        }
        
        
        /**
         * Returns a message if one is available.
         * <p>
         * The call adjusts the message count.
         * 
         * @return a message or {@code null} if none is available
         */
        synchronized Message removeMessage() {
            if (!open)
                throw new IllegalStateException("batch is not open");

            // our messages expired.
            if ( System.nanoTime() > visibilityDeadlineNano ) { 
                messages.clear();
                return null;
            }
            
            if (messages.isEmpty())
                return null;
            else
                return messages.remove(messages.size() - 1);
        }

        /**
         * Nacks and clears all messages remaining in the batch.
         */
        synchronized void clear() {
            if (!open)
                throw new IllegalStateException("batch is not open");

            if (System.nanoTime() < visibilityDeadlineNano) {
                ChangeMessageVisibilityBatchRequest batchRequest = new ChangeMessageVisibilityBatchRequest()
                .withQueueUrl(qUrl);
                ResultConverter.appendUserAgent(batchRequest, AmazonSQSBufferedAsyncClient.USER_AGENT);

                List<ChangeMessageVisibilityBatchRequestEntry> entries = 
                    new ArrayList<ChangeMessageVisibilityBatchRequestEntry>(messages.size());

                int i = 0;
                for (Message m : messages) {
                        
                    entries.add(new ChangeMessageVisibilityBatchRequestEntry()
                            .withId(Integer.toString(i))
                            .withReceiptHandle(m.getReceiptHandle())
                            .withVisibilityTimeout(0));
                    ++i;
                }
                
                try {
                    batchRequest.setEntries(entries);
                    sqsClient.changeMessageVisibilityBatch(batchRequest);
                } catch (AmazonClientException e) {
                    // Log and ignore.
                    log.warn("ReceiveMessageBatchTask: changeMessageVisibility failed "    + e);
                }
            }
            messages.clear();
        }

        /**
         * Attempts to retrieve messages from SQS and upon completion (successful or
         * unsuccessful) reports the batch as complete and open 
         * */
        public void run() {
            
            try {
                visibilityDeadlineNano = System.nanoTime() + visibilityTimeoutNanos;
                ReceiveMessageRequest request = new ReceiveMessageRequest(qUrl).withMaxNumberOfMessages(config.getMaxBatchSize());
                ResultConverter.appendUserAgent(request, AmazonSQSBufferedAsyncClient.USER_AGENT);
                
                if ( config.getVisibilityTimeoutSeconds() > 0 ) {
                    request.setVisibilityTimeout(config.getVisibilityTimeoutSeconds());
                    visibilityDeadlineNano = System.nanoTime() + TimeUnit.NANOSECONDS.convert(config.getVisibilityTimeoutSeconds(), TimeUnit.SECONDS);
                }
                
                if ( config.isLongPoll() ) {
                    request.withWaitTimeSeconds(config.getLongPollWaitTimeoutSeconds());
                }

                messages = sqsClient.receiveMessage(request).getMessages();
            } catch (AmazonClientException e) {
                exception = e;
            } finally {
                //whatever happened, we are done and can be considered open
                open = true;
                parentBuffer.reportBatchFinished(this);
            }
            
        }
    }
}  //end of ReceiveQueueBuffer>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/AmazonSQSBufferedAsyncClient.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */



package com.amazonaws.services.sqs.buffered;

import java.util.LinkedHashMap;
import java.util.concurrent.Future;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonServiceException;
import com.amazonaws.AmazonWebServiceRequest;
import com.amazonaws.ResponseMetadata;
import com.amazonaws.handlers.AsyncHandler;
import com.amazonaws.services.sqs.AmazonSQSAsync;
import com.amazonaws.services.sqs.model.AddPermissionRequest;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchRequest;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchResult;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityRequest;
import com.amazonaws.services.sqs.model.CreateQueueRequest;
import com.amazonaws.services.sqs.model.CreateQueueResult;
import com.amazonaws.services.sqs.model.DeleteMessageBatchRequest;
import com.amazonaws.services.sqs.model.DeleteMessageBatchResult;
import com.amazonaws.services.sqs.model.DeleteMessageRequest;
import com.amazonaws.services.sqs.model.DeleteQueueRequest;
import com.amazonaws.services.sqs.model.GetQueueAttributesRequest;
import com.amazonaws.services.sqs.model.GetQueueAttributesResult;
import com.amazonaws.services.sqs.model.GetQueueUrlRequest;
import com.amazonaws.services.sqs.model.GetQueueUrlResult;
import com.amazonaws.services.sqs.model.ListQueuesRequest;
import com.amazonaws.services.sqs.model.ListQueuesResult;
import com.amazonaws.services.sqs.model.ReceiveMessageRequest;
import com.amazonaws.services.sqs.model.ReceiveMessageResult;
import com.amazonaws.services.sqs.model.RemovePermissionRequest;
import com.amazonaws.services.sqs.model.SendMessageBatchRequest;
import com.amazonaws.services.sqs.model.SendMessageBatchResult;
import com.amazonaws.services.sqs.model.SendMessageRequest;
import com.amazonaws.services.sqs.model.SendMessageResult;
import com.amazonaws.services.sqs.model.SetQueueAttributesRequest;
import com.amazonaws.util.VersionInfoUtils;

/**
 * AmazonSQSBufferedAsyncClient provides client-side batching of outgoing
 * sendMessage, deleteMessage and changeMessageVisibility calls. <br>
 * 
 * After receiving a call, rather than executing it right away, this client
 * waits for a configurable period of time ( default=200ms) for other calls of
 * the same type to come in; if such calls do come in, they are also not
 * executed immediately, but instead are added to the batch. When the batch
 * becomes full or the timeout period expires, the entire batch is executed at
 * once and the results are returned to the callers. This method of operation
 * leads to reduced operating costs (since SQS charges per call and fewer
 * calls are made) and increased overall throughput (since more work is
 * performed per call, and all fixed costs of making a call are amortized over a
 * greater amount of work). The cost of this method is increased latency for
 * individual calls, since calls spend some time waiting on the client side for
 * the potential batch-mates to appear before they are actually executed. <br>
 * 
 * This client also performs pre-fetching of messages from SQS. After the first
 * receiveMessage call is made, the client attempts not only to satisfy that
 * call, but also pre-fetch extra messages to store in a temporary buffer.
 * Future receiveMessage calls will be satisfied from the buffer, and only if
 * the buffer is empty  will the calling thread have to wait for the
 * messages to be fetched. The size of the buffer and the maximum number of
 * threads used for prefetching are configurable. <br>
 * 
 * AmazonSQSBufferedAsyncClient is thread-safe.<br>
 * */
public class AmazonSQSBufferedAsyncClient implements AmazonSQSAsync {
    
    public static final String USER_AGENT = AmazonSQSBufferedAsyncClient.class.getSimpleName() + "/" + VersionInfoUtils.getVersion();
    
    private final CachingMap buffers = new CachingMap( 16, (float) 0.75, true );
    private final AmazonSQSAsync realSQS;
    private final QueueBufferConfig bufferConfigExemplar;
    
    public AmazonSQSBufferedAsyncClient( AmazonSQSAsync paramRealSQS) {
        this( paramRealSQS, new QueueBufferConfig());
    }
    
    //route all future constructors to the most general one, because validation
    //happens here
    public AmazonSQSBufferedAsyncClient( AmazonSQSAsync paramRealSQS, QueueBufferConfig config) {
        config.validate();
        realSQS = paramRealSQS;
        bufferConfigExemplar = config;
    }

    
    public void setQueueAttributes(
            SetQueueAttributesRequest setQueueAttributesRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(setQueueAttributesRequest, USER_AGENT);
        realSQS.setQueueAttributes(setQueueAttributesRequest);
    }

    
    public ChangeMessageVisibilityBatchResult changeMessageVisibilityBatch(
            ChangeMessageVisibilityBatchRequest changeMessageVisibilityBatchRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(changeMessageVisibilityBatchRequest, USER_AGENT);
        return realSQS.changeMessageVisibilityBatch(changeMessageVisibilityBatchRequest);
    }

    
    public void changeMessageVisibility(
            ChangeMessageVisibilityRequest changeMessageVisibilityRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(changeMessageVisibilityRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(changeMessageVisibilityRequest.getQueueUrl());
        buffer.changeMessageVisibilitySync(changeMessageVisibilityRequest);
    }

    
    public SendMessageBatchResult sendMessageBatch(
            SendMessageBatchRequest sendMessageBatchRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(sendMessageBatchRequest, USER_AGENT);
        return realSQS.sendMessageBatch(sendMessageBatchRequest);
    }


    
    public SendMessageResult sendMessage(SendMessageRequest sendMessageRequest)
            throws AmazonServiceException, AmazonClientException {
        QueueBuffer buffer = getQBuffer(sendMessageRequest.getQueueUrl());
        ResultConverter.appendUserAgent(sendMessageRequest, USER_AGENT);
        return buffer.sendMessageSync(sendMessageRequest);
    }

    
    public ReceiveMessageResult receiveMessage(
            ReceiveMessageRequest receiveMessageRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(receiveMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(receiveMessageRequest.getQueueUrl());
        return buffer.receiveMessageSync(receiveMessageRequest);
    }

    
    public DeleteMessageBatchResult deleteMessageBatch(
            DeleteMessageBatchRequest deleteMessageBatchRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(deleteMessageBatchRequest, USER_AGENT);
        return realSQS.deleteMessageBatch(deleteMessageBatchRequest);
    }

    
    public void deleteMessage(DeleteMessageRequest deleteMessageRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(deleteMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(deleteMessageRequest.getQueueUrl());
        buffer.deleteMessageSync(deleteMessageRequest);
    }

    
    public void shutdown() {
        for( QueueBuffer buffer : buffers.values() ) {
            buffer.shutdown();
        }
        realSQS.shutdown();
    }

    
    public Future<ChangeMessageVisibilityBatchResult> changeMessageVisibilityBatchAsync(
            ChangeMessageVisibilityBatchRequest changeMessageVisibilityBatchRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(changeMessageVisibilityBatchRequest, USER_AGENT);
        return realSQS.changeMessageVisibilityBatchAsync(changeMessageVisibilityBatchRequest);
    }

    
    public Future<Void> changeMessageVisibilityAsync(
            ChangeMessageVisibilityRequest changeMessageVisibilityRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(changeMessageVisibilityRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(changeMessageVisibilityRequest.getQueueUrl());
        return buffer.changeMessageVisibility(changeMessageVisibilityRequest, null);
        
    }

    
    public Future<SendMessageBatchResult> sendMessageBatchAsync(
            SendMessageBatchRequest sendMessageBatchRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(sendMessageBatchRequest, USER_AGENT);
        return realSQS.sendMessageBatchAsync(sendMessageBatchRequest);
    }

    
    public Future<SendMessageResult> sendMessageAsync(
            SendMessageRequest sendMessageRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(sendMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(sendMessageRequest.getQueueUrl());
        return buffer.sendMessage(sendMessageRequest, null);
        
    }

    
    public Future<ReceiveMessageResult> receiveMessageAsync(
            ReceiveMessageRequest receiveMessageRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(receiveMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(receiveMessageRequest.getQueueUrl());
        return buffer.receiveMessage(receiveMessageRequest, null);
    }


    
    public Future<DeleteMessageBatchResult> deleteMessageBatchAsync(
            DeleteMessageBatchRequest deleteMessageBatchRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(deleteMessageBatchRequest, USER_AGENT);
        return realSQS.deleteMessageBatchAsync(deleteMessageBatchRequest);
    }



    
    public void setEndpoint(String endpoint) throws IllegalArgumentException {
        realSQS.setEndpoint(endpoint);
    }

    
    public Future<Void> setQueueAttributesAsync(
            SetQueueAttributesRequest setQueueAttributesRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(setQueueAttributesRequest, USER_AGENT);
        return realSQS.setQueueAttributesAsync(setQueueAttributesRequest);
    }

    
    public Future<GetQueueUrlResult> getQueueUrlAsync(
            GetQueueUrlRequest getQueueUrlRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(getQueueUrlRequest, USER_AGENT);
        return realSQS.getQueueUrlAsync(getQueueUrlRequest);
    }

    
    public Future<Void> removePermissionAsync(
            RemovePermissionRequest removePermissionRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(removePermissionRequest, USER_AGENT);
        return realSQS.removePermissionAsync(removePermissionRequest);
    }

    
    public GetQueueUrlResult getQueueUrl(GetQueueUrlRequest getQueueUrlRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(getQueueUrlRequest, USER_AGENT);
        return realSQS.getQueueUrl(getQueueUrlRequest);
    }

    
    public void removePermission(RemovePermissionRequest removePermissionRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(removePermissionRequest, USER_AGENT);
        realSQS.removePermission(removePermissionRequest);
    }

    
    public Future<GetQueueAttributesResult> getQueueAttributesAsync(
            GetQueueAttributesRequest getQueueAttributesRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(getQueueAttributesRequest, USER_AGENT);
        return realSQS.getQueueAttributesAsync(getQueueAttributesRequest);
    }

    
    public GetQueueAttributesResult getQueueAttributes(
            GetQueueAttributesRequest getQueueAttributesRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(getQueueAttributesRequest, USER_AGENT);
        return realSQS.getQueueAttributes(getQueueAttributesRequest);
    }

    
    public Future<Void> deleteQueueAsync(DeleteQueueRequest deleteQueueRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(deleteQueueRequest, USER_AGENT);
        return realSQS.deleteQueueAsync(deleteQueueRequest);
    }

    
    public void deleteQueue(DeleteQueueRequest deleteQueueRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(deleteQueueRequest, USER_AGENT);
        realSQS.deleteQueue(deleteQueueRequest);
    }
    
    
    public Future<ListQueuesResult> listQueuesAsync(
            ListQueuesRequest listQueuesRequest) throws AmazonServiceException,
            AmazonClientException {
        ResultConverter.appendUserAgent(listQueuesRequest, USER_AGENT);
        return realSQS.listQueuesAsync(listQueuesRequest);
    }

    
    public ListQueuesResult listQueues(ListQueuesRequest listQueuesRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(listQueuesRequest, USER_AGENT);
        return realSQS.listQueues(listQueuesRequest);
    }

    
    public Future<CreateQueueResult> createQueueAsync(
            CreateQueueRequest createQueueRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(createQueueRequest, USER_AGENT);
        return realSQS.createQueueAsync(createQueueRequest);
    }

    
    public CreateQueueResult createQueue(CreateQueueRequest createQueueRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(createQueueRequest, USER_AGENT);
        return realSQS.createQueue(createQueueRequest);
    }

    
    public Future<Void> addPermissionAsync(
            AddPermissionRequest addPermissionRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(addPermissionRequest, USER_AGENT);
        return realSQS.addPermissionAsync(addPermissionRequest);
    }

    
    public void addPermission(AddPermissionRequest addPermissionRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(addPermissionRequest, USER_AGENT);
        realSQS.addPermission(addPermissionRequest);
    }


    
    public ListQueuesResult listQueues() throws AmazonServiceException,
            AmazonClientException {
        return realSQS.listQueues();
    }

    
    public ResponseMetadata getCachedResponseMetadata(
            AmazonWebServiceRequest request) {
        ResultConverter.appendUserAgent(request, USER_AGENT);
        return realSQS.getCachedResponseMetadata(request);
    }

    
    public Future<Void> deleteMessageAsync(
            DeleteMessageRequest deleteMessageRequest)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(deleteMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(deleteMessageRequest.getQueueUrl());
        return buffer.deleteMessage(deleteMessageRequest, null);
    }
    
    /**
     * Returns (creating it if necessary) a queue buffer for a particular queue
     * Since we are only storing a limited number of queue buffers, it is
     * possible that as a result of calling this method the least recently used
     * queue buffer will be removed from our queue buffer cache
     * 
     * @return a queue buffer associated with the provided queue URL. Never null
     */
    private synchronized QueueBuffer getQBuffer(String qUrl) {
        QueueBuffer toReturn = buffers.get(qUrl);
        if ( null == toReturn ) {
            QueueBufferConfig config = new QueueBufferConfig( bufferConfigExemplar );
            toReturn = new QueueBuffer( config, qUrl, realSQS );
            buffers.put(qUrl,toReturn);
        }
        return toReturn;
    }
    
    class CachingMap extends LinkedHashMap<String, QueueBuffer > {
        private static final long serialVersionUID = 1;
        private static final int MAX_ENTRIES = 100;
        
        public CachingMap( int initial, float loadFactor, boolean accessOrder) {
            super(initial, loadFactor, accessOrder);
        }
        
        
        protected boolean removeEldestEntry(java.util.Map.Entry< String, QueueBuffer > eldest) {
            return size() > MAX_ENTRIES;
        }
        
    }

    public Future<Void> changeMessageVisibilityAsync(
            ChangeMessageVisibilityRequest changeMessageVisibilityRequest,
            AsyncHandler<ChangeMessageVisibilityRequest, Void> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(changeMessageVisibilityRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(changeMessageVisibilityRequest.getQueueUrl());
        return buffer.changeMessageVisibility(changeMessageVisibilityRequest, asyncHandler);
    }

    public Future<SendMessageResult> sendMessageAsync(
            SendMessageRequest sendMessageRequest,
            AsyncHandler<SendMessageRequest, SendMessageResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(sendMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(sendMessageRequest.getQueueUrl());
        return buffer.sendMessage(sendMessageRequest, asyncHandler);

    }

    public Future<ReceiveMessageResult> receiveMessageAsync(
            ReceiveMessageRequest receiveMessageRequest,
            AsyncHandler<ReceiveMessageRequest, ReceiveMessageResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(receiveMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(receiveMessageRequest.getQueueUrl());
        return buffer.receiveMessage(receiveMessageRequest, asyncHandler);
    }


    public Future<Void> deleteMessageAsync(
            DeleteMessageRequest deleteMessageRequest,
            AsyncHandler<DeleteMessageRequest, Void> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        ResultConverter.appendUserAgent(deleteMessageRequest, USER_AGENT);
        QueueBuffer buffer = getQBuffer(deleteMessageRequest.getQueueUrl());
        return buffer.deleteMessage(deleteMessageRequest, asyncHandler);
    }
    
    public Future<Void> setQueueAttributesAsync(
            SetQueueAttributesRequest setQueueAttributesRequest,
            AsyncHandler<SetQueueAttributesRequest, Void> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.setQueueAttributesAsync(setQueueAttributesRequest,
                asyncHandler);
    }

    public Future<ChangeMessageVisibilityBatchResult> changeMessageVisibilityBatchAsync(
            ChangeMessageVisibilityBatchRequest changeMessageVisibilityBatchRequest,
            AsyncHandler<ChangeMessageVisibilityBatchRequest, ChangeMessageVisibilityBatchResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.changeMessageVisibilityBatchAsync(
                changeMessageVisibilityBatchRequest, asyncHandler);
    }

    public Future<GetQueueUrlResult> getQueueUrlAsync(
            GetQueueUrlRequest getQueueUrlRequest,
            AsyncHandler<GetQueueUrlRequest, GetQueueUrlResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.getQueueUrlAsync(getQueueUrlRequest, asyncHandler);
    }

    public Future<Void> removePermissionAsync(
            RemovePermissionRequest removePermissionRequest,
            AsyncHandler<RemovePermissionRequest, Void> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.removePermissionAsync(removePermissionRequest,
                asyncHandler);
    }

    public Future<GetQueueAttributesResult> getQueueAttributesAsync(
            GetQueueAttributesRequest getQueueAttributesRequest,
            AsyncHandler<GetQueueAttributesRequest, GetQueueAttributesResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.getQueueAttributesAsync(getQueueAttributesRequest,
                asyncHandler);
    }

    public Future<SendMessageBatchResult> sendMessageBatchAsync(
            SendMessageBatchRequest sendMessageBatchRequest,
            AsyncHandler<SendMessageBatchRequest, SendMessageBatchResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.sendMessageBatchAsync(sendMessageBatchRequest,
                asyncHandler);
    }

    public Future<Void> deleteQueueAsync(DeleteQueueRequest deleteQueueRequest,
            AsyncHandler<DeleteQueueRequest, Void> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.deleteQueueAsync(deleteQueueRequest, asyncHandler);
    }

    public Future<ListQueuesResult> listQueuesAsync(
            ListQueuesRequest listQueuesRequest,
            AsyncHandler<ListQueuesRequest, ListQueuesResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.listQueuesAsync(listQueuesRequest, asyncHandler);
    }

    public Future<DeleteMessageBatchResult> deleteMessageBatchAsync(
            DeleteMessageBatchRequest deleteMessageBatchRequest,
            AsyncHandler<DeleteMessageBatchRequest, DeleteMessageBatchResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.deleteMessageBatchAsync(deleteMessageBatchRequest,
                asyncHandler);
    }

    public Future<CreateQueueResult> createQueueAsync(
            CreateQueueRequest createQueueRequest,
            AsyncHandler<CreateQueueRequest, CreateQueueResult> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.createQueueAsync(createQueueRequest, asyncHandler);
    }

    public Future<Void> addPermissionAsync(
            AddPermissionRequest addPermissionRequest,
            AsyncHandler<AddPermissionRequest, Void> asyncHandler)
            throws AmazonServiceException, AmazonClientException {
        return realSQS.addPermissionAsync(addPermissionRequest, asyncHandler);
    }



}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/sqs/buffered/SendQueueBuffer.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */



package com.amazonaws.services.sqs.buffered;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.amazonaws.AmazonClientException;
import com.amazonaws.AmazonWebServiceRequest;
import com.amazonaws.services.sqs.AmazonSQS;
import com.amazonaws.services.sqs.model.BatchResultErrorEntry;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchRequest;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchRequestEntry;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchResult;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityBatchResultEntry;
import com.amazonaws.services.sqs.model.ChangeMessageVisibilityRequest;
import com.amazonaws.services.sqs.model.DeleteMessageBatchRequest;
import com.amazonaws.services.sqs.model.DeleteMessageBatchRequestEntry;
import com.amazonaws.services.sqs.model.DeleteMessageBatchResult;
import com.amazonaws.services.sqs.model.DeleteMessageBatchResultEntry;
import com.amazonaws.services.sqs.model.DeleteMessageRequest;
import com.amazonaws.services.sqs.model.SendMessageBatchRequest;
import com.amazonaws.services.sqs.model.SendMessageBatchRequestEntry;
import com.amazonaws.services.sqs.model.SendMessageBatchResult;
import com.amazonaws.services.sqs.model.SendMessageBatchResultEntry;
import com.amazonaws.services.sqs.model.SendMessageRequest;
import com.amazonaws.services.sqs.model.SendMessageResult;


/**
 * This class is responsible for buffering outgoing SQS requests, i.e. requests
 * to send a message, delete a message and change the visibility of the message. <br>
 * 
 * When a request arrives, the buffer adds the message to a message batch of an
 * appropriate type (creating such a batch if there currently isn't one
 * outstanding). When the outstanding batch becomes full, or when a configurable
 * timeout expires, the buffer makes a call to SQS to execute the current batch. <br>
 * 
 * Internally, the batch objects maintain a list of futures corresponding to the
 * requests added to them. When a batch completes, it loads the results into the
 * futures and marks the futures as complete.
 * */
public class SendQueueBuffer {
    
    
    private static Log log = LogFactory.getLog(SendQueueBuffer.class);

    // Interface to support event notifications with a parameter.
    private interface Listener<T> {
        void invoke(T o);
    };

    /** Config settings for this buffer*/
    private final QueueBufferConfig config;
    
    /** Url of our queue */
    private final String qUrl;

    /**
     * The {@code AmazonSQS} client to use for this buffer's operations.
     */
    private final AmazonSQS sqsClient;

    /**
     * The executor service for the batching tasks.
     */
    private final Executor executor;

    /**
     * Object used to serialize sendMessage calls.
     */
    private final Object sendMessageLock = new Object();

    /**
     * Object used to serialize deleteMessage calls.
     */
    private final Object deleteMessageLock = new Object();

    /**
     * Object used to serialize changeMessageVisibility calls.
     */
    private final Object changeMessageVisibilityLock = new Object();

    /**
     * Current batching task for sendMessage. Using a size 1 array to allow
     * "passing by reference". Synchronized by {@code sendMessageLock}.
     */
    private final SendMessageBatchTask[] openSendMessageBatchTask = new SendMessageBatchTask[1];

    /**
     * Current batching task for deleteMessage. Using a size 1 array to allow
     * "passing by reference". Synchronized by {@code deleteMessageLock}.
     */
    private final DeleteMessageBatchTask[] openDeleteMessageBatchTask = new DeleteMessageBatchTask[1];

    /**
     * Current batching task for changeMessageVisibility. Using a size 1 array
     * to allow "passing by reference". Synchronized by
     * {@code changeMessageVisibilityLock}.
     */
    private final ChangeMessageVisibilityBatchTask[] openChangeMessageVisibilityBatchTask = new ChangeMessageVisibilityBatchTask[1];

    /**
     * Permits controlling the number of in flight SendMessage batches.
     */
    private final Semaphore inflightSendMessageBatches;

    /**
     * Permits controlling the number of in flight DeleteMessage batches.
     */
    private final Semaphore inflightDeleteMessageBatches;

    /**
     * Permits controlling the number of in flight ChangeMessageVisibility
     * batches.
     */
    private final Semaphore inflightChangeMessageVisibilityBatches;

    SendQueueBuffer(AmazonSQS sqsClient, Executor executor, QueueBufferConfig paramConfig, String url) {
        this.sqsClient = sqsClient;
        this.executor = executor;
        this.config = paramConfig;
        qUrl = url;
        int maxBatch = config.getMaxInflightOutboundBatches();
        
        //must allow at least one outbound batch.
        maxBatch = maxBatch > 0 ? maxBatch : 1;

        this.inflightSendMessageBatches = new Semaphore( maxBatch);
        this.inflightDeleteMessageBatches = new Semaphore( maxBatch);
        this.inflightChangeMessageVisibilityBatches = new Semaphore( maxBatch);
    }
    
      public QueueBufferConfig getConfig()  {
          return config;
      }

      /**
       * @return never null
       */
      public QueueBufferFuture< SendMessageRequest, SendMessageResult > sendMessage( SendMessageRequest request, QueueBufferCallback<SendMessageRequest, SendMessageResult> callback)
      {
          QueueBufferFuture<SendMessageRequest, SendMessageResult>  result = 
                  submitOutboundRequest(sendMessageLock, openSendMessageBatchTask, request, inflightSendMessageBatches, callback);
          return result;
      }
      
      /**
       * @return never null
       */
      public QueueBufferFuture<DeleteMessageRequest, Void> deleteMessage(DeleteMessageRequest request, QueueBufferCallback<DeleteMessageRequest, Void > callback) {
          return submitOutboundRequest(deleteMessageLock, 
                  openDeleteMessageBatchTask,
                  request, 
                  inflightDeleteMessageBatches,
                  callback);
      }
      
      /**
       * @return never null
       */
      public QueueBufferFuture<ChangeMessageVisibilityRequest, Void> changeMessageVisibility(ChangeMessageVisibilityRequest request, QueueBufferCallback<ChangeMessageVisibilityRequest, Void> callback) {
          return submitOutboundRequest(
                changeMessageVisibilityLock, 
                openChangeMessageVisibilityBatchTask,
                request,
                inflightChangeMessageVisibilityBatches,
                callback);
      }
      
    /**
     * @return new {@code OutboundBatchTask} of appropriate type, never null
     */
    @SuppressWarnings("unchecked")
    private <R extends AmazonWebServiceRequest, Result> OutboundBatchTask<R, Result> newOutboundBatchTask(
            R request) {
        if (request instanceof SendMessageRequest)
            return (OutboundBatchTask<R, Result>) new SendMessageBatchTask();
        else if (request instanceof DeleteMessageRequest)
            return (OutboundBatchTask<R, Result>) new DeleteMessageBatchTask();
        else if (request instanceof ChangeMessageVisibilityRequest)
            return (OutboundBatchTask<R, Result>) new ChangeMessageVisibilityBatchTask();
        else
            // this should never happen
            throw new IllegalArgumentException("Unsupported request type " + request.getClass().getName());
    }

    /**
     * Flushes all outstanding outbound requests ({@code SendMessage},
     * {@code DeleteMessage}, {@code ChangeMessageVisibility}) in this buffer.
     * <p>
     * The call returns successfully when all outstanding outbound requests
     * submitted before the call are completed (i.e. processed by SQS).
     */
    public void flush() {

        try {
            synchronized (sendMessageLock) {
                inflightSendMessageBatches
                        .acquire(config.getMaxInflightOutboundBatches());
                inflightSendMessageBatches
                        .release(config.getMaxInflightOutboundBatches());
            }
            synchronized (deleteMessageLock) {
                inflightDeleteMessageBatches
                        .acquire(config.getMaxInflightOutboundBatches());
                inflightDeleteMessageBatches
                        .release(config.getMaxInflightOutboundBatches());
            }
            synchronized (changeMessageVisibilityLock) {
                inflightChangeMessageVisibilityBatches
                        .acquire(config.getMaxInflightOutboundBatches());
                inflightChangeMessageVisibilityBatches
                        .release(config.getMaxInflightOutboundBatches());
            }
        } catch( InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    /**
     * Submits an outbound request for delivery to the queue associated with
     * this buffer.
     * <p>
     * 
     * @param operationLock
     *            the lock synchronizing calls for the call type (
     *            {@code sendMessage}, {@code deleteMessage},
     *            {@code changeMessageVisibility} )
     * @param openOutboundBatchTask
     *            the open batch task for this call type
     * @param request
     *            the request to submit
     * @param inflightOperationBatches
     *            the permits controlling the batches for this type of request
     * @return never null
     * @throws AmazonClientException
     *             (see the various outbound calls for details)
     */
    @SuppressWarnings("unchecked")
    <OBT extends OutboundBatchTask<R, Result>, R extends AmazonWebServiceRequest, Result> QueueBufferFuture<R, Result> submitOutboundRequest(
            Object operationLock, 
            OBT[] openOutboundBatchTask, 
            R request,
            final Semaphore inflightOperationBatches, 
            QueueBufferCallback<R, Result> callback) {
        /*
         * Callers add requests to a single batch task (openOutboundBatchTask)
         * until it is full or maxBatchOpenMs elapses. The total number of batch
         * task in flight is controlled by the inflightOperationBatch semaphore
         * capped at maxInflightOutboundBatches.
         */
        QueueBufferFuture<R, Result> theFuture = null;
        try {
            synchronized (operationLock) {
                if (openOutboundBatchTask[0] == null || ((theFuture = openOutboundBatchTask[0].addRequest(request, callback))) == null) {
                    OBT obt = (OBT) newOutboundBatchTask(request);
                    inflightOperationBatches.acquire();
                    openOutboundBatchTask[0] = obt;
                    // Register a listener for the event signaling that the
                    // batch task has completed (successfully or not).
                    openOutboundBatchTask[0].onCompleted = new Listener<OutboundBatchTask<R, Result>>() {
                        public void invoke(OutboundBatchTask<R, Result> task) {
                            inflightOperationBatches.release();
                        }
                    };
                    
                    if ( log.isTraceEnabled() ) {
                        log.trace("Queue " + qUrl + " created new batch for " + request.getClass().toString()
                                + " " + inflightOperationBatches.availablePermits() 
                                + " free slots remain");
                    }
                    
                    theFuture = openOutboundBatchTask[0].addRequest(request, callback);
                    executor.execute(openOutboundBatchTask[0]);
                    if ( null == theFuture ) {
                        //this can happen only if the request itself is flawed, 
                        //so that it can't be added to any batch, even a brand
                        //new one
                        throw new AmazonClientException("Failed to schedule request "+ request + " for execution" );
                    }
                }
            }

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            AmazonClientException toThrow = new AmazonClientException("Interrupted while waiting for lock.");
            toThrow.initCause(e);
            throw toThrow;
        }

        return theFuture;
    }


    /**
     * Task to send a batch of outbound requests to SQS.
     * <p>
     * The batch task is constructed open and accepts requests until full, or
     * until {@code maxBatchOpenMs} elapses. At that point, the batch closes and
     * the collected requests are assembled into a single batch request to SQS.
     * Specialized for each type of outbound request.
     * <p>
     * Instances of this class (and subclasses) are thread-safe.
     * 
     * @param <R>
     *            the type of the SQS request to batch
     * @param <Result>
     *            the type of result he futures issued by this task will return
     */
    private abstract class OutboundBatchTask<R extends AmazonWebServiceRequest, Result> implements Runnable {
        final List<R> requests;
        final ArrayList<QueueBufferFuture<R, Result>> futures;
        AtomicBoolean open = new AtomicBoolean(true);
        volatile Listener<OutboundBatchTask<R, Result>> onCompleted = null;

        OutboundBatchTask() {
            requests = new ArrayList<R>(config.getMaxBatchSize());
            futures = new ArrayList<QueueBufferFuture<R, Result>>(config.getMaxBatchSize());
        }

        /**
         * Adds a request to the batch if it is still open and has capacity.
         * 
         * @return the future that can be used to get the results of the 
         * execution, or null if the addition failed. 
         */
        synchronized QueueBufferFuture<R, Result> addRequest(R request, QueueBufferCallback<R, Result> callback) {
            if (!open.get())
                return null;

            QueueBufferFuture<R, Result> theFuture = addIfAllowed(request, callback);

            // if the addition did not work, or this addition made us full,
            // we can close the request
            if ((null == theFuture) || isFull()) {
                open.set(false);
            }

            // the batch request is as full as it will ever be. no need to wait
            // for the timeout, we can run it now.
            if (!open.get())
                notify();

            return theFuture;
        }

        /**
         * Adds the request to the batch if capacity allows it.
         * 
         * @param request
         * @return the future that will be signaled when the request is
         *         completed and can be used to retrieve the result. Can be null
         *         if the addition could not be done
         */
        synchronized QueueBufferFuture<R, Result> addIfAllowed(R request, QueueBufferCallback<R,Result> callback) {
            if (isOkToAdd(request)) {
                requests.add(request);

                QueueBufferFuture<R, Result> theFuture = new QueueBufferFuture<R, Result>(callback);

                futures.add(theFuture);
                onRequestAdded(request);
                return theFuture;
            } else
                return null;
        }

        protected synchronized boolean isOkToAdd(R request) {
            return requests.size() < config.getMaxBatchSize();
        }
        
        protected synchronized void onRequestAdded(R request) {
            // to be overridden by subclasses
        }

        /**
         * @return whether the buffer is filled to capacity
         */
        synchronized boolean isFull() {
            return requests.size() >= config.getMaxBatchSize();
        }

        /**
         * Processes the batch once closed.
         */
        abstract void process();

        @Override
        public synchronized void run() {
            try {
                long deadlineMs = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS ) + 
                        config.getMaxBatchOpenMs() +1;
                long t = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS );
                while (open.get()  && (t  < deadlineMs ) ) {
                    t = TimeUnit.MILLISECONDS.convert(System.nanoTime(), TimeUnit.NANOSECONDS );
                    
                    //zero means "wait forever", can't have that.
                    long toWait = Math.max(1, deadlineMs - t);
                    wait(toWait);
                }
                    
                open.set(false);
                process();
            } catch (InterruptedException e) {
                failAll( e );
            } catch (AmazonClientException e) {
                failAll( e );
            } catch (RuntimeException e) {
                failAll( e );
                throw e;
            } catch (Error e) {
                failAll( new AmazonClientException("Error encountered", e) );
                throw e;
            } finally {
                //make a copy of the listener since it can be modified from outside
                Listener<OutboundBatchTask<R, Result>> completionListener = onCompleted;
                if (completionListener != null)
                    completionListener.invoke(this);
            }
        }
        
        private void failAll( Exception e) {
            for( QueueBufferFuture<R, Result> f : futures ) {
                f.setFailure(e);
            }
        }
    }

    private class SendMessageBatchTask extends
            OutboundBatchTask<SendMessageRequest, SendMessageResult> {
        int batchSizeBytes = 0;

        @Override
        protected synchronized boolean isOkToAdd(SendMessageRequest request) {
            return ( requests.size() < config.getMaxBatchSize() ) && 
                    ((request.getMessageBody().getBytes().length + batchSizeBytes) < config.getMaxBatchSizeBytes()); 
        }

        @Override
        protected void onRequestAdded(SendMessageRequest request) {
            batchSizeBytes += request.getMessageBody().getBytes().length;
        }

        @Override
        synchronized boolean isFull() {
            return ( requests.size() >= config.getMaxBatchSize() ) || 
                    ( batchSizeBytes >= config.getMaxBatchSizeBytes());
        }

        @Override
        void process() {
            if (requests.isEmpty())
                return;

            SendMessageBatchRequest batchRequest = new SendMessageBatchRequest()
                    .withQueueUrl(qUrl);
            ResultConverter.appendUserAgent(batchRequest, AmazonSQSBufferedAsyncClient.USER_AGENT);

            List<SendMessageBatchRequestEntry> entries = new ArrayList<SendMessageBatchRequestEntry>(
                    requests.size());
            for (int i = 0, n = requests.size(); i < n; i++)
                entries.add(new SendMessageBatchRequestEntry()
                        .withId(Integer.toString(i))
                        .withMessageBody(requests.get(i).getMessageBody())
                        .withDelaySeconds(requests.get(i).getDelaySeconds()));
            batchRequest.setEntries(entries);

            SendMessageBatchResult batchResult = sqsClient
                    .sendMessageBatch(batchRequest);

            for (SendMessageBatchResultEntry entry : batchResult
                    .getSuccessful()) {
                int index = Integer.parseInt(entry.getId());
                futures.get(index).setSuccess(ResultConverter.convert(entry));
            }

            for (BatchResultErrorEntry errorEntry : batchResult.getFailed()) {
                int index = Integer.parseInt(errorEntry.getId());
                if ( errorEntry.isSenderFault() ) {
                    futures.get(index).setFailure( ResultConverter.convert(errorEntry));
                } else {
                    //retry.
                    try {
                        //this will retry internally up to 3 times.
                        futures.get(index).setSuccess(sqsClient.sendMessage(requests.get(index)));
                    } catch ( AmazonClientException ace ) {
                        futures.get(index).setFailure(ace);
                    }
                }
            }

        }

    }

    private class DeleteMessageBatchTask extends
            OutboundBatchTask<DeleteMessageRequest, Void> {

        @Override
        void process() {
            if (requests.isEmpty())
                return;

            DeleteMessageBatchRequest batchRequest = new DeleteMessageBatchRequest()
                    .withQueueUrl(qUrl);
            ResultConverter.appendUserAgent(batchRequest, AmazonSQSBufferedAsyncClient.USER_AGENT);

            List<DeleteMessageBatchRequestEntry> entries = new ArrayList<DeleteMessageBatchRequestEntry>(
                    requests.size());
            for (int i = 0, n = requests.size(); i < n; i++)
                entries.add(new DeleteMessageBatchRequestEntry().withId(
                        Integer.toString(i)).withReceiptHandle(
                        requests.get(i).getReceiptHandle()));
            batchRequest.setEntries(entries);

            DeleteMessageBatchResult batchResult = sqsClient
                    .deleteMessageBatch(batchRequest);

            for (DeleteMessageBatchResultEntry entry : batchResult
                    .getSuccessful()) {
                int index = Integer.parseInt(entry.getId());
                futures.get(index).setSuccess(null);
            }

            for (BatchResultErrorEntry errorEntry : batchResult.getFailed()) {
                int index = Integer.parseInt(errorEntry.getId());
                if ( errorEntry.isSenderFault() ) {
                      futures.get(index).setFailure( ResultConverter.convert(errorEntry));
                } else {
                    try {
                        //retry.
                        sqsClient.deleteMessage(requests.get(index));
                        futures.get(index).setSuccess(null);
                    } catch ( AmazonClientException ace ) {
                        futures.get(index).setFailure(ace);
                    }
                }
           }
        }
    }

    private class ChangeMessageVisibilityBatchTask extends
            OutboundBatchTask<ChangeMessageVisibilityRequest, Void> {

        @Override
        void process() {
            if (requests.isEmpty())
                return;

            ChangeMessageVisibilityBatchRequest batchRequest = new ChangeMessageVisibilityBatchRequest()
                    .withQueueUrl(qUrl);
            ResultConverter.appendUserAgent(batchRequest, AmazonSQSBufferedAsyncClient.USER_AGENT);

            List<ChangeMessageVisibilityBatchRequestEntry> entries = new ArrayList<ChangeMessageVisibilityBatchRequestEntry>(
                    requests.size());
            for (int i = 0, n = requests.size(); i < n; i++)
                entries.add(new ChangeMessageVisibilityBatchRequestEntry()
                        .withId(Integer.toString(i))
                        .withReceiptHandle(requests.get(i).getReceiptHandle())
                        .withVisibilityTimeout(
                                requests.get(i).getVisibilityTimeout()));
            batchRequest.setEntries(entries);

            ChangeMessageVisibilityBatchResult batchResult = sqsClient
                    .changeMessageVisibilityBatch(batchRequest);

            for (ChangeMessageVisibilityBatchResultEntry entry : batchResult
                    .getSuccessful()) {
                int index = Integer.parseInt(entry.getId());
                futures.get(index).setSuccess(null);
            }

            for (BatchResultErrorEntry errorEntry : batchResult.getFailed()) {
                int index = Integer.parseInt(errorEntry.getId());
                if ( errorEntry.isSenderFault() ) {
                    futures.get(index).setFailure( ResultConverter.convert(errorEntry));
                } else {
                    try {
                        //retry.
                        sqsClient.changeMessageVisibility(requests.get(index));
                        futures.get(index).setSuccess(null);
                    } catch ( AmazonClientException ace ) {
                        futures.get(index).setFailure(ace);
                    }
                }
            }

        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/CreateSnapshotFromVolumeRecoveryPointResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * A JSON object containing the following fields:
 * </p>
 * 
 * <ul>
 * <li> CreateSnapshotFromVolumeRecoveryPointOutput$SnapshotId </li>
 * <li> CreateSnapshotFromVolumeRecoveryPointOutput$VolumeARN </li>
 * <li> CreateSnapshotFromVolumeRecoveryPointOutput$VolumeRecoveryPointTime </li>
 * 
 * </ul>
 */
public class CreateSnapshotFromVolumeRecoveryPointResult {

    /**
     * The snapshot ID that is used to refer to the snapshot in future
     * operations such as describing snapshots (Amazon Elastic Compute Cloud
     * API DescribeSnapshots) or creating a volume from a snapshot
     * (<a>CreateStorediSCSIVolume</a>).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     */
    private String snapshotId;

    /**
     * The ARN of the volume of which the snapshot was taken. Obtain volume
     * ARNs from the <a>ListVolumes</a> operation.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String volumeARN;

    /**
     * The time of the recovery point. Data up to this recovery point are
     * included in the snapshot. <p><emphasis>Type</emphasis>: String format
     * of a date in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     */
    private String volumeRecoveryPointTime;

    /**
     * The snapshot ID that is used to refer to the snapshot in future
     * operations such as describing snapshots (Amazon Elastic Compute Cloud
     * API DescribeSnapshots) or creating a volume from a snapshot
     * (<a>CreateStorediSCSIVolume</a>).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @return The snapshot ID that is used to refer to the snapshot in future
     *         operations such as describing snapshots (Amazon Elastic Compute Cloud
     *         API DescribeSnapshots) or creating a volume from a snapshot
     *         (<a>CreateStorediSCSIVolume</a>).
     */
    public String getSnapshotId() {
        return snapshotId;
    }
    
    /**
     * The snapshot ID that is used to refer to the snapshot in future
     * operations such as describing snapshots (Amazon Elastic Compute Cloud
     * API DescribeSnapshots) or creating a volume from a snapshot
     * (<a>CreateStorediSCSIVolume</a>).
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @param snapshotId The snapshot ID that is used to refer to the snapshot in future
     *         operations such as describing snapshots (Amazon Elastic Compute Cloud
     *         API DescribeSnapshots) or creating a volume from a snapshot
     *         (<a>CreateStorediSCSIVolume</a>).
     */
    public void setSnapshotId(String snapshotId) {
        this.snapshotId = snapshotId;
    }
    
    /**
     * The snapshot ID that is used to refer to the snapshot in future
     * operations such as describing snapshots (Amazon Elastic Compute Cloud
     * API DescribeSnapshots) or creating a volume from a snapshot
     * (<a>CreateStorediSCSIVolume</a>).
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @param snapshotId The snapshot ID that is used to refer to the snapshot in future
     *         operations such as describing snapshots (Amazon Elastic Compute Cloud
     *         API DescribeSnapshots) or creating a volume from a snapshot
     *         (<a>CreateStorediSCSIVolume</a>).
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateSnapshotFromVolumeRecoveryPointResult withSnapshotId(String snapshotId) {
        this.snapshotId = snapshotId;
        return this;
    }
    
    
    /**
     * The ARN of the volume of which the snapshot was taken. Obtain volume
     * ARNs from the <a>ListVolumes</a> operation.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The ARN of the volume of which the snapshot was taken. Obtain volume
     *         ARNs from the <a>ListVolumes</a> operation.
     */
    public String getVolumeARN() {
        return volumeARN;
    }
    
    /**
     * The ARN of the volume of which the snapshot was taken. Obtain volume
     * ARNs from the <a>ListVolumes</a> operation.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The ARN of the volume of which the snapshot was taken. Obtain volume
     *         ARNs from the <a>ListVolumes</a> operation.
     */
    public void setVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
    }
    
    /**
     * The ARN of the volume of which the snapshot was taken. Obtain volume
     * ARNs from the <a>ListVolumes</a> operation.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The ARN of the volume of which the snapshot was taken. Obtain volume
     *         ARNs from the <a>ListVolumes</a> operation.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateSnapshotFromVolumeRecoveryPointResult withVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
        return this;
    }
    
    
    /**
     * The time of the recovery point. Data up to this recovery point are
     * included in the snapshot. <p><emphasis>Type</emphasis>: String format
     * of a date in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     *
     * @return The time of the recovery point. Data up to this recovery point are
     *         included in the snapshot. <p><emphasis>Type</emphasis>: String format
     *         of a date in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     */
    public String getVolumeRecoveryPointTime() {
        return volumeRecoveryPointTime;
    }
    
    /**
     * The time of the recovery point. Data up to this recovery point are
     * included in the snapshot. <p><emphasis>Type</emphasis>: String format
     * of a date in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     *
     * @param volumeRecoveryPointTime The time of the recovery point. Data up to this recovery point are
     *         included in the snapshot. <p><emphasis>Type</emphasis>: String format
     *         of a date in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     */
    public void setVolumeRecoveryPointTime(String volumeRecoveryPointTime) {
        this.volumeRecoveryPointTime = volumeRecoveryPointTime;
    }
    
    /**
     * The time of the recovery point. Data up to this recovery point are
     * included in the snapshot. <p><emphasis>Type</emphasis>: String format
     * of a date in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeRecoveryPointTime The time of the recovery point. Data up to this recovery point are
     *         included in the snapshot. <p><emphasis>Type</emphasis>: String format
     *         of a date in the ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateSnapshotFromVolumeRecoveryPointResult withVolumeRecoveryPointTime(String volumeRecoveryPointTime) {
        this.volumeRecoveryPointTime = volumeRecoveryPointTime;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (snapshotId != null) sb.append("SnapshotId: " + snapshotId + ", ");
        if (volumeARN != null) sb.append("VolumeARN: " + volumeARN + ", ");
        if (volumeRecoveryPointTime != null) sb.append("VolumeRecoveryPointTime: " + volumeRecoveryPointTime + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getSnapshotId() == null) ? 0 : getSnapshotId().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeARN() == null) ? 0 : getVolumeARN().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeRecoveryPointTime() == null) ? 0 : getVolumeRecoveryPointTime().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof CreateSnapshotFromVolumeRecoveryPointResult == false) return false;
        CreateSnapshotFromVolumeRecoveryPointResult other = (CreateSnapshotFromVolumeRecoveryPointResult)obj;
        
        if (other.getSnapshotId() == null ^ this.getSnapshotId() == null) return false;
        if (other.getSnapshotId() != null && other.getSnapshotId().equals(this.getSnapshotId()) == false) return false; 
        if (other.getVolumeARN() == null ^ this.getVolumeARN() == null) return false;
        if (other.getVolumeARN() != null && other.getVolumeARN().equals(this.getVolumeARN()) == false) return false; 
        if (other.getVolumeRecoveryPointTime() == null ^ this.getVolumeRecoveryPointTime() == null) return false;
        if (other.getVolumeRecoveryPointTime() != null && other.getVolumeRecoveryPointTime().equals(this.getVolumeRecoveryPointTime()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/CreateCachediSCSIVolumeRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#createCachediSCSIVolume(CreateCachediSCSIVolumeRequest) CreateCachediSCSIVolume operation}.
 * <p>
 * This operation creates a cached volume on a specified cached gateway. This operation is supported only for the gateway-cached volume architecture.
 * </p>
 * <p>
 * <b>NOTE:</b>Cache storage must be allocated to the gateway before you can create a cached volume. Use the AddCache operation to add cache storage to a
 * gateway.
 * </p>
 * <p>
 * In the request, you must specify the gateway, size of the volume in bytes, the iSCSI target name, an IP address on which to expose the target, and a
 * unique client token. In response, AWS Storage Gateway creates the volume and returns information about it such as the volume Amazon Resource Name
 * (ARN), its size, and the iSCSI target ARN that initiators can use to connect to the volume target.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#createCachediSCSIVolume(CreateCachediSCSIVolumeRequest)
 */
public class CreateCachediSCSIVolumeRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * The size of the cached volume.
     */
    private Long volumeSizeInBytes;

    /**
     * The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as
     * the new stored volume. Specify this field if you want to create the
     * iSCSI cached volume from a snapshot; otherwise, do not include this
     * field. To list snapshots for your account, use <a
     * rence/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>
     * in Amazon Elastic Compute Cloud API Reference.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     */
    private String snapshotId;

    /**
     * The name of the iSCSI target used by initiators to connect to the
     * target and as a suffix for the target ARN. For example, specifying
     * <b>TargetName</b> as <i>myvolume</i> results in the target ARN of
     * 22223333:gateway/mygateway/target/iqn.1997-05.com.amazon:myvolume</i>.
     * The target name must be unique across all volumes of a gateway.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 200<br/>
     * <b>Pattern: </b>^[-\.;a-z0-9]+$<br/>
     */
    private String targetName;

    /**
     * The network interface of the gateway on which to expose the iSCSI
     * target. Only IPv4 addresses are accepted. Use the
     * <a>DescribeGatewayInformation</a> operation to get a list of the
     * network interfaces available on the gateway.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z<br/>
     */
    private String networkInterfaceId;

    /**
     * A unique identifying string for the cached volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>5 - 100<br/>
     */
    private String clientToken;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeRequest withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * The size of the cached volume.
     *
     * @return The size of the cached volume.
     */
    public Long getVolumeSizeInBytes() {
        return volumeSizeInBytes;
    }
    
    /**
     * The size of the cached volume.
     *
     * @param volumeSizeInBytes The size of the cached volume.
     */
    public void setVolumeSizeInBytes(Long volumeSizeInBytes) {
        this.volumeSizeInBytes = volumeSizeInBytes;
    }
    
    /**
     * The size of the cached volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeSizeInBytes The size of the cached volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeRequest withVolumeSizeInBytes(Long volumeSizeInBytes) {
        this.volumeSizeInBytes = volumeSizeInBytes;
        return this;
    }
    
    
    /**
     * The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as
     * the new stored volume. Specify this field if you want to create the
     * iSCSI cached volume from a snapshot; otherwise, do not include this
     * field. To list snapshots for your account, use <a
     * rence/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>
     * in Amazon Elastic Compute Cloud API Reference.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @return The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as
     *         the new stored volume. Specify this field if you want to create the
     *         iSCSI cached volume from a snapshot; otherwise, do not include this
     *         field. To list snapshots for your account, use <a
     *         rence/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>
     *         in Amazon Elastic Compute Cloud API Reference.
     */
    public String getSnapshotId() {
        return snapshotId;
    }
    
    /**
     * The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as
     * the new stored volume. Specify this field if you want to create the
     * iSCSI cached volume from a snapshot; otherwise, do not include this
     * field. To list snapshots for your account, use <a
     * rence/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>
     * in Amazon Elastic Compute Cloud API Reference.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @param snapshotId The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as
     *         the new stored volume. Specify this field if you want to create the
     *         iSCSI cached volume from a snapshot; otherwise, do not include this
     *         field. To list snapshots for your account, use <a
     *         rence/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>
     *         in Amazon Elastic Compute Cloud API Reference.
     */
    public void setSnapshotId(String snapshotId) {
        this.snapshotId = snapshotId;
    }
    
    /**
     * The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as
     * the new stored volume. Specify this field if you want to create the
     * iSCSI cached volume from a snapshot; otherwise, do not include this
     * field. To list snapshots for your account, use <a
     * rence/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>
     * in Amazon Elastic Compute Cloud API Reference.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @param snapshotId The snapshot ID (e.g., "snap-1122aabb") of the snapshot to restore as
     *         the new stored volume. Specify this field if you want to create the
     *         iSCSI cached volume from a snapshot; otherwise, do not include this
     *         field. To list snapshots for your account, use <a
     *         rence/ApiReference-query-DescribeSnapshots.html">DescribeSnapshots</a>
     *         in Amazon Elastic Compute Cloud API Reference.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeRequest withSnapshotId(String snapshotId) {
        this.snapshotId = snapshotId;
        return this;
    }
    
    
    /**
     * The name of the iSCSI target used by initiators to connect to the
     * target and as a suffix for the target ARN. For example, specifying
     * <b>TargetName</b> as <i>myvolume</i> results in the target ARN of
     * 22223333:gateway/mygateway/target/iqn.1997-05.com.amazon:myvolume</i>.
     * The target name must be unique across all volumes of a gateway.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 200<br/>
     * <b>Pattern: </b>^[-\.;a-z0-9]+$<br/>
     *
     * @return The name of the iSCSI target used by initiators to connect to the
     *         target and as a suffix for the target ARN. For example, specifying
     *         <b>TargetName</b> as <i>myvolume</i> results in the target ARN of
     *         22223333:gateway/mygateway/target/iqn.1997-05.com.amazon:myvolume</i>.
     *         The target name must be unique across all volumes of a gateway.
     */
    public String getTargetName() {
        return targetName;
    }
    
    /**
     * The name of the iSCSI target used by initiators to connect to the
     * target and as a suffix for the target ARN. For example, specifying
     * <b>TargetName</b> as <i>myvolume</i> results in the target ARN of
     * 22223333:gateway/mygateway/target/iqn.1997-05.com.amazon:myvolume</i>.
     * The target name must be unique across all volumes of a gateway.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 200<br/>
     * <b>Pattern: </b>^[-\.;a-z0-9]+$<br/>
     *
     * @param targetName The name of the iSCSI target used by initiators to connect to the
     *         target and as a suffix for the target ARN. For example, specifying
     *         <b>TargetName</b> as <i>myvolume</i> results in the target ARN of
     *         22223333:gateway/mygateway/target/iqn.1997-05.com.amazon:myvolume</i>.
     *         The target name must be unique across all volumes of a gateway.
     */
    public void setTargetName(String targetName) {
        this.targetName = targetName;
    }
    
    /**
     * The name of the iSCSI target used by initiators to connect to the
     * target and as a suffix for the target ARN. For example, specifying
     * <b>TargetName</b> as <i>myvolume</i> results in the target ARN of
     * 22223333:gateway/mygateway/target/iqn.1997-05.com.amazon:myvolume</i>.
     * The target name must be unique across all volumes of a gateway.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 200<br/>
     * <b>Pattern: </b>^[-\.;a-z0-9]+$<br/>
     *
     * @param targetName The name of the iSCSI target used by initiators to connect to the
     *         target and as a suffix for the target ARN. For example, specifying
     *         <b>TargetName</b> as <i>myvolume</i> results in the target ARN of
     *         22223333:gateway/mygateway/target/iqn.1997-05.com.amazon:myvolume</i>.
     *         The target name must be unique across all volumes of a gateway.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeRequest withTargetName(String targetName) {
        this.targetName = targetName;
        return this;
    }
    
    
    /**
     * The network interface of the gateway on which to expose the iSCSI
     * target. Only IPv4 addresses are accepted. Use the
     * <a>DescribeGatewayInformation</a> operation to get a list of the
     * network interfaces available on the gateway.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z<br/>
     *
     * @return The network interface of the gateway on which to expose the iSCSI
     *         target. Only IPv4 addresses are accepted. Use the
     *         <a>DescribeGatewayInformation</a> operation to get a list of the
     *         network interfaces available on the gateway.
     */
    public String getNetworkInterfaceId() {
        return networkInterfaceId;
    }
    
    /**
     * The network interface of the gateway on which to expose the iSCSI
     * target. Only IPv4 addresses are accepted. Use the
     * <a>DescribeGatewayInformation</a> operation to get a list of the
     * network interfaces available on the gateway.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z<br/>
     *
     * @param networkInterfaceId The network interface of the gateway on which to expose the iSCSI
     *         target. Only IPv4 addresses are accepted. Use the
     *         <a>DescribeGatewayInformation</a> operation to get a list of the
     *         network interfaces available on the gateway.
     */
    public void setNetworkInterfaceId(String networkInterfaceId) {
        this.networkInterfaceId = networkInterfaceId;
    }
    
    /**
     * The network interface of the gateway on which to expose the iSCSI
     * target. Only IPv4 addresses are accepted. Use the
     * <a>DescribeGatewayInformation</a> operation to get a list of the
     * network interfaces available on the gateway.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\A(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}\z<br/>
     *
     * @param networkInterfaceId The network interface of the gateway on which to expose the iSCSI
     *         target. Only IPv4 addresses are accepted. Use the
     *         <a>DescribeGatewayInformation</a> operation to get a list of the
     *         network interfaces available on the gateway.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeRequest withNetworkInterfaceId(String networkInterfaceId) {
        this.networkInterfaceId = networkInterfaceId;
        return this;
    }
    
    
    /**
     * A unique identifying string for the cached volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>5 - 100<br/>
     *
     * @return A unique identifying string for the cached volume.
     */
    public String getClientToken() {
        return clientToken;
    }
    
    /**
     * A unique identifying string for the cached volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>5 - 100<br/>
     *
     * @param clientToken A unique identifying string for the cached volume.
     */
    public void setClientToken(String clientToken) {
        this.clientToken = clientToken;
    }
    
    /**
     * A unique identifying string for the cached volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>5 - 100<br/>
     *
     * @param clientToken A unique identifying string for the cached volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeRequest withClientToken(String clientToken) {
        this.clientToken = clientToken;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        if (volumeSizeInBytes != null) sb.append("VolumeSizeInBytes: " + volumeSizeInBytes + ", ");
        if (snapshotId != null) sb.append("SnapshotId: " + snapshotId + ", ");
        if (targetName != null) sb.append("TargetName: " + targetName + ", ");
        if (networkInterfaceId != null) sb.append("NetworkInterfaceId: " + networkInterfaceId + ", ");
        if (clientToken != null) sb.append("ClientToken: " + clientToken + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeSizeInBytes() == null) ? 0 : getVolumeSizeInBytes().hashCode()); 
        hashCode = prime * hashCode + ((getSnapshotId() == null) ? 0 : getSnapshotId().hashCode()); 
        hashCode = prime * hashCode + ((getTargetName() == null) ? 0 : getTargetName().hashCode()); 
        hashCode = prime * hashCode + ((getNetworkInterfaceId() == null) ? 0 : getNetworkInterfaceId().hashCode()); 
        hashCode = prime * hashCode + ((getClientToken() == null) ? 0 : getClientToken().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof CreateCachediSCSIVolumeRequest == false) return false;
        CreateCachediSCSIVolumeRequest other = (CreateCachediSCSIVolumeRequest)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        if (other.getVolumeSizeInBytes() == null ^ this.getVolumeSizeInBytes() == null) return false;
        if (other.getVolumeSizeInBytes() != null && other.getVolumeSizeInBytes().equals(this.getVolumeSizeInBytes()) == false) return false; 
        if (other.getSnapshotId() == null ^ this.getSnapshotId() == null) return false;
        if (other.getSnapshotId() != null && other.getSnapshotId().equals(this.getSnapshotId()) == false) return false; 
        if (other.getTargetName() == null ^ this.getTargetName() == null) return false;
        if (other.getTargetName() != null && other.getTargetName().equals(this.getTargetName()) == false) return false; 
        if (other.getNetworkInterfaceId() == null ^ this.getNetworkInterfaceId() == null) return false;
        if (other.getNetworkInterfaceId() != null && other.getNetworkInterfaceId().equals(this.getNetworkInterfaceId()) == false) return false; 
        if (other.getClientToken() == null ^ this.getClientToken() == null) return false;
        if (other.getClientToken() != null && other.getClientToken().equals(this.getClientToken()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/VolumeRecoveryPointInfo.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * Lists information about the recovery points of a cached volume.
 * </p>
 */
public class VolumeRecoveryPointInfo {

    /**
     * The Amazon Resource Name (ARN) of the volume associated with the
     * recovery point.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String volumeARN;

    /**
     * The size, in bytes, of the volume to which the recovery point is
     * associated.
     */
    private Long volumeSizeInBytes;

    /**
     * The size, in bytes, of the volume in use at the time of the recovery
     * point.
     */
    private Long volumeUsageInBytes;

    /**
     * The time of the recovery point. The format of the time is in the
     * ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     */
    private String volumeRecoveryPointTime;

    /**
     * The Amazon Resource Name (ARN) of the volume associated with the
     * recovery point.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the volume associated with the
     *         recovery point.
     */
    public String getVolumeARN() {
        return volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume associated with the
     * recovery point.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume associated with the
     *         recovery point.
     */
    public void setVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume associated with the
     * recovery point.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume associated with the
     *         recovery point.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public VolumeRecoveryPointInfo withVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
        return this;
    }
    
    
    /**
     * The size, in bytes, of the volume to which the recovery point is
     * associated.
     *
     * @return The size, in bytes, of the volume to which the recovery point is
     *         associated.
     */
    public Long getVolumeSizeInBytes() {
        return volumeSizeInBytes;
    }
    
    /**
     * The size, in bytes, of the volume to which the recovery point is
     * associated.
     *
     * @param volumeSizeInBytes The size, in bytes, of the volume to which the recovery point is
     *         associated.
     */
    public void setVolumeSizeInBytes(Long volumeSizeInBytes) {
        this.volumeSizeInBytes = volumeSizeInBytes;
    }
    
    /**
     * The size, in bytes, of the volume to which the recovery point is
     * associated.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeSizeInBytes The size, in bytes, of the volume to which the recovery point is
     *         associated.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public VolumeRecoveryPointInfo withVolumeSizeInBytes(Long volumeSizeInBytes) {
        this.volumeSizeInBytes = volumeSizeInBytes;
        return this;
    }
    
    
    /**
     * The size, in bytes, of the volume in use at the time of the recovery
     * point.
     *
     * @return The size, in bytes, of the volume in use at the time of the recovery
     *         point.
     */
    public Long getVolumeUsageInBytes() {
        return volumeUsageInBytes;
    }
    
    /**
     * The size, in bytes, of the volume in use at the time of the recovery
     * point.
     *
     * @param volumeUsageInBytes The size, in bytes, of the volume in use at the time of the recovery
     *         point.
     */
    public void setVolumeUsageInBytes(Long volumeUsageInBytes) {
        this.volumeUsageInBytes = volumeUsageInBytes;
    }
    
    /**
     * The size, in bytes, of the volume in use at the time of the recovery
     * point.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeUsageInBytes The size, in bytes, of the volume in use at the time of the recovery
     *         point.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public VolumeRecoveryPointInfo withVolumeUsageInBytes(Long volumeUsageInBytes) {
        this.volumeUsageInBytes = volumeUsageInBytes;
        return this;
    }
    
    
    /**
     * The time of the recovery point. The format of the time is in the
     * ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     *
     * @return The time of the recovery point. The format of the time is in the
     *         ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     */
    public String getVolumeRecoveryPointTime() {
        return volumeRecoveryPointTime;
    }
    
    /**
     * The time of the recovery point. The format of the time is in the
     * ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     *
     * @param volumeRecoveryPointTime The time of the recovery point. The format of the time is in the
     *         ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     */
    public void setVolumeRecoveryPointTime(String volumeRecoveryPointTime) {
        this.volumeRecoveryPointTime = volumeRecoveryPointTime;
    }
    
    /**
     * The time of the recovery point. The format of the time is in the
     * ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeRecoveryPointTime The time of the recovery point. The format of the time is in the
     *         ISO8601 extended YYYY-MM-DD'T'HH:MM:SS'Z' format.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public VolumeRecoveryPointInfo withVolumeRecoveryPointTime(String volumeRecoveryPointTime) {
        this.volumeRecoveryPointTime = volumeRecoveryPointTime;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (volumeARN != null) sb.append("VolumeARN: " + volumeARN + ", ");
        if (volumeSizeInBytes != null) sb.append("VolumeSizeInBytes: " + volumeSizeInBytes + ", ");
        if (volumeUsageInBytes != null) sb.append("VolumeUsageInBytes: " + volumeUsageInBytes + ", ");
        if (volumeRecoveryPointTime != null) sb.append("VolumeRecoveryPointTime: " + volumeRecoveryPointTime + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getVolumeARN() == null) ? 0 : getVolumeARN().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeSizeInBytes() == null) ? 0 : getVolumeSizeInBytes().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeUsageInBytes() == null) ? 0 : getVolumeUsageInBytes().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeRecoveryPointTime() == null) ? 0 : getVolumeRecoveryPointTime().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof VolumeRecoveryPointInfo == false) return false;
        VolumeRecoveryPointInfo other = (VolumeRecoveryPointInfo)obj;
        
        if (other.getVolumeARN() == null ^ this.getVolumeARN() == null) return false;
        if (other.getVolumeARN() != null && other.getVolumeARN().equals(this.getVolumeARN()) == false) return false; 
        if (other.getVolumeSizeInBytes() == null ^ this.getVolumeSizeInBytes() == null) return false;
        if (other.getVolumeSizeInBytes() != null && other.getVolumeSizeInBytes().equals(this.getVolumeSizeInBytes()) == false) return false; 
        if (other.getVolumeUsageInBytes() == null ^ this.getVolumeUsageInBytes() == null) return false;
        if (other.getVolumeUsageInBytes() != null && other.getVolumeUsageInBytes().equals(this.getVolumeUsageInBytes()) == false) return false; 
        if (other.getVolumeRecoveryPointTime() == null ^ this.getVolumeRecoveryPointTime() == null) return false;
        if (other.getVolumeRecoveryPointTime() != null && other.getVolumeRecoveryPointTime().equals(this.getVolumeRecoveryPointTime()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeUploadBufferRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#describeUploadBuffer(DescribeUploadBufferRequest) DescribeUploadBuffer operation}.
 * <p>
 * This operation returns information about the upload buffer of a gateway. This operation is supported for both the gateway-stored and gateway-cached
 * volume architectures.
 * </p>
 * <p>
 * The response includes disk IDs that are configured as upload buffer space, and it includes the amount of upload buffer space allocated and used.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#describeUploadBuffer(DescribeUploadBufferRequest)
 */
public class DescribeUploadBufferRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeUploadBufferRequest withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DescribeUploadBufferRequest == false) return false;
        DescribeUploadBufferRequest other = (DescribeUploadBufferRequest)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/AddCacheRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#addCache(AddCacheRequest) AddCache operation}.
 * <p>
 * This operation configures one or more gateway local disks as cache for a cached-volume gateway. This operation is supported only for the
 * gateway-cached volume architecture (see <a href="http://docs.amazonwebservices.com/storagegateway/latest/userguide/StorageGatewayConcepts.html">
 * Storage Gateway Concepts </a> ).
 * </p>
 * <p>
 * In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to add cache, and one or more disk IDs that you want to configure
 * as cache.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#addCache(AddCacheRequest)
 */
public class AddCacheRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
     * operation to return a list of gateways for your account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * An array of strings that identify disks that are to be configured as
     * cache. Each string in the array must be minimum length of 1 and
     * maximum length of 300. You can get the disk IDs from the
     * ListLocalDisks API.
     */
    private java.util.List<String> diskIds;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
     * operation to return a list of gateways for your account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
     *         operation to return a list of gateways for your account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
     * operation to return a list of gateways for your account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
     *         operation to return a list of gateways for your account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
     * operation to return a list of gateways for your account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the ListGateways
     *         operation to return a list of gateways for your account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddCacheRequest withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * An array of strings that identify disks that are to be configured as
     * cache. Each string in the array must be minimum length of 1 and
     * maximum length of 300. You can get the disk IDs from the
     * ListLocalDisks API.
     *
     * @return An array of strings that identify disks that are to be configured as
     *         cache. Each string in the array must be minimum length of 1 and
     *         maximum length of 300. You can get the disk IDs from the
     *         ListLocalDisks API.
     */
    public java.util.List<String> getDiskIds() {
        
        if (diskIds == null) {
            diskIds = new java.util.ArrayList<String>();
        }
        return diskIds;
    }
    
    /**
     * An array of strings that identify disks that are to be configured as
     * cache. Each string in the array must be minimum length of 1 and
     * maximum length of 300. You can get the disk IDs from the
     * ListLocalDisks API.
     *
     * @param diskIds An array of strings that identify disks that are to be configured as
     *         cache. Each string in the array must be minimum length of 1 and
     *         maximum length of 300. You can get the disk IDs from the
     *         ListLocalDisks API.
     */
    public void setDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
            return;
        }

        java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
        diskIdsCopy.addAll(diskIds);
        this.diskIds = diskIdsCopy;
    }
    
    /**
     * An array of strings that identify disks that are to be configured as
     * cache. Each string in the array must be minimum length of 1 and
     * maximum length of 300. You can get the disk IDs from the
     * ListLocalDisks API.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of strings that identify disks that are to be configured as
     *         cache. Each string in the array must be minimum length of 1 and
     *         maximum length of 300. You can get the disk IDs from the
     *         ListLocalDisks API.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddCacheRequest withDiskIds(String... diskIds) {
        if (getDiskIds() == null) setDiskIds(new java.util.ArrayList<String>(diskIds.length));
        for (String value : diskIds) {
            getDiskIds().add(value);
        }
        return this;
    }
    
    /**
     * An array of strings that identify disks that are to be configured as
     * cache. Each string in the array must be minimum length of 1 and
     * maximum length of 300. You can get the disk IDs from the
     * ListLocalDisks API.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of strings that identify disks that are to be configured as
     *         cache. Each string in the array must be minimum length of 1 and
     *         maximum length of 300. You can get the disk IDs from the
     *         ListLocalDisks API.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddCacheRequest withDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
        } else {
            java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
            diskIdsCopy.addAll(diskIds);
            this.diskIds = diskIdsCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        if (diskIds != null) sb.append("DiskIds: " + diskIds + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        hashCode = prime * hashCode + ((getDiskIds() == null) ? 0 : getDiskIds().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof AddCacheRequest == false) return false;
        AddCacheRequest other = (AddCacheRequest)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        if (other.getDiskIds() == null ^ this.getDiskIds() == null) return false;
        if (other.getDiskIds() != null && other.getDiskIds().equals(this.getDiskIds()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/ListVolumeRecoveryPointsResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * A JSON object containing the following fields:
 * </p>
 * 
 * <ul>
 * <li> ListVolumeRecoveryPointsOutput$GatewayARN </li>
 * <li> ListVolumeRecoveryPointsOutput$VolumeRecoveryPointInfos </li>
 * 
 * </ul>
 */
public class ListVolumeRecoveryPointsResult {

    /**
     * The Amazon Resource Name (ARN) of the activated gateway whose local
     * disk information is returned.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     * describes a recovery point. If no recovery points are defined for the
     * volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     */
    private java.util.List<VolumeRecoveryPointInfo> volumeRecoveryPointInfos;

    /**
     * The Amazon Resource Name (ARN) of the activated gateway whose local
     * disk information is returned.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the activated gateway whose local
     *         disk information is returned.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the activated gateway whose local
     * disk information is returned.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the activated gateway whose local
     *         disk information is returned.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the activated gateway whose local
     * disk information is returned.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the activated gateway whose local
     *         disk information is returned.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public ListVolumeRecoveryPointsResult withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     * describes a recovery point. If no recovery points are defined for the
     * volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     *
     * @return An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     *         describes a recovery point. If no recovery points are defined for the
     *         volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     */
    public java.util.List<VolumeRecoveryPointInfo> getVolumeRecoveryPointInfos() {
        
        if (volumeRecoveryPointInfos == null) {
            volumeRecoveryPointInfos = new java.util.ArrayList<VolumeRecoveryPointInfo>();
        }
        return volumeRecoveryPointInfos;
    }
    
    /**
     * An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     * describes a recovery point. If no recovery points are defined for the
     * volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     *
     * @param volumeRecoveryPointInfos An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     *         describes a recovery point. If no recovery points are defined for the
     *         volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     */
    public void setVolumeRecoveryPointInfos(java.util.Collection<VolumeRecoveryPointInfo> volumeRecoveryPointInfos) {
        if (volumeRecoveryPointInfos == null) {
            this.volumeRecoveryPointInfos = null;
            return;
        }

        java.util.List<VolumeRecoveryPointInfo> volumeRecoveryPointInfosCopy = new java.util.ArrayList<VolumeRecoveryPointInfo>(volumeRecoveryPointInfos.size());
        volumeRecoveryPointInfosCopy.addAll(volumeRecoveryPointInfos);
        this.volumeRecoveryPointInfos = volumeRecoveryPointInfosCopy;
    }
    
    /**
     * An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     * describes a recovery point. If no recovery points are defined for the
     * volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeRecoveryPointInfos An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     *         describes a recovery point. If no recovery points are defined for the
     *         volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public ListVolumeRecoveryPointsResult withVolumeRecoveryPointInfos(VolumeRecoveryPointInfo... volumeRecoveryPointInfos) {
        if (getVolumeRecoveryPointInfos() == null) setVolumeRecoveryPointInfos(new java.util.ArrayList<VolumeRecoveryPointInfo>(volumeRecoveryPointInfos.length));
        for (VolumeRecoveryPointInfo value : volumeRecoveryPointInfos) {
            getVolumeRecoveryPointInfos().add(value);
        }
        return this;
    }
    
    /**
     * An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     * describes a recovery point. If no recovery points are defined for the
     * volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeRecoveryPointInfos An array of <a>VolumeRecoveryPointInfo</a> objects, where each object
     *         describes a recovery point. If no recovery points are defined for the
     *         volume, then <i>VolumeRecoveryPointInfos</i> is an empty array "[]"
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public ListVolumeRecoveryPointsResult withVolumeRecoveryPointInfos(java.util.Collection<VolumeRecoveryPointInfo> volumeRecoveryPointInfos) {
        if (volumeRecoveryPointInfos == null) {
            this.volumeRecoveryPointInfos = null;
        } else {
            java.util.List<VolumeRecoveryPointInfo> volumeRecoveryPointInfosCopy = new java.util.ArrayList<VolumeRecoveryPointInfo>(volumeRecoveryPointInfos.size());
            volumeRecoveryPointInfosCopy.addAll(volumeRecoveryPointInfos);
            this.volumeRecoveryPointInfos = volumeRecoveryPointInfosCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        if (volumeRecoveryPointInfos != null) sb.append("VolumeRecoveryPointInfos: " + volumeRecoveryPointInfos + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeRecoveryPointInfos() == null) ? 0 : getVolumeRecoveryPointInfos().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof ListVolumeRecoveryPointsResult == false) return false;
        ListVolumeRecoveryPointsResult other = (ListVolumeRecoveryPointsResult)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        if (other.getVolumeRecoveryPointInfos() == null ^ this.getVolumeRecoveryPointInfos() == null) return false;
        if (other.getVolumeRecoveryPointInfos() != null && other.getVolumeRecoveryPointInfos().equals(this.getVolumeRecoveryPointInfos()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeCachediSCSIVolumesResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * A JSON object containing the following fields:
 * </p>
 * 
 * <ul>
 * <li> DescribeCachediSCSIVolumesOutput$CachediSCSIVolumes </li>
 * 
 * </ul>
 */
public class DescribeCachediSCSIVolumesResult {

    /**
     * An array of <a>CachediSCSIVolume</a> objects where each object
     * contains metadata about one cached volume.
     */
    private java.util.List<CachediSCSIVolume> cachediSCSIVolumes;

    /**
     * An array of <a>CachediSCSIVolume</a> objects where each object
     * contains metadata about one cached volume.
     *
     * @return An array of <a>CachediSCSIVolume</a> objects where each object
     *         contains metadata about one cached volume.
     */
    public java.util.List<CachediSCSIVolume> getCachediSCSIVolumes() {
        
        if (cachediSCSIVolumes == null) {
            cachediSCSIVolumes = new java.util.ArrayList<CachediSCSIVolume>();
        }
        return cachediSCSIVolumes;
    }
    
    /**
     * An array of <a>CachediSCSIVolume</a> objects where each object
     * contains metadata about one cached volume.
     *
     * @param cachediSCSIVolumes An array of <a>CachediSCSIVolume</a> objects where each object
     *         contains metadata about one cached volume.
     */
    public void setCachediSCSIVolumes(java.util.Collection<CachediSCSIVolume> cachediSCSIVolumes) {
        if (cachediSCSIVolumes == null) {
            this.cachediSCSIVolumes = null;
            return;
        }

        java.util.List<CachediSCSIVolume> cachediSCSIVolumesCopy = new java.util.ArrayList<CachediSCSIVolume>(cachediSCSIVolumes.size());
        cachediSCSIVolumesCopy.addAll(cachediSCSIVolumes);
        this.cachediSCSIVolumes = cachediSCSIVolumesCopy;
    }
    
    /**
     * An array of <a>CachediSCSIVolume</a> objects where each object
     * contains metadata about one cached volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cachediSCSIVolumes An array of <a>CachediSCSIVolume</a> objects where each object
     *         contains metadata about one cached volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCachediSCSIVolumesResult withCachediSCSIVolumes(CachediSCSIVolume... cachediSCSIVolumes) {
        if (getCachediSCSIVolumes() == null) setCachediSCSIVolumes(new java.util.ArrayList<CachediSCSIVolume>(cachediSCSIVolumes.length));
        for (CachediSCSIVolume value : cachediSCSIVolumes) {
            getCachediSCSIVolumes().add(value);
        }
        return this;
    }
    
    /**
     * An array of <a>CachediSCSIVolume</a> objects where each object
     * contains metadata about one cached volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cachediSCSIVolumes An array of <a>CachediSCSIVolume</a> objects where each object
     *         contains metadata about one cached volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCachediSCSIVolumesResult withCachediSCSIVolumes(java.util.Collection<CachediSCSIVolume> cachediSCSIVolumes) {
        if (cachediSCSIVolumes == null) {
            this.cachediSCSIVolumes = null;
        } else {
            java.util.List<CachediSCSIVolume> cachediSCSIVolumesCopy = new java.util.ArrayList<CachediSCSIVolume>(cachediSCSIVolumes.size());
            cachediSCSIVolumesCopy.addAll(cachediSCSIVolumes);
            this.cachediSCSIVolumes = cachediSCSIVolumesCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (cachediSCSIVolumes != null) sb.append("CachediSCSIVolumes: " + cachediSCSIVolumes + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getCachediSCSIVolumes() == null) ? 0 : getCachediSCSIVolumes().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DescribeCachediSCSIVolumesResult == false) return false;
        DescribeCachediSCSIVolumesResult other = (DescribeCachediSCSIVolumesResult)obj;
        
        if (other.getCachediSCSIVolumes() == null ^ this.getCachediSCSIVolumes() == null) return false;
        if (other.getCachediSCSIVolumes() != null && other.getCachediSCSIVolumes().equals(this.getCachediSCSIVolumes()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeUploadBufferResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * A JSON object containing the following fields:
 * </p>
 * 
 * <ul>
 * <li> DescribeUploadBufferOutput$DiskIds </li>
 * <li> DescribeUploadBufferOutput$GatewayARN </li>
 * <li> DescribeUploadBufferOutput$UploadBufferUsedInBytes </li>
 * <li> DescribeUploadBufferOutput$UploadBufferAllocatedInBytes </li>
 * 
 * </ul>
 */
public class DescribeUploadBufferResult {

    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * <a>ListGateways</a> operations to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * An array of the gateway's local disk IDs that are configured as
     * working storage. Each local disk ID is specified as a string (minimum
     * length of 1 and maximum length of 300). If no local disks are
     * configured as working storage, then the <code>DiskIds</code> array is
     * empty.
     */
    private java.util.List<String> diskIds;

    /**
     * The total upload buffer in bytes in use by the gateway. If no upload
     * buffer is configured for the gateway, this field returns 0.
     */
    private Long uploadBufferUsedInBytes;

    /**
     * The total upload buffer in bytes allocated for the gateway. If no
     * upload buffer is configured for the gateway, this field returns 0.
     */
    private Long uploadBufferAllocatedInBytes;

    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * <a>ListGateways</a> operations to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return In response, AWS Storage Gateway returns the ARN of the activated
     *         gateway. If you don't remember the ARN of a gateway, you can use the
     *         <a>ListGateways</a> operations to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * <a>ListGateways</a> operations to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN In response, AWS Storage Gateway returns the ARN of the activated
     *         gateway. If you don't remember the ARN of a gateway, you can use the
     *         <a>ListGateways</a> operations to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * <a>ListGateways</a> operations to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN In response, AWS Storage Gateway returns the ARN of the activated
     *         gateway. If you don't remember the ARN of a gateway, you can use the
     *         <a>ListGateways</a> operations to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeUploadBufferResult withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * An array of the gateway's local disk IDs that are configured as
     * working storage. Each local disk ID is specified as a string (minimum
     * length of 1 and maximum length of 300). If no local disks are
     * configured as working storage, then the <code>DiskIds</code> array is
     * empty.
     *
     * @return An array of the gateway's local disk IDs that are configured as
     *         working storage. Each local disk ID is specified as a string (minimum
     *         length of 1 and maximum length of 300). If no local disks are
     *         configured as working storage, then the <code>DiskIds</code> array is
     *         empty.
     */
    public java.util.List<String> getDiskIds() {
        
        if (diskIds == null) {
            diskIds = new java.util.ArrayList<String>();
        }
        return diskIds;
    }
    
    /**
     * An array of the gateway's local disk IDs that are configured as
     * working storage. Each local disk ID is specified as a string (minimum
     * length of 1 and maximum length of 300). If no local disks are
     * configured as working storage, then the <code>DiskIds</code> array is
     * empty.
     *
     * @param diskIds An array of the gateway's local disk IDs that are configured as
     *         working storage. Each local disk ID is specified as a string (minimum
     *         length of 1 and maximum length of 300). If no local disks are
     *         configured as working storage, then the <code>DiskIds</code> array is
     *         empty.
     */
    public void setDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
            return;
        }

        java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
        diskIdsCopy.addAll(diskIds);
        this.diskIds = diskIdsCopy;
    }
    
    /**
     * An array of the gateway's local disk IDs that are configured as
     * working storage. Each local disk ID is specified as a string (minimum
     * length of 1 and maximum length of 300). If no local disks are
     * configured as working storage, then the <code>DiskIds</code> array is
     * empty.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of the gateway's local disk IDs that are configured as
     *         working storage. Each local disk ID is specified as a string (minimum
     *         length of 1 and maximum length of 300). If no local disks are
     *         configured as working storage, then the <code>DiskIds</code> array is
     *         empty.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeUploadBufferResult withDiskIds(String... diskIds) {
        if (getDiskIds() == null) setDiskIds(new java.util.ArrayList<String>(diskIds.length));
        for (String value : diskIds) {
            getDiskIds().add(value);
        }
        return this;
    }
    
    /**
     * An array of the gateway's local disk IDs that are configured as
     * working storage. Each local disk ID is specified as a string (minimum
     * length of 1 and maximum length of 300). If no local disks are
     * configured as working storage, then the <code>DiskIds</code> array is
     * empty.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of the gateway's local disk IDs that are configured as
     *         working storage. Each local disk ID is specified as a string (minimum
     *         length of 1 and maximum length of 300). If no local disks are
     *         configured as working storage, then the <code>DiskIds</code> array is
     *         empty.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeUploadBufferResult withDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
        } else {
            java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
            diskIdsCopy.addAll(diskIds);
            this.diskIds = diskIdsCopy;
        }

        return this;
    }
    
    /**
     * The total upload buffer in bytes in use by the gateway. If no upload
     * buffer is configured for the gateway, this field returns 0.
     *
     * @return The total upload buffer in bytes in use by the gateway. If no upload
     *         buffer is configured for the gateway, this field returns 0.
     */
    public Long getUploadBufferUsedInBytes() {
        return uploadBufferUsedInBytes;
    }
    
    /**
     * The total upload buffer in bytes in use by the gateway. If no upload
     * buffer is configured for the gateway, this field returns 0.
     *
     * @param uploadBufferUsedInBytes The total upload buffer in bytes in use by the gateway. If no upload
     *         buffer is configured for the gateway, this field returns 0.
     */
    public void setUploadBufferUsedInBytes(Long uploadBufferUsedInBytes) {
        this.uploadBufferUsedInBytes = uploadBufferUsedInBytes;
    }
    
    /**
     * The total upload buffer in bytes in use by the gateway. If no upload
     * buffer is configured for the gateway, this field returns 0.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param uploadBufferUsedInBytes The total upload buffer in bytes in use by the gateway. If no upload
     *         buffer is configured for the gateway, this field returns 0.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeUploadBufferResult withUploadBufferUsedInBytes(Long uploadBufferUsedInBytes) {
        this.uploadBufferUsedInBytes = uploadBufferUsedInBytes;
        return this;
    }
    
    
    /**
     * The total upload buffer in bytes allocated for the gateway. If no
     * upload buffer is configured for the gateway, this field returns 0.
     *
     * @return The total upload buffer in bytes allocated for the gateway. If no
     *         upload buffer is configured for the gateway, this field returns 0.
     */
    public Long getUploadBufferAllocatedInBytes() {
        return uploadBufferAllocatedInBytes;
    }
    
    /**
     * The total upload buffer in bytes allocated for the gateway. If no
     * upload buffer is configured for the gateway, this field returns 0.
     *
     * @param uploadBufferAllocatedInBytes The total upload buffer in bytes allocated for the gateway. If no
     *         upload buffer is configured for the gateway, this field returns 0.
     */
    public void setUploadBufferAllocatedInBytes(Long uploadBufferAllocatedInBytes) {
        this.uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytes;
    }
    
    /**
     * The total upload buffer in bytes allocated for the gateway. If no
     * upload buffer is configured for the gateway, this field returns 0.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param uploadBufferAllocatedInBytes The total upload buffer in bytes allocated for the gateway. If no
     *         upload buffer is configured for the gateway, this field returns 0.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeUploadBufferResult withUploadBufferAllocatedInBytes(Long uploadBufferAllocatedInBytes) {
        this.uploadBufferAllocatedInBytes = uploadBufferAllocatedInBytes;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        if (diskIds != null) sb.append("DiskIds: " + diskIds + ", ");
        if (uploadBufferUsedInBytes != null) sb.append("UploadBufferUsedInBytes: " + uploadBufferUsedInBytes + ", ");
        if (uploadBufferAllocatedInBytes != null) sb.append("UploadBufferAllocatedInBytes: " + uploadBufferAllocatedInBytes + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        hashCode = prime * hashCode + ((getDiskIds() == null) ? 0 : getDiskIds().hashCode()); 
        hashCode = prime * hashCode + ((getUploadBufferUsedInBytes() == null) ? 0 : getUploadBufferUsedInBytes().hashCode()); 
        hashCode = prime * hashCode + ((getUploadBufferAllocatedInBytes() == null) ? 0 : getUploadBufferAllocatedInBytes().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DescribeUploadBufferResult == false) return false;
        DescribeUploadBufferResult other = (DescribeUploadBufferResult)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        if (other.getDiskIds() == null ^ this.getDiskIds() == null) return false;
        if (other.getDiskIds() != null && other.getDiskIds().equals(this.getDiskIds()) == false) return false; 
        if (other.getUploadBufferUsedInBytes() == null ^ this.getUploadBufferUsedInBytes() == null) return false;
        if (other.getUploadBufferUsedInBytes() != null && other.getUploadBufferUsedInBytes().equals(this.getUploadBufferUsedInBytes()) == false) return false; 
        if (other.getUploadBufferAllocatedInBytes() == null ^ this.getUploadBufferAllocatedInBytes() == null) return false;
        if (other.getUploadBufferAllocatedInBytes() != null && other.getUploadBufferAllocatedInBytes().equals(this.getUploadBufferAllocatedInBytes()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/ListVolumeRecoveryPointsRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#listVolumeRecoveryPoints(ListVolumeRecoveryPointsRequest) ListVolumeRecoveryPoints operation}.
 * <p>
 * This operation lists the recovery points for a specified gateway. This operation is supported only for the gateway-cached volume architecture.
 * </p>
 * <p>
 * Each gateway-cached volume has one recovery point. A volume recovery point is a point in time at which all data of the volume is consistent and from
 * which you can create a snapshot. To create a snapshot from a volume recovery point use the CreateSnapshotFromVolumeRecoveryPoint operation.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#listVolumeRecoveryPoints(ListVolumeRecoveryPointsRequest)
 */
public class ListVolumeRecoveryPointsRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public ListVolumeRecoveryPointsRequest withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof ListVolumeRecoveryPointsRequest == false) return false;
        ListVolumeRecoveryPointsRequest other = (ListVolumeRecoveryPointsRequest)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/CreateSnapshotFromVolumeRecoveryPointRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#createSnapshotFromVolumeRecoveryPoint(CreateSnapshotFromVolumeRecoveryPointRequest) CreateSnapshotFromVolumeRecoveryPoint operation}.
 * <p>
 * This operation initiates a snapshot of a gateway from a volume recovery point. This operation is supported only for the gateway-cached volume
 * architecture (see StorageGatewayConcepts).
 * </p>
 * <p>
 * A volume recovery point is a point in time at which all data of the volume is consistent and from which you can create a snapshot. To get a list of
 * volume recovery point for gateway-cached volumes, use ListVolumeRecoveryPoints.
 * </p>
 * <p>
 * In the <code>CreateSnapshotFromVolumeRecoveryPoint</code> request, you identify the volume by providing its Amazon Resource Name (ARN). You must also
 * provide a description for the snapshot. When AWS Storage Gateway takes a snapshot of the specified volume, the snapshot and its description appear in
 * the AWS Storage Gateway console. In response, AWS Storage Gateway returns you a snapshot ID. You can use this snapshot ID to check the snapshot
 * progress or later use it when you want to create a volume from a snapshot.
 * </p>
 * <p>
 * <b>NOTE:</b> To list or delete a snapshot, you must use the Amazon EC2 API. For more information, go to DeleteSnapshot and DescribeSnapshots in Amazon
 * Elastic Compute Cloud API Reference.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#createSnapshotFromVolumeRecoveryPoint(CreateSnapshotFromVolumeRecoveryPointRequest)
 */
public class CreateSnapshotFromVolumeRecoveryPointRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String volumeARN;

    /**
     * A textual description of the snapshot that appears in the Amazon EC2
     * console, Elastic Block Store snapshots panel in the <b>Description</b>
     * field, and in the AWS Storage Gateway snapshot <b>Details</b> pane,
     * <b>Description</b> field. <p><i>Length</i>: Minimum length of 1.
     * Maximum length of 255.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 255<br/>
     */
    private String snapshotDescription;

    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the volume. Use the
     *         <a>ListVolumes</a> operation to return a list of gateway volumes.
     */
    public String getVolumeARN() {
        return volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume. Use the
     *         <a>ListVolumes</a> operation to return a list of gateway volumes.
     */
    public void setVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume. Use the
     *         <a>ListVolumes</a> operation to return a list of gateway volumes.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateSnapshotFromVolumeRecoveryPointRequest withVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
        return this;
    }
    
    
    /**
     * A textual description of the snapshot that appears in the Amazon EC2
     * console, Elastic Block Store snapshots panel in the <b>Description</b>
     * field, and in the AWS Storage Gateway snapshot <b>Details</b> pane,
     * <b>Description</b> field. <p><i>Length</i>: Minimum length of 1.
     * Maximum length of 255.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 255<br/>
     *
     * @return A textual description of the snapshot that appears in the Amazon EC2
     *         console, Elastic Block Store snapshots panel in the <b>Description</b>
     *         field, and in the AWS Storage Gateway snapshot <b>Details</b> pane,
     *         <b>Description</b> field. <p><i>Length</i>: Minimum length of 1.
     *         Maximum length of 255.
     */
    public String getSnapshotDescription() {
        return snapshotDescription;
    }
    
    /**
     * A textual description of the snapshot that appears in the Amazon EC2
     * console, Elastic Block Store snapshots panel in the <b>Description</b>
     * field, and in the AWS Storage Gateway snapshot <b>Details</b> pane,
     * <b>Description</b> field. <p><i>Length</i>: Minimum length of 1.
     * Maximum length of 255.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 255<br/>
     *
     * @param snapshotDescription A textual description of the snapshot that appears in the Amazon EC2
     *         console, Elastic Block Store snapshots panel in the <b>Description</b>
     *         field, and in the AWS Storage Gateway snapshot <b>Details</b> pane,
     *         <b>Description</b> field. <p><i>Length</i>: Minimum length of 1.
     *         Maximum length of 255.
     */
    public void setSnapshotDescription(String snapshotDescription) {
        this.snapshotDescription = snapshotDescription;
    }
    
    /**
     * A textual description of the snapshot that appears in the Amazon EC2
     * console, Elastic Block Store snapshots panel in the <b>Description</b>
     * field, and in the AWS Storage Gateway snapshot <b>Details</b> pane,
     * <b>Description</b> field. <p><i>Length</i>: Minimum length of 1.
     * Maximum length of 255.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>1 - 255<br/>
     *
     * @param snapshotDescription A textual description of the snapshot that appears in the Amazon EC2
     *         console, Elastic Block Store snapshots panel in the <b>Description</b>
     *         field, and in the AWS Storage Gateway snapshot <b>Details</b> pane,
     *         <b>Description</b> field. <p><i>Length</i>: Minimum length of 1.
     *         Maximum length of 255.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateSnapshotFromVolumeRecoveryPointRequest withSnapshotDescription(String snapshotDescription) {
        this.snapshotDescription = snapshotDescription;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (volumeARN != null) sb.append("VolumeARN: " + volumeARN + ", ");
        if (snapshotDescription != null) sb.append("SnapshotDescription: " + snapshotDescription + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getVolumeARN() == null) ? 0 : getVolumeARN().hashCode()); 
        hashCode = prime * hashCode + ((getSnapshotDescription() == null) ? 0 : getSnapshotDescription().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof CreateSnapshotFromVolumeRecoveryPointRequest == false) return false;
        CreateSnapshotFromVolumeRecoveryPointRequest other = (CreateSnapshotFromVolumeRecoveryPointRequest)obj;
        
        if (other.getVolumeARN() == null ^ this.getVolumeARN() == null) return false;
        if (other.getVolumeARN() != null && other.getVolumeARN().equals(this.getVolumeARN()) == false) return false; 
        if (other.getSnapshotDescription() == null ^ this.getSnapshotDescription() == null) return false;
        if (other.getSnapshotDescription() != null && other.getSnapshotDescription().equals(this.getSnapshotDescription()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/CachediSCSIVolume.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * Describes a cached storage volume.
 * </p>
 */
public class CachediSCSIVolume {

    /**
     * The Amazon Resource Name (ARN) of the storage volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String volumeARN;

    /**
     * The unique identifier of the storage volume, e.g. vol-1122AABB.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>12 - 30<br/>
     */
    private String volumeId;

    /**
     * A value describing the type of volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>STORED iSCSI, CACHED iSCSI
     */
    private String volumeType;

    /**
     * A value that indicates the state of the volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>CREATING, AVAILABLE, RESTORING, BOOTSTRAPPING, IRRECOVERABLE, PASS THROUGH, RESTORE AND PASS THROUGH, DELETED, WORKING STORAGE NOT CONFIGURED, UPLOAD BUFFER NOT CONFIGURED
     */
    private String volumeStatus;

    /**
     * The size of the volume in bytes that was specified in the
     * <a>API_CreateCachediSCSIVolume</a> operation.
     */
    private Long volumeSizeInBytes;

    /**
     * The percentage complete if the volume is restoring or bootstrapping
     * that represents the percent of data transferred. This field does not
     * appear in the response if the stored volume is not restoring or
     * bootstrapping.
     */
    private Double volumeProgress;

    /**
     * If the cached volume was created from a snapshot, this field contains
     * the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     */
    private String sourceSnapshotId;

    /**
     * Lists iSCSI information about a volume.
     */
    private VolumeiSCSIAttributes volumeiSCSIAttributes;

    /**
     * The Amazon Resource Name (ARN) of the storage volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the storage volume.
     */
    public String getVolumeARN() {
        return volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the storage volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the storage volume.
     */
    public void setVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the storage volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the storage volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CachediSCSIVolume withVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
        return this;
    }
    
    
    /**
     * The unique identifier of the storage volume, e.g. vol-1122AABB.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>12 - 30<br/>
     *
     * @return The unique identifier of the storage volume, e.g. vol-1122AABB.
     */
    public String getVolumeId() {
        return volumeId;
    }
    
    /**
     * The unique identifier of the storage volume, e.g. vol-1122AABB.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>12 - 30<br/>
     *
     * @param volumeId The unique identifier of the storage volume, e.g. vol-1122AABB.
     */
    public void setVolumeId(String volumeId) {
        this.volumeId = volumeId;
    }
    
    /**
     * The unique identifier of the storage volume, e.g. vol-1122AABB.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>12 - 30<br/>
     *
     * @param volumeId The unique identifier of the storage volume, e.g. vol-1122AABB.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CachediSCSIVolume withVolumeId(String volumeId) {
        this.volumeId = volumeId;
        return this;
    }
    
    
    /**
     * A value describing the type of volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>STORED iSCSI, CACHED iSCSI
     *
     * @return A value describing the type of volume.
     *
     * @see VolumeType
     */
    public String getVolumeType() {
        return volumeType;
    }
    
    /**
     * A value describing the type of volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>STORED iSCSI, CACHED iSCSI
     *
     * @param volumeType A value describing the type of volume.
     *
     * @see VolumeType
     */
    public void setVolumeType(String volumeType) {
        this.volumeType = volumeType;
    }
    
    /**
     * A value describing the type of volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>STORED iSCSI, CACHED iSCSI
     *
     * @param volumeType A value describing the type of volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     *
     * @see VolumeType
     */
    public CachediSCSIVolume withVolumeType(String volumeType) {
        this.volumeType = volumeType;
        return this;
    }
    
    
    /**
     * A value describing the type of volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>STORED iSCSI, CACHED iSCSI
     *
     * @param volumeType A value describing the type of volume.
     *
     * @see VolumeType
     */
    public void setVolumeType(VolumeType volumeType) {
        this.volumeType = volumeType.toString();
    }
    
    /**
     * A value describing the type of volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>STORED iSCSI, CACHED iSCSI
     *
     * @param volumeType A value describing the type of volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     *
     * @see VolumeType
     */
    public CachediSCSIVolume withVolumeType(VolumeType volumeType) {
        this.volumeType = volumeType.toString();
        return this;
    }
    
    /**
     * A value that indicates the state of the volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>CREATING, AVAILABLE, RESTORING, BOOTSTRAPPING, IRRECOVERABLE, PASS THROUGH, RESTORE AND PASS THROUGH, DELETED, WORKING STORAGE NOT CONFIGURED, UPLOAD BUFFER NOT CONFIGURED
     *
     * @return A value that indicates the state of the volume.
     *
     * @see VolumeStatus
     */
    public String getVolumeStatus() {
        return volumeStatus;
    }
    
    /**
     * A value that indicates the state of the volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>CREATING, AVAILABLE, RESTORING, BOOTSTRAPPING, IRRECOVERABLE, PASS THROUGH, RESTORE AND PASS THROUGH, DELETED, WORKING STORAGE NOT CONFIGURED, UPLOAD BUFFER NOT CONFIGURED
     *
     * @param volumeStatus A value that indicates the state of the volume.
     *
     * @see VolumeStatus
     */
    public void setVolumeStatus(String volumeStatus) {
        this.volumeStatus = volumeStatus;
    }
    
    /**
     * A value that indicates the state of the volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>CREATING, AVAILABLE, RESTORING, BOOTSTRAPPING, IRRECOVERABLE, PASS THROUGH, RESTORE AND PASS THROUGH, DELETED, WORKING STORAGE NOT CONFIGURED, UPLOAD BUFFER NOT CONFIGURED
     *
     * @param volumeStatus A value that indicates the state of the volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     *
     * @see VolumeStatus
     */
    public CachediSCSIVolume withVolumeStatus(String volumeStatus) {
        this.volumeStatus = volumeStatus;
        return this;
    }
    
    
    /**
     * A value that indicates the state of the volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>CREATING, AVAILABLE, RESTORING, BOOTSTRAPPING, IRRECOVERABLE, PASS THROUGH, RESTORE AND PASS THROUGH, DELETED, WORKING STORAGE NOT CONFIGURED, UPLOAD BUFFER NOT CONFIGURED
     *
     * @param volumeStatus A value that indicates the state of the volume.
     *
     * @see VolumeStatus
     */
    public void setVolumeStatus(VolumeStatus volumeStatus) {
        this.volumeStatus = volumeStatus.toString();
    }
    
    /**
     * A value that indicates the state of the volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Allowed Values: </b>CREATING, AVAILABLE, RESTORING, BOOTSTRAPPING, IRRECOVERABLE, PASS THROUGH, RESTORE AND PASS THROUGH, DELETED, WORKING STORAGE NOT CONFIGURED, UPLOAD BUFFER NOT CONFIGURED
     *
     * @param volumeStatus A value that indicates the state of the volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     *
     * @see VolumeStatus
     */
    public CachediSCSIVolume withVolumeStatus(VolumeStatus volumeStatus) {
        this.volumeStatus = volumeStatus.toString();
        return this;
    }
    
    /**
     * The size of the volume in bytes that was specified in the
     * <a>API_CreateCachediSCSIVolume</a> operation.
     *
     * @return The size of the volume in bytes that was specified in the
     *         <a>API_CreateCachediSCSIVolume</a> operation.
     */
    public Long getVolumeSizeInBytes() {
        return volumeSizeInBytes;
    }
    
    /**
     * The size of the volume in bytes that was specified in the
     * <a>API_CreateCachediSCSIVolume</a> operation.
     *
     * @param volumeSizeInBytes The size of the volume in bytes that was specified in the
     *         <a>API_CreateCachediSCSIVolume</a> operation.
     */
    public void setVolumeSizeInBytes(Long volumeSizeInBytes) {
        this.volumeSizeInBytes = volumeSizeInBytes;
    }
    
    /**
     * The size of the volume in bytes that was specified in the
     * <a>API_CreateCachediSCSIVolume</a> operation.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeSizeInBytes The size of the volume in bytes that was specified in the
     *         <a>API_CreateCachediSCSIVolume</a> operation.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CachediSCSIVolume withVolumeSizeInBytes(Long volumeSizeInBytes) {
        this.volumeSizeInBytes = volumeSizeInBytes;
        return this;
    }
    
    
    /**
     * The percentage complete if the volume is restoring or bootstrapping
     * that represents the percent of data transferred. This field does not
     * appear in the response if the stored volume is not restoring or
     * bootstrapping.
     *
     * @return The percentage complete if the volume is restoring or bootstrapping
     *         that represents the percent of data transferred. This field does not
     *         appear in the response if the stored volume is not restoring or
     *         bootstrapping.
     */
    public Double getVolumeProgress() {
        return volumeProgress;
    }
    
    /**
     * The percentage complete if the volume is restoring or bootstrapping
     * that represents the percent of data transferred. This field does not
     * appear in the response if the stored volume is not restoring or
     * bootstrapping.
     *
     * @param volumeProgress The percentage complete if the volume is restoring or bootstrapping
     *         that represents the percent of data transferred. This field does not
     *         appear in the response if the stored volume is not restoring or
     *         bootstrapping.
     */
    public void setVolumeProgress(Double volumeProgress) {
        this.volumeProgress = volumeProgress;
    }
    
    /**
     * The percentage complete if the volume is restoring or bootstrapping
     * that represents the percent of data transferred. This field does not
     * appear in the response if the stored volume is not restoring or
     * bootstrapping.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeProgress The percentage complete if the volume is restoring or bootstrapping
     *         that represents the percent of data transferred. This field does not
     *         appear in the response if the stored volume is not restoring or
     *         bootstrapping.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CachediSCSIVolume withVolumeProgress(Double volumeProgress) {
        this.volumeProgress = volumeProgress;
        return this;
    }
    
    
    /**
     * If the cached volume was created from a snapshot, this field contains
     * the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @return If the cached volume was created from a snapshot, this field contains
     *         the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     *         included.
     */
    public String getSourceSnapshotId() {
        return sourceSnapshotId;
    }
    
    /**
     * If the cached volume was created from a snapshot, this field contains
     * the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @param sourceSnapshotId If the cached volume was created from a snapshot, this field contains
     *         the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     *         included.
     */
    public void setSourceSnapshotId(String sourceSnapshotId) {
        this.sourceSnapshotId = sourceSnapshotId;
    }
    
    /**
     * If the cached volume was created from a snapshot, this field contains
     * the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Pattern: </b>\Asnap-[0-9a-fA-F]{8}\z<br/>
     *
     * @param sourceSnapshotId If the cached volume was created from a snapshot, this field contains
     *         the snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     *         included.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CachediSCSIVolume withSourceSnapshotId(String sourceSnapshotId) {
        this.sourceSnapshotId = sourceSnapshotId;
        return this;
    }
    
    
    /**
     * Lists iSCSI information about a volume.
     *
     * @return Lists iSCSI information about a volume.
     */
    public VolumeiSCSIAttributes getVolumeiSCSIAttributes() {
        return volumeiSCSIAttributes;
    }
    
    /**
     * Lists iSCSI information about a volume.
     *
     * @param volumeiSCSIAttributes Lists iSCSI information about a volume.
     */
    public void setVolumeiSCSIAttributes(VolumeiSCSIAttributes volumeiSCSIAttributes) {
        this.volumeiSCSIAttributes = volumeiSCSIAttributes;
    }
    
    /**
     * Lists iSCSI information about a volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeiSCSIAttributes Lists iSCSI information about a volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CachediSCSIVolume withVolumeiSCSIAttributes(VolumeiSCSIAttributes volumeiSCSIAttributes) {
        this.volumeiSCSIAttributes = volumeiSCSIAttributes;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (volumeARN != null) sb.append("VolumeARN: " + volumeARN + ", ");
        if (volumeId != null) sb.append("VolumeId: " + volumeId + ", ");
        if (volumeType != null) sb.append("VolumeType: " + volumeType + ", ");
        if (volumeStatus != null) sb.append("VolumeStatus: " + volumeStatus + ", ");
        if (volumeSizeInBytes != null) sb.append("VolumeSizeInBytes: " + volumeSizeInBytes + ", ");
        if (volumeProgress != null) sb.append("VolumeProgress: " + volumeProgress + ", ");
        if (sourceSnapshotId != null) sb.append("SourceSnapshotId: " + sourceSnapshotId + ", ");
        if (volumeiSCSIAttributes != null) sb.append("VolumeiSCSIAttributes: " + volumeiSCSIAttributes + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getVolumeARN() == null) ? 0 : getVolumeARN().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeId() == null) ? 0 : getVolumeId().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeType() == null) ? 0 : getVolumeType().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeStatus() == null) ? 0 : getVolumeStatus().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeSizeInBytes() == null) ? 0 : getVolumeSizeInBytes().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeProgress() == null) ? 0 : getVolumeProgress().hashCode()); 
        hashCode = prime * hashCode + ((getSourceSnapshotId() == null) ? 0 : getSourceSnapshotId().hashCode()); 
        hashCode = prime * hashCode + ((getVolumeiSCSIAttributes() == null) ? 0 : getVolumeiSCSIAttributes().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof CachediSCSIVolume == false) return false;
        CachediSCSIVolume other = (CachediSCSIVolume)obj;
        
        if (other.getVolumeARN() == null ^ this.getVolumeARN() == null) return false;
        if (other.getVolumeARN() != null && other.getVolumeARN().equals(this.getVolumeARN()) == false) return false; 
        if (other.getVolumeId() == null ^ this.getVolumeId() == null) return false;
        if (other.getVolumeId() != null && other.getVolumeId().equals(this.getVolumeId()) == false) return false; 
        if (other.getVolumeType() == null ^ this.getVolumeType() == null) return false;
        if (other.getVolumeType() != null && other.getVolumeType().equals(this.getVolumeType()) == false) return false; 
        if (other.getVolumeStatus() == null ^ this.getVolumeStatus() == null) return false;
        if (other.getVolumeStatus() != null && other.getVolumeStatus().equals(this.getVolumeStatus()) == false) return false; 
        if (other.getVolumeSizeInBytes() == null ^ this.getVolumeSizeInBytes() == null) return false;
        if (other.getVolumeSizeInBytes() != null && other.getVolumeSizeInBytes().equals(this.getVolumeSizeInBytes()) == false) return false; 
        if (other.getVolumeProgress() == null ^ this.getVolumeProgress() == null) return false;
        if (other.getVolumeProgress() != null && other.getVolumeProgress().equals(this.getVolumeProgress()) == false) return false; 
        if (other.getSourceSnapshotId() == null ^ this.getSourceSnapshotId() == null) return false;
        if (other.getSourceSnapshotId() != null && other.getSourceSnapshotId().equals(this.getSourceSnapshotId()) == false) return false; 
        if (other.getVolumeiSCSIAttributes() == null ^ this.getVolumeiSCSIAttributes() == null) return false;
        if (other.getVolumeiSCSIAttributes() != null && other.getVolumeiSCSIAttributes().equals(this.getVolumeiSCSIAttributes()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DeleteSnapshotScheduleResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * A JSON object containing the following fields:
 * </p>
 * 
 * <ul>
 * <li> DeleteSnapshotScheduleOutput$VolumeARN </li>
 * 
 * </ul>
 */
public class DeleteSnapshotScheduleResult {

    /**
     * The Amazon Resource Name (ARN) of the volume of which the snapshot was
     * taken.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String volumeARN;

    /**
     * The Amazon Resource Name (ARN) of the volume of which the snapshot was
     * taken.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the volume of which the snapshot was
     *         taken.
     */
    public String getVolumeARN() {
        return volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume of which the snapshot was
     * taken.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume of which the snapshot was
     *         taken.
     */
    public void setVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume of which the snapshot was
     * taken.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume of which the snapshot was
     *         taken.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DeleteSnapshotScheduleResult withVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (volumeARN != null) sb.append("VolumeARN: " + volumeARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getVolumeARN() == null) ? 0 : getVolumeARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DeleteSnapshotScheduleResult == false) return false;
        DeleteSnapshotScheduleResult other = (DeleteSnapshotScheduleResult)obj;
        
        if (other.getVolumeARN() == null ^ this.getVolumeARN() == null) return false;
        if (other.getVolumeARN() != null && other.getVolumeARN().equals(this.getVolumeARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeCachediSCSIVolumesRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#describeCachediSCSIVolumes(DescribeCachediSCSIVolumesRequest) DescribeCachediSCSIVolumes operation}.
 * <p>
 * This operation returns a description of the gateway volumes specified in the request. This operation is supported only for the gateway-cached volume
 * architecture.
 * </p>
 * <p>
 * The list of gateway volumes in the request must be from one gateway. In the response Amazon Storage Gateway returns volume information sorted by
 * volume Amazon Resource Name (ARN).
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#describeCachediSCSIVolumes(DescribeCachediSCSIVolumesRequest)
 */
public class DescribeCachediSCSIVolumesRequest extends AmazonWebServiceRequest {

    /**
     * An array of strings, where each string represents the Amazon Resource
     * Name (ARN) of a cached volume. All of the specified cached volumes
     * must be from the same gateway. Use <a>ListVolumes</a> to get volume
     * ARNs of a gateway.
     */
    private java.util.List<String> volumeARNs;

    /**
     * An array of strings, where each string represents the Amazon Resource
     * Name (ARN) of a cached volume. All of the specified cached volumes
     * must be from the same gateway. Use <a>ListVolumes</a> to get volume
     * ARNs of a gateway.
     *
     * @return An array of strings, where each string represents the Amazon Resource
     *         Name (ARN) of a cached volume. All of the specified cached volumes
     *         must be from the same gateway. Use <a>ListVolumes</a> to get volume
     *         ARNs of a gateway.
     */
    public java.util.List<String> getVolumeARNs() {
        
        if (volumeARNs == null) {
            volumeARNs = new java.util.ArrayList<String>();
        }
        return volumeARNs;
    }
    
    /**
     * An array of strings, where each string represents the Amazon Resource
     * Name (ARN) of a cached volume. All of the specified cached volumes
     * must be from the same gateway. Use <a>ListVolumes</a> to get volume
     * ARNs of a gateway.
     *
     * @param volumeARNs An array of strings, where each string represents the Amazon Resource
     *         Name (ARN) of a cached volume. All of the specified cached volumes
     *         must be from the same gateway. Use <a>ListVolumes</a> to get volume
     *         ARNs of a gateway.
     */
    public void setVolumeARNs(java.util.Collection<String> volumeARNs) {
        if (volumeARNs == null) {
            this.volumeARNs = null;
            return;
        }

        java.util.List<String> volumeARNsCopy = new java.util.ArrayList<String>(volumeARNs.size());
        volumeARNsCopy.addAll(volumeARNs);
        this.volumeARNs = volumeARNsCopy;
    }
    
    /**
     * An array of strings, where each string represents the Amazon Resource
     * Name (ARN) of a cached volume. All of the specified cached volumes
     * must be from the same gateway. Use <a>ListVolumes</a> to get volume
     * ARNs of a gateway.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeARNs An array of strings, where each string represents the Amazon Resource
     *         Name (ARN) of a cached volume. All of the specified cached volumes
     *         must be from the same gateway. Use <a>ListVolumes</a> to get volume
     *         ARNs of a gateway.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCachediSCSIVolumesRequest withVolumeARNs(String... volumeARNs) {
        if (getVolumeARNs() == null) setVolumeARNs(new java.util.ArrayList<String>(volumeARNs.length));
        for (String value : volumeARNs) {
            getVolumeARNs().add(value);
        }
        return this;
    }
    
    /**
     * An array of strings, where each string represents the Amazon Resource
     * Name (ARN) of a cached volume. All of the specified cached volumes
     * must be from the same gateway. Use <a>ListVolumes</a> to get volume
     * ARNs of a gateway.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param volumeARNs An array of strings, where each string represents the Amazon Resource
     *         Name (ARN) of a cached volume. All of the specified cached volumes
     *         must be from the same gateway. Use <a>ListVolumes</a> to get volume
     *         ARNs of a gateway.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCachediSCSIVolumesRequest withVolumeARNs(java.util.Collection<String> volumeARNs) {
        if (volumeARNs == null) {
            this.volumeARNs = null;
        } else {
            java.util.List<String> volumeARNsCopy = new java.util.ArrayList<String>(volumeARNs.size());
            volumeARNsCopy.addAll(volumeARNs);
            this.volumeARNs = volumeARNsCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (volumeARNs != null) sb.append("VolumeARNs: " + volumeARNs + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getVolumeARNs() == null) ? 0 : getVolumeARNs().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DescribeCachediSCSIVolumesRequest == false) return false;
        DescribeCachediSCSIVolumesRequest other = (DescribeCachediSCSIVolumesRequest)obj;
        
        if (other.getVolumeARNs() == null ^ this.getVolumeARNs() == null) return false;
        if (other.getVolumeARNs() != null && other.getVolumeARNs().equals(this.getVolumeARNs()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeCacheResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * A JSON object containing the following fields:
 * </p>
 * 
 * <ul>
 * <li> DescribeCacheOutput$CacheAllocatedInBytes </li>
 * <li> DescribeCacheOutput$CacheDirtyPercentage </li>
 * <li> DescribeCacheOutput$CacheHitPercentage </li>
 * <li> DescribeCacheOutput$CacheMissPercentage </li>
 * <li> DescribeCacheOutput$CacheUsedPercentage </li>
 * <li> DescribeCacheOutput$DiskIds </li>
 * <li> DescribeCacheOutput$GatewayARN </li>
 * 
 * </ul>
 */
public class DescribeCacheResult {

    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * List Gateways operations to return a list of gateways for your account
     * and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * An array of the gateway's local disk IDs that are configured as cache.
     * Each local disk ID is specified as a string (minimum length of 1 and
     * maximum length of 300). If no local disks are configured as cache,
     * then the <code>DiskIds</code> array is empty.
     */
    private java.util.List<String> diskIds;

    /**
     * The size allocated, in bytes, for the cache. If no cache is defined
     * for the gateway, this field returns 0.
     */
    private Long cacheAllocatedInBytes;

    /**
     * The percentage (0 to 100) of the cache storage in use. If no cached is
     * defined for the gateway, this field returns 0.
     */
    private Double cacheUsedPercentage;

    /**
     * The percentage of the cache that contains data that has not yet been
     * persisted to Amazon S3. If no cached is defined for the gateway, this
     * field returns 0.
     */
    private Double cacheDirtyPercentage;

    /**
     * The percentage (0 to 100) of data read from the storage volume that
     * was read from cache. If no cached is defined for the gateway, this
     * field returns 0.
     */
    private Double cacheHitPercentage;

    /**
     * TThe percentage (0 to 100) of data read from the storage volume that
     * was not read from the cache, but was read from Amazon S3. If no cached
     * is defined for the gateway, this field returns 0.
     */
    private Double cacheMissPercentage;

    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * List Gateways operations to return a list of gateways for your account
     * and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return In response, AWS Storage Gateway returns the ARN of the activated
     *         gateway. If you don't remember the ARN of a gateway, you can use the
     *         List Gateways operations to return a list of gateways for your account
     *         and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * List Gateways operations to return a list of gateways for your account
     * and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN In response, AWS Storage Gateway returns the ARN of the activated
     *         gateway. If you don't remember the ARN of a gateway, you can use the
     *         List Gateways operations to return a list of gateways for your account
     *         and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * In response, AWS Storage Gateway returns the ARN of the activated
     * gateway. If you don't remember the ARN of a gateway, you can use the
     * List Gateways operations to return a list of gateways for your account
     * and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN In response, AWS Storage Gateway returns the ARN of the activated
     *         gateway. If you don't remember the ARN of a gateway, you can use the
     *         List Gateways operations to return a list of gateways for your account
     *         and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * An array of the gateway's local disk IDs that are configured as cache.
     * Each local disk ID is specified as a string (minimum length of 1 and
     * maximum length of 300). If no local disks are configured as cache,
     * then the <code>DiskIds</code> array is empty.
     *
     * @return An array of the gateway's local disk IDs that are configured as cache.
     *         Each local disk ID is specified as a string (minimum length of 1 and
     *         maximum length of 300). If no local disks are configured as cache,
     *         then the <code>DiskIds</code> array is empty.
     */
    public java.util.List<String> getDiskIds() {
        
        if (diskIds == null) {
            diskIds = new java.util.ArrayList<String>();
        }
        return diskIds;
    }
    
    /**
     * An array of the gateway's local disk IDs that are configured as cache.
     * Each local disk ID is specified as a string (minimum length of 1 and
     * maximum length of 300). If no local disks are configured as cache,
     * then the <code>DiskIds</code> array is empty.
     *
     * @param diskIds An array of the gateway's local disk IDs that are configured as cache.
     *         Each local disk ID is specified as a string (minimum length of 1 and
     *         maximum length of 300). If no local disks are configured as cache,
     *         then the <code>DiskIds</code> array is empty.
     */
    public void setDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
            return;
        }

        java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
        diskIdsCopy.addAll(diskIds);
        this.diskIds = diskIdsCopy;
    }
    
    /**
     * An array of the gateway's local disk IDs that are configured as cache.
     * Each local disk ID is specified as a string (minimum length of 1 and
     * maximum length of 300). If no local disks are configured as cache,
     * then the <code>DiskIds</code> array is empty.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of the gateway's local disk IDs that are configured as cache.
     *         Each local disk ID is specified as a string (minimum length of 1 and
     *         maximum length of 300). If no local disks are configured as cache,
     *         then the <code>DiskIds</code> array is empty.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withDiskIds(String... diskIds) {
        if (getDiskIds() == null) setDiskIds(new java.util.ArrayList<String>(diskIds.length));
        for (String value : diskIds) {
            getDiskIds().add(value);
        }
        return this;
    }
    
    /**
     * An array of the gateway's local disk IDs that are configured as cache.
     * Each local disk ID is specified as a string (minimum length of 1 and
     * maximum length of 300). If no local disks are configured as cache,
     * then the <code>DiskIds</code> array is empty.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of the gateway's local disk IDs that are configured as cache.
     *         Each local disk ID is specified as a string (minimum length of 1 and
     *         maximum length of 300). If no local disks are configured as cache,
     *         then the <code>DiskIds</code> array is empty.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
        } else {
            java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
            diskIdsCopy.addAll(diskIds);
            this.diskIds = diskIdsCopy;
        }

        return this;
    }
    
    /**
     * The size allocated, in bytes, for the cache. If no cache is defined
     * for the gateway, this field returns 0.
     *
     * @return The size allocated, in bytes, for the cache. If no cache is defined
     *         for the gateway, this field returns 0.
     */
    public Long getCacheAllocatedInBytes() {
        return cacheAllocatedInBytes;
    }
    
    /**
     * The size allocated, in bytes, for the cache. If no cache is defined
     * for the gateway, this field returns 0.
     *
     * @param cacheAllocatedInBytes The size allocated, in bytes, for the cache. If no cache is defined
     *         for the gateway, this field returns 0.
     */
    public void setCacheAllocatedInBytes(Long cacheAllocatedInBytes) {
        this.cacheAllocatedInBytes = cacheAllocatedInBytes;
    }
    
    /**
     * The size allocated, in bytes, for the cache. If no cache is defined
     * for the gateway, this field returns 0.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cacheAllocatedInBytes The size allocated, in bytes, for the cache. If no cache is defined
     *         for the gateway, this field returns 0.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withCacheAllocatedInBytes(Long cacheAllocatedInBytes) {
        this.cacheAllocatedInBytes = cacheAllocatedInBytes;
        return this;
    }
    
    
    /**
     * The percentage (0 to 100) of the cache storage in use. If no cached is
     * defined for the gateway, this field returns 0.
     *
     * @return The percentage (0 to 100) of the cache storage in use. If no cached is
     *         defined for the gateway, this field returns 0.
     */
    public Double getCacheUsedPercentage() {
        return cacheUsedPercentage;
    }
    
    /**
     * The percentage (0 to 100) of the cache storage in use. If no cached is
     * defined for the gateway, this field returns 0.
     *
     * @param cacheUsedPercentage The percentage (0 to 100) of the cache storage in use. If no cached is
     *         defined for the gateway, this field returns 0.
     */
    public void setCacheUsedPercentage(Double cacheUsedPercentage) {
        this.cacheUsedPercentage = cacheUsedPercentage;
    }
    
    /**
     * The percentage (0 to 100) of the cache storage in use. If no cached is
     * defined for the gateway, this field returns 0.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cacheUsedPercentage The percentage (0 to 100) of the cache storage in use. If no cached is
     *         defined for the gateway, this field returns 0.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withCacheUsedPercentage(Double cacheUsedPercentage) {
        this.cacheUsedPercentage = cacheUsedPercentage;
        return this;
    }
    
    
    /**
     * The percentage of the cache that contains data that has not yet been
     * persisted to Amazon S3. If no cached is defined for the gateway, this
     * field returns 0.
     *
     * @return The percentage of the cache that contains data that has not yet been
     *         persisted to Amazon S3. If no cached is defined for the gateway, this
     *         field returns 0.
     */
    public Double getCacheDirtyPercentage() {
        return cacheDirtyPercentage;
    }
    
    /**
     * The percentage of the cache that contains data that has not yet been
     * persisted to Amazon S3. If no cached is defined for the gateway, this
     * field returns 0.
     *
     * @param cacheDirtyPercentage The percentage of the cache that contains data that has not yet been
     *         persisted to Amazon S3. If no cached is defined for the gateway, this
     *         field returns 0.
     */
    public void setCacheDirtyPercentage(Double cacheDirtyPercentage) {
        this.cacheDirtyPercentage = cacheDirtyPercentage;
    }
    
    /**
     * The percentage of the cache that contains data that has not yet been
     * persisted to Amazon S3. If no cached is defined for the gateway, this
     * field returns 0.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cacheDirtyPercentage The percentage of the cache that contains data that has not yet been
     *         persisted to Amazon S3. If no cached is defined for the gateway, this
     *         field returns 0.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withCacheDirtyPercentage(Double cacheDirtyPercentage) {
        this.cacheDirtyPercentage = cacheDirtyPercentage;
        return this;
    }
    
    
    /**
     * The percentage (0 to 100) of data read from the storage volume that
     * was read from cache. If no cached is defined for the gateway, this
     * field returns 0.
     *
     * @return The percentage (0 to 100) of data read from the storage volume that
     *         was read from cache. If no cached is defined for the gateway, this
     *         field returns 0.
     */
    public Double getCacheHitPercentage() {
        return cacheHitPercentage;
    }
    
    /**
     * The percentage (0 to 100) of data read from the storage volume that
     * was read from cache. If no cached is defined for the gateway, this
     * field returns 0.
     *
     * @param cacheHitPercentage The percentage (0 to 100) of data read from the storage volume that
     *         was read from cache. If no cached is defined for the gateway, this
     *         field returns 0.
     */
    public void setCacheHitPercentage(Double cacheHitPercentage) {
        this.cacheHitPercentage = cacheHitPercentage;
    }
    
    /**
     * The percentage (0 to 100) of data read from the storage volume that
     * was read from cache. If no cached is defined for the gateway, this
     * field returns 0.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cacheHitPercentage The percentage (0 to 100) of data read from the storage volume that
     *         was read from cache. If no cached is defined for the gateway, this
     *         field returns 0.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withCacheHitPercentage(Double cacheHitPercentage) {
        this.cacheHitPercentage = cacheHitPercentage;
        return this;
    }
    
    
    /**
     * TThe percentage (0 to 100) of data read from the storage volume that
     * was not read from the cache, but was read from Amazon S3. If no cached
     * is defined for the gateway, this field returns 0.
     *
     * @return TThe percentage (0 to 100) of data read from the storage volume that
     *         was not read from the cache, but was read from Amazon S3. If no cached
     *         is defined for the gateway, this field returns 0.
     */
    public Double getCacheMissPercentage() {
        return cacheMissPercentage;
    }
    
    /**
     * TThe percentage (0 to 100) of data read from the storage volume that
     * was not read from the cache, but was read from Amazon S3. If no cached
     * is defined for the gateway, this field returns 0.
     *
     * @param cacheMissPercentage TThe percentage (0 to 100) of data read from the storage volume that
     *         was not read from the cache, but was read from Amazon S3. If no cached
     *         is defined for the gateway, this field returns 0.
     */
    public void setCacheMissPercentage(Double cacheMissPercentage) {
        this.cacheMissPercentage = cacheMissPercentage;
    }
    
    /**
     * TThe percentage (0 to 100) of data read from the storage volume that
     * was not read from the cache, but was read from Amazon S3. If no cached
     * is defined for the gateway, this field returns 0.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param cacheMissPercentage TThe percentage (0 to 100) of data read from the storage volume that
     *         was not read from the cache, but was read from Amazon S3. If no cached
     *         is defined for the gateway, this field returns 0.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheResult withCacheMissPercentage(Double cacheMissPercentage) {
        this.cacheMissPercentage = cacheMissPercentage;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        if (diskIds != null) sb.append("DiskIds: " + diskIds + ", ");
        if (cacheAllocatedInBytes != null) sb.append("CacheAllocatedInBytes: " + cacheAllocatedInBytes + ", ");
        if (cacheUsedPercentage != null) sb.append("CacheUsedPercentage: " + cacheUsedPercentage + ", ");
        if (cacheDirtyPercentage != null) sb.append("CacheDirtyPercentage: " + cacheDirtyPercentage + ", ");
        if (cacheHitPercentage != null) sb.append("CacheHitPercentage: " + cacheHitPercentage + ", ");
        if (cacheMissPercentage != null) sb.append("CacheMissPercentage: " + cacheMissPercentage + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        hashCode = prime * hashCode + ((getDiskIds() == null) ? 0 : getDiskIds().hashCode()); 
        hashCode = prime * hashCode + ((getCacheAllocatedInBytes() == null) ? 0 : getCacheAllocatedInBytes().hashCode()); 
        hashCode = prime * hashCode + ((getCacheUsedPercentage() == null) ? 0 : getCacheUsedPercentage().hashCode()); 
        hashCode = prime * hashCode + ((getCacheDirtyPercentage() == null) ? 0 : getCacheDirtyPercentage().hashCode()); 
        hashCode = prime * hashCode + ((getCacheHitPercentage() == null) ? 0 : getCacheHitPercentage().hashCode()); 
        hashCode = prime * hashCode + ((getCacheMissPercentage() == null) ? 0 : getCacheMissPercentage().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DescribeCacheResult == false) return false;
        DescribeCacheResult other = (DescribeCacheResult)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        if (other.getDiskIds() == null ^ this.getDiskIds() == null) return false;
        if (other.getDiskIds() != null && other.getDiskIds().equals(this.getDiskIds()) == false) return false; 
        if (other.getCacheAllocatedInBytes() == null ^ this.getCacheAllocatedInBytes() == null) return false;
        if (other.getCacheAllocatedInBytes() != null && other.getCacheAllocatedInBytes().equals(this.getCacheAllocatedInBytes()) == false) return false; 
        if (other.getCacheUsedPercentage() == null ^ this.getCacheUsedPercentage() == null) return false;
        if (other.getCacheUsedPercentage() != null && other.getCacheUsedPercentage().equals(this.getCacheUsedPercentage()) == false) return false; 
        if (other.getCacheDirtyPercentage() == null ^ this.getCacheDirtyPercentage() == null) return false;
        if (other.getCacheDirtyPercentage() != null && other.getCacheDirtyPercentage().equals(this.getCacheDirtyPercentage()) == false) return false; 
        if (other.getCacheHitPercentage() == null ^ this.getCacheHitPercentage() == null) return false;
        if (other.getCacheHitPercentage() != null && other.getCacheHitPercentage().equals(this.getCacheHitPercentage()) == false) return false; 
        if (other.getCacheMissPercentage() == null ^ this.getCacheMissPercentage() == null) return false;
        if (other.getCacheMissPercentage() != null && other.getCacheMissPercentage().equals(this.getCacheMissPercentage()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeCacheRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#describeCache(DescribeCacheRequest) DescribeCache operation}.
 * <p>
 * This operation returns information about the cache of a gateway. This operation is supported only for the gateway-cached volume architecture.
 * </p>
 * <p>
 * The response includes disk IDs that are configured as cache, and it includes the amount of cache allocated and used.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#describeCache(DescribeCacheRequest)
 */
public class DescribeCacheRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DescribeCacheRequest withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DescribeCacheRequest == false) return false;
        DescribeCacheRequest other = (DescribeCacheRequest)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/CreateCachediSCSIVolumeResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * A JSON object containing the following fields:
 * </p>
 * 
 * <ul>
 * <li> CreateCachediSCSIVolume$TargetARN </li>
 * <li> CreateCachediSCSIVolume$VolumeARN </li>
 * 
 * </ul>
 */
public class CreateCachediSCSIVolumeResult {

    /**
     * The ARN of the configured volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String volumeARN;

    /**
     * The ARN of the volume target that includes the iSCSI name that
     * initiators can use to connect to the target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 800<br/>
     */
    private String targetARN;

    /**
     * The ARN of the configured volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The ARN of the configured volume.
     */
    public String getVolumeARN() {
        return volumeARN;
    }
    
    /**
     * The ARN of the configured volume.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The ARN of the configured volume.
     */
    public void setVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
    }
    
    /**
     * The ARN of the configured volume.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The ARN of the configured volume.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeResult withVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
        return this;
    }
    
    
    /**
     * The ARN of the volume target that includes the iSCSI name that
     * initiators can use to connect to the target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 800<br/>
     *
     * @return The ARN of the volume target that includes the iSCSI name that
     *         initiators can use to connect to the target.
     */
    public String getTargetARN() {
        return targetARN;
    }
    
    /**
     * The ARN of the volume target that includes the iSCSI name that
     * initiators can use to connect to the target.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 800<br/>
     *
     * @param targetARN The ARN of the volume target that includes the iSCSI name that
     *         initiators can use to connect to the target.
     */
    public void setTargetARN(String targetARN) {
        this.targetARN = targetARN;
    }
    
    /**
     * The ARN of the volume target that includes the iSCSI name that
     * initiators can use to connect to the target.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 800<br/>
     *
     * @param targetARN The ARN of the volume target that includes the iSCSI name that
     *         initiators can use to connect to the target.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public CreateCachediSCSIVolumeResult withTargetARN(String targetARN) {
        this.targetARN = targetARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (volumeARN != null) sb.append("VolumeARN: " + volumeARN + ", ");
        if (targetARN != null) sb.append("TargetARN: " + targetARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getVolumeARN() == null) ? 0 : getVolumeARN().hashCode()); 
        hashCode = prime * hashCode + ((getTargetARN() == null) ? 0 : getTargetARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof CreateCachediSCSIVolumeResult == false) return false;
        CreateCachediSCSIVolumeResult other = (CreateCachediSCSIVolumeResult)obj;
        
        if (other.getVolumeARN() == null ^ this.getVolumeARN() == null) return false;
        if (other.getVolumeARN() != null && other.getVolumeARN().equals(this.getVolumeARN()) == false) return false; 
        if (other.getTargetARN() == null ^ this.getTargetARN() == null) return false;
        if (other.getTargetARN() != null && other.getTargetARN().equals(this.getTargetARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/AddCacheResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * The Amazon Resource Name (ARN) of the gateway for which cache storage was configured.
 * </p>
 */
public class AddCacheResult {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddCacheResult withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof AddCacheResult == false) return false;
        AddCacheResult other = (AddCacheResult)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DeleteSnapshotScheduleRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#deleteSnapshotSchedule(DeleteSnapshotScheduleRequest) DeleteSnapshotSchedule operation}.
 * <p>
 * This operation deletes a snapshot of a volume.
 * </p>
 * <p>
 * You can take snapshots of your gateway volumes on a scheduled or ad-hoc basis. This API enables you to delete a snapshot schedule for a volume. For
 * more information, see <a href="http://docs.amazonwebservices.com/storagegateway/latest/userguide/WorkingWithSnapshots.html"> Working with Snapshots
 * </a> . In the <code>DeleteSnapshotSchedule</code> request, you identify the volume by providing its Amazon Resource Name (ARN).
 * </p>
 * <p>
 * <b>NOTE:</b> To list or delete a snapshot, you must use the Amazon EC2 API. For more information, go to DeleteSnapshot and DescribeSnapshots in Amazon
 * Elastic Compute Cloud API Reference.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#deleteSnapshotSchedule(DeleteSnapshotScheduleRequest)
 */
public class DeleteSnapshotScheduleRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String volumeARN;

    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the volume. Use the
     *         <a>ListVolumes</a> operation to return a list of gateway volumes.
     */
    public String getVolumeARN() {
        return volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume. Use the
     *         <a>ListVolumes</a> operation to return a list of gateway volumes.
     */
    public void setVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the volume. Use the
     * <a>ListVolumes</a> operation to return a list of gateway volumes.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param volumeARN The Amazon Resource Name (ARN) of the volume. Use the
     *         <a>ListVolumes</a> operation to return a list of gateway volumes.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public DeleteSnapshotScheduleRequest withVolumeARN(String volumeARN) {
        this.volumeARN = volumeARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (volumeARN != null) sb.append("VolumeARN: " + volumeARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getVolumeARN() == null) ? 0 : getVolumeARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof DeleteSnapshotScheduleRequest == false) return false;
        DeleteSnapshotScheduleRequest other = (DeleteSnapshotScheduleRequest)obj;
        
        if (other.getVolumeARN() == null ^ this.getVolumeARN() == null) return false;
        if (other.getVolumeARN() != null && other.getVolumeARN().equals(this.getVolumeARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/AddUploadBufferRequest.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;
import com.amazonaws.AmazonWebServiceRequest;

/**
 * Container for the parameters to the {@link com.amazonaws.services.storagegateway.AWSStorageGateway#addUploadBuffer(AddUploadBufferRequest) AddUploadBuffer operation}.
 * <p>
 * This operation configures one or more gateway local disks as upload buffer for a specified gateway. This operation is supported for both the
 * gateway-stored and gateway-cached volume architectures.
 * </p>
 * <p>
 * In the request, you specify the gateway Amazon Resource Name (ARN) to which you want to add upload buffer, and one or more disk IDs that you want to
 * configure as upload buffer.
 * </p>
 *
 * @see com.amazonaws.services.storagegateway.AWSStorageGateway#addUploadBuffer(AddUploadBufferRequest)
 */
public class AddUploadBufferRequest extends AmazonWebServiceRequest {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * An array of strings that identify disks that are to be configured as
     * upload buffer. Each string in the array must be minimum length of 1
     * and maximum length of 300. You can get disk IDs from the
     * <a>ListLocalDisks</a> API.
     */
    private java.util.List<String> diskIds;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddUploadBufferRequest withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * An array of strings that identify disks that are to be configured as
     * upload buffer. Each string in the array must be minimum length of 1
     * and maximum length of 300. You can get disk IDs from the
     * <a>ListLocalDisks</a> API.
     *
     * @return An array of strings that identify disks that are to be configured as
     *         upload buffer. Each string in the array must be minimum length of 1
     *         and maximum length of 300. You can get disk IDs from the
     *         <a>ListLocalDisks</a> API.
     */
    public java.util.List<String> getDiskIds() {
        
        if (diskIds == null) {
            diskIds = new java.util.ArrayList<String>();
        }
        return diskIds;
    }
    
    /**
     * An array of strings that identify disks that are to be configured as
     * upload buffer. Each string in the array must be minimum length of 1
     * and maximum length of 300. You can get disk IDs from the
     * <a>ListLocalDisks</a> API.
     *
     * @param diskIds An array of strings that identify disks that are to be configured as
     *         upload buffer. Each string in the array must be minimum length of 1
     *         and maximum length of 300. You can get disk IDs from the
     *         <a>ListLocalDisks</a> API.
     */
    public void setDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
            return;
        }

        java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
        diskIdsCopy.addAll(diskIds);
        this.diskIds = diskIdsCopy;
    }
    
    /**
     * An array of strings that identify disks that are to be configured as
     * upload buffer. Each string in the array must be minimum length of 1
     * and maximum length of 300. You can get disk IDs from the
     * <a>ListLocalDisks</a> API.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of strings that identify disks that are to be configured as
     *         upload buffer. Each string in the array must be minimum length of 1
     *         and maximum length of 300. You can get disk IDs from the
     *         <a>ListLocalDisks</a> API.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddUploadBufferRequest withDiskIds(String... diskIds) {
        if (getDiskIds() == null) setDiskIds(new java.util.ArrayList<String>(diskIds.length));
        for (String value : diskIds) {
            getDiskIds().add(value);
        }
        return this;
    }
    
    /**
     * An array of strings that identify disks that are to be configured as
     * upload buffer. Each string in the array must be minimum length of 1
     * and maximum length of 300. You can get disk IDs from the
     * <a>ListLocalDisks</a> API.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     *
     * @param diskIds An array of strings that identify disks that are to be configured as
     *         upload buffer. Each string in the array must be minimum length of 1
     *         and maximum length of 300. You can get disk IDs from the
     *         <a>ListLocalDisks</a> API.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddUploadBufferRequest withDiskIds(java.util.Collection<String> diskIds) {
        if (diskIds == null) {
            this.diskIds = null;
        } else {
            java.util.List<String> diskIdsCopy = new java.util.ArrayList<String>(diskIds.size());
            diskIdsCopy.addAll(diskIds);
            this.diskIds = diskIdsCopy;
        }

        return this;
    }
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        if (diskIds != null) sb.append("DiskIds: " + diskIds + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        hashCode = prime * hashCode + ((getDiskIds() == null) ? 0 : getDiskIds().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof AddUploadBufferRequest == false) return false;
        AddUploadBufferRequest other = (AddUploadBufferRequest)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        if (other.getDiskIds() == null ^ this.getDiskIds() == null) return false;
        if (other.getDiskIds() != null && other.getDiskIds().equals(this.getDiskIds()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/CreateCachediSCSIVolumeRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Create Cachedi S C S I Volume Request Marshaller
 */
public class CreateCachediSCSIVolumeRequestMarshaller implements Marshaller<Request<CreateCachediSCSIVolumeRequest>, CreateCachediSCSIVolumeRequest> {

    

    public Request<CreateCachediSCSIVolumeRequest> marshall(CreateCachediSCSIVolumeRequest createCachediSCSIVolumeRequest) {
		if (createCachediSCSIVolumeRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<CreateCachediSCSIVolumeRequest> request = new DefaultRequest<CreateCachediSCSIVolumeRequest>(createCachediSCSIVolumeRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.CreateCachediSCSIVolume";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (createCachediSCSIVolumeRequest.getGatewayARN() != null) {
                jsonWriter.key("GatewayARN").value(createCachediSCSIVolumeRequest.getGatewayARN());
            }
            if (createCachediSCSIVolumeRequest.getVolumeSizeInBytes() != null) {
                jsonWriter.key("VolumeSizeInBytes").value(createCachediSCSIVolumeRequest.getVolumeSizeInBytes());
            }
            if (createCachediSCSIVolumeRequest.getSnapshotId() != null) {
                jsonWriter.key("SnapshotId").value(createCachediSCSIVolumeRequest.getSnapshotId());
            }
            if (createCachediSCSIVolumeRequest.getTargetName() != null) {
                jsonWriter.key("TargetName").value(createCachediSCSIVolumeRequest.getTargetName());
            }
            if (createCachediSCSIVolumeRequest.getNetworkInterfaceId() != null) {
                jsonWriter.key("NetworkInterfaceId").value(createCachediSCSIVolumeRequest.getNetworkInterfaceId());
            }
            if (createCachediSCSIVolumeRequest.getClientToken() != null) {
                jsonWriter.key("ClientToken").value(createCachediSCSIVolumeRequest.getClientToken());
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/CreateCachediSCSIVolumeResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Create Cachedi S C S I Volume Result JSON Unmarshaller
 */
public class CreateCachediSCSIVolumeResultJsonUnmarshaller implements Unmarshaller<CreateCachediSCSIVolumeResult, JsonUnmarshallerContext> {

    

    public CreateCachediSCSIVolumeResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        CreateCachediSCSIVolumeResult createCachediSCSIVolumeResult = new CreateCachediSCSIVolumeResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("VolumeARN", targetDepth)) {
                    context.nextToken();
                    createCachediSCSIVolumeResult.setVolumeARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("TargetARN", targetDepth)) {
                    context.nextToken();
                    createCachediSCSIVolumeResult.setTargetARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return createCachediSCSIVolumeResult;
    }

    private static CreateCachediSCSIVolumeResultJsonUnmarshaller instance;
    public static CreateCachediSCSIVolumeResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new CreateCachediSCSIVolumeResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/CachediSCSIVolumeJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Cachedi S C S I Volume JSON Unmarshaller
 */
public class CachediSCSIVolumeJsonUnmarshaller implements Unmarshaller<CachediSCSIVolume, JsonUnmarshallerContext> {

    

    public CachediSCSIVolume unmarshall(JsonUnmarshallerContext context) throws Exception {
        CachediSCSIVolume cachediSCSIVolume = new CachediSCSIVolume();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("VolumeARN", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setVolumeARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeId", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setVolumeId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeType", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setVolumeType(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeStatus", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setVolumeStatus(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeSizeInBytes", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setVolumeSizeInBytes(LongJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeProgress", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setVolumeProgress(DoubleJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("SourceSnapshotId", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setSourceSnapshotId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeiSCSIAttributes", targetDepth)) {
                    context.nextToken();
                    cachediSCSIVolume.setVolumeiSCSIAttributes(VolumeiSCSIAttributesJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return cachediSCSIVolume;
    }

    private static CachediSCSIVolumeJsonUnmarshaller instance;
    public static CachediSCSIVolumeJsonUnmarshaller getInstance() {
        if (instance == null) instance = new CachediSCSIVolumeJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DescribeCachediSCSIVolumesResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Describe Cachedi S C S I Volumes Result JSON Unmarshaller
 */
public class DescribeCachediSCSIVolumesResultJsonUnmarshaller implements Unmarshaller<DescribeCachediSCSIVolumesResult, JsonUnmarshallerContext> {

    

    public DescribeCachediSCSIVolumesResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DescribeCachediSCSIVolumesResult describeCachediSCSIVolumesResult = new DescribeCachediSCSIVolumesResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("CachediSCSIVolumes", targetDepth)) {
                    describeCachediSCSIVolumesResult.setCachediSCSIVolumes(new ListUnmarshaller<CachediSCSIVolume>(CachediSCSIVolumeJsonUnmarshaller.getInstance()).unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return describeCachediSCSIVolumesResult;
    }

    private static DescribeCachediSCSIVolumesResultJsonUnmarshaller instance;
    public static DescribeCachediSCSIVolumesResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DescribeCachediSCSIVolumesResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DescribeCacheResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Describe Cache Result JSON Unmarshaller
 */
public class DescribeCacheResultJsonUnmarshaller implements Unmarshaller<DescribeCacheResult, JsonUnmarshallerContext> {

    

    public DescribeCacheResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DescribeCacheResult describeCacheResult = new DescribeCacheResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("GatewayARN", targetDepth)) {
                    context.nextToken();
                    describeCacheResult.setGatewayARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("DiskIds", targetDepth)) {
                    describeCacheResult.setDiskIds(new ListUnmarshaller<String>(StringJsonUnmarshaller.getInstance()).unmarshall(context));
                }
                if (context.testExpression("CacheAllocatedInBytes", targetDepth)) {
                    context.nextToken();
                    describeCacheResult.setCacheAllocatedInBytes(LongJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CacheUsedPercentage", targetDepth)) {
                    context.nextToken();
                    describeCacheResult.setCacheUsedPercentage(DoubleJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CacheDirtyPercentage", targetDepth)) {
                    context.nextToken();
                    describeCacheResult.setCacheDirtyPercentage(DoubleJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CacheHitPercentage", targetDepth)) {
                    context.nextToken();
                    describeCacheResult.setCacheHitPercentage(DoubleJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("CacheMissPercentage", targetDepth)) {
                    context.nextToken();
                    describeCacheResult.setCacheMissPercentage(DoubleJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return describeCacheResult;
    }

    private static DescribeCacheResultJsonUnmarshaller instance;
    public static DescribeCacheResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DescribeCacheResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/ListVolumeRecoveryPointsResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * List Volume Recovery Points Result JSON Unmarshaller
 */
public class ListVolumeRecoveryPointsResultJsonUnmarshaller implements Unmarshaller<ListVolumeRecoveryPointsResult, JsonUnmarshallerContext> {

    

    public ListVolumeRecoveryPointsResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        ListVolumeRecoveryPointsResult listVolumeRecoveryPointsResult = new ListVolumeRecoveryPointsResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("GatewayARN", targetDepth)) {
                    context.nextToken();
                    listVolumeRecoveryPointsResult.setGatewayARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeRecoveryPointInfos", targetDepth)) {
                    listVolumeRecoveryPointsResult.setVolumeRecoveryPointInfos(new ListUnmarshaller<VolumeRecoveryPointInfo>(VolumeRecoveryPointInfoJsonUnmarshaller.getInstance()).unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return listVolumeRecoveryPointsResult;
    }

    private static ListVolumeRecoveryPointsResultJsonUnmarshaller instance;
    public static ListVolumeRecoveryPointsResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new ListVolumeRecoveryPointsResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DeleteSnapshotScheduleRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Delete Snapshot Schedule Request Marshaller
 */
public class DeleteSnapshotScheduleRequestMarshaller implements Marshaller<Request<DeleteSnapshotScheduleRequest>, DeleteSnapshotScheduleRequest> {

    

    public Request<DeleteSnapshotScheduleRequest> marshall(DeleteSnapshotScheduleRequest deleteSnapshotScheduleRequest) {
		if (deleteSnapshotScheduleRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<DeleteSnapshotScheduleRequest> request = new DefaultRequest<DeleteSnapshotScheduleRequest>(deleteSnapshotScheduleRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.DeleteSnapshotSchedule";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (deleteSnapshotScheduleRequest.getVolumeARN() != null) {
                jsonWriter.key("VolumeARN").value(deleteSnapshotScheduleRequest.getVolumeARN());
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/AddUploadBufferRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Add Upload Buffer Request Marshaller
 */
public class AddUploadBufferRequestMarshaller implements Marshaller<Request<AddUploadBufferRequest>, AddUploadBufferRequest> {

    

    public Request<AddUploadBufferRequest> marshall(AddUploadBufferRequest addUploadBufferRequest) {
		if (addUploadBufferRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<AddUploadBufferRequest> request = new DefaultRequest<AddUploadBufferRequest>(addUploadBufferRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.AddUploadBuffer";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (addUploadBufferRequest.getGatewayARN() != null) {
                jsonWriter.key("GatewayARN").value(addUploadBufferRequest.getGatewayARN());
            }

            java.util.List<String> diskIdsList = addUploadBufferRequest.getDiskIds();
            if (diskIdsList != null && diskIdsList.size() > 0) {

                jsonWriter.key("DiskIds");
                jsonWriter.array();

                for (String diskIdsListValue : diskIdsList) {
                    if (diskIdsListValue != null) {
                        jsonWriter.value(diskIdsListValue);
                    }
                }
                jsonWriter.endArray();
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/VolumeRecoveryPointInfoJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Volume Recovery Point Info JSON Unmarshaller
 */
public class VolumeRecoveryPointInfoJsonUnmarshaller implements Unmarshaller<VolumeRecoveryPointInfo, JsonUnmarshallerContext> {

    

    public VolumeRecoveryPointInfo unmarshall(JsonUnmarshallerContext context) throws Exception {
        VolumeRecoveryPointInfo volumeRecoveryPointInfo = new VolumeRecoveryPointInfo();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("VolumeARN", targetDepth)) {
                    context.nextToken();
                    volumeRecoveryPointInfo.setVolumeARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeSizeInBytes", targetDepth)) {
                    context.nextToken();
                    volumeRecoveryPointInfo.setVolumeSizeInBytes(LongJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeUsageInBytes", targetDepth)) {
                    context.nextToken();
                    volumeRecoveryPointInfo.setVolumeUsageInBytes(LongJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeRecoveryPointTime", targetDepth)) {
                    context.nextToken();
                    volumeRecoveryPointInfo.setVolumeRecoveryPointTime(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return volumeRecoveryPointInfo;
    }

    private static VolumeRecoveryPointInfoJsonUnmarshaller instance;
    public static VolumeRecoveryPointInfoJsonUnmarshaller getInstance() {
        if (instance == null) instance = new VolumeRecoveryPointInfoJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/AddCacheRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Add Cache Request Marshaller
 */
public class AddCacheRequestMarshaller implements Marshaller<Request<AddCacheRequest>, AddCacheRequest> {

    

    public Request<AddCacheRequest> marshall(AddCacheRequest addCacheRequest) {
		if (addCacheRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<AddCacheRequest> request = new DefaultRequest<AddCacheRequest>(addCacheRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.AddCache";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (addCacheRequest.getGatewayARN() != null) {
                jsonWriter.key("GatewayARN").value(addCacheRequest.getGatewayARN());
            }

            java.util.List<String> diskIdsList = addCacheRequest.getDiskIds();
            if (diskIdsList != null && diskIdsList.size() > 0) {

                jsonWriter.key("DiskIds");
                jsonWriter.array();

                for (String diskIdsListValue : diskIdsList) {
                    if (diskIdsListValue != null) {
                        jsonWriter.value(diskIdsListValue);
                    }
                }
                jsonWriter.endArray();
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DeleteSnapshotScheduleResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Delete Snapshot Schedule Result JSON Unmarshaller
 */
public class DeleteSnapshotScheduleResultJsonUnmarshaller implements Unmarshaller<DeleteSnapshotScheduleResult, JsonUnmarshallerContext> {

    

    public DeleteSnapshotScheduleResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DeleteSnapshotScheduleResult deleteSnapshotScheduleResult = new DeleteSnapshotScheduleResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("VolumeARN", targetDepth)) {
                    context.nextToken();
                    deleteSnapshotScheduleResult.setVolumeARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return deleteSnapshotScheduleResult;
    }

    private static DeleteSnapshotScheduleResultJsonUnmarshaller instance;
    public static DeleteSnapshotScheduleResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DeleteSnapshotScheduleResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/CreateSnapshotFromVolumeRecoveryPointRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Create Snapshot From Volume Recovery Point Request Marshaller
 */
public class CreateSnapshotFromVolumeRecoveryPointRequestMarshaller implements Marshaller<Request<CreateSnapshotFromVolumeRecoveryPointRequest>, CreateSnapshotFromVolumeRecoveryPointRequest> {

    

    public Request<CreateSnapshotFromVolumeRecoveryPointRequest> marshall(CreateSnapshotFromVolumeRecoveryPointRequest createSnapshotFromVolumeRecoveryPointRequest) {
		if (createSnapshotFromVolumeRecoveryPointRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<CreateSnapshotFromVolumeRecoveryPointRequest> request = new DefaultRequest<CreateSnapshotFromVolumeRecoveryPointRequest>(createSnapshotFromVolumeRecoveryPointRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.CreateSnapshotFromVolumeRecoveryPoint";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (createSnapshotFromVolumeRecoveryPointRequest.getVolumeARN() != null) {
                jsonWriter.key("VolumeARN").value(createSnapshotFromVolumeRecoveryPointRequest.getVolumeARN());
            }
            if (createSnapshotFromVolumeRecoveryPointRequest.getSnapshotDescription() != null) {
                jsonWriter.key("SnapshotDescription").value(createSnapshotFromVolumeRecoveryPointRequest.getSnapshotDescription());
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DescribeUploadBufferRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Describe Upload Buffer Request Marshaller
 */
public class DescribeUploadBufferRequestMarshaller implements Marshaller<Request<DescribeUploadBufferRequest>, DescribeUploadBufferRequest> {

    

    public Request<DescribeUploadBufferRequest> marshall(DescribeUploadBufferRequest describeUploadBufferRequest) {
		if (describeUploadBufferRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<DescribeUploadBufferRequest> request = new DefaultRequest<DescribeUploadBufferRequest>(describeUploadBufferRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.DescribeUploadBuffer";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (describeUploadBufferRequest.getGatewayARN() != null) {
                jsonWriter.key("GatewayARN").value(describeUploadBufferRequest.getGatewayARN());
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DescribeCachediSCSIVolumesRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Describe Cachedi S C S I Volumes Request Marshaller
 */
public class DescribeCachediSCSIVolumesRequestMarshaller implements Marshaller<Request<DescribeCachediSCSIVolumesRequest>, DescribeCachediSCSIVolumesRequest> {

    

    public Request<DescribeCachediSCSIVolumesRequest> marshall(DescribeCachediSCSIVolumesRequest describeCachediSCSIVolumesRequest) {
		if (describeCachediSCSIVolumesRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<DescribeCachediSCSIVolumesRequest> request = new DefaultRequest<DescribeCachediSCSIVolumesRequest>(describeCachediSCSIVolumesRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.DescribeCachediSCSIVolumes";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	

            java.util.List<String> volumeARNsList = describeCachediSCSIVolumesRequest.getVolumeARNs();
            if (volumeARNsList != null && volumeARNsList.size() > 0) {

                jsonWriter.key("VolumeARNs");
                jsonWriter.array();

                for (String volumeARNsListValue : volumeARNsList) {
                    if (volumeARNsListValue != null) {
                        jsonWriter.value(volumeARNsListValue);
                    }
                }
                jsonWriter.endArray();
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/CreateSnapshotFromVolumeRecoveryPointResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Create Snapshot From Volume Recovery Point Result JSON Unmarshaller
 */
public class CreateSnapshotFromVolumeRecoveryPointResultJsonUnmarshaller implements Unmarshaller<CreateSnapshotFromVolumeRecoveryPointResult, JsonUnmarshallerContext> {

    

    public CreateSnapshotFromVolumeRecoveryPointResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        CreateSnapshotFromVolumeRecoveryPointResult createSnapshotFromVolumeRecoveryPointResult = new CreateSnapshotFromVolumeRecoveryPointResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("SnapshotId", targetDepth)) {
                    context.nextToken();
                    createSnapshotFromVolumeRecoveryPointResult.setSnapshotId(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeARN", targetDepth)) {
                    context.nextToken();
                    createSnapshotFromVolumeRecoveryPointResult.setVolumeARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("VolumeRecoveryPointTime", targetDepth)) {
                    context.nextToken();
                    createSnapshotFromVolumeRecoveryPointResult.setVolumeRecoveryPointTime(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return createSnapshotFromVolumeRecoveryPointResult;
    }

    private static CreateSnapshotFromVolumeRecoveryPointResultJsonUnmarshaller instance;
    public static CreateSnapshotFromVolumeRecoveryPointResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new CreateSnapshotFromVolumeRecoveryPointResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/AddCacheResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Add Cache Result JSON Unmarshaller
 */
public class AddCacheResultJsonUnmarshaller implements Unmarshaller<AddCacheResult, JsonUnmarshallerContext> {

    

    public AddCacheResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        AddCacheResult addCacheResult = new AddCacheResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("GatewayARN", targetDepth)) {
                    context.nextToken();
                    addCacheResult.setGatewayARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return addCacheResult;
    }

    private static AddCacheResultJsonUnmarshaller instance;
    public static AddCacheResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new AddCacheResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/ListVolumeRecoveryPointsRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * List Volume Recovery Points Request Marshaller
 */
public class ListVolumeRecoveryPointsRequestMarshaller implements Marshaller<Request<ListVolumeRecoveryPointsRequest>, ListVolumeRecoveryPointsRequest> {

    

    public Request<ListVolumeRecoveryPointsRequest> marshall(ListVolumeRecoveryPointsRequest listVolumeRecoveryPointsRequest) {
		if (listVolumeRecoveryPointsRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<ListVolumeRecoveryPointsRequest> request = new DefaultRequest<ListVolumeRecoveryPointsRequest>(listVolumeRecoveryPointsRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.ListVolumeRecoveryPoints";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (listVolumeRecoveryPointsRequest.getGatewayARN() != null) {
                jsonWriter.key("GatewayARN").value(listVolumeRecoveryPointsRequest.getGatewayARN());
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DescribeUploadBufferResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Describe Upload Buffer Result JSON Unmarshaller
 */
public class DescribeUploadBufferResultJsonUnmarshaller implements Unmarshaller<DescribeUploadBufferResult, JsonUnmarshallerContext> {

    

    public DescribeUploadBufferResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        DescribeUploadBufferResult describeUploadBufferResult = new DescribeUploadBufferResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("GatewayARN", targetDepth)) {
                    context.nextToken();
                    describeUploadBufferResult.setGatewayARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("DiskIds", targetDepth)) {
                    describeUploadBufferResult.setDiskIds(new ListUnmarshaller<String>(StringJsonUnmarshaller.getInstance()).unmarshall(context));
                }
                if (context.testExpression("UploadBufferUsedInBytes", targetDepth)) {
                    context.nextToken();
                    describeUploadBufferResult.setUploadBufferUsedInBytes(LongJsonUnmarshaller.getInstance().unmarshall(context));
                }
                if (context.testExpression("UploadBufferAllocatedInBytes", targetDepth)) {
                    context.nextToken();
                    describeUploadBufferResult.setUploadBufferAllocatedInBytes(LongJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return describeUploadBufferResult;
    }

    private static DescribeUploadBufferResultJsonUnmarshaller instance;
    public static DescribeUploadBufferResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new DescribeUploadBufferResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/DescribeCacheRequestMarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model.transform;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.Map;
import java.util.List;

import com.amazonaws.AmazonClientException;
import com.amazonaws.Request;
import com.amazonaws.DefaultRequest;
import com.amazonaws.http.HttpMethodName;
import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.Marshaller;
import com.amazonaws.util.StringUtils;
import com.amazonaws.util.StringInputStream;
import com.amazonaws.util.json.*;

/**
 * Describe Cache Request Marshaller
 */
public class DescribeCacheRequestMarshaller implements Marshaller<Request<DescribeCacheRequest>, DescribeCacheRequest> {

    

    public Request<DescribeCacheRequest> marshall(DescribeCacheRequest describeCacheRequest) {
		if (describeCacheRequest == null) {
		    throw new AmazonClientException("Invalid argument passed to marshall(...)");
		}

        Request<DescribeCacheRequest> request = new DefaultRequest<DescribeCacheRequest>(describeCacheRequest, "AWSStorageGateway");
        String target = "StorageGateway_20120630.DescribeCache";
        request.addHeader("X-Amz-Target", target);
        request.addHeader("Content-Type", "application/x-amz-json-1.1");

        
        request.setHttpMethod(HttpMethodName.POST);


        String uriResourcePath = ""; 
        
        uriResourcePath = uriResourcePath.replaceAll("//", "/");

        if (uriResourcePath.contains("?")) {
            String queryString = uriResourcePath.substring(uriResourcePath.indexOf("?") + 1);
            uriResourcePath    = uriResourcePath.substring(0, uriResourcePath.indexOf("?"));

            for (String s : queryString.split("[;&]")) {
                String[] nameValuePair = s.split("=");
                if (nameValuePair.length == 2) {
                    request.addParameter(nameValuePair[0], nameValuePair[1]);
                } else {
                    request.addParameter(s, null);
                }
            }
        }

        request.setResourcePath(uriResourcePath);


        
        try {
        	StringWriter stringWriter = new StringWriter();
        	JSONWriter jsonWriter = new JSONWriter(stringWriter);

        	
            
        	jsonWriter.object();
        	
            if (describeCacheRequest.getGatewayARN() != null) {
                jsonWriter.key("GatewayARN").value(describeCacheRequest.getGatewayARN());
            }

    	    jsonWriter.endObject();
        	

    	    String snippet = stringWriter.toString();
    	    byte[] content = snippet.getBytes("UTF-8");
        	request.setContent(new StringInputStream(snippet));
	        request.addHeader("Content-Length", Integer.toString(content.length));
        } catch(Throwable t) {
          throw new AmazonClientException("Unable to marshall request to JSON: " + t.getMessage(), t);
        }
        

        return request;
    }

    private String getString(String s) {
        if (s == null) return "";
        return s;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/transform/AddUploadBufferResultJsonUnmarshaller.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */

package com.amazonaws.services.storagegateway.model.transform;

import java.util.Map;
import java.util.Map.Entry;

import com.amazonaws.services.storagegateway.model.*;
import com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;
import com.amazonaws.transform.*;

import org.codehaus.jackson.JsonToken;
import static org.codehaus.jackson.JsonToken.*;

/**
 * Add Upload Buffer Result JSON Unmarshaller
 */
public class AddUploadBufferResultJsonUnmarshaller implements Unmarshaller<AddUploadBufferResult, JsonUnmarshallerContext> {

    

    public AddUploadBufferResult unmarshall(JsonUnmarshallerContext context) throws Exception {
        AddUploadBufferResult addUploadBufferResult = new AddUploadBufferResult();

        
        
        int originalDepth = context.getCurrentDepth();
        int targetDepth = originalDepth + 1;

        JsonToken token = context.currentToken;
        if (token == null) token = context.nextToken();

        while (true) {
            if (token == null) break;

            
            if (token == FIELD_NAME || token == START_OBJECT) {
                if (context.testExpression("GatewayARN", targetDepth)) {
                    context.nextToken();
                    addUploadBufferResult.setGatewayARN(StringJsonUnmarshaller.getInstance().unmarshall(context));
                }
            } else if (token == END_ARRAY || token == END_OBJECT) {
                if (context.getCurrentDepth() <= originalDepth) break;
            }
            

            token = context.nextToken();
        }
        
        return addUploadBufferResult;
    }

    private static AddUploadBufferResultJsonUnmarshaller instance;
    public static AddUploadBufferResultJsonUnmarshaller getInstance() {
        if (instance == null) instance = new AddUploadBufferResultJsonUnmarshaller();
        return instance;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/AddUploadBufferResult.java;<<<<<<< MINE
=======
/*
 * Copyright 2010-2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 * 
 *  http://aws.amazon.com/apache2.0
 * 
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
package com.amazonaws.services.storagegateway.model;

/**
 * <p>
 * The Amazon Resource Name (ARN) of the gateway for which upload buffer was configured.
 * </p>
 */
public class AddUploadBufferResult {

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     */
    private String gatewayARN;

    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @return The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public String getGatewayARN() {
        return gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     */
    public void setGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
    }
    
    /**
     * The Amazon Resource Name (ARN) of the gateway. Use the
     * <a>ListGateways</a> operation to return a list of gateways for your
     * account and region.
     * <p>
     * Returns a reference to this object so that method calls can be chained together.
     * <p>
     * <b>Constraints:</b><br/>
     * <b>Length: </b>50 - 500<br/>
     *
     * @param gatewayARN The Amazon Resource Name (ARN) of the gateway. Use the
     *         <a>ListGateways</a> operation to return a list of gateways for your
     *         account and region.
     *
     * @return A reference to this updated object so that method calls can be chained 
     *         together. 
     */
    public AddUploadBufferResult withGatewayARN(String gatewayARN) {
        this.gatewayARN = gatewayARN;
        return this;
    }
    
    
    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        if (gatewayARN != null) sb.append("GatewayARN: " + gatewayARN + ", ");
        sb.append("}");
        return sb.toString();
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;
        
        hashCode = prime * hashCode + ((getGatewayARN() == null) ? 0 : getGatewayARN().hashCode()); 
        return hashCode;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
    
        if (obj instanceof AddUploadBufferResult == false) return false;
        AddUploadBufferResult other = (AddUploadBufferResult)obj;
        
        if (other.getGatewayARN() == null ^ this.getGatewayARN() == null) return false;
        if (other.getGatewayARN() != null && other.getGatewayARN().equals(this.getGatewayARN()) == false) return false; 
        return true;
    }
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     * enabled for the iSCSI target. </li> <li>
     * <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     * object that represents a collection of iSCSI attributes for one stored
     * volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume (p. 203) objects where each object contains metadata
     * about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     * disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     * interface ID of the stored volume that initiator use to map the stored
     * volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     * The port used to communicate with iSCSI targets. </li> <li>
     * <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     * was created, existing data on the underlying local disk was preserved.
     * <p><i>Valid Values</i>: true, false </li> <li>
     * <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     * snapshot, this field contains the snapshot ID used, e.g.
     * snap-1122aabb. Otherwise, this field is not included. </li> <li>
     * <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     * target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     * of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     * of the local disk that was specified in the
     * <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     * enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     * logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     * network interface ID of the stored volume that initiator use to map
     * the stored volume as an iSCSI target. </li> <li>
     * <p><b>NetworkInterfacePort</b>: The port used to communicate with
     * iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     * if when the stored volume was created, existing data on the underlying
     * local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     * the stored volume was created from a snapshot, this field contains the
     * snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume objects where each object contains metadata about
     * one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     * Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     * Amazon Resource Name (ARN) of the stored volume. </li> <li>
     * <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     * specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     * enabled for the iSCSI target. </li> <li>
     * <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     * object that represents a collection of iSCSI attributes for one stored
     * volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume (p. 203) objects where each object contains metadata
     * about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     * disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     * interface ID of the stored volume that initiator use to map the stored
     * volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     * The port used to communicate with iSCSI targets. </li> <li>
     * <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     * was created, existing data on the underlying local disk was preserved.
     * <p><i>Valid Values</i>: true, false </li> <li>
     * <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     * snapshot, this field contains the snapshot ID used, e.g.
     * snap-1122aabb. Otherwise, this field is not included. </li> <li>
     * <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     * target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     * of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     * of the local disk that was specified in the
     * <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     * enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     * logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     * network interface ID of the stored volume that initiator use to map
     * the stored volume as an iSCSI target. </li> <li>
     * <p><b>NetworkInterfacePort</b>: The port used to communicate with
     * iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     * if when the stored volume was created, existing data on the underlying
     * local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     * the stored volume was created from a snapshot, this field contains the
     * snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume objects where each object contains metadata about
     * one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     * Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     * Amazon Resource Name (ARN) of the stored volume. </li> <li>
     * <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     * specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     *         enabled for the iSCSI target. </li> <li>
     *         <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     *         object that represents a collection of iSCSI attributes for one stored
     *         volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume (p. 203) objects where each object contains metadata
     *         about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     *         disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     *         interface ID of the stored volume that initiator use to map the stored
     *         volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     *         The port used to communicate with iSCSI targets. </li> <li>
     *         <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     *         was created, existing data on the underlying local disk was preserved.
     *         <p><i>Valid Values</i>: true, false </li> <li>
     *         <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     *         snapshot, this field contains the snapshot ID used, e.g.
     *         snap-1122aabb. Otherwise, this field is not included. </li> <li>
     *         <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     *         target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     *         of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     *         of the local disk that was specified in the
     *         <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     *         enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     *         logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     *         network interface ID of the stored volume that initiator use to map
     *         the stored volume as an iSCSI target. </li> <li>
     *         <p><b>NetworkInterfacePort</b>: The port used to communicate with
     *         iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     *         if when the stored volume was created, existing data on the underlying
     *         local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     *         the stored volume was created from a snapshot, this field contains the
     *         snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     *         included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume objects where each object contains metadata about
     *         one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     *         Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     *         Amazon Resource Name (ARN) of the stored volume. </li> <li>
     *         <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     *         specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     * enabled for the iSCSI target. </li> <li>
     * <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     * object that represents a collection of iSCSI attributes for one stored
     * volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume (p. 203) objects where each object contains metadata
     * about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     * disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     * interface ID of the stored volume that initiator use to map the stored
     * volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     * The port used to communicate with iSCSI targets. </li> <li>
     * <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     * was created, existing data on the underlying local disk was preserved.
     * <p><i>Valid Values</i>: true, false </li> <li>
     * <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     * snapshot, this field contains the snapshot ID used, e.g.
     * snap-1122aabb. Otherwise, this field is not included. </li> <li>
     * <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     * target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     * of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     * of the local disk that was specified in the
     * <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     * enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     * logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     * network interface ID of the stored volume that initiator use to map
     * the stored volume as an iSCSI target. </li> <li>
     * <p><b>NetworkInterfacePort</b>: The port used to communicate with
     * iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     * if when the stored volume was created, existing data on the underlying
     * local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     * the stored volume was created from a snapshot, this field contains the
     * snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume objects where each object contains metadata about
     * one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     * Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     * Amazon Resource Name (ARN) of the stored volume. </li> <li>
     * <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     * specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     *         enabled for the iSCSI target. </li> <li>
     *         <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     *         object that represents a collection of iSCSI attributes for one stored
     *         volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume (p. 203) objects where each object contains metadata
     *         about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     *         disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     *         interface ID of the stored volume that initiator use to map the stored
     *         volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     *         The port used to communicate with iSCSI targets. </li> <li>
     *         <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     *         was created, existing data on the underlying local disk was preserved.
     *         <p><i>Valid Values</i>: true, false </li> <li>
     *         <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     *         snapshot, this field contains the snapshot ID used, e.g.
     *         snap-1122aabb. Otherwise, this field is not included. </li> <li>
     *         <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     *         target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     *         of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     *         of the local disk that was specified in the
     *         <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     *         enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     *         logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     *         network interface ID of the stored volume that initiator use to map
     *         the stored volume as an iSCSI target. </li> <li>
     *         <p><b>NetworkInterfacePort</b>: The port used to communicate with
     *         iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     *         if when the stored volume was created, existing data on the underlying
     *         local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     *         the stored volume was created from a snapshot, this field contains the
     *         snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     *         included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume objects where each object contains metadata about
     *         one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     *         Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     *         Amazon Resource Name (ARN) of the stored volume. </li> <li>
     *         <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     *         specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     * enabled for the iSCSI target. </li> <li>
     * <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     * object that represents a collection of iSCSI attributes for one stored
     * volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume (p. 203) objects where each object contains metadata
     * about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     * disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     * interface ID of the stored volume that initiator use to map the stored
     * volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     * The port used to communicate with iSCSI targets. </li> <li>
     * <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     * was created, existing data on the underlying local disk was preserved.
     * <p><i>Valid Values</i>: true, false </li> <li>
     * <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     * snapshot, this field contains the snapshot ID used, e.g.
     * snap-1122aabb. Otherwise, this field is not included. </li> <li>
     * <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     * target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     * of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     * of the local disk that was specified in the
     * <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     * enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     * logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     * network interface ID of the stored volume that initiator use to map
     * the stored volume as an iSCSI target. </li> <li>
     * <p><b>NetworkInterfacePort</b>: The port used to communicate with
     * iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     * if when the stored volume was created, existing data on the underlying
     * local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     * the stored volume was created from a snapshot, this field contains the
     * snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume objects where each object contains metadata about
     * one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     * Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     * Amazon Resource Name (ARN) of the stored volume. </li> <li>
     * <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     * specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     *         enabled for the iSCSI target. </li> <li>
     *         <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     *         object that represents a collection of iSCSI attributes for one stored
     *         volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume (p. 203) objects where each object contains metadata
     *         about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     *         disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     *         interface ID of the stored volume that initiator use to map the stored
     *         volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     *         The port used to communicate with iSCSI targets. </li> <li>
     *         <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     *         was created, existing data on the underlying local disk was preserved.
     *         <p><i>Valid Values</i>: true, false </li> <li>
     *         <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     *         snapshot, this field contains the snapshot ID used, e.g.
     *         snap-1122aabb. Otherwise, this field is not included. </li> <li>
     *         <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     *         target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     *         of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     *         of the local disk that was specified in the
     *         <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     *         enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     *         logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     *         network interface ID of the stored volume that initiator use to map
     *         the stored volume as an iSCSI target. </li> <li>
     *         <p><b>NetworkInterfacePort</b>: The port used to communicate with
     *         iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     *         if when the stored volume was created, existing data on the underlying
     *         local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     *         the stored volume was created from a snapshot, this field contains the
     *         snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     *         included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume objects where each object contains metadata about
     *         one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     *         Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     *         Amazon Resource Name (ARN) of the stored volume. </li> <li>
     *         <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     *         specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     * enabled for the iSCSI target. </li> <li>
     * <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     * object that represents a collection of iSCSI attributes for one stored
     * volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume (p. 203) objects where each object contains metadata
     * about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     * disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     * interface ID of the stored volume that initiator use to map the stored
     * volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     * The port used to communicate with iSCSI targets. </li> <li>
     * <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     * was created, existing data on the underlying local disk was preserved.
     * <p><i>Valid Values</i>: true, false </li> <li>
     * <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     * snapshot, this field contains the snapshot ID used, e.g.
     * snap-1122aabb. Otherwise, this field is not included. </li> <li>
     * <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     * target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     * of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     * of the local disk that was specified in the
     * <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     * enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     * logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     * network interface ID of the stored volume that initiator use to map
     * the stored volume as an iSCSI target. </li> <li>
     * <p><b>NetworkInterfacePort</b>: The port used to communicate with
     * iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     * if when the stored volume was created, existing data on the underlying
     * local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     * the stored volume was created from a snapshot, this field contains the
     * snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     * included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     * StorediSCSIVolume objects where each object contains metadata about
     * one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     * Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     * Amazon Resource Name (ARN) of the stored volume. </li> <li>
     * <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     * specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/model/DescribeStorediSCSIVolumesResult.java;<<<<<<< MINE
     *         enabled for the iSCSI target. </li> <li>
     *         <p><b>VolumeiSCSIAttributes</b>: An <a>VolumeiSCSIAttributes</a>
     *         object that represents a collection of iSCSI attributes for one stored
     *         volume. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume (p. 203) objects where each object contains metadata
     *         about one stored volume. </li> <li> <p><b>LunNumber</b>: The logical
     *         disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The network
     *         interface ID of the stored volume that initiator use to map the stored
     *         volume as an iSCSI target. </li> <li> <p><b>NetworkInterfacePort</b>:
     *         The port used to communicate with iSCSI targets. </li> <li>
     *         <p><b>PreservedExistingData</b>: Indicates if when the stored volume
     *         was created, existing data on the underlying local disk was preserved.
     *         <p><i>Valid Values</i>: true, false </li> <li>
     *         <p><b>SourceSnapshotId</b>: If the stored volume was created from a
     *         snapshot, this field contains the snapshot ID used, e.g.
     *         snap-1122aabb. Otherwise, this field is not included. </li> <li>
     *         <p><b>TargetARN</b>: The Amazon Resource Name (ARN) of the volume
     *         target. </li> <li> <p><b>VolumeARN</b>: The Amazon Resource Name (ARN)
     *         of the stored volume. </li> <li> <p><b>VolumeDiskId</b>: The disk ID
     *         of the local disk that was specified in the
     *         <a>CreateStorediSCSIVolume</a> operation. </li> <li>
=======
     *         enabled for the iSCSI target. </li> <li> <p><b>LunNumber</b>: The
     *         logical disk number. </li> <li> <p><b>NetworkInterfaceId</b>: The
     *         network interface ID of the stored volume that initiator use to map
     *         the stored volume as an iSCSI target. </li> <li>
     *         <p><b>NetworkInterfacePort</b>: The port used to communicate with
     *         iSCSI targets. </li> <li> <p><b>PreservedExistingData</b>: Indicates
     *         if when the stored volume was created, existing data on the underlying
     *         local disk was preserved. </li> <li> <p><b>SourceSnapshotId</b>: If
     *         the stored volume was created from a snapshot, this field contains the
     *         snapshot ID used, e.g. snap-1122aabb. Otherwise, this field is not
     *         included. </li> <li> <p><b>StorediSCSIVolumes</b>: An array of
     *         StorediSCSIVolume objects where each object contains metadata about
     *         one stored volume. </li> <li> <p><b>TargetARN</b>: The Amazon Resource
     *         Name (ARN) of the volume target. </li> <li> <p><b>VolumeARN</b>: The
     *         Amazon Resource Name (ARN) of the stored volume. </li> <li>
     *         <p><b>VolumeDiskId</b>: The disk ID of the local disk that was
     *         specified in the <a>CreateStorediSCSIVolume</a> operation. </li> <li>
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/AWSStorageGatewayAsyncClient.java;<<<<<<< MINE
=======
     *
     * @param listGatewaysRequest Container for the necessary parameters to
     *           execute the ListGateways operation on AWSStorageGateway.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListGateways service method, as returned by AWSStorageGateway.
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AWSStorageGateway indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListGatewaysResult> listGatewaysAsync(
            final ListGatewaysRequest listGatewaysRequest,
            final AsyncHandler<ListGatewaysRequest, ListGatewaysResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<ListGatewaysResult>() {
            public ListGatewaysResult call() throws Exception {
            	ListGatewaysResult result;
                try {
            		result = listGateways(listGatewaysRequest);
            	} catch (Exception ex) {
            	    asyncHandler.onError(ex);
    				throw ex;
            	}
            	asyncHandler.onSuccess(listGatewaysRequest, result);
               	return result;
		    }
		});
    }
    
    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/AWSStorageGatewayAsyncClient.java;<<<<<<< MINE
=======
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/AWSStorageGatewayAsyncClient.java;<<<<<<< MINE
=======
     *
     * @param addUploadBufferRequest Container for the necessary parameters
     *           to execute the AddUploadBuffer operation on AWSStorageGateway.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         AddUploadBuffer service method, as returned by AWSStorageGateway.
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AWSStorageGateway indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<AddUploadBufferResult> addUploadBufferAsync(
            final AddUploadBufferRequest addUploadBufferRequest,
            final AsyncHandler<AddUploadBufferRequest, AddUploadBufferResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException {
        return executorService.submit(new Callable<AddUploadBufferResult>() {
            public AddUploadBufferResult call() throws Exception {
            	AddUploadBufferResult result;
                try {
            		result = addUploadBuffer(addUploadBufferRequest);
            	} catch (Exception ex) {
            	    asyncHandler.onError(ex);
    				throw ex;
            	}
            	asyncHandler.onSuccess(addUploadBufferRequest, result);
               	return result;
		    }
		});
    }
    
    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/AWSStorageGatewayAsync.java;<<<<<<< MINE
=======
     *
     * @param listGatewaysRequest Container for the necessary parameters to
     *           execute the ListGateways operation on AWSStorageGateway.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         ListGateways service method, as returned by AWSStorageGateway.
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AWSStorageGateway indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<ListGatewaysResult> listGatewaysAsync(ListGatewaysRequest listGatewaysRequest,
            AsyncHandler<ListGatewaysRequest, ListGatewaysResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/AWSStorageGatewayAsync.java;<<<<<<< MINE
=======
     *
     * @param createStorediSCSIVolumeRequest Container for the necessary
     *           parameters to execute the CreateStorediSCSIVolume operation on
     *           AWSStorageGateway.
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
     * 
     * @return A Java Future object containing the response from the
     *         CreateStorediSCSIVolume service method, as returned by
     *         AWSStorageGateway.
     *
     * @throws AmazonClientException
     *             If any internal errors are encountered inside the client while
     *             attempting to make the request or handle the response.  For example
     *             if a network connection is not available.
     * @throws AmazonServiceException
     *             If an error response is returned by AWSStorageGateway indicating
     *             either a problem with the data in the request, or a server side issue.
     */
    public Future<CreateStorediSCSIVolumeResult> createStorediSCSIVolumeAsync(CreateStorediSCSIVolumeRequest createStorediSCSIVolumeRequest,
            AsyncHandler<CreateStorediSCSIVolumeRequest, CreateStorediSCSIVolumeResult> asyncHandler)
                    throws AmazonServiceException, AmazonClientException;

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/aws-sdk-java/revisions/rev_50eeb45_8cee0c9/rev_50eeb45-8cee0c9/src/main/java/com/amazonaws/services/storagegateway/AWSStorageGatewayAsync.java;<<<<<<< MINE
=======
     * @param asyncHandler Asynchronous callback handler for events in the
     *           life-cycle of the request. Users could provide the implementation of
     *           the four callback methods in this interface to process the operation
     *           result or handle the exception.
>>>>>>> YOURS
