file;linedbasedConf
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_1faaddf_7d50288/rev_1faaddf-7d50288/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE

    private static AmazonAutoScaling getAmazonAutoScalingClient() {
        String aWSAccessId = eurekaConfig.getAWSAccessId();
        String aWSSecretKey = eurekaConfig.getAWSSecretKey();
        ClientConfiguration clientConfiguration = new ClientConfiguration()
                .withConnectionTimeout(eurekaConfig.getASGQueryTimeoutMs());

        if (null != aWSAccessId && !"".equals(aWSAccessId) &&
                null != aWSSecretKey && !"".equals(aWSSecretKey)) {
            return new AmazonAutoScalingClient(
                    new BasicAWSCredentials(aWSAccessId, aWSSecretKey),
                    clientConfiguration);
        }
        else
        {
            return new AmazonAutoScalingClient(
                    new InstanceProfileCredentialsProvider(),
                    clientConfiguration);
        }
    }
   
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_0dadaea_ddcda44/rev_0dadaea-ddcda44/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
    .getInstance().getConfiguration();
    private static final AmazonAutoScaling client = getAmazonAutoScalingClient();
=======
            .getInstance().getConfiguration();
    private static final AmazonAutoScaling client = new AmazonAutoScalingClient(
            new BasicAWSCredentials(eurekaConfig.getAWSAccessId(),
                    eurekaConfig.getAWSSecretKey()),
            new ClientConfiguration().withConnectionTimeout(eurekaConfig
                    .getASGQueryTimeoutMs()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_4727485_42d73d3/rev_4727485-42d73d3/eureka-core/src/main/java/com/netflix/eureka/resources/ResponseCache.java;<<<<<<< MINE
import java.util.Arrays;
=======
import java.util.Date;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
        discoveryJerseyClient = EurekaJerseyClient.createSSLJerseyClient(
                EUREKA_SERVER_CONFIG.getRemoteRegionConnectTimeoutMs(),
                EUREKA_SERVER_CONFIG.getRemoteRegionReadTimeoutMs(),
                EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnectionsPerHost(),
                EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnections(),
                EUREKA_SERVER_CONFIG.getRemoteRegionConnectionIdleTimeoutSeconds(),
                EUREKA_SERVER_CONFIG.getRemoteRegionTrustStore(),
                EUREKA_SERVER_CONFIG.getRemoteRegionTrustStorePassword());
=======
        if (remoteRegionURL.getProtocol().equals("http")) {
            discoveryJerseyClient = EurekaJerseyClient.createJerseyClient(
                    EUREKA_SERVER_CONFIG.getRemoteRegionConnectTimeoutMs(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionReadTimeoutMs(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnectionsPerHost(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnections(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionConnectionIdleTimeoutSeconds());
        } else {
            discoveryJerseyClient = EurekaJerseyClient.createSSLJerseyClient(
                    EUREKA_SERVER_CONFIG.getRemoteRegionConnectTimeoutMs(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionReadTimeoutMs(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnectionsPerHost(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnections(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionConnectionIdleTimeoutSeconds(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionTrustStore(),
                    EUREKA_SERVER_CONFIG.getRemoteRegionTrustStorePassword());
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
=======
import static com.netflix.eureka.util.EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS;
import static com.netflix.eureka.util.EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
=======
import java.util.Set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
    protected List<RemoteRegionRegistry> remoteRegionRegistryList = new ArrayList<RemoteRegionRegistry>();
=======
    protected Map<String, RemoteRegionRegistry> regionNameVSRemoteRegistry = new HashMap<String, RemoteRegionRegistry>();
    protected String[] allKnownRemoteRegions = new String[0];
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
    public Application getApplication(String appName,
                                      boolean includeRemoteRegion) {
=======
    public Application getApplication(String appName, boolean includeRemoteRegion) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            for (RemoteRegionRegistry remoteRegistry : this.remoteRegionRegistryList) {
                Application application = remoteRegistry
                        .getApplication(appName);
=======
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
        return this.getApplications(true);
=======
        return this.getApplications(true); // keeping the current behavior of not mixing two regions in the same app.
    }

    /**
     * Returns applications including instances from all remote regions. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with a <code>null</code> argument.
     */
    public Applications getApplicationsFromAllRemoteRegions() {
        return getApplicationsFromMultipleRegions(null);
    }

    /**
     * Returns applications including instances from local region only. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with an empty array.
     */
    public Applications getApplicationsFromLocalRegionOnly() {
        return getApplicationsFromMultipleRegions(new String[0]);
    }

    /**
     * This method will return applications with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     * The application instances for which this union will be done can be restricted to the names returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for every region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     * If you are not selectively requesting for a remote region, use {@link #getApplicationsFromAllRemoteRegions()}
     * or {@link #getApplicationsFromLocalRegionOnly()}
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The applications with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be only for certain whitelisted apps as explained above.
     */
    public Applications getApplicationsFromMultipleRegions(@Nullable String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
        } else {
            GET_ALL_CACHE_MISS.increment();
        }
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : _registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }
                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                if (null != remoteRegistry) {
                    Applications remoteApps = remoteRegistry.getApplications();
                    for (Application application : remoteApps.getRegisteredApplications()) {
                        if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                            Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                            if (appInstanceTillNow == null) {
                                appInstanceTillNow = new Application(application.getName());
                                apps.addApplication(appInstanceTillNow);
                            }
                            for (InstanceInfo instanceInfo : application.getInstances()) {
                                appInstanceTillNow.addInstance(instanceInfo);
                            }
                        }
                    }
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    /**
     * This method will return an application with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    @Nullable
    public Application getApplicationFromMultipleRegions(String appName, @Nullable String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        Application app = null;

        Map<String, Lease<InstanceInfo>> leaseMap = _registry.get(appName);

        if (leaseMap != null && leaseMap.size() > 0) {
            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {
                if (app == null) {
                    app = new Application(appName);
                }
                app.addInstance(decorateInstanceInfo(entry.getValue()));
            }
        }

        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                if (shouldFetchFromRemoteRegistry(appName, remoteRegion)) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Application remoteApp = remoteRegistry.getApplication(appName);
                        if (null != remoteApp) {
                            if (null == app) {
                                app = new Application(appName);
                            }
                            for (InstanceInfo instanceInfo : remoteApp.getInstances()) {
                                app.addInstance(instanceInfo);
                            }
                        }
                    }
                }
            }
        }
        return app;
    }

    private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {
        Set<String> whiteList = eurekaConfig.getRemoteRegionAppWhitelist(remoteRegion);
        if (null == whiteList) {
            whiteList = eurekaConfig.getRemoteRegionAppWhitelist(null); // see global whitelist.
        }
        return null == whiteList || whiteList.contains(appName);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            for (RemoteRegionRegistry remoteRegistry : this.remoteRegionRegistryList) {
=======
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue
                    .iterator();
=======
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            for (RemoteRegionRegistry remoteRegistry : this.remoteRegionRegistryList) {
                Applications applications = remoteRegistry
                        .getApplicationDeltas();
                for (Application application : applications
                        .getRegisteredApplications()) {
                    Application appInLocalRegistry = allAppsInLocalRegion
                            .getRegisteredApplications(application.getName());
=======
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Applications applications = remoteRegistry.getApplicationDeltas();
                for (Application application : applications.getRegisteredApplications()) {
                    Application appInLocalRegistry = allAppsInLocalRegion.getRegisteredApplications(application.getName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = { instanceInfo.getId(),
                                  instanceInfo.getStatus().name(),
                                  instanceInfo.getActionType().name() };
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
=======
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = { instanceInfo.getId(),
                                  instanceInfo.getStatus().name(),
                                  instanceInfo.getActionType().name() };
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
     * @param includeRemoteRegion
=======
     * @param includeRemoteRegions
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            for (RemoteRegionRegistry remoteRegistry : this.remoteRegionRegistryList) {
=======
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
     * @param includeRemoteRegion
=======
     * @param includeRemoteRegions
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            for (RemoteRegionRegistry remoteRegistry : this.remoteRegionRegistryList) {
=======
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            String[] remoteRegionUrls = eurekaConfig.getRemoteRegionUrls();
            if (remoteRegionUrls != null) {
                for (String remoteRegionUrl : remoteRegionUrls) {
                    RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(
                            new URL(remoteRegionUrl));
                    remoteRegionRegistryList.add(remoteRegionRegistry);
=======
            Map<String, String> remoteRegionUrlsWithName = eurekaConfig.getRemoteRegionUrlsWithName();
            if (remoteRegionUrlsWithName != null) {
                allKnownRemoteRegions = new String[remoteRegionUrlsWithName.size()];
                int remoteRegionArrayIndex = 0;
                for (Entry<String, String> remoteRegionUrlWithName : remoteRegionUrlsWithName.entrySet()) {
                    RemoteRegionRegistry remoteRegionRegistry = new RemoteRegionRegistry(new URL(remoteRegionUrlWithName.getValue()));
                    regionNameVSRemoteRegistry.put(remoteRegionUrlWithName.getKey(), remoteRegionRegistry);
                    allKnownRemoteRegions[remoteRegionArrayIndex++] = remoteRegionUrlWithName.getKey();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE
=======
import java.util.Map;
import java.util.Set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE
=======
     * Get a map of region name against remote region discovery url.
     *
     * @return - An unmodifiable map of remote region name against remote region discovery url. Empty map if no remote region url
     * is defined.
     */
    Map<String, String> getRemoteRegionUrlsWithName();

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE
=======
     * @deprecated Use {@link #getRemoteRegionUrlsWithName()}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE
     * Get the time interval for which the registryinformation need to be fetched from the remote region.
=======
     * Returns a list of applications that must be retrieved from the passed remote region. <br/>
     * This list can be <code>null</code> which means that no filtering should be applied on the applications
     * for this region i.e. all applications must be returned. <br/>
     * A global whitelist can also be configured which can be used when no setting is available for a region, such a
     * whitelist can be obtained by passing <code>null</code> to this method.
     *
     * @param regionName Name of the region for which the application whitelist is to be retrieved. If null a global
     *                   setting is returned.
     *
     * @return A set of application names which must be retrieved from the passed region. If <code>null</code> all
     * applications must be retrieved.
     */
    @Nullable
    Set<String> getRemoteRegionAppWhitelist(@Nullable String regionName);

    /**
     * Get the time interval for which the registry information need to be fetched from the remote region.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java;<<<<<<< MINE
    RENEW("renewCounter", "Number of total renews seen since startup"), CANCEL(
            "cancelCounter", "Number of total cancels seen since startup"), GET_ALL_CACHE_MISS(
            "getAllCacheMissCounter",
            "Number of total registery queries seen since startup"), GET_ALL_CACHE_MISS_DELTA(
            "getAllCacheMissDeltaCounter",
            "Number of total registery queries for delta seen since startup"), GET_ALL_DELTA(
            "getAllDeltaCounter", "Number of total deltas since startup"), GET_ALL(
            "getAllCounter",
            "Number of total registry queries seen since startup"), REGISTER(
            "registerCounter", "Number of total registers seen since startup"), EXPIRED(
            "expiredCounter", "Number of total expired leases since startup"), STATUS_UPDATE(
            "statusUpdateCounter",
            "Number of total admin status updates since startup"), CANCEL_NOT_FOUND(
            "cancelNotFoundCounter",
            "Number of total cancel requests on non-existing instance since startup"), RENEW_NOT_FOUND(
            "renewNotFoundexpiredCounter",
            "Number of total renew on non-existing instance since startup"), REJECTED_REPLICATIONS(
            "numOfRejectedReplications",
            "Number of replications rejected because of full queue"), FAILED_REPLICATIONS(
            "numOfFailedReplications",
            "Number of failed replications - likely from timeouts");
=======
    RENEW("renewCounter", "Number of total renews seen since startup"),
    CANCEL("cancelCounter", "Number of total cancels seen since startup"),
    GET_ALL_CACHE_MISS("getAllCacheMissCounter", "Number of total registery queries seen since startup"),
    GET_ALL_CACHE_MISS_DELTA("getAllCacheMissDeltaCounter", "Number of total registery queries for delta seen since startup"),
    GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS("getAllWithRemoteRegionCacheMissCounter", "Number of total registry with remote region queries seen since startup"),
    GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA("getAllWithRemoteRegionCacheMissDeltaCounter", "Number of total registry queries for delta with remote region seen since startup"),
    GET_ALL_DELTA("getAllDeltaCounter", "Number of total deltas since startup"),
    GET_ALL_DELTA_WITH_REMOTE_REGIONS("getAllDeltaWithRemoteRegionCounter", "Number of total deltas with remote regions since startup"),
    GET_ALL("getAllCounter", "Number of total registry queries seen since startup"),
    GET_ALL_WITH_REMOTE_REGIONS("getAllWithRemoteRegionCounter", "Number of total registry queries with remote regions, seen since startup"),
    REGISTER("registerCounter", "Number of total registers seen since startup"),
    EXPIRED("expiredCounter", "Number of total expired leases since startup"),
    STATUS_UPDATE("statusUpdateCounter", "Number of total admin status updates since startup"),
    CANCEL_NOT_FOUND("cancelNotFoundCounter", "Number of total cancel requests on non-existing instance since startup"),
    RENEW_NOT_FOUND("renewNotFoundexpiredCounter", "Number of total renew on non-existing instance since startup"),
    REJECTED_REPLICATIONS("numOfRejectedReplications", "Number of replications rejected because of full queue"),
    FAILED_REPLICATIONS("numOfFailedReplications", "Number of failed replications - likely from timeouts");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
        for (RemoteRegionRegistry remoteRegionRegistry : this.remoteRegionRegistryList) {
=======
        for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/resources/ResponseCache.java;<<<<<<< MINE
=======
    private final com.netflix.servo.monitor.Timer serializeAllAppsWithRemoteRegionTimer = Monitors
            .newTimer("serialize-all_remote_region");
    private final com.netflix.servo.monitor.Timer serializeDeltaAppsWithRemoteRegionTimer = Monitors
            .newTimer("serialize-all-delta_remote_region");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
    @Nullable
    @Override
    public Set<String> getRemoteRegionAppWhitelist(@Nullable String regionName) {
        if (null == regionName) {
            regionName = "global";
        } else {
            regionName = regionName.trim().toLowerCase();
        }
        DynamicStringProperty appWhiteListProp =
                configInstance.getStringProperty(namespace + "remoteRegion." + regionName + ".appWhiteList", null);
        if (null == appWhiteListProp || null == appWhiteListProp.get()) {
            return null;
        } else {
            String appWhiteListStr = appWhiteListProp.get();
            String[] whitelistEntries = appWhiteListStr.split(",");
            return new HashSet<String>(Arrays.asList(whitelistEntries));
        }
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
package com.netflix.eureka.mock;

import com.netflix.discovery.converters.XmlXStream;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import org.mortbay.jetty.Request;
import org.mortbay.jetty.Server;
import org.mortbay.jetty.handler.AbstractHandler;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

/**
 * @author Nitesh Kant
 */
public class MockRemoteEurekaServer {

    public static final String EUREKA_API_BASE_PATH = "/eureka/v2/";

    private final Map<String, Application> applicationMap;
    private final Map<String, Application> applicationDeltaMap;
    private final Server server;
    private boolean sentDelta;

    public MockRemoteEurekaServer(int port, Map<String, Application> applicationMap,
                                  Map<String, Application> applicationDeltaMap) {
        this.applicationMap = applicationMap;
        this.applicationDeltaMap = applicationDeltaMap;
        server = new Server(port);
        server.setHandler(new AppsResourceHandler());
    }

    public void start() throws Exception {
        server.start();
    }

    public void stop() throws Exception {
        server.stop();
    }

    public boolean isSentDelta() {
        return sentDelta;
    }

    private class AppsResourceHandler extends AbstractHandler {

        @Override
        public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch)
                throws IOException, ServletException {
            String pathInfo = request.getPathInfo();
            System.out.println(
                    "Eureka resource mock, received request on path: " + pathInfo + ". HTTP method: |" + request
                            .getMethod() + "|");
            boolean handled = false;
            if (null != pathInfo && pathInfo.startsWith("")) {
                pathInfo = pathInfo.substring(EUREKA_API_BASE_PATH.length());
                if (pathInfo.startsWith("apps/delta")) {
                    Applications apps = new Applications();
                    for (Application application : applicationDeltaMap.values()) {
                        apps.addApplication(application);
                    }
                    apps.setAppsHashCode(apps.getReconcileHashCode());
                    sendOkResponseWithContent((Request) request, response, XmlXStream.getInstance().toXML(apps));
                    handled = true;
                    sentDelta = true;
                } else if(pathInfo.startsWith("apps")) {
                    Applications apps = new Applications();
                    for (Application application : applicationMap.values()) {
                        apps.addApplication(application);
                    }
                    apps.setAppsHashCode(apps.getReconcileHashCode());
                    sendOkResponseWithContent((Request) request, response, XmlXStream.getInstance().toXML(apps));
                    handled = true;
                }
            }

            if(!handled) {
                response.sendError(HttpServletResponse.SC_NOT_FOUND,
                                   "Request path: " + pathInfo + " not supported by eureka resource mock.");
            }
        }

        private void sendOkResponseWithContent(Request request, HttpServletResponse response, String content)
                throws IOException {
            response.setContentType("application/xml");
            response.setStatus(HttpServletResponse.SC_OK);
            response.getWriter().println(content);
            response.getWriter().flush();
            request.setHandled(true);
            System.out.println("Eureka resource mock, sent response for request path: " + request.getPathInfo());
        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/test/java/com/netflix/eureka/TestDefaultEurekaServerConfig.java;<<<<<<< MINE
=======
package com.netflix.eureka;

import com.netflix.config.ConfigurationManager;
import junit.framework.Assert;
import org.junit.Test;

import java.util.Map;
import java.util.Set;

/**
 * @author Nitesh Kant
 */
public class TestDefaultEurekaServerConfig {

    @Test
    public void testRemoteRegionUrlsWithName2Regions() throws Exception {
        String region1 = "myregion1";
        String region1url = "http://local:888/eee";
        String region2 = "myregion2";
        String region2url = "http://local:888/eee";
        ConfigurationManager.getConfigInstance().setProperty("eureka.remoteRegionUrlsWithName", region1
                                                                                                + ";" + region1url
                                                                                                + "," + region2
                                                                                                + ";" + region2url);
        DefaultEurekaServerConfig config = new DefaultEurekaServerConfig();
        Map<String,String> remoteRegionUrlsWithName = config.getRemoteRegionUrlsWithName();

        Assert.assertEquals("Unexpected remote region url count.", 2, remoteRegionUrlsWithName.size());
        Assert.assertTrue("Remote region 1 not found.", remoteRegionUrlsWithName.containsKey(region1));
        Assert.assertTrue("Remote region 2 not found.", remoteRegionUrlsWithName.containsKey(region2));
        Assert.assertEquals("Unexpected remote region 1 url.", region1url, remoteRegionUrlsWithName.get(region1));
        Assert.assertEquals("Unexpected remote region 2 url.", region2url, remoteRegionUrlsWithName.get(region2));

    }

    @Test
    public void testRemoteRegionUrlsWithName1Region() throws Exception {
        String region1 = "myregion1";
        String region1url = "http://local:888/eee";
        ConfigurationManager.getConfigInstance().setProperty("eureka.remoteRegionUrlsWithName", region1
                                                                                                + ";" + region1url);
        DefaultEurekaServerConfig config = new DefaultEurekaServerConfig();
        Map<String,String> remoteRegionUrlsWithName = config.getRemoteRegionUrlsWithName();

        Assert.assertEquals("Unexpected remote region url count.", 1, remoteRegionUrlsWithName.size());
        Assert.assertTrue("Remote region 1 not found.", remoteRegionUrlsWithName.containsKey(region1));
        Assert.assertEquals("Unexpected remote region 1 url.", region1url, remoteRegionUrlsWithName.get(region1));

    }

    @Test
    public void testGetGlobalAppWhiteList() throws Exception {
        String whitelistApp = "myapp";
        ConfigurationManager.getConfigInstance().setProperty("eureka.remoteRegion.global.appWhiteList", whitelistApp);
        DefaultEurekaServerConfig config = new DefaultEurekaServerConfig();
        Set<String> globalList = config.getRemoteRegionAppWhitelist(null);
        Assert.assertNotNull("Global whitelist is null.", globalList);
        Assert.assertEquals("Global whitelist not as expected.", 1, globalList.size());
        Assert.assertEquals("Global whitelist not as expected.", whitelistApp, globalList.iterator().next());
    }

    @Test
    public void testGetRegionAppWhiteList() throws Exception {
        String globalWhiteListApp = "myapp";
        String regionWhiteListApp = "myapp";
        ConfigurationManager.getConfigInstance().setProperty("eureka.remoteRegion.global.appWhiteList", globalWhiteListApp);
        ConfigurationManager.getConfigInstance().setProperty("eureka.remoteRegion.region1.appWhiteList", regionWhiteListApp);
        DefaultEurekaServerConfig config = new DefaultEurekaServerConfig();
        Set<String> regionList = config.getRemoteRegionAppWhitelist(null);
        Assert.assertNotNull("Region whitelist is null.", regionList);
        Assert.assertEquals("Region whitelist not as expected.", 1, regionList.size());
        Assert.assertEquals("Region whitelist not as expected.", regionWhiteListApp, regionList.iterator().next());
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/test/java/com/netflix/eureka/InstanceRegistryTest.java;<<<<<<< MINE
=======
package com.netflix.eureka;

import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.DataCenterInfo;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.MyDataCenterInstanceConfig;
import com.netflix.config.ConfigurationManager;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.Pair;
import com.netflix.eureka.mock.MockRemoteEurekaServer;
import junit.framework.Assert;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * @author Nitesh Kant
 */
public class InstanceRegistryTest {

    public static final int REMOTE_REGION_PORT = 7777;
    private final Map<String, Application> remoteRegionApps = new HashMap<String, Application>();
    private final Map<String, Application> remoteRegionAppsDelta = new HashMap<String, Application>();

    private List<Pair<String, String>> registeredApps = new ArrayList<Pair<String, String>>();
    private MockRemoteEurekaServer mockRemoteEurekaServer;
    private InstanceRegistry registry;
    public static final String REMOTE_REGION_APP_NAME = "MYAPP";
    public static final String REMOTE_REGION_INSTANCE_1_HOSTNAME = "blah";

    public static final String LOCAL_REGION_APP_NAME = "MYLOCAPP";
    public static final String LOCAL_REGION_INSTANCE_1_HOSTNAME = "blahloc";
    public static final String LOCAL_REGION_INSTANCE_2_HOSTNAME = "blahloc2";

    @Before
    public void setUp() throws Exception {
        ConfigurationManager.getConfigInstance().setProperty("eureka.deltaRetentionTimerIntervalInMs",
                                                             "600000");
        ConfigurationManager.getConfigInstance().setProperty("eureka.remoteRegion.registryFetchIntervalInSeconds",
                                                             "5");
        ConfigurationManager.getConfigInstance().setProperty("eureka.remoteRegionUrlsWithName",
                                                             "myregion;http://localhost:" + REMOTE_REGION_PORT + "/" +
                                                             MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
        populateRemoteRegistryAtStartup();
        mockRemoteEurekaServer = new MockRemoteEurekaServer(REMOTE_REGION_PORT, remoteRegionApps, remoteRegionAppsDelta);
        mockRemoteEurekaServer.start();

        EurekaServerConfig serverConfig = new DefaultEurekaServerConfig();
        EurekaServerConfigurationManager.getInstance().setConfiguration(serverConfig);
        ApplicationInfoManager.getInstance().initComponent(new MyDataCenterInstanceConfig());
        registry = new InstanceRegistry() {

            @Override
            public boolean isLeaseExpirationEnabled() {
                return false;
            }

            @Override
            public InstanceInfo getNextServerFromEureka(String virtualHostname, boolean secure) {
                return null;
            }
        };
        registry.initRemoteRegionRegistry();
    }

    @After
    public void tearDown() throws Exception {
        mockRemoteEurekaServer.stop();
        for (Pair<String, String> registeredApp : registeredApps) {
            System.out.println("Canceling application: " + registeredApp.first() + " from local registry.");
            registry.cancel(registeredApp.first(), registeredApp.second(), false);
        }
        remoteRegionApps.clear();
        remoteRegionAppsDelta.clear();
        ConfigurationManager.getConfigInstance().clearProperty("eureka.remoteRegionUrls");
        ConfigurationManager.getConfigInstance().clearProperty("eureka.deltaRetentionTimerIntervalInMs");
    }

    @Test
    public void testGetAppsFromAllRemoteRegions() throws Exception {
        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from remote registry", REMOTE_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsDeltaFromAllRemoteRegions() throws Exception {
        testGetAppsFromAllRemoteRegions(); // to add to registry

        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME)); /// local delta
        waitForDeltaToBeRetrieved();
        Applications appDelta = registry.getApplicationDeltasFromMultipleRegions(null);
        List<Application> registeredApplications = appDelta.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 2, registeredApplications.size());
        Application locaApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                locaApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app in delta.", locaApplication);
        Assert.assertEquals("Local registry app instance count in delta not as expected.", 1,
                            locaApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app in delta", remApplication);
        Assert.assertEquals("Remote registry app instance count  in delta not as expected.", 1,
                            remApplication.getInstances().size());
    }

    private void waitForDeltaToBeRetrieved() throws InterruptedException {
        int count = 0;
        while (count < 3 && !mockRemoteEurekaServer.isSentDelta()) {
            System.out.println("Sleeping for 10 seconds to let the remote registry fetch delta. Attempt: " + count);
            Thread.sleep(10 * 1000);
            System.out.println("Done sleeping for 10 seconds to let the remote registry fetch delta");
        }
    }

    @Test
    public void testGetAppsFromLocalRegionOnly() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromLocalRegionOnly();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from local region do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from local registry", LOCAL_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsFromBothRegions() throws Exception {
        registerInstanceLocally(createRemoteInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from both regions do not match", 2, registeredApplications.size());
        Application locaApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                locaApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app", locaApplication);
        Assert.assertEquals("Local registry app instance count not as expected.", 1,
                            locaApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app", remApplication);
        Assert.assertEquals("Remote registry app instance count not as expected.", 2,
                            remApplication.getInstances().size());

    }

    private void registerInstanceLocally(InstanceInfo remoteInstance) {
        registry.register(remoteInstance, 10000000, false);
        registeredApps.add(new Pair<String, String>(LOCAL_REGION_APP_NAME, LOCAL_REGION_APP_NAME));
    }

    private void populateRemoteRegistryAtStartup() {
        Application myapp = createRemoteApps();
        Application myappDelta = createRemoteAppsDelta();
        remoteRegionApps.put(REMOTE_REGION_APP_NAME, myapp);
        remoteRegionAppsDelta.put(REMOTE_REGION_APP_NAME, myappDelta);
    }

    private Application createRemoteApps() {
        Application myapp = new Application(REMOTE_REGION_APP_NAME);
        InstanceInfo instanceInfo = createRemoteInstance(REMOTE_REGION_INSTANCE_1_HOSTNAME);
        //instanceInfo.setActionType(InstanceInfo.ActionType.MODIFIED);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private Application createRemoteAppsDelta() {
        Application myapp = new Application(REMOTE_REGION_APP_NAME);
        InstanceInfo instanceInfo = createRemoteInstance(REMOTE_REGION_INSTANCE_1_HOSTNAME);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private InstanceInfo createRemoteInstance(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = InstanceInfo.Builder.newBuilder();
        instanceBuilder.setAppName(REMOTE_REGION_APP_NAME);
        instanceBuilder.setHostName(instanceHostName);
        instanceBuilder.setIPAddr("10.10.101.1");
        instanceBuilder.setDataCenterInfo(new DataCenterInfo() {
            @Override
            public Name getName() {
                return Name.MyOwn;
            }
        });
        return instanceBuilder.build();
    }

    private Application createLocalApps() {
        Application myapp = new Application(LOCAL_REGION_APP_NAME);
        InstanceInfo instanceInfo = createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private InstanceInfo createLocalInstance(String hostname) {
        InstanceInfo.Builder instanceBuilder = InstanceInfo.Builder.newBuilder();
        instanceBuilder.setAppName(LOCAL_REGION_APP_NAME);
        instanceBuilder.setHostName(hostname);
        instanceBuilder.setIPAddr("10.10.101.1");
        instanceBuilder.setDataCenterInfo(new DataCenterInfo() {
            @Override
            public Name getName() {
                return Name.MyOwn;
            }
        });
        return instanceBuilder.build();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
=======
import com.google.common.base.Preconditions;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
=======
import com.netflix.discovery.InstanceRegionChecker;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
    private Set<InstanceInfo> instances;
=======
    private final Set<InstanceInfo> instances;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
        instancesMap.remove(i.getId());
        synchronized (instances) {
            instances.remove(i);
            isDirty = true;
        }
=======
        removeInstance(i, true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
        List<InstanceInfo> instanceInfoList = null;
=======
        _shuffleAndStoreInstances(filterUpInstances, false, null, null, null);
    }

    public void shuffleAndStoreInstances(Map<String, Applications> remoteRegionsRegistry,
                                         EurekaClientConfig clientConfig, InstanceRegionChecker instanceRegionChecker) {
        _shuffleAndStoreInstances(clientConfig.shouldFilterOnlyUpInstances(), true, remoteRegionsRegistry, clientConfig,
                                  instanceRegionChecker);
    }

    private void _shuffleAndStoreInstances(boolean filterUpInstances, boolean indexByRemoteRegions,
                                           @Nullable Map<String, Applications> remoteRegionsRegistry,
                                           @Nullable EurekaClientConfig clientConfig,
                                           @Nullable InstanceRegionChecker instanceRegionChecker) {
        List<InstanceInfo> instanceInfoList;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
        if (filterUpInstances) {
=======
        if (indexByRemoteRegions || filterUpInstances) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
                if (!InstanceStatus.UP.equals(instanceInfo.getStatus())) {
=======
                if (filterUpInstances && !InstanceStatus.UP.equals(instanceInfo.getStatus())) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
=======
                } else if (indexByRemoteRegions && null != instanceRegionChecker && null != clientConfig
                           && null != remoteRegionsRegistry) {
                    String instanceRegion = instanceRegionChecker.getInstanceRegion(instanceInfo);
                    if (!instanceRegionChecker.isLocalRegion(instanceRegion)) {
                        Applications appsForRemoteRegion = remoteRegionsRegistry.get(instanceRegion);
                        if (null == appsForRemoteRegion) {
                            appsForRemoteRegion = new Applications();
                            remoteRegionsRegistry.put(instanceRegion, appsForRemoteRegion);
                        }

                        Application remoteApp = appsForRemoteRegion.getRegisteredApplications(instanceInfo.getAppName());
                        if (null == remoteApp) {
                            remoteApp = new Application(instanceInfo.getAppName());
                            appsForRemoteRegion.addApplication(remoteApp);
                        }

                        remoteApp.addInstance(instanceInfo);
                        this.removeInstance(instanceInfo, false);
                        it.remove();
                    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
    
    
=======

    private void removeInstance(InstanceInfo i, boolean markAsDirty) {
        instancesMap.remove(i.getId());
        synchronized (instances) {
            instances.remove(i);
            if (markAsDirty) {
                isDirty = true;
            }
        }
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
=======
import com.netflix.discovery.InstanceRegionChecker;
import com.sun.jersey.api.client.Client;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
        Map<String, AtomicInteger> instanceCountMap = new TreeMap<String, AtomicInteger>();
=======
        TreeMap<String, AtomicInteger> instanceCountMap = new TreeMap<String, AtomicInteger>();
        populateInstanceCountMap(instanceCountMap);
        return getReconcileHashCode(instanceCountMap);
    }

    public void populateInstanceCountMap(TreeMap<String, AtomicInteger> instanceCountMap) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
=======
    }

    public static String getReconcileHashCode(TreeMap<String, AtomicInteger> instanceCountMap) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
=======
        _shuffleInstances(filterUpInstances, false, null, null, null);
    }

    public void shuffleAndIndexInstances(Map<String, Applications> remoteRegionsRegistry, EurekaClientConfig clientConfig,
                                         InstanceRegionChecker instanceRegionChecker) {
        _shuffleInstances(clientConfig.shouldFilterOnlyUpInstances(), true, remoteRegionsRegistry, clientConfig,
                          instanceRegionChecker);
    }

    private void _shuffleInstances(boolean filterUpInstances, boolean indexByRemoteRegions,
                                   @Nullable Map<String, Applications> remoteRegionsRegistry,
                                   @Nullable EurekaClientConfig clientConfig,
                                   @Nullable InstanceRegionChecker instanceRegionChecker) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
            application.shuffleAndStoreInstances(filterUpInstances);
=======
            if (indexByRemoteRegions) {
                application.shuffleAndStoreInstances(remoteRegionsRegistry, clientConfig, instanceRegionChecker);
            } else {
                application.shuffleAndStoreInstances(filterUpInstances);
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/InstanceRegionChecker.java;<<<<<<< MINE
=======
package com.netflix.discovery;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.DataCenterInfo;
import com.netflix.appinfo.InstanceInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.Map;

import static com.netflix.discovery.DefaultEurekaClientConfig.DEFAULT_ZONE;

/**
 * @author Nitesh Kant
 */
public class InstanceRegionChecker {

    private static final Logger logger = LoggerFactory.getLogger(InstanceRegionChecker.class);

    private final Map<String, String> availabilityZoneVsRegion = new HashMap<String, String>();
    private final String localRegion;

    InstanceRegionChecker(String remoteRegionsToFetch, EurekaClientConfig clientConfig) {
        localRegion = clientConfig.getRegion();
        if (null != remoteRegionsToFetch) {
            String[] remoteRegions = remoteRegionsToFetch.split(",");
            for (String remoteRegion : remoteRegions) {
                String[] availabilityZones = clientConfig.getAvailabilityZones(remoteRegion);
                if (null == availabilityZones ||
                    (availabilityZones.length == 1 && availabilityZones[0].equals(DEFAULT_ZONE))) {
                    String msg = "No availability zone information available for remote region: " + remoteRegion +
                                 ". This is required if registry information for this region is configured to be fetched.";
                    logger.error(msg);
                    throw new RuntimeException(msg);
                } else {
                    for (String availabilityZone : availabilityZones) {
                        availabilityZoneVsRegion.put(availabilityZone, remoteRegion);
                    }
                }
            }
        }
    }


    @Nullable
    public String getInstanceRegion(InstanceInfo instanceInfo) {
        if (DataCenterInfo.Name.Amazon.equals(instanceInfo.getDataCenterInfo().getName())) {
            Map<String, String> metadata = instanceInfo.getMetadata();
            String availabilityZone = metadata.get(AmazonInfo.MetaDataKey.availabilityZone.getName());
            if (null != availabilityZone) {
                return availabilityZoneVsRegion.get(availabilityZone);
            }
        }

        return null;
    }

    public boolean isInstanceInLocalRegion(InstanceInfo instanceInfo) {
        String instanceRegion = getInstanceRegion(instanceInfo);
        return isLocalRegion(instanceRegion);
    }

    public boolean isLocalRegion(@Nullable String instanceRegion) {
        return null == instanceRegion || instanceRegion.equals(localRegion); // no region == local
    }

    public String getLocalRegion() {
        return localRegion;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
=======
    public static final String DEFAULT_ZONE = "defaultZone";
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
=======
    @Nullable
    @Override
    public String fetchRegistryForRemoteRegions() {
        return configInstance.getStringProperty(namespace + "fetchRemoteRegionsRegistry", null).get();
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
                        "defaultZone").get().split(",");
=======
                        DEFAULT_ZONE).get().split(",");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
=======
     * Comma separated list of regions for which the eureka registry information will be fetched. It is mandatory to
     * define the availability zones for each of these regions as returned by {@link #getAvailabilityZones(String)}.
     * Failing to do so, will result in failure of discovery client startup.
     *
     * @return Comma separated list of regions for which the eureka registry information will be fetched.
     * <code>null</code> if no remote region has to be fetched.
     */
    @Nullable
    String fetchRegistryForRemoteRegions();

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
     * 
=======
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
import java.util.Collections;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            .newTimer(PREFIX + "Register");;
=======
            .newTimer(PREFIX + "Register");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private volatile AtomicReference<Applications> applications = new AtomicReference<Applications>();
=======
    private volatile AtomicReference<Applications> localRegionApps = new AtomicReference<Applications>();
    private volatile Map<String, Applications> remoteRegionVsApps = new ConcurrentHashMap<String, Applications>();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    private final String remoteRegionsToFetch;
    private final InstanceRegionChecker instanceRegionChecker;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            applications.set(new Applications());
=======
            localRegionApps.set(new Applications());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE

=======
            remoteRegionsToFetch = clientConfig.fetchRegistryForRemoteRegions();
            instanceRegionChecker = new InstanceRegionChecker(remoteRegionsToFetch, clientConfig);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        return applications.get();
=======
        return localRegionApps.get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    public List<InstanceInfo> getInstancesByVipAddress(String vipAddress,
            boolean secure) {
=======
    public List<InstanceInfo> getInstancesByVipAddress(String vipAddress, boolean secure) {
        return getInstancesByVipAddress(vipAddress, secure, instanceRegionChecker.getLocalRegion());
    }

    /**
     * Gets the list of instances matching the given VIP Address in the passed region.
     *
     * @param vipAddress - The VIP address to match the instances for.
     * @param secure - true if it is a secure vip address, false otherwise
     * @param region - region from which the instances are to be fetched.
     *
     * @return - The list of {@link InstanceInfo} objects matching the criteria, empty list if not instances found.
     */
    public List<InstanceInfo> getInstancesByVipAddress(String vipAddress, boolean secure, String region) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
        Applications applications;
        if (instanceRegionChecker.isLocalRegion(region)) {
            applications = this.localRegionApps.get();
        } else {
            applications = remoteRegionVsApps.get(region);
            if (null == region) {
                logger.debug("No applications are defined for region {}, so returning an empty instance list for vip address {}.",
                             region, vipAddress);
                return Collections.emptyList();
            }
        }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            return this.applications.get().getInstancesByVirtualHostName(
                    vipAddress);
=======
            return applications.getInstancesByVirtualHostName(vipAddress);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            return this.applications.get().getInstancesBySecureVirtualHostName(
                    vipAddress);
=======
            return applications.getInstancesBySecureVirtualHostName(vipAddress);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        Applications apps = this.applications.get();
=======
        Applications apps = this.localRegionApps.get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        InstanceInfo instanceInfo = instanceInfoList.get(index);
        return instanceInfo;
=======
        return instanceInfoList.get(index);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        if (instanceInfo != null) {
=======
        if (instanceInfo != null && shouldRegister(instanceInfo)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
            Applications applications = getApplications();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    || (getApplications() == null)
                    || (getApplications().getRegisteredApplications().size() == 0)
=======
                    || (applications == null)
                    || (applications.getRegisteredApplications().size() == 0)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    || (getApplications().getVersion() == -1)) {
=======
                    || (applications.getVersion() == -1)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                        (getApplications() == null));
=======
                        (applications == null));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                        (getApplications().getRegisteredApplications().size() == 0));
                logger.info("Application version is -1: {}", (getApplications()
=======
                        (applications.getRegisteredApplications().size() == 0));
                logger.info("Application version is -1: {}", (applications
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    String reconcileHashCode = getApplications()
                            .getReconcileHashCode();
=======
                    String reconcileHashCode = getReconcileHashCode(applications);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    private String getReconcileHashCode(Applications applications) {
        TreeMap<String, AtomicInteger> instanceCountMap = new TreeMap<String, AtomicInteger>();
        if (isFetchingRemoteRegionRegistries()) {
            for (Applications remoteApp : remoteRegionVsApps.values()) {
                remoteApp.populateInstanceCountMap(instanceCountMap);
            }
        }
        applications.populateInstanceCountMap(instanceCountMap);
        return Applications.getReconcileHashCode(instanceCountMap);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            applications.set(this.filterAndShuffle(apps));
=======
            localRegionApps.set(this.filterAndShuffle(apps));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        Applications serverApps = (Applications) response
                .getEntity(Applications.class);
=======
        Applications serverApps = response.getEntity(Applications.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            Map<String, List<String>> reconcileDiffMap = getApplications()
            .getReconcileMapDiff(serverApps);
=======
            Map<String, List<String>> reconcileDiffMap = getApplications().getReconcileMapDiff(serverApps);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            for (Map.Entry<String, List<String>> mapEntry : reconcileDiffMap
                    .entrySet()) {
=======
            for (Map.Entry<String, List<String>> mapEntry : reconcileDiffMap.entrySet()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        applications.set(this.filterAndShuffle(serverApps));
=======
        localRegionApps.set(this.filterAndShuffle(serverApps));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private void updateDelta(Applications delta) {
=======
    private void
    updateDelta(Applications delta) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
                Applications applications = getApplications();
                String instanceRegion = instanceRegionChecker.getInstanceRegion(instance);
                if (!instanceRegionChecker.isLocalRegion(instanceRegion)) {
                    Applications remoteApps = remoteRegionVsApps.get(instanceRegion);
                    if (null == remoteApps) {
                        remoteApps = new Applications();
                        remoteRegionVsApps.put(instanceRegion, remoteApps);
                    }
                    applications = remoteApps;
                }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    Application existingApp = getApplications()
=======
                    Application existingApp = applications
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                        getApplications().addApplication(app);
=======
                        applications.addApplication(app);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    logger.debug("Added instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
=======
                    logger.debug("Added instance {} to the existing apps in region {}",
                            instance.getId(), instanceRegion);
                    applications.getRegisteredApplications(
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    Application existingApp = getApplications()
=======
                    Application existingApp = applications
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                        getApplications().addApplication(app);
=======
                        applications.addApplication(app);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                            instance.getId());
=======
                                 instance.getId());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    getApplications().getRegisteredApplications(
=======
                    applications.getRegisteredApplications(
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    Application existingApp = getApplications()
=======
                    Application existingApp = applications
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                        getApplications().addApplication(app);
=======
                        applications.addApplication(app);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                            instance.getId());
                    getApplications().getRegisteredApplications(
=======
                                 instance.getId());
                    applications.getRegisteredApplications(
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        getApplications().shuffleInstances(
                clientConfig.shouldFilterOnlyUpInstances());
=======
        getApplications().shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());

        for (Applications applications : remoteRegionVsApps.values()) {
            applications.setVersion(delta.getVersion());
            applications.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
                if (isFetchingRemoteRegionRegistries()) {
                    urlPath += "?regions=" + remoteRegionsToFetch;
                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
                if (isFetchingRemoteRegionRegistries()) {
                    urlPath += "?regions=" + remoteRegionsToFetch;
                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    applications.set(this.filterAndShuffle(apps));
=======
                    localRegionApps.set(this.filterAndShuffle(apps));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            apps.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());
=======
            if (isFetchingRemoteRegionRegistries()) {
                Map<String, Applications> remoteRegionVsApps = new ConcurrentHashMap<String, Applications>();
                apps.shuffleAndIndexInstances(remoteRegionVsApps, clientConfig, instanceRegionChecker);
                for (Applications applications : remoteRegionVsApps.values()) {
                    applications.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());
                }
                this.remoteRegionVsApps = remoteRegionVsApps;
            } else {
                apps.shuffleInstances(clientConfig.shouldFilterOnlyUpInstances());
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
   
=======

    private boolean isFetchingRemoteRegionRegistries() {
        return null != remoteRegionsToFetch;
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
package com.netflix.discovery;

import com.netflix.discovery.converters.XmlXStream;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import org.mortbay.jetty.Request;
import org.mortbay.jetty.Server;
import org.mortbay.jetty.handler.AbstractHandler;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

/**
 * @author Nitesh Kant
 */
public class MockRemoteEurekaServer {

    public static final String EUREKA_API_BASE_PATH = "/eureka/v2/";

    private final Map<String, Application> applicationMap;
    private final Map<String, Application> remoteRegionApps;
    private final Map<String, Application> remoteRegionAppsDelta;
    private final Map<String, Application> applicationDeltaMap;
    private final Server server;
    private boolean sentDelta;

    public MockRemoteEurekaServer(int port, Map<String, Application> localRegionApps,
                                  Map<String, Application> localRegionAppsDelta,
                                  Map<String, Application> remoteRegionApps,
                                  Map<String, Application> remoteRegionAppsDelta) {
        this.applicationMap = localRegionApps;
        this.applicationDeltaMap = localRegionAppsDelta;
        this.remoteRegionApps = remoteRegionApps;
        this.remoteRegionAppsDelta = remoteRegionAppsDelta;
        server = new Server(port);
        server.setHandler(new AppsResourceHandler());
    }

    public void start() throws Exception {
        server.start();
    }

    public void stop() throws Exception {
        server.stop();
    }

    public boolean isSentDelta() {
        return sentDelta;
    }

    private class AppsResourceHandler extends AbstractHandler {

        @Override
        public void handle(String target, HttpServletRequest request, HttpServletResponse response, int dispatch)
                throws IOException, ServletException {
            String pathInfo = request.getPathInfo();
            System.out.println(
                    "Eureka resource mock, received request on path: " + pathInfo + ". HTTP method: |" + request
                            .getMethod() + "|" + ", query string: " + request.getQueryString());
            boolean handled = false;
            if (null != pathInfo && pathInfo.startsWith("")) {
                pathInfo = pathInfo.substring(EUREKA_API_BASE_PATH.length());
                boolean includeRemote = isRemoteRequest(request);

                if (pathInfo.startsWith("apps/delta")) {
                    Applications apps = new Applications();
                    apps.setVersion(100l);
                    if (!sentDelta) {
                        addDeltaApps(includeRemote, apps);
                    }
                    apps.setAppsHashCode(getDeltaAppsHashCode(includeRemote));
                    sendOkResponseWithContent((Request) request, response, XmlXStream.getInstance().toXML(apps));
                    handled = true;
                    sentDelta = true;
                } else if(pathInfo.startsWith("apps")) {
                    Applications apps = new Applications();
                    apps.setVersion(100l);
                    for (Application application : applicationMap.values()) {
                        apps.addApplication(application);
                    }
                    if (includeRemote) {
                        for (Application application : remoteRegionApps.values()) {
                            apps.addApplication(application);
                        }
                    }

                    if (sentDelta) {
                        addDeltaApps(includeRemote, apps);
                    }
                    apps.setAppsHashCode(apps.getReconcileHashCode());
                    sendOkResponseWithContent((Request) request, response, XmlXStream.getInstance().toXML(apps));
                    handled = true;
                }
            }

            if(!handled) {
                response.sendError(HttpServletResponse.SC_NOT_FOUND,
                                   "Request path: " + pathInfo + " not supported by eureka resource mock.");
            }
        }

        private void addDeltaApps(boolean includeRemote, Applications apps) {
            for (Application application : applicationDeltaMap.values()) {
                apps.addApplication(application);
            }
            if (includeRemote) {
                for (Application application : remoteRegionAppsDelta.values()) {
                    apps.addApplication(application);
                }
            }
        }

        private String getDeltaAppsHashCode(boolean includeRemote) {
            Applications allApps = new Applications();
            for (Application application : applicationMap.values()) {
                allApps.addApplication(application);
            }

            if (includeRemote) {
                for (Application application : remoteRegionApps.values()) {
                    allApps.addApplication(application);
                }
            }
            addDeltaApps(includeRemote, allApps);
            return allApps.getReconcileHashCode();
        }

        private boolean isRemoteRequest(HttpServletRequest request) {
            String queryString = request.getQueryString();
            return queryString.contains("regions=");
        }

        private void sendOkResponseWithContent(Request request, HttpServletResponse response, String content)
                throws IOException {
            response.setContentType("application/xml");
            response.setStatus(HttpServletResponse.SC_OK);
            response.getWriter().println(content);
            response.getWriter().flush();
            request.setHandled(true);
            System.out.println("Eureka resource mock, sent response for request path: " + request.getPathInfo());
        }
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientTest.java;<<<<<<< MINE
=======
package com.netflix.discovery;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.DataCenterInfo;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.config.ConfigurationManager;
import com.netflix.discovery.shared.Application;
import junit.framework.Assert;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import javax.annotation.Nullable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * @author Nitesh Kant
 */
public class DiscoveryClientTest {

    public static final String ALL_REGIONS_VIP_ADDR = "myvip";
    public static final String REMOTE_REGION_INSTANCE_1_HOSTNAME = "blah";
    public static final String REMOTE_REGION_INSTANCE_2_HOSTNAME = "blah2";

    public static final String LOCAL_REGION_APP_NAME = "MYAPP_LOC";
    public static final String LOCAL_REGION_INSTANCE_1_HOSTNAME = "blahloc";
    public static final String LOCAL_REGION_INSTANCE_2_HOSTNAME = "blahloc2";

    public static final String REMOTE_REGION_APP_NAME = "MYAPP";
    public static final String REMOTE_REGION = "myregion";
    public static final String REMOTE_ZONE = "myzone";

    private MockRemoteEurekaServer mockLocalEurekaServer;
    private final Map<String, Application> localRegionApps = new HashMap<String, Application>();
    private final Map<String, Application> localRegionAppsDelta = new HashMap<String, Application>();
    private final Map<String, Application> remoteRegionApps = new HashMap<String, Application>();
    private final Map<String, Application> remoteRegionAppsDelta = new HashMap<String, Application>();

    private DiscoveryClient client;
    public static final int LOCAL_EUREKA_PORT = 7799;

    @Before
    public void setUp() throws Exception {
        ConfigurationManager.getConfigInstance().setProperty("eureka.client.refresh.interval", "10");
        ConfigurationManager.getConfigInstance().setProperty("eureka.registration.enabled", "false");
        ConfigurationManager.getConfigInstance().setProperty("eureka.fetchRemoteRegionsRegistry", REMOTE_REGION);
        ConfigurationManager.getConfigInstance().setProperty("eureka.myregion.availabilityZones", REMOTE_ZONE);
        ConfigurationManager.getConfigInstance().setProperty("eureka.serviceUrl.default",
                                                             "http://localhost:" + LOCAL_EUREKA_PORT +
                                                             MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
        populateLocalRegistryAtStartup();
        populateRemoteRegistryAtStartup();

        mockLocalEurekaServer = new MockRemoteEurekaServer(LOCAL_EUREKA_PORT, localRegionApps, localRegionAppsDelta,
                                                           remoteRegionApps, remoteRegionAppsDelta);
        mockLocalEurekaServer.start();

        InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder();
        builder.setIPAddr("10.10.101.00");
        builder.setHostName("Hosttt");
        builder.setAppName("EurekaTestApp-" + UUID.randomUUID());
        builder.setDataCenterInfo(new DataCenterInfo() {
            @Override
            public Name getName() {
                return Name.MyOwn;
            }
        });
        client = new DiscoveryClient(builder.build(), new DefaultEurekaClientConfig());
    }

    @After
    public void tearDown() throws Exception {
        client.shutdown();
        ConfigurationManager.getConfigInstance().clearProperty("eureka.client.refresh.interval");
        ConfigurationManager.getConfigInstance().clearProperty("eureka.registration.enabled");
        ConfigurationManager.getConfigInstance().clearProperty("eureka.fetchRemoteRegionsRegistry");
        ConfigurationManager.getConfigInstance().clearProperty("eureka.myregion.availabilityZones");
        ConfigurationManager.getConfigInstance().clearProperty("eureka.serviceUrl.default");
        mockLocalEurekaServer.stop();
        localRegionApps.clear();
        localRegionAppsDelta.clear();
        remoteRegionApps.clear();
        remoteRegionAppsDelta.clear();
    }

    @Test
    public void testGetByVipInLocalRegion() throws Exception {
        List<InstanceInfo> instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false);
        Assert.assertEquals("Unexpected number of instances found for local region.", 1, instancesByVipAddress.size());
        InstanceInfo instance = instancesByVipAddress.iterator().next();
        Assert.assertEquals("Local instance not returned for local region vip address",
                            LOCAL_REGION_INSTANCE_1_HOSTNAME, instance.getHostName());
    }

    @Test
    public void testGetByVipInRemoteRegion() throws Exception {
        List<InstanceInfo> instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false, REMOTE_REGION);
        Assert.assertEquals("Unexpected number of instances found for remote region.", 1, instancesByVipAddress.size());
        InstanceInfo instance = instancesByVipAddress.iterator().next();
        Assert.assertEquals("Remote instance not returned for remote region vip address", REMOTE_REGION_INSTANCE_1_HOSTNAME, instance.getHostName());
    }

    @Test
    public void testDelta() throws Exception {
        waitForDeltaToBeRetrieved();

        checkInstancesFromARegion("local", LOCAL_REGION_INSTANCE_1_HOSTNAME,
                                  LOCAL_REGION_INSTANCE_2_HOSTNAME);
        checkInstancesFromARegion(REMOTE_REGION, REMOTE_REGION_INSTANCE_1_HOSTNAME,
                                  REMOTE_REGION_INSTANCE_2_HOSTNAME);
    }

    private void checkInstancesFromARegion(String region, String instance1Hostname, String instance2Hostname) {
        List<InstanceInfo> instancesByVipAddress;
        if (region.equals("local")) {
            instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false);
        } else {
            instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false, region);
        }
        Assert.assertEquals("Unexpected number of instances found for " + region + " region.", 2,
                            instancesByVipAddress.size());
        InstanceInfo localInstance1 = null;
        InstanceInfo localInstance2 = null;
        for (InstanceInfo instance : instancesByVipAddress) {
            if (instance.getHostName().equals(instance1Hostname)) {
                localInstance1 = instance;
            } else if (instance.getHostName().equals(instance2Hostname)) {
                localInstance2 = instance;
            }
        }

        Assert.assertNotNull("Expected instance not returned for " + region + " region vip address", localInstance1);
        Assert.assertNotNull("Instance added as delta not returned for " + region + " region vip address", localInstance2);
    }

    private void waitForDeltaToBeRetrieved() throws InterruptedException {
        int count = 0;
        while (count < 3 && !mockLocalEurekaServer.isSentDelta()) {
            System.out.println("Sleeping for 10 seconds to let the remote registry fetch delta. Attempt: " + count);
            Thread.sleep(10 * 1000);
            System.out.println("Done sleeping for 10 seconds to let the remote registry fetch delta");
        }
    }

    private void populateRemoteRegistryAtStartup() {
        Application myapp = createRemoteApps();
        Application myappDelta = createRemoteAppsDelta();
        remoteRegionApps.put(REMOTE_REGION_APP_NAME, myapp);
        remoteRegionAppsDelta.put(REMOTE_REGION_APP_NAME, myappDelta);
    }

    private Application createRemoteApps() {
        Application myapp = new Application(REMOTE_REGION_APP_NAME);
        InstanceInfo instanceInfo = createRemoteInstance(REMOTE_REGION_INSTANCE_1_HOSTNAME);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private Application createRemoteAppsDelta() {
        Application myapp = new Application(REMOTE_REGION_APP_NAME);
        InstanceInfo instanceInfo = createRemoteInstance(REMOTE_REGION_INSTANCE_2_HOSTNAME);
        instanceInfo.setActionType(InstanceInfo.ActionType.ADDED);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private InstanceInfo createRemoteInstance(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = InstanceInfo.Builder.newBuilder();
        instanceBuilder.setAppName(REMOTE_REGION_APP_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP_ADDR);
        instanceBuilder.setHostName(instanceHostName);
        instanceBuilder.setIPAddr("10.10.101.1");
        AmazonInfo amazonInfo = getAmazonInfo(REMOTE_ZONE, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
    }

    private void populateLocalRegistryAtStartup() {
        Application myapp = createLocalApps();
        Application myappDelta = createLocalAppsDelta();
        localRegionApps.put(LOCAL_REGION_APP_NAME, myapp);
        localRegionAppsDelta.put(LOCAL_REGION_APP_NAME, myappDelta);
    }

    private Application createLocalApps() {
        Application myapp = new Application(LOCAL_REGION_APP_NAME);
        InstanceInfo instanceInfo = createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private Application createLocalAppsDelta() {
        Application myapp = new Application(LOCAL_REGION_APP_NAME);
        InstanceInfo instanceInfo = createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME);
        instanceInfo.setActionType(InstanceInfo.ActionType.ADDED);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private InstanceInfo createLocalInstance(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = InstanceInfo.Builder.newBuilder();
        instanceBuilder.setAppName(LOCAL_REGION_APP_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP_ADDR);
        instanceBuilder.setHostName(instanceHostName);
        instanceBuilder.setIPAddr("10.10.101.1");
        AmazonInfo amazonInfo = getAmazonInfo(null, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
    }

    private AmazonInfo getAmazonInfo(@Nullable String availabilityZone, String instanceHostName) {
        AmazonInfo.Builder azBuilder = AmazonInfo.Builder.newBuilder();
        azBuilder.addMetadata(AmazonInfo.MetaDataKey.availabilityZone, (null == availabilityZone) ? "us-east-1a" : availabilityZone);
        azBuilder.addMetadata(AmazonInfo.MetaDataKey.instanceId, instanceHostName);
        azBuilder.addMetadata(AmazonInfo.MetaDataKey.amiId, "XXX");
        azBuilder.addMetadata(AmazonInfo.MetaDataKey.instanceType, "XXX");
        azBuilder.addMetadata(AmazonInfo.MetaDataKey.localIpv4, "XXX");
        azBuilder.addMetadata(AmazonInfo.MetaDataKey.publicIpv4, "XXX");
        azBuilder.addMetadata(AmazonInfo.MetaDataKey.publicHostname, instanceHostName);
        return azBuilder.build();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            this.eventBus = eventBus;
=======
            scheduler = Executors.newScheduledThreadPool(4);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;<<<<<<< MINE
        final int eurekaPort = localRandomEurekaPort + (int)(Math.random() * 10);
        ConfigurationManager.getConfigInstance().setProperty("eureka.registration.enabled", "false");
        ConfigurationManager.getConfigInstance().setProperty("eureka.serviceUrl.default",
                                                             "http://localhost:" + eurekaPort +
                                                             MockRemoteEurekaServer.EUREKA_API_BASE_PATH);

        mockLocalEurekaServer = new MockRemoteEurekaServer(eurekaPort, Collections.<String, Application>emptyMap(),
=======
        mockLocalEurekaServer = new MockRemoteEurekaServer(Collections.<String, Application>emptyMap(),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
        mockLocalEurekaServer = new MockRemoteEurekaServer(eurekaPort, localRegionApps, localRegionAppsDelta,
                                                           remoteRegionApps, remoteRegionAppsDelta);
        mockLocalEurekaServer.start();

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
    private final int port;
=======
    private int port;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
    public MockRemoteEurekaServer(int port, Map<String, Application> localRegionApps,
=======
    public MockRemoteEurekaServer(Map<String, Application> localRegionApps,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
=======
    /*
     * (non-Javadoc)
     *
     * @see com.netflix.discovery.EurekaClientConfig#getRegistryRefreshSingleVipAddress()
     */
    @Override
    public String getRegistryRefreshSingleVipAddress() {
        return configInstance.getStringProperty(
                namespace + "registryRefreshSingleVipAddress", null).get();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
=======

    /**
     * Indicates whether the client is only interested in the registry information for a single VIP.
     *
     * @return the address of the VIP (name:port).
     * <code>null</code> if single VIP interest is not present.
     */
    @Nullable
    String getRegistryRefreshSingleVipAddress();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
import com.google.common.base.Strings;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            if (clientConfig.shouldDisableDelta() || forceFullRegistryFetch || (applications == null)
                    || (applications.getRegisteredApplications().size() == 0)
                    // The client application does not have the latest library
                    // supporting delta
                    || (applications.getVersion() == -1)) {
=======
            if (clientConfig.shouldDisableDelta()
                || (!Strings.isNullOrEmpty(clientConfig.getRegistryRefreshSingleVipAddress()))
                || forceFullRegistryFetch
                || (applications == null)
                || (applications.getRegisteredApplications().size() == 0)
                || (applications.getVersion() == -1)) //Client application does not have latest library supporting delta
            {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
                logger.info("Single vip registry refresh property : {}", clientConfig.getRegistryRefreshSingleVipAddress());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                urlPath = "apps/";
=======
                final String vipAddress = clientConfig.getRegistryRefreshSingleVipAddress();
                urlPath = vipAddress == null ? "apps/" : "vips/" + vipAddress;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
import java.rmi.dgc.Lease;
import java.util.Arrays;
import java.util.List;
=======
import java.util.Arrays;
import java.util.List;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    public static final String ALL_REGIONS_VIP_ADDR = "myvip";
    public static final String REMOTE_REGION_INSTANCE_1_HOSTNAME = "blah";
    public static final String REMOTE_REGION_INSTANCE_2_HOSTNAME = "blah2";
    public static final String LOCAL_REGION_APP_NAME = "MYAPP_LOC";
    public static final String LOCAL_REGION_INSTANCE_1_HOSTNAME = "blahloc";
    public static final String LOCAL_REGION_INSTANCE_2_HOSTNAME = "blahloc2";
    public static final String REMOTE_REGION_APP_NAME = "MYAPP";
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE

    public static final String ALL_REGIONS_VIP1_ADDR = "myvip1";
    public static final String REMOTE_REGION_APP1_INSTANCE1_HOSTNAME = "blah1-1";
    public static final String REMOTE_REGION_APP1_INSTANCE2_HOSTNAME = "blah1-2";
    public static final String LOCAL_REGION_APP1_NAME = "MYAPP1_LOC";
    public static final String LOCAL_REGION_APP1_INSTANCE1_HOSTNAME = "blahloc1-1";
    public static final String LOCAL_REGION_APP1_INSTANCE2_HOSTNAME = "blahloc1-2";
    public static final String REMOTE_REGION_APP1_NAME = "MYAPP1";

    public static final String ALL_REGIONS_VIP2_ADDR = "myvip2";
    public static final String REMOTE_REGION_APP2_INSTANCE1_HOSTNAME = "blah2-1";
    public static final String REMOTE_REGION_APP2_INSTANCE2_HOSTNAME = "blah2-2";
    public static final String REMOTE_REGION_APP2_INSTANCE3_HOSTNAME = "blah2-3";
    public static final String LOCAL_REGION_APP2_NAME = "MYAPP2_LOC";
    public static final String LOCAL_REGION_APP2_INSTANCE1_HOSTNAME = "blahloc2-1";
    public static final String LOCAL_REGION_APP2_INSTANCE2_HOSTNAME = "blahloc2-2";
    public static final String LOCAL_REGION_APP2_INSTANCE3_HOSTNAME = "blahloc2-3";
    public static final String REMOTE_REGION_APP2_NAME = "MYAPP2";

=======

    public static final String ALL_REGIONS_VIP1_ADDR = "myvip1";
    public static final String REMOTE_REGION_APP1_INSTANCE1_HOSTNAME = "blah1-1";
    public static final String REMOTE_REGION_APP1_INSTANCE2_HOSTNAME = "blah1-2";
    public static final String LOCAL_REGION_APP1_NAME = "MYAPP1_LOC";
    public static final String LOCAL_REGION_APP1_INSTANCE1_HOSTNAME = "blahloc1-1";
    public static final String LOCAL_REGION_APP1_INSTANCE2_HOSTNAME = "blahloc1-2";
    public static final String REMOTE_REGION_APP1_NAME = "MYAPP1";

    public static final String ALL_REGIONS_VIP2_ADDR = "myvip2";
    public static final String REMOTE_REGION_APP2_INSTANCE1_HOSTNAME = "blah2-1";
    public static final String REMOTE_REGION_APP2_INSTANCE2_HOSTNAME = "blah2-2";
    public static final String LOCAL_REGION_APP2_NAME = "MYAPP2_LOC";
    public static final String LOCAL_REGION_APP2_INSTANCE1_HOSTNAME = "blahloc2-1";
    public static final String LOCAL_REGION_APP2_INSTANCE2_HOSTNAME = "blahloc2-2";
    public static final String REMOTE_REGION_APP2_NAME = "MYAPP2";

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
=======
        setupDiscoveryClient();
    }

    protected void setupDiscoveryClient() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
        for (Application app : createRemoteApps()) {
            mockLocalEurekaServer.addRemoteRegionApps(app.getName(), app);
        }

        for (Application appDelta : createRemoteAppsDelta()) {
            mockLocalEurekaServer.addRemoteRegionAppsDelta(appDelta.getName(), appDelta);
        }
    }
=======
        for (Application app : createRemoteApps()) {
            mockLocalEurekaServer.addRemoteRegionApps(app.getName(), app);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static List<Application> createRemoteApps() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(REMOTE_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, REMOTE_REGION_APP1_INSTANCE1_HOSTNAME, null);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(REMOTE_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, REMOTE_REGION_APP2_INSTANCE1_HOSTNAME, null);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
    }

    private static List<Application> createRemoteAppsDelta() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(REMOTE_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, REMOTE_REGION_APP1_INSTANCE2_HOSTNAME, null);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(REMOTE_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, REMOTE_REGION_APP2_INSTANCE2_HOSTNAME, null);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
=======
        for (Application appDelta : createRemoteAppsDelta()) {
            mockLocalEurekaServer.addRemoteRegionAppsDelta(appDelta.getName(), appDelta);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private void populateLocalRegistryAtStartup() {
        for (Application app : createLocalApps()) {
            mockLocalEurekaServer.addLocalRegionApps(app.getName(), app);
        }

        for (Application appDelta : createLocalAppsDelta()) {
            mockLocalEurekaServer.addLocalRegionAppsDelta(appDelta.getName(), appDelta);
        }
=======
    private static List<Application> createRemoteApps() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createRemoteInstanceForApp1(REMOTE_REGION_APP1_INSTANCE1_HOSTNAME);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createRemoteInstanceForApp2(REMOTE_REGION_APP2_INSTANCE1_HOSTNAME);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    protected void addLocalAppDelta() {
        Application myappDelta = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo = createInstance(LOCAL_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, LOCAL_REGION_APP2_INSTANCE3_HOSTNAME, null);
        instanceInfo.setActionType(InstanceInfo.ActionType.ADDED);
        myappDelta.addInstance(instanceInfo);
        mockLocalEurekaServer.addLocalRegionAppsDelta(LOCAL_REGION_APP2_NAME, myappDelta);
=======
    private static List<Application> createRemoteAppsDelta() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createRemoteInstanceForApp1(REMOTE_REGION_APP1_INSTANCE2_HOSTNAME);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createRemoteInstanceForApp2(REMOTE_REGION_APP2_INSTANCE2_HOSTNAME);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static List<Application> createLocalApps() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(LOCAL_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, LOCAL_REGION_APP1_INSTANCE1_HOSTNAME, null);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(LOCAL_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, LOCAL_REGION_APP2_INSTANCE1_HOSTNAME, null);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
=======
    private static InstanceInfo createRemoteInstanceForApp1(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(REMOTE_REGION_APP1_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP1_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(REMOTE_ZONE, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
    }

    private static InstanceInfo createRemoteInstanceForApp2(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(REMOTE_REGION_APP2_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP2_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(REMOTE_ZONE, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static List<Application> createLocalAppsDelta() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(LOCAL_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, LOCAL_REGION_APP1_INSTANCE2_HOSTNAME, null);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(LOCAL_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, LOCAL_REGION_APP2_INSTANCE2_HOSTNAME, null);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
=======
    private void populateLocalRegistryAtStartup() {
        for (Application app : createLocalApps()) {
            mockLocalEurekaServer.addLocalRegionApps(app.getName(), app);
        }

        for (Application appDelta : createLocalAppsDelta()) {
            mockLocalEurekaServer.addLocalRegionAppsDelta(appDelta.getName(), appDelta);
        }
    }

    private static List<Application> createLocalApps() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createLocalInstanceForApp1(LOCAL_REGION_APP1_INSTANCE1_HOSTNAME);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createLocalInstanceForApp2(LOCAL_REGION_APP2_INSTANCE1_HOSTNAME);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
    }

    private static List<Application> createLocalAppsDelta() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createLocalInstanceForApp1(LOCAL_REGION_APP1_INSTANCE2_HOSTNAME);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createLocalInstanceForApp2(LOCAL_REGION_APP2_INSTANCE2_HOSTNAME);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static InstanceInfo createInstance(String appName, String vipAddress, String instanceHostName, String zone) {
=======
    private static InstanceInfo.Builder createBaseInstance(String instanceHostName) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
        instanceBuilder.setAppName(appName);
        instanceBuilder.setVIPAddress(vipAddress);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
        instanceBuilder.setLeaseInfo(LeaseInfo.Builder.newBuilder().build());
        AmazonInfo amazonInfo = getAmazonInfo(zone, instanceHostName);
=======
        instanceBuilder.setLeaseInfo(LeaseInfo.Builder.newBuilder().build());
        return instanceBuilder;
    }

    private static InstanceInfo createLocalInstanceForApp1(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(LOCAL_REGION_APP1_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP1_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(null, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
    }

    private static InstanceInfo createLocalInstanceForApp2(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(LOCAL_REGION_APP2_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP2_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(null, instanceHostName);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
=======
import com.netflix.config.ConfigurationManager;
import com.netflix.discovery.shared.Application;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
        List<InstanceInfo> instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false);
=======
        List<InstanceInfo> instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP1_ADDR, false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
                            LOCAL_REGION_INSTANCE_1_HOSTNAME, instance.getHostName());
=======
                LOCAL_REGION_APP1_INSTANCE1_HOSTNAME, instance.getHostName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
=======
    public void testCacheRefreshSingleAppForLocalRegion() throws Exception {
        final String propertyName = "eureka.registryRefreshSingleVipAddress";
        try {
            if (client != null) {
                client.shutdown();  // shutdown and restart the client to pick up the config
            }

            ConfigurationManager.getConfigInstance().setProperty(propertyName, ALL_REGIONS_VIP1_ADDR);
            setupDiscoveryClient();

            List<Application> registeredApps = client.getApplications().getRegisteredApplications();
            Assert.assertEquals(1, registeredApps.size());

            Application app = registeredApps.get(0);
            Assert.assertEquals(LOCAL_REGION_APP1_NAME, app.getName());

            List<InstanceInfo> instances = app.getInstances();
            Assert.assertEquals(1, instances.size());
        } finally {
            ConfigurationManager.getConfigInstance().clearProperty(propertyName);
        }
    }

    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
        List<InstanceInfo> instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false, REMOTE_REGION);
=======
        List<InstanceInfo> instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP1_ADDR, false, REMOTE_REGION);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
        Assert.assertEquals("Remote instance not returned for remote region vip address", REMOTE_REGION_INSTANCE_1_HOSTNAME, instance.getHostName());
=======
        Assert.assertEquals("Remote instance not returned for remote region vip address", REMOTE_REGION_APP1_INSTANCE1_HOSTNAME, instance.getHostName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
        checkInstancesFromARegion("local", LOCAL_REGION_APP1_INSTANCE1_HOSTNAME,
                LOCAL_REGION_APP1_INSTANCE2_HOSTNAME);
        checkInstancesFromARegion(REMOTE_REGION, REMOTE_REGION_APP1_INSTANCE1_HOSTNAME,
                REMOTE_REGION_APP1_INSTANCE2_HOSTNAME);
    }

    @Test
    public void testAppsHashCodeAfterRefresh() throws Exception {
        Assert.assertEquals("UP_2_", client.getApplications().getAppsHashCode());

        addLocalAppDelta();
        mockLocalEurekaServer.waitForDeltaToBeRetrieved(CLIENT_REFRESH_RATE);

        Assert.assertEquals("UP_3_", client.getApplications().getAppsHashCode());
=======
        checkInstancesFromARegion("local", LOCAL_REGION_APP1_INSTANCE1_HOSTNAME,
                LOCAL_REGION_APP1_INSTANCE2_HOSTNAME);
        checkInstancesFromARegion(REMOTE_REGION, REMOTE_REGION_APP1_INSTANCE1_HOSTNAME,
                REMOTE_REGION_APP1_INSTANCE2_HOSTNAME);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
            instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false);
=======
            instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP1_ADDR, false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
            instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP_ADDR, false, region);
=======
            instancesByVipAddress = client.getInstancesByVipAddress(ALL_REGIONS_VIP1_ADDR, false, region);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
import com.netflix.appinfo.InstanceInfo;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
                } else if (pathInfo.startsWith("vips/")) {
                    String vipAddress = pathInfo.substring("vips/".length());
                    Applications apps = new Applications();
                    apps.setVersion(-1l);
                    for (Application application : applicationMap.values()) {
                        Application retApp = new Application(application.getName());
                        for (InstanceInfo instance : application.getInstances()) {
                            if (vipAddress.equals(instance.getVIPAddress())) {
                                retApp.addInstance(instance);
                            }
                        }

                        if (retApp.getInstances().size() > 0) {
                            apps.addApplication(retApp);
                        }
                    }

                    apps.setAppsHashCode(apps.getReconcileHashCode());
                    sendOkResponseWithContent((Request) request, response, apps);
                    handled = true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
import com.google.common.base.Strings;
import com.netflix.appinfo.AbstractEurekaIdentity;
import com.netflix.servo.monitor.DynamicCounter;
import com.netflix.servo.monitor.MonitorConfig;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
=======
import com.google.common.base.Strings;
import com.netflix.appinfo.AbstractEurekaIdentity;
import com.netflix.servo.monitor.DynamicCounter;
import com.netflix.servo.monitor.MonitorConfig;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
        if ( EurekaServerConfigurationManager.getInstance().getConfiguration().shouldLogIdentityHeaders() ) {
=======
        if (EurekaServerConfigurationManager.getInstance().getConfiguration().shouldLogIdentityHeaders()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
=======
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
=======
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.ActionType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.ActionType;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
            Applications delta, String reconcileHashCode) throws Throwable {
=======
                                                     Applications delta, String reconcileHashCode) throws Throwable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

import com.netflix.discovery.converters.StringCache;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
import com.netflix.discovery.converters.StringCache;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
        .getString(EUREKA_DATACENTER);
=======
                .getString(EUREKA_DATACENTER);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
    throws InterruptedException {
=======
            throws InterruptedException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
         // Bind to EIP if needed
=======
        // Bind to EIP if needed
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
               try {
                    if (eipManager.isEIPBound()) {
                        break;
                    } else {
                        eipManager.bindEIP();
                    }
                } catch (Throwable e) {
                    logger.error("Cannot bind to EIP", e);
                    Thread.sleep(EIP_BIND_SLEEP_TIME_MS);
=======
            try {
                if (eipManager.isEIPBound()) {
                    break;
                } else {
                    eipManager.bindEIP();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
            } catch (Throwable e) {
                logger.error("Cannot bind to EIP", e);
                Thread.sleep(EIP_BIND_SLEEP_TIME_MS);
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
       // Schedule a timer which periodically checks for EIP binding.
=======
        // Schedule a timer which periodically checks for EIP binding.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
            @Override
            public void run() {
                try {
                    // If the EIP is not bound, the registry could  be stale
                    // First sync up the registry from the neighboring node before
                    // trying to bind the EIP
                    EIPManager eipManager = EIPManager.getInstance();
                    if (!eipManager.isEIPBound()) {
                        registry.clearRegistry();
                        int count = registry.syncUp();
                        registry.openForTraffic(count);
                    } else {
                        // An EIP is already bound
                        return;
                    }
                    eipManager.bindEIP();
                } catch (Throwable e) {
                    logger.error("Could not bind to EIP", e);
                }
            }
        }, eurekaServerConfig.getEIPBindingRetryIntervalMs(),
        eurekaServerConfig.getEIPBindingRetryIntervalMs());
=======
                           @Override
                           public void run() {
                               try {
                                   // If the EIP is not bound, the registry could  be stale
                                   // First sync up the registry from the neighboring node before
                                   // trying to bind the EIP
                                   EIPManager eipManager = EIPManager.getInstance();
                                   if (!eipManager.isEIPBound()) {
                                       registry.clearRegistry();
                                       int count = registry.syncUp();
                                       registry.openForTraffic(count);
                                   } else {
                                       // An EIP is already bound
                                       return;
                                   }
                                   eipManager.bindEIP();
                               } catch (Throwable e) {
                                   logger.error("Could not bind to EIP", e);
                               }
                           }
                       }, eurekaServerConfig.getEIPBindingRetryIntervalMs(),
                eurekaServerConfig.getEIPBindingRetryIntervalMs());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
import javax.annotation.Nullable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                                               .getLastDirtyTimestamp();
=======
                        .getLastDirtyTimestamp();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                            + "the one that is being registered {}", existingLastDirtyTimestamp,
=======
                                    + "the one that is being registered {}", existingLastDirtyTimestamp,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                                              + "(" + r.getId() + ")"));
=======
                        + "(" + r.getId() + ")"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                        + "overrides", r.getOverriddenStatus(), r.getId());
=======
                                + "overrides", r.getOverriddenStatus(), r.getId());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                         + r.getId());
=======
                    + r.getId());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                            + appName + ":" + id);
=======
                        + appName + ":" + id);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                             + id);
=======
                        + id);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                if(overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
=======
                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                     instanceInfo.getOverriddenStatus().name(),
                                     instanceInfo.getId()};
=======
                            instanceInfo.getOverriddenStatus().name(),
                            instanceInfo.getId()};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                            + "Hence setting the status to overridden status", args);
=======
                                    + "Hence setting the status to overridden status", args);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            || (!overriddenStatus.equals(instanceStatus))) {
=======
                || (!overriddenStatus.equals(instanceStatus))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                if(currentOverride != null && info != null) {
=======
                if (currentOverride != null && info != null) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String )
=======
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                    Arrays.toString(remoteRegions));
=======
                Arrays.toString(remoteRegions));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                    + "whitelist and this app is not in the whitelist.", application.getName(),
=======
                                            + "whitelist and this app is not in the whitelist.", application.getName(),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                         + this.recentlyChangedQueue.size());
=======
                    + this.recentlyChangedQueue.size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                 instanceInfo.getStatus().name(),
                                 instanceInfo.getActionType().name()};
=======
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                 instanceInfo.getStatus().name(),
                                 instanceInfo.getActionType().name()};
=======
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
=======
                && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                if(application != null) {
=======
                if (application != null) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                .entrySet().iterator(); iter.hasNext();) {
=======
                .entrySet().iterator(); iter.hasNext(); ) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                    || (isLeaseExpirationEnabled() && lease.isExpired())) {
=======
                        || (isLeaseExpirationEnabled() && lease.isExpired())) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                                             .getRegisteredApplications()) {
=======
                        .getRegisteredApplications()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                                   .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                                   .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                                   .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                                   .setRenewalIntervalInSecs(renewalInterval)
                                   .setDurationInSecs(leaseDuration)
                                   .setEvictionTimestamp(lease.getEvictionTimestamp()).build());
=======
                .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                .setRenewalIntervalInSecs(renewalInterval)
                .setDurationInSecs(leaseDuration)
                .setEvictionTimestamp(lease.getEvictionTimestamp()).build());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
            && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
=======
                && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
=======
                    && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
                    Arrays.toString(allKnownRemoteRegions));
=======
                Arrays.toString(allKnownRemoteRegions));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
=======
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;

import com.netflix.discovery.EurekaIdentityHeaderFilter;
import com.netflix.eureka.EurekaServerIdentity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
=======
import com.netflix.discovery.EurekaIdentityHeaderFilter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
=======
import com.netflix.eureka.EurekaServerIdentity;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                    if (serviceUrl.startsWith("https://") && 
                    		"true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
	                    jerseyClient = EurekaJerseyClient.createSystemSSLJerseyClient(jerseyClientName,
	                            config.getPeerNodeConnectTimeoutMs(),
	                            config.getPeerNodeReadTimeoutMs(),
	                            config.getPeerNodeTotalConnections(),
	                            config.getPeerNodeTotalConnectionsPerHost(),
	                            config.getPeerNodeConnectionIdleTimeoutSeconds());
                    }else{
	                    jerseyClient = EurekaJerseyClient.createJerseyClient(jerseyClientName,
	                            config.getPeerNodeConnectTimeoutMs(),
	                            config.getPeerNodeReadTimeoutMs(),
	                            config.getPeerNodeTotalConnections(),
	                            config.getPeerNodeTotalConnectionsPerHost(),
	                            config.getPeerNodeConnectionIdleTimeoutSeconds());
=======
                    if (serviceUrl.startsWith("https://") &&
                            "true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
                        jerseyClient = EurekaJerseyClient.createSystemSSLJerseyClient(jerseyClientName,
                                config.getPeerNodeConnectTimeoutMs(),
                                config.getPeerNodeReadTimeoutMs(),
                                config.getPeerNodeTotalConnections(),
                                config.getPeerNodeTotalConnectionsPerHost(),
                                config.getPeerNodeConnectionIdleTimeoutSeconds());
                    } else {
                        jerseyClient = EurekaJerseyClient.createJerseyClient(jerseyClientName,
                                config.getPeerNodeConnectTimeoutMs(),
                                config.getPeerNodeReadTimeoutMs(),
                                config.getPeerNodeTotalConnections(),
                                config.getPeerNodeTotalConnectionsPerHost(),
                                config.getPeerNodeConnectionIdleTimeoutSeconds());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
               ip = InetAddress.getLocalHost().getHostAddress();
=======
                ip = InetAddress.getLocalHost().getHostAddress();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            final InstanceInfo info, final InstanceStatus overriddenStatus,
            boolean primeConnection) throws Throwable {
=======
                          final InstanceInfo info, final InstanceStatus overriddenStatus,
                          boolean primeConnection) throws Throwable {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            public void handleFailure(int statusCode) throws Throwable  {
               super.handleFailure(statusCode);
               if (statusCode == 404) {
                   logger.warn(name + appName + "/" + id
                           + " : heartbeat: missing entry.");
                   if (info != null) {
                       logger.warn(
                               "Cannot find instance id {} and hence replicating the instance with status {}",
                               info.getId(), info.getStatus().toString());
                       register(info);
                   }
               } else if (config.shouldSyncWhenTimestampDiffers() && this.getPeerInstanceInfo() != null) {
                   syncInstancesIfTimestampDiffers(id, info, this.getPeerInstanceInfo());
               }
=======
            public void handleFailure(int statusCode) throws Throwable {
                super.handleFailure(statusCode);
                if (statusCode == 404) {
                    logger.warn(name + appName + "/" + id
                            + " : heartbeat: missing entry.");
                    if (info != null) {
                        logger.warn(
                                "Cannot find instance id {} and hence replicating the instance with status {}",
                                info.getId(), info.getStatus().toString());
                        register(info);
                    }
                } else if (config.shouldSyncWhenTimestampDiffers() && this.getPeerInstanceInfo() != null) {
                    syncInstancesIfTimestampDiffers(id, info, this.getPeerInstanceInfo());
                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            final InstanceStatus newStatus, final InstanceInfo info) {
=======
                             final InstanceStatus newStatus, final InstanceInfo info) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                   return response.getStatus();
=======
                    return response.getStatus();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            final InstanceInfo info, final InstanceStatus overriddenStatus, ReplicationTask task)
=======
                              final InstanceInfo info, final InstanceStatus overriddenStatus, ReplicationTask task)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                .queryParam("lastDirtyTimestamp",
=======
                    .queryParam("lastDirtyTimestamp",
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            if ((response.getStatus() == Status.OK.getStatusCode())  && response.hasEntity()) {
=======
            if ((response.getStatus() == Status.OK.getStatusCode()) && response.hasEntity()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
     /**
=======
    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
     /**
=======
    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
           ) {
=======
    ) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                if (infoFromPeer != null) {
                    Object[] args = {id, info.getLastDirtyTimestamp(), infoFromPeer.getLastDirtyTimestamp()};
=======
            if (infoFromPeer != null) {
                Object[] args = {id, info.getLastDirtyTimestamp(), infoFromPeer.getLastDirtyTimestamp()};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
=======
                logger.warn(
                        "Peer wants us to take the instance information from it, since the timestamp differs,"
                                + "Id : {} My Timestamp : {}, Peer's timestamp: {}", args);
                if ((infoFromPeer.getOverriddenStatus() != null)
                        && !(InstanceStatus.UNKNOWN.equals(infoFromPeer
                        .getOverriddenStatus()))) {
                    Object[] args1 = {id, info.getOverriddenStatus(), infoFromPeer.getOverriddenStatus()};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                            "Peer wants us to take the instance information from it, since the timestamp differs,"
                            + "Id : {} My Timestamp : {}, Peer's timestamp: {}", args);
                    if ((infoFromPeer.getOverriddenStatus() != null)
                            && !(InstanceStatus.UNKNOWN.equals(infoFromPeer
                                    .getOverriddenStatus()))) {
                        Object[] args1 = {id, info.getOverriddenStatus(), infoFromPeer.getOverriddenStatus()};
                        logger.warn(
                                "Overridden Status info -id {}, mine {}, peer's {}",
                                args1);
=======
                            "Overridden Status info -id {}, mine {}, peer's {}",
                            args1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                        PeerAwareInstanceRegistry.getInstance()
                                .storeOverriddenStatusIfRequired(id,
                                        infoFromPeer.getOverriddenStatus());
                    }
                    PeerAwareInstanceRegistry.getInstance().register(
                            infoFromPeer, true);
=======
                    PeerAwareInstanceRegistry.getInstance()
                            .storeOverriddenStatusIfRequired(id,
                                    infoFromPeer.getOverriddenStatus());
                }
                PeerAwareInstanceRegistry.getInstance().register(
                        infoFromPeer, true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                }
=======
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                 250);
=======
                250);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            private String BATCH_URL_PATH = "peerreplication/batch/";;
=======
                    private String BATCH_URL_PATH = "peerreplication/batch/";
                    ;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            @Override
            public void process(List<ReplicationTask> tasks) {
                if (!tasks.get(0).isBatchingSupported()) {
                    executeSingle(tasks);
                } else if (!executeBatch(tasks)) {
                    executeSingle(tasks);
                }
            }
=======
                    @Override
                    public void process(List<ReplicationTask> tasks) {
                        if (!tasks.get(0).isBatchingSupported()) {
                            executeSingle(tasks);
                        } else if (!executeBatch(tasks)) {
                            executeSingle(tasks);
                        }
                    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            private boolean executeBatch(List<ReplicationTask> tasks) {
                boolean success = true;
                boolean done = true;
                PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList();
                for (ReplicationTask task : tasks) {
                   if (System.currentTimeMillis()
                            - config.getMaxTimeForReplication() > task
                            .getSubmitTime()) {
                       Object[] args = {task.getAppName(), task.getId(),
                               task.getAction(),
                               new Date(System.currentTimeMillis()),
                               new Date(task.getSubmitTime())};
=======
                    private boolean executeBatch(List<ReplicationTask> tasks) {
                        boolean success = true;
                        boolean done = true;
                        PeerEurekaNode.ReplicationList list = new PeerEurekaNode.ReplicationList();
                        for (ReplicationTask task : tasks) {
                            if (System.currentTimeMillis()
                                    - config.getMaxTimeForReplication() > task
                                    .getSubmitTime()) {
                                Object[] args = {task.getAppName(), task.getId(),
                                        task.getAction(),
                                        new Date(System.currentTimeMillis()),
                                        new Date(task.getSubmitTime())};
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                        logger.warn(
                                "Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, "
                                + "Current Time : {}, Submit Time :{}", args);
=======
                                logger.warn(
                                        "Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, "
                                                + "Current Time : {}, Submit Time :{}", args);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                       continue;
                    }
                    PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance();
                    instance.setAppName(task.getAppName());
                    instance.setId(task.getId());
                    InstanceInfo instanceInfo = task.getInstanceInfo();
                    if (instanceInfo != null) {
                        String overriddenStatus = (task
                                .getOverriddenStatus() == null ? null
=======
                                continue;
                            }
                            PeerEurekaNode.ReplicationInstance instance = new PeerEurekaNode.ReplicationInstance();
                            instance.setAppName(task.getAppName());
                            instance.setId(task.getId());
                            InstanceInfo instanceInfo = task.getInstanceInfo();
                            if (instanceInfo != null) {
                                String overriddenStatus = (task
                                        .getOverriddenStatus() == null ? null
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                        instance.setOverriddenStatus(overriddenStatus);
                        instance.setLastDirtyTimestamp(instanceInfo
                                .getLastDirtyTimestamp());
                        if (task.shouldReplicateInstanceInfo()) {
                            instance.setInstanceInfo(instanceInfo);
=======
                                instance.setOverriddenStatus(overriddenStatus);
                                instance.setLastDirtyTimestamp(instanceInfo
                                        .getLastDirtyTimestamp());
                                if (task.shouldReplicateInstanceInfo()) {
                                    instance.setInstanceInfo(instanceInfo);
                                }
                                String instanceStatus = instanceInfo
                                        .getStatus() == null ? null
                                        : instanceInfo.getStatus().name();
                                instance.setStatus(instanceStatus);
                            }
                            instance.setAction(task.getAction());
                            list.addReplicationInstance(instance);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                        String instanceStatus = instanceInfo
                        .getStatus() == null ? null
                                : instanceInfo.getStatus().name();
                        instance.setStatus(instanceStatus);
                    }
                    instance.setAction(task.getAction());
                    list.addReplicationInstance(instance);
                }
                if (list.getList().size() == 0) {
                    return true;
                }
                Action action = list.getList().get(0).action;
                DynamicCounter.increment("Batch_"
                        + action

                        + "_tries");

                do {
                    done = true;
                    ClientResponse response = null;
                    try {
                        response = jerseyApacheClient
                        .resource(serviceUrl)
                        .path(BATCH_URL_PATH)
                        .accept(MediaType.APPLICATION_JSON_TYPE)
                        .type(MediaType.APPLICATION_JSON_TYPE)
                        .post(ClientResponse.class, list);
                        if (!isSuccess(response.getStatus())) {
                            return false;
=======
                        if (list.getList().size() == 0) {
                            return true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
=======
                        Action action = list.getList().get(0).action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                                + "_success");
=======
                                + "_tries");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                        PeerEurekaNode.ReplicationListResponse batchResponse = response
                        .getEntity(PeerEurekaNode.ReplicationListResponse.class);
                        int ctr = 0;
                        for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse
                                .getResponseList()) {
                            int statusCode = singleResponse
                            .getStatusCode();
                            if ((!isSuccess(statusCode))
                                    || (singleResponse
                                    .getResponseEntity() != null)) {
                                if (singleResponse.getResponseEntity() != null) {
                                    tasks.get(ctr)
                                    .setPeerInstanceInfo(
                                            singleResponse
                                            .getResponseEntity());
=======
                        do {
                            done = true;
                            ClientResponse response = null;
                            try {
                                response = jerseyApacheClient
                                        .resource(serviceUrl)
                                        .path(BATCH_URL_PATH)
                                        .accept(MediaType.APPLICATION_JSON_TYPE)
                                        .type(MediaType.APPLICATION_JSON_TYPE)
                                        .post(ClientResponse.class, list);
                                if (!isSuccess(response.getStatus())) {
                                    return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                                tasks.get(ctr)
                                .handleFailure(statusCode);
                            }
=======
                                DynamicCounter.increment("Batch_"
                                        + action
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                            ++ctr;
                        }
                        done = true;
=======
                                        + "_success");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                    } catch (Throwable e) {
=======
                                PeerEurekaNode.ReplicationListResponse batchResponse = response
                                        .getEntity(PeerEurekaNode.ReplicationListResponse.class);
                                int ctr = 0;
                                for (PeerEurekaNode.ReplicationInstanceResponse singleResponse : batchResponse
                                        .getResponseList()) {
                                    int statusCode = singleResponse
                                            .getStatusCode();
                                    if ((!isSuccess(statusCode))
                                            || (singleResponse
                                            .getResponseEntity() != null)) {
                                        if (singleResponse.getResponseEntity() != null) {
                                            tasks.get(ctr)
                                                    .setPeerInstanceInfo(
                                                            singleResponse
                                                                    .getResponseEntity());
                                        }
                                        tasks.get(ctr)
                                                .handleFailure(statusCode);
                                    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                        if ((isNetworkConnectException(e))) {
                            DynamicCounter.increment("Batch_"
                                    + action
                              + "_retries");
                            done = false;
                        } else {
                            success = false;
                            logger.info(
                                    "Not re-trying this exception because it does not seem to be a network exception",
                                    e);
                        }
                    } finally {
                        if (response != null) {
                            response.close();
                        }
                    }
                } while (!done);
                return success;
            }
=======
                                    ++ctr;
                                }
                                done = true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
=======
                            } catch (Throwable e) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
            private void executeSingle(List<ReplicationTask> tasks) {
                for (ReplicationTask task : tasks) {
                    boolean done = true;
                    do {
                        done = true;
                        try {
                              if (System.currentTimeMillis()
                                    - config.getMaxTimeForReplication() > task
                                    .getSubmitTime()) {
                                  Object[] args = {
                                          task.getAppName(),
                                          task.getId(),
                                          task.getAction(),
                                          new Date(System.currentTimeMillis()),
                                          new Date(task.getSubmitTime()) };

                                logger.warn(
                                        "Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}",
                                        args);

                                continue;
=======
                                if ((isNetworkConnectException(e))) {
                                    DynamicCounter.increment("Batch_"
                                            + action
                                            + "_retries");
                                    done = false;
                                } else {
                                    success = false;
                                    logger.info(
                                            "Not re-trying this exception because it does not seem to be a network exception",
                                            e);
                                }
                            } finally {
                                if (response != null) {
                                    response.close();
                                }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                            DynamicCounter.increment("Single_"
                                    + task.getAction().name()
=======
                        } while (!done);
                        return success;
                    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                                    + "_tries");
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                            int statusCode = task.execute();
                            if (!isSuccess(statusCode)) {
                                task.handleFailure(statusCode);
                            }
                            DynamicCounter.increment("Single_"
                                    + task.getAction().name()

                                    + "_success");

                        } catch (Throwable e) {
                            logger.error(
                                    name + task.getAppName() + "/"
                                    + task.getId() + ":"
                                    + task.getAction(), e);
                            try {
                                Thread.sleep(RETRY_SLEEP_TIME_MS);
                            } catch (InterruptedException e1) {

                            }
                            if ((isNetworkConnectException(e))) {
                                DynamicCounter.increment(task
                                        .getAction().name()
                                        + "_retries");
                                done = false;
                            } else {
                                logger.info(
                                        "Not re-trying this exception because it does not seem to be a network "
                                        + "exception", e);
                            }
=======
                    private void executeSingle(List<ReplicationTask> tasks) {
                        for (ReplicationTask task : tasks) {
                            boolean done = true;
                            do {
                                done = true;
                                try {
                                    if (System.currentTimeMillis()
                                            - config.getMaxTimeForReplication() > task
                                            .getSubmitTime()) {
                                        Object[] args = {
                                                task.getAppName(),
                                                task.getId(),
                                                task.getAction(),
                                                new Date(System.currentTimeMillis()),
                                                new Date(task.getSubmitTime())};

                                        logger.warn(
                                                "Replication events older than the threshold. AppName : {}, Id: {}, Action : {}, Current Time : {}, Submit Time :{}",
                                                args);

                                        continue;
                                    }
                                    DynamicCounter.increment("Single_"
                                            + task.getAction().name()

                                            + "_tries");

                                    int statusCode = task.execute();
                                    if (!isSuccess(statusCode)) {
                                        task.handleFailure(statusCode);
                                    }
                                    DynamicCounter.increment("Single_"
                                            + task.getAction().name()

                                            + "_success");

                                } catch (Throwable e) {
                                    logger.error(
                                            name + task.getAppName() + "/"
                                                    + task.getId() + ":"
                                                    + task.getAction(), e);
                                    try {
                                        Thread.sleep(RETRY_SLEEP_TIME_MS);
                                    } catch (InterruptedException e1) {

                                    }
                                    if ((isNetworkConnectException(e))) {
                                        DynamicCounter.increment(task
                                                .getAction().name()
                                                + "_retries");
                                        done = false;
                                    } else {
                                        logger.info(
                                                "Not re-trying this exception because it does not seem to be a network "
                                                        + "exception", e);
                                    }
                                }
                            } while (!done);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                    } while (!done);
                }
            }
        });
=======
                    }
                });
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
                &&  statusCode < 300;
=======
                && statusCode < 300;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
=======
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
    .getLogger(EIPManager.class);
=======
            .getLogger(EIPManager.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
    .getInstance().getConfiguration();
=======
            .getInstance().getConfiguration();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
        .get(MetaDataKey.instanceId);
=======
                .get(MetaDataKey.instanceId);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
        .get(MetaDataKey.availabilityZone);
=======
                .get(MetaDataKey.availabilityZone);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
        .get(MetaDataKey.publicIpv4);
=======
                .get(MetaDataKey.publicIpv4);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
                                + "skipping this", eipEntry, associatedInstanceId);
=======
                                        + "skipping this", eipEntry, associatedInstanceId);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
                            + publicIp);
=======
                        + publicIp);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
            .get(MetaDataKey.publicIpv4);
=======
                    .get(MetaDataKey.publicIpv4);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
                .withPublicIps(myPublicIP);
=======
                        .withPublicIps(myPublicIP);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
                .describeAddresses(describeAddressRequest);
=======
                        .describeAddresses(describeAddressRequest);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
                    + myZone);
=======
                            + myZone);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
        .getEurekaClientConfig().getEurekaServerServiceUrls(myZone);
=======
                .getEurekaClientConfig().getEurekaServerServiceUrls(myZone);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
        .getEurekaClient().getServiceUrlsFromDNS(myZone, true);
=======
                .getEurekaClient().getServiceUrlsFromDNS(myZone, true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
        .getConfiguration();
=======
                .getConfiguration();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;<<<<<<< MINE
        .getRegion();
=======
                .getRegion();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
import com.google.common.base.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
=======
import com.google.common.base.Strings;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
        .getApplications(false);
=======
                .getApplications(false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            @Override
            public void run() {
                updateRenewalThreshold();
=======
                           @Override
                           public void run() {
                               updateRenewalThreshold();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            }
=======
                           }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
        }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
=======
                       }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
                @Override
                public void run() {
                    try {
                        updatePeerEurekaNodes();
                    } catch (Throwable e) {
                        logger.error("Cannot update the replica Nodes", e);
                    }
=======
                                           @Override
                                           public void run() {
                                               try {
                                                   updatePeerEurekaNodes();
                                               } catch (Throwable e) {
                                                   logger.error("Cannot update the replica Nodes", e);
                                               }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
                }
            }, EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs(),
=======
                                           }
                                       }, EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs(),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
                                + "channels are open", peerHostName);
=======
                                        + "channels are open", peerHostName);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
                                               + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
=======
                    + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            final boolean isReplication) {
=======
                          final boolean isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            final boolean isReplication) {
=======
                         final boolean isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            final InstanceStatus newStatus, String lastDirtyTimestamp,
            final boolean isReplication) {
=======
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            final boolean isReplication) {
=======
                             final boolean isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            boolean secure) {
=======
                                                boolean secure) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
               if ((count * 2) > (EUREKA_SERVER_CONFIG
=======
                if ((count * 2) > (EUREKA_SERVER_CONFIG
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
                        + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
=======
                + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            InstanceInfo info /* optional */,
            InstanceStatus newStatus /* optional */, boolean isReplication) {
=======
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            String id, InstanceInfo info, InstanceStatus newStatus,
            PeerEurekaNode node) {
=======
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            case Cancel:
                node.cancel(appName, id);
                break;
            case Heartbeat:
                InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                        .get(id);
                infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                        false);
                break;
            case Register:
                node.register(info);
                break;
            case StatusUpdate:
                infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                break;
            case DeleteStatusOverride:
                infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                node.deleteStatusOverride(appName, id, infoFromRegistry);
                break;
=======
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                            .get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                            false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
            final ASGStatus newStatus, final PeerEurekaNode node) {
=======
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;<<<<<<< MINE
import java.io.IOException;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;<<<<<<< MINE
=======
import java.io.IOException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;<<<<<<< MINE
            FilterChain chain) throws IOException, ServletException {
=======
                         FilterChain chain) throws IOException, ServletException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;<<<<<<< MINE
                    + status + " - try another DS node: ");
=======
                            + status + " - try another DS node: ");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
=======
import javax.ws.rs.core.Response;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
import javax.ws.rs.core.Response;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
=======
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
@Produces({ "application/xml", "application/json" })
=======
@Produces({"application/xml", "application/json"})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    .getLogger(StatusResource.class);
=======
            .getLogger(StatusResource.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    .getInstance();
=======
            .getInstance();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
        .getAppName();
=======
                .getAppName();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
            .getApplication(myAppName, false);
=======
                    .getApplication(myAppName, false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
=======
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
@Produces({ "application/xml", "application/json" })
=======
@Produces({"application/xml", "application/json"})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
                        .getConfiguration().shouldSyncWhenTimestampDiffers()) {
=======
                .getConfiguration().shouldSyncWhenTimestampDiffers()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
            if(registry.getInstanceByAppAndId(app.getName(), id) == null) {
=======
            if (registry.getInstanceByAppAndId(app.getName(), id) == null) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
            if(registry.getInstanceByAppAndId(app.getName(), id) == null) {
=======
            if (registry.getInstanceByAppAndId(app.getName(), id) == null) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
            boolean isReplication) {
=======
                                            boolean isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
                            .getLastDirtyTimestamp()))) {
=======
                    .getLastDirtyTimestamp()))) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
@Produces({ "application/xml", "application/json" })
=======
@Produces({"application/xml", "application/json"})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
    .getLogger(ASGResource.class);
=======
            .getLogger(ASGResource.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
            @QueryParam("value") String newStatus,
            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
=======
                                 @QueryParam("value") String newStatus,
                                 @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE
import java.util.List;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
=======
import java.util.List;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE
@Produces({ "application/xml", "application/json" })
=======
@Produces({"application/xml", "application/json"})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE
            @PathParam("id") String id) {
=======
                            @PathParam("id") String id) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
import com.netflix.eureka.util.EurekaMonitors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
=======
import com.netflix.eureka.util.EurekaMonitors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
@Produces({ "application/xml", "application/json" })
=======
@Produces({"application/xml", "application/json"})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
            @HeaderParam("Accept") final String acceptHeader) {
=======
                                   @HeaderParam("Accept") final String acceptHeader) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
    @Consumes({ "application/json", "application/xml" })
=======
    @Consumes({"application/json", "application/xml"})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
=======
                            @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
@Produces({ "application/xml", "application/json" })
=======
@Produces({"application/xml", "application/json"})
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
      * @return A batched response containing the information about the responses of individual events
=======
     * @return A batched response containing the information about the responses of individual events
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
                                .getLastDirtyTimestamp().toString());
=======
                        .getLastDirtyTimestamp().toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
                        .setResponseEntity((InstanceInfo) response
                                .getEntity());
=======
                                .setResponseEntity((InstanceInfo) response
                                        .getEntity());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
                    .setStatusCode(Status.OK.getStatusCode());
=======
                            .setStatusCode(Status.OK.getStatusCode());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
                            .toString());
=======
                                    .toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
                    .setStatusCode(response.getStatus());
=======
                            .setStatusCode(response.getStatus());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
                    .setStatusCode(response.getStatus());
=======
                            .setStatusCode(response.getStatus());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
                    .setStatusCode(response.getStatus());
=======
                            .setStatusCode(response.getStatus());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
import com.netflix.config.ConfigurationManager;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
import com.netflix.config.DynamicPropertyFactory;
import com.netflix.config.DynamicStringProperty;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
import com.netflix.config.ConfigurationManager;
import com.netflix.config.DynamicPropertyFactory;
import com.netflix.config.DynamicStringProperty;

import javax.annotation.Nullable;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
    .getLogger(DefaultEurekaServerConfig.class);
=======
            .getLogger(DefaultEurekaServerConfig.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
    .getInstance();
=======
            .getInstance();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
    .getInstance().getStringProperty("eureka.server.props",
    "eureka-server");
=======
            .getInstance().getStringProperty("eureka.server.props",
                    "eureka-server");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
            .loadCascadedPropertiesFromResources(eurekaPropsFile);
=======
                    .loadCascadedPropertiesFromResources(eurekaPropsFile);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
                    + "specific properties or the configuration is installed with a different mechanism.",
=======
                            + "specific properties or the configuration is installed with a different mechanism.",
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
        .getIntProperty(namespace + "peerEurekaNodesUpdateIntervalMs",
                (10 * 60 * 1000)).get();
=======
                .getIntProperty(namespace + "peerEurekaNodesUpdateIntervalMs",
                        (10 * 60 * 1000)).get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
        .getLongProperty(
                namespace + "maxIdleThreadAgeInMinutesForStatusReplication",
                10).get();
=======
                .getLongProperty(
                        namespace + "maxIdleThreadAgeInMinutesForStatusReplication",
                        10).get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
        eureka.remoteRegionUrlsWithName=region1;http://region1host/eureka/v2,region2;http://region2host/eureka/v2
=======
     eureka.remoteRegionUrlsWithName=region1;http://region1host/eureka/v2,region2;http://region2host/eureka/v2
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
        region1->"http://region1host/eureka/v2"
        region2->"http://region2host/eureka/v2"
=======
     region1->"http://region1host/eureka/v2"
     region2->"http://region2host/eureka/v2"
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
                             new String[]{propName, remoteRegionUrlWithNamePair, pairSplitChar});
=======
                        new String[]{propName, remoteRegionUrlWithNamePair, pairSplitChar});
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;<<<<<<< MINE
import static org.junit.Assert.*;
import static org.mockito.Mockito.*;
=======
import static org.junit.Assert.assertEquals;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;<<<<<<< MINE
=======
import java.util.Map;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;<<<<<<< MINE
import java.util.Map;
import java.util.Set;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;<<<<<<< MINE
                                                                                                + ';' + region1url
                                                                                                + ',' + region2
                                                                                                + ';' + region2url);
=======
                + ';' + region1url
                + ',' + region2
                + ';' + region2url);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;<<<<<<< MINE
        Map<String,String> remoteRegionUrlsWithName = config.getRemoteRegionUrlsWithName();
=======
        Map<String, String> remoteRegionUrlsWithName = config.getRemoteRegionUrlsWithName();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;<<<<<<< MINE
                                                                                                + ';' + region1url);
=======
                + ';' + region1url);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;<<<<<<< MINE
        Map<String,String> remoteRegionUrlsWithName = config.getRemoteRegionUrlsWithName();
=======
        Map<String, String> remoteRegionUrlsWithName = config.getRemoteRegionUrlsWithName();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.Map;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
                                                 entry.getValue().getInstances().size());
=======
                    entry.getValue().getInstances().size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
                                   "Request path: " + pathInfo + " not supported by eureka resource mock.");
=======
                        "Request path: " + pathInfo + " not supported by eureka resource mock.");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
                               " with content" + content);
=======
                    " with content" + content);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/util/RateLimiterTest.java;<<<<<<< MINE
import static org.junit.Assert.*;
=======
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
                                                             "5");
=======
                "5");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
                                                             REMOTE_REGION_NAME + ";http://localhost:"
                                                             + REMOTE_REGION_PORT + '/' +
                                                             MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
=======
                REMOTE_REGION_NAME + ";http://localhost:"
                        + REMOTE_REGION_PORT + '/' +
                        MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
                                                             "http://localhost:" + mockRemoteEurekaServer.getPort() +
                                                             MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
=======
                "http://localhost:" + mockRemoteEurekaServer.getPort() +
                        MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
                while(line != null) {  // need to read all the buffer for a clean connection close
=======
                while (line != null) {  // need to read all the buffer for a clean connection close
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
        .getLogger(Builder.class);
=======
                .getLogger(Builder.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
                        if (uc.getResponseCode() != HttpURLConnection.HTTP_OK ) {  // need to read the error for clean connection close
=======
                        if (uc.getResponseCode() != HttpURLConnection.HTTP_OK) {  // need to read the error for clean connection close
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
                                while(br.readLine() != null) {
=======
                                while (br.readLine() != null) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
            .getInstance().getBooleanProperty(
                    namespace + "logAmazonMetadataErrors", false);
=======
                        .getInstance().getBooleanProperty(
                                namespace + "logAmazonMetadataErrors", false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
            .getInstance().getIntProperty(
                    namespace + "mt.read_timeout", 8000);
=======
                        .getInstance().getIntProperty(
                                namespace + "mt.read_timeout", 8000);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
            .getInstance().getIntProperty(
                    namespace + "mt.connect_timeout", 3000);
=======
                        .getInstance().getIntProperty(
                                namespace + "mt.connect_timeout", 3000);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;<<<<<<< MINE
            .getInstance().getIntProperty(namespace + "mt.num_retries",
                    3);
=======
                        .getInstance().getIntProperty(namespace + "mt.num_retries",
                                3);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;<<<<<<< MINE
import javax.inject.Inject;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
import javax.inject.Inject;

import com.netflix.governator.guice.lazy.LazySingleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
import com.netflix.appinfo.LeaseInfo;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
=======
import com.netflix.appinfo.LeaseInfo;
import com.netflix.governator.guice.lazy.LazySingleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
            .newBuilder()
            .setRenewalIntervalInSecs(
                    config.getLeaseRenewalIntervalInSeconds())
=======
                    .newBuilder()
                    .setRenewalIntervalInSecs(
                            config.getLeaseRenewalIntervalInSeconds())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
                .setAppName(config.getAppname())
                .setAppGroupName(config.getAppGroupName())
                .setDataCenterInfo(config.getDataCenterInfo())
                .setIPAddr(config.getIpAddress())
                .setHostName(config.getHostName(false))
                .setPort(config.getNonSecurePort())
                .enablePort(PortType.UNSECURE,
                        config.isNonSecurePortEnabled())
                .setSecurePort(config.getSecurePort())
                .enablePort(PortType.SECURE, config.getSecurePortEnabled())
                .setVIPAddress(config.getVirtualHostName())
                .setSecureVIPAddress(config.getSecureVirtualHostName())
                .setHomePageUrl(config.getHomePageUrlPath(),
                                config.getHomePageUrl())
                .setStatusPageUrl(config.getStatusPageUrlPath(),
                                  config.getStatusPageUrl())
                .setHealthCheckUrls(config.getHealthCheckUrlPath(),
                                    config.getHealthCheckUrl(),
                                    config.getSecureHealthCheckUrl())
                .setASGName(config.getASGName());
    
=======
                    .setAppName(config.getAppname())
                    .setAppGroupName(config.getAppGroupName())
                    .setDataCenterInfo(config.getDataCenterInfo())
                    .setIPAddr(config.getIpAddress())
                    .setHostName(config.getHostName(false))
                    .setPort(config.getNonSecurePort())
                    .enablePort(PortType.UNSECURE,
                            config.isNonSecurePortEnabled())
                    .setSecurePort(config.getSecurePort())
                    .enablePort(PortType.SECURE, config.getSecurePortEnabled())
                    .setVIPAddress(config.getVirtualHostName())
                    .setSecureVIPAddress(config.getSecureVirtualHostName())
                    .setHomePageUrl(config.getHomePageUrlPath(),
                            config.getHomePageUrl())
                    .setStatusPageUrl(config.getStatusPageUrlPath(),
                            config.getStatusPageUrl())
                    .setHealthCheckUrls(config.getHealthCheckUrlPath(),
                            config.getHealthCheckUrl(),
                            config.getSecureHealthCheckUrl())
                    .setASGName(config.getASGName());

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java;<<<<<<< MINE
=======
import com.netflix.discovery.shared.Pair;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java;<<<<<<< MINE
import com.netflix.discovery.shared.Pair;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java;<<<<<<< MINE
    .getLogger(AbstractInstanceConfig.class);
=======
            .getLogger(AbstractInstanceConfig.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;<<<<<<< MINE
                        + "register. \nSet the property " + namespace + "validateInstanceId to false to ignore the"
                        + "metadata call");
=======
                                + "register. \nSet the property " + namespace + "validateInstanceId to false to ignore the"
                                + "metadata call");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;<<<<<<< MINE
                AmazonInfo newInfo = AmazonInfo.Builder.newBuilder()
                .autoBuild(namespace);
                String newHostname = newInfo.get(MetaDataKey.publicHostname);
                String existingHostname = ((AmazonInfo) info)
                .get(MetaDataKey.publicHostname);
                if (newHostname != null
                        && !newHostname.equals(existingHostname)) {
                    // public dns has changed on us, re-sync it
                    logger.warn("The public hostname changed from : "
                            + existingHostname + " => " + newHostname);
                    this.info = newInfo;
                }
       } catch (Throwable t) {
=======
            AmazonInfo newInfo = AmazonInfo.Builder.newBuilder()
                    .autoBuild(namespace);
            String newHostname = newInfo.get(MetaDataKey.publicHostname);
            String existingHostname = ((AmazonInfo) info)
                    .get(MetaDataKey.publicHostname);
            if (newHostname != null
                    && !newHostname.equals(existingHostname)) {
                // public dns has changed on us, re-sync it
                logger.warn("The public hostname changed from : "
                        + existingHostname + " => " + newHostname);
                this.info = newInfo;
            }
        } catch (Throwable t) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
=======
import com.netflix.config.ConfigurationManager;
import com.netflix.config.DynamicPropertyFactory;
import com.netflix.config.DynamicStringProperty;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
import com.netflix.config.ConfigurationManager;
import com.netflix.config.DynamicPropertyFactory;
import com.netflix.config.DynamicStringProperty;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
implements EurekaInstanceConfig {
=======
        implements EurekaInstanceConfig {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
    .getLogger(PropertiesInstanceConfig.class);
=======
            .getLogger(PropertiesInstanceConfig.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
    .getInstance().getStringProperty("eureka.client.props",
    "eureka-client");
=======
            .getInstance().getStringProperty("eureka.client.props",
                    "eureka-client");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
    .getInstance();
=======
            .getInstance();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
                                           super.isInstanceEnabledOnit()).get();
=======
                super.isInstanceEnabledOnit()).get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
        .get();
=======
                .get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
                                           super.getSecurePortEnabled()).get();
=======
                super.getSecurePortEnabled()).get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
        .get();
=======
                .get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
        .getBackingConfigurationSource();
=======
                .getBackingConfigurationSource();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
        iter.hasNext();) {
=======
             iter.hasNext(); ) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
                return INSTANCE.getStringProperty(namespace + "statusPageUrlPath",
                        DEFAULT_STATUSPAGE_URLPATH).get();
=======
        return INSTANCE.getStringProperty(namespace + "statusPageUrlPath",
                DEFAULT_STATUSPAGE_URLPATH).get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
       return INSTANCE.getStringProperty(namespace + "statusPageUrl", null)
        .get();
=======
        return INSTANCE.getStringProperty(namespace + "statusPageUrl", null)
                .get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
            DEFAULT_HOMEPAGE_URLPATH).get();
=======
                DEFAULT_HOMEPAGE_URLPATH).get();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
        .get();
     }
=======
                .get();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
     }
=======
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
                                                                               UNKNOWN_APPLICATION);
=======
                UNKNOWN_APPLICATION);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;<<<<<<< MINE
                    + "specific properties or the configuration is installed with a different mechanism.",
=======
                            + "specific properties or the configuration is installed with a different mechanism.",
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
import javax.annotation.Nullable;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
                                  instanceRegionChecker);
=======
                instanceRegionChecker);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;<<<<<<< MINE
                           && null != remoteRegionsRegistry) {
=======
                        && null != remoteRegionsRegistry) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
import com.netflix.discovery.InstanceRegionChecker;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
=======
import com.netflix.discovery.InstanceRegionChecker;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE

import javax.annotation.Nullable;
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
	AtomicReference<List<InstanceInfo>> ref = this.shuffleVirtualHostNameMap
		.get(virtualHostName.toUpperCase(Locale.ROOT));
=======
        AtomicReference<List<InstanceInfo>> ref = this.shuffleVirtualHostNameMap
                .get(virtualHostName.toUpperCase(Locale.ROOT));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;<<<<<<< MINE
            Map<String, AbstractQueue<InstanceInfo>> vipMap) {
=======
                                  Map<String, AbstractQueue<InstanceInfo>> vipMap) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java;<<<<<<< MINE
=======
import com.google.common.base.Preconditions;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.netflix.servo.monitor.Timer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java;<<<<<<< MINE
import com.google.common.base.Preconditions;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.netflix.servo.monitor.Timer;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java;<<<<<<< MINE
    @Monitor(name="connectionCount", type=DataSourceType.GAUGE)
=======
    @Monitor(name = "connectionCount", type = DataSourceType.GAUGE)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
=======
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
                                                                               maxTotalConnections);
=======
                    maxTotalConnections);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
                                    connectionIdleTimeout, jerseyClientConfig);
=======
                    connectionIdleTimeout, jerseyClientConfig);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
     * @param proxyHost 
=======
     * @param proxyHost
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
     * @param proxyPort 
=======
     * @param proxyPort
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
            int readTimeout, int maxConnectionsPerHost, int maxTotalConnections, int connectionIdleTimeout, 
            String proxyHost, String proxyPort, String proxyUserName, String proxyPassword) {
      Preconditions.checkNotNull(clientName, "Client name can not be null.");
      try {
          ClientConfig jerseyClientConfig = new ProxyCustomApacheHttpClientConfig(clientName, maxConnectionsPerHost,
                  maxTotalConnections, proxyHost, proxyPort, proxyUserName, proxyPassword);
          
          return new JerseyClient(connectionTimeout, readTimeout, 
                                  connectionIdleTimeout, jerseyClientConfig);
      } catch (Throwable e) {
          throw new RuntimeException("Cannot create Jersey client ", e);
      }
=======
                                                       int readTimeout, int maxConnectionsPerHost, int maxTotalConnections, int connectionIdleTimeout,
                                                       String proxyHost, String proxyPort, String proxyUserName, String proxyPassword) {
        Preconditions.checkNotNull(clientName, "Client name can not be null.");
        try {
            ClientConfig jerseyClientConfig = new ProxyCustomApacheHttpClientConfig(clientName, maxConnectionsPerHost,
                    maxTotalConnections, proxyHost, proxyPort, proxyUserName, proxyPassword);

            return new JerseyClient(connectionTimeout, readTimeout,
                    connectionIdleTimeout, jerseyClientConfig);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client ", e);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
                                    connectionIdleTimeout, jerseyClientConfig);
=======
                    connectionIdleTimeout, jerseyClientConfig);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
    		int readTimeout, int maxConnectionsPerHost,
    		int maxTotalConnections, int connectionIdleTimeout) {
    	Preconditions.checkNotNull(clientName, "Client name can not be null.");	
     	try {
    		ClientConfig jerseyClientConfig = new SystemSSLCustomApacheHttpClientConfig(
    				clientName, maxConnectionsPerHost, maxTotalConnections);
    		
    		return new JerseyClient(connectionTimeout, readTimeout,
    				connectionIdleTimeout, jerseyClientConfig);
    	} catch (Throwable e) {
    		throw new RuntimeException("Cannot create System SSL Jersey client ", e);
    	}
=======
                                                           int readTimeout, int maxConnectionsPerHost,
                                                           int maxTotalConnections, int connectionIdleTimeout) {
        Preconditions.checkNotNull(clientName, "Client name can not be null.");
        try {
            ClientConfig jerseyClientConfig = new SystemSSLCustomApacheHttpClientConfig(
                    clientName, maxConnectionsPerHost, maxTotalConnections);

            return new JerseyClient(connectionTimeout, readTimeout,
                    connectionIdleTimeout, jerseyClientConfig);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create System SSL Jersey client ", e);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
      
      public ProxyCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost, int maxTotalConnections,
              String proxyHost, String proxyPort, String proxyUserName, String proxyPassword)
          throws Throwable {
        MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName);
        cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
        cm.setMaxTotal(maxTotalConnections);
        getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
          // To pin a client to specific server in case redirect happens, we handle redirects directly
          // (see DiscoveryClient.makeRemoteCall methods).
        getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
          getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);

        if (proxyUserName != null && proxyPassword != null) {
          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
        } else {
          // Due to bug in apache client, user name/password must always be set.
          // Otherwise proxy configuration is ignored.
          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
          getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
        }
        getProperties().put(
                DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI,
                "http://" + proxyHost + ":" + proxyPort);
      }
=======

        public ProxyCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost, int maxTotalConnections,
                                                 String proxyHost, String proxyPort, String proxyUserName, String proxyPassword)
                throws Throwable {
            MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName);
            cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
            cm.setMaxTotal(maxTotalConnections);
            getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
            // To pin a client to specific server in case redirect happens, we handle redirects directly
            // (see DiscoveryClient.makeRemoteCall methods).
            getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
            getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);

            if (proxyUserName != null && proxyPassword != null) {
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
            } else {
                // Due to bug in apache client, user name/password must always be set.
                // Otherwise proxy configuration is ignored.
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
            }
            getProperties().put(
                    DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI,
                    "http://" + proxyHost + ":" + proxyPort);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
            .getInstance(TrustManagerFactory.getDefaultAlgorithm());
=======
                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
                .setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
=======
                        .setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
                                                                  .getDefaultAlgorithm());
=======
                        .getDefaultAlgorithm());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
    	private static final int HTTPS_PORT = 443;
    	private static final String PROTOCOL = "https";
    	
    	public SystemSSLCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost,
    			int maxTotalConnections) throws Throwable {
    		
    		SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
    		SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
    		sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));
    		
    		MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
    		cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
    		cm.setMaxTotal(maxTotalConnections);
    		getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
=======
        private static final int HTTPS_PORT = 443;
        private static final String PROTOCOL = "https";

        public SystemSSLCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost,
                                                     int maxTotalConnections) throws Throwable {

            SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
            SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
            sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

            MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
            cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
            cm.setMaxTotal(maxTotalConnections);
            getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
    		getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);
    	}
=======
            getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
            private final AtomicInteger threadNumber = new AtomicInteger(1);
=======
                    private final AtomicInteger threadNumber = new AtomicInteger(1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                thread.setDaemon(true);
                return thread;
            }
        });
=======
                    @Override
                    public Thread newThread(Runnable r) {
                        Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                        thread.setDaemon(true);
                        return thread;
                    }
                });
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
                    .getClientHandler()
                    .getHttpClient()
                    .getConnectionManager()
                    .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
=======
                            .getClientHandler()
                            .getHttpClient()
                            .getConnectionManager()
                            .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/InstanceRegionChecker.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
import java.util.Map;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/InstanceRegionChecker.java;<<<<<<< MINE
import javax.annotation.Nullable;
import java.util.Map;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE
import java.util.concurrent.atomic.AtomicLong;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
=======
import java.util.concurrent.atomic.AtomicLong;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE
public class EurekaUpStatusResolver  {
=======
public class EurekaUpStatusResolver {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE
        this.client   = client;
=======
        this.client = client;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java;<<<<<<< MINE

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java;<<<<<<< MINE
            EurekaClientConfig eurekaConfig) {
=======
                              EurekaClientConfig eurekaConfig) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
import com.netflix.governator.guice.lazy.FineGrainedLazySingleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE

import javax.annotation.Nullable;
=======
import com.netflix.governator.guice.lazy.FineGrainedLazySingleton;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
                    + "specific properties or the configuration is installed with a different mechanism.",
=======
                            + "specific properties or the configuration is installed with a different mechanism.",
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
    
	@Override
	public int getInitialInstanceInfoReplicationIntervalSeconds() {
=======

    @Override
    public int getInitialInstanceInfoReplicationIntervalSeconds() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
	}
=======
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;<<<<<<< MINE
import com.google.common.base.Supplier;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;<<<<<<< MINE
=======
import com.google.common.base.Supplier;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;<<<<<<< MINE
                    || (availabilityZones.size() == 1 && availabilityZones.iterator().next().equals(DEFAULT_ZONE))
                    || availabilityZones.isEmpty()) {
=======
                        || (availabilityZones.size() == 1 && availabilityZones.iterator().next().equals(DEFAULT_ZONE))
                        || availabilityZones.isEmpty()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
import java.util.List;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
import javax.annotation.Nullable;

import java.util.List;
import java.util.Set;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
import javax.annotation.Nullable;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;<<<<<<< MINE
=======
import javax.ws.rs.core.MediaType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;<<<<<<< MINE
import javax.ws.rs.core.MediaType;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;<<<<<<< MINE
    throws IOException {
=======
            throws IOException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;<<<<<<< MINE
    throws IOException {
=======
            throws IOException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
=======
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
    .newCounter(UNMARSHAL_ERROR);
=======
            .newCounter(UNMARSHAL_ERROR);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
    .getLogger(Converters.class);
=======
            .getLogger(Converters.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                MarshallingContext context) {
=======
                            MarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                UnmarshallingContext context) {
=======
                                UnmarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                MarshallingContext context) {
=======
                            MarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                UnmarshallingContext context) {
=======
                                UnmarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                MarshallingContext context) {
=======
                            MarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                    "com.netflix.appinfo.AmazonInfo");
=======
                            "com.netflix.appinfo.AmazonInfo");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                    "com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo");
=======
                            "com.netflix.appinfo.InstanceInfo$DefaultDataCenterInfo");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                    "java.util.Collections$EmptyMap");
=======
                            "java.util.Collections$EmptyMap");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                UnmarshallingContext context) {
=======
                                UnmarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                MarshallingContext context) {
=======
                            MarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                    "java.util.Collections$EmptyMap");
=======
                            "java.util.Collections$EmptyMap");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                UnmarshallingContext context) {
=======
                                UnmarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                        for(Map.Entry<String, String> entry: metadataMap.entrySet()) {
=======
                        for (Map.Entry<String, String> entry : metadataMap.entrySet()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                MarshallingContext context) {
=======
                            MarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                UnmarshallingContext context) {
=======
                                UnmarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                MarshallingContext context) {
=======
                            MarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                    .iterator(); iter.hasNext();) {
=======
                    .iterator(); iter.hasNext(); ) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
                UnmarshallingContext context) {
=======
                                UnmarshallingContext context) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
            HierarchicalStreamWriter writer) {
=======
                                            HierarchicalStreamWriter writer) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;<<<<<<< MINE
            Object o) {
=======
                                              Object o) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import com.netflix.appinfo.DataCenterInfo.Name;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import com.netflix.discovery.shared.LookupService;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        if(isQueryAction(action)) {
=======
        if (isQueryAction(action)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    if(isQueryAction(action)) {
=======
                    if (isQueryAction(action)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        String[] availZones = clientConfig.getAvailabilityZones(clientConfig .getRegion());
=======
        String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;<<<<<<< MINE
=======
import javax.inject.Singleton;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;<<<<<<< MINE
import javax.inject.Singleton;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.concurrent.ConcurrentHashMap;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
=======
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.concurrent.ConcurrentHashMap;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
MessageBodyReader {
=======
        MessageBodyReader {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
    .getLogger(DiscoveryJerseyProvider.class);
=======
            .getLogger(DiscoveryJerseyProvider.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
            Annotation[] annotations, MediaType mediaType) {
=======
                              Annotation[] annotations, MediaType mediaType) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
            Annotation[] annotations, MediaType mediaType,
            MultivaluedMap headers, InputStream inputStream)
    throws IOException, WebApplicationException {
=======
                           Annotation[] annotations, MediaType mediaType,
                           MultivaluedMap headers, InputStream inputStream)
            throws IOException, WebApplicationException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
        if(mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {
=======
        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
            } catch(Error e) {
=======
            } catch (Error e) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
            Type type, Annotation[] annotations, MediaType mediaType) {
=======
                        Type type, Annotation[] annotations, MediaType mediaType) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
            Annotation[] annotations, MediaType mediaType) {
=======
                               Annotation[] annotations, MediaType mediaType) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
            Type type, Annotation[] annotations, MediaType mediaType,
            MultivaluedMap headers, OutputStream outputStream)
    throws IOException, WebApplicationException {
=======
                        Type type, Annotation[] annotations, MediaType mediaType,
                        MultivaluedMap headers, OutputStream outputStream)
            throws IOException, WebApplicationException {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
        if(mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {
=======
        if (mediaType.equals(MediaType.APPLICATION_JSON_TYPE)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
            .getAnnotation(Serializer.class);
=======
                    .getAnnotation(Serializer.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;<<<<<<< MINE
    private static ISerializer getSerializer(@SuppressWarnings("rawtypes")Class serializableClass) {
=======
    private static ISerializer getSerializer(@SuppressWarnings("rawtypes") Class serializableClass) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/ISerializer.java;<<<<<<< MINE
=======
import javax.ws.rs.core.MediaType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/ISerializer.java;<<<<<<< MINE
import javax.ws.rs.core.MediaType;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/appinfo/AmazonInfoTest.java;<<<<<<< MINE
import org.junit.Test;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/appinfo/AmazonInfoTest.java;<<<<<<< MINE
=======
import org.junit.Test;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;<<<<<<< MINE
=======
import java.util.List;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;<<<<<<< MINE
import java.util.List;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;<<<<<<< MINE
        DataCenterInfo myDCI = new DataCenterInfo(){
            public DataCenterInfo.Name getName(){return DataCenterInfo.Name.MyOwn;}
=======
        DataCenterInfo myDCI = new DataCenterInfo() {
            public DataCenterInfo.Name getName() {
                return DataCenterInfo.Name.MyOwn;
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;<<<<<<< MINE
                                                        .setAppName("test")
                                                        .setVIPAddress("test.testname:1")
                                                        .setDataCenterInfo(myDCI)
                                                        .setHostName("test.hostname").build();
=======
                .setAppName("test")
                .setVIPAddress("test.testname:1")
                .setDataCenterInfo(myDCI)
                .setHostName("test.hostname").build();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;<<<<<<< MINE
                     application.getByInstanceId("test.hostname"));
=======
                application.getByInstanceId("test.hostname"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockBackupRegistry.java;<<<<<<< MINE
=======
import java.util.HashMap;
import java.util.Map;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockBackupRegistry.java;<<<<<<< MINE
import java.util.HashMap;
import java.util.Map;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientCloseJerseyThreadTest.java;<<<<<<< MINE
import static org.hamcrest.CoreMatchers.equalTo;
import static org.junit.Assert.assertThat;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientCloseJerseyThreadTest.java;<<<<<<< MINE
=======
import static org.hamcrest.CoreMatchers.equalTo;
import static org.junit.Assert.assertThat;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;<<<<<<< MINE
=======
import java.util.UUID;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;<<<<<<< MINE
import com.netflix.discovery.shared.Application;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;<<<<<<< MINE
import java.util.Collections;
import java.util.Properties;
import java.util.UUID;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;<<<<<<< MINE
                MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
=======
                        MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;<<<<<<< MINE
                           mockLocalEurekaServer.isSentRegistry());
=======
                mockLocalEurekaServer.isSentRegistry());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.List;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
import javax.annotation.Nullable;
import java.util.Arrays;
import java.util.List;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    public MockRemoteEurekaServer mockLocalEurekaServer= new MockRemoteEurekaServer();
=======
    public MockRemoteEurekaServer mockLocalEurekaServer = new MockRemoteEurekaServer();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
=======
import java.util.List;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
import com.netflix.config.DynamicPropertyFactory;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
import java.util.Arrays;
import java.util.List;
import java.util.Set;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
            Thread.sleep(7*1000);
=======
            Thread.sleep(7 * 1000);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
            Thread.sleep(7*1000);
=======
            Thread.sleep(7 * 1000);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
                                                                                   REMOTE_REGION);
=======
                REMOTE_REGION);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
                            instancesByVipAddress.size());
=======
                instancesByVipAddress.size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
                            instancesByVipAddress.size());
=======
                instancesByVipAddress.size());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
import javax.annotation.Nullable;

import junit.framework.Assert;

import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
=======
import junit.framework.Assert;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Rule;
import org.junit.Test;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
                                                             "http://localhost:" + eurekaPort +
                                                             MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
=======
                "http://localhost:" + eurekaPort +
                        MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
    
    
=======


>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
                @UpStatus   Supplier<Boolean> upStatusSupplier,
=======
                @UpStatus Supplier<Boolean> upStatusSupplier,
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
                ) {
=======
        ) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
            
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
            Assert.assertEquals(state, (boolean)upStatusSupplier.get());
=======
            Assert.assertEquals(state, (boolean) upStatusSupplier.get());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
                    new AbstractModule() {
                        @Override
                        protected void configure() {
                            bind(EventBus.class).toInstance(eventBus);
                            bind(Service.class);
                            bind(InstanceInfo.class).toInstance(instanceInfo);
                        }
                    })
=======
                        new AbstractModule() {
                            @Override
                            protected void configure() {
                                bind(EventBus.class).toInstance(eventBus);
                                bind(Service.class);
                                bind(InstanceInfo.class).toInstance(instanceInfo);
                            }
                        })
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;<<<<<<< MINE
=======
import javax.annotation.Nullable;
import java.util.List;
import java.util.UUID;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;<<<<<<< MINE
import javax.annotation.Nullable;
import java.util.List;
import java.util.UUID;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;<<<<<<< MINE
                                                             "http://localhost:" + NOT_AVAILABLE_EUREKA_PORT /*Should always be unavailable*/
                                                             +
                                                             MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
=======
                "http://localhost:" + NOT_AVAILABLE_EUREKA_PORT /*Should always be unavailable*/
                        +
                        MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;<<<<<<< MINE
                                     new Provider<BackupRegistry>() {
                                         @Override
                                         public BackupRegistry get() {
                                             return backupRegistry;
                                         }
                                     });
=======
                new Provider<BackupRegistry>() {
                    @Override
                    public BackupRegistry get() {
                        return backupRegistry;
                    }
                });
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;<<<<<<< MINE
            } else if(registeredApplication.getName().equals(REMOTE_REGION_APP_NAME)) {
=======
            } else if (registeredApplication.getName().equals(REMOTE_REGION_APP_NAME)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
    private final Map<String, Application> applicationMap        = new HashMap<String, Application>();
    private final Map<String, Application> remoteRegionApps      = new HashMap<String, Application>();
=======
    private final Map<String, Application> applicationMap = new HashMap<String, Application>();
    private final Map<String, Application> remoteRegionApps = new HashMap<String, Application>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
    private final Map<String, Application> applicationDeltaMap   = new HashMap<String, Application>();
=======
    private final Map<String, Application> applicationDeltaMap = new HashMap<String, Application>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
            Thread.sleep( 3 * refreshRate * 1000);
=======
            Thread.sleep(3 * refreshRate * 1000);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
                        System.out.println("Eureka port: " +  port + ". " + System.currentTimeMillis() +". Not including delta as it has already been sent.");
=======
                        System.out.println("Eureka port: " + port + ". " + System.currentTimeMillis() + ". Not including delta as it has already been sent.");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
                } else if(pathInfo.equals("apps/")) {
=======
                } else if (pathInfo.equals("apps/")) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
                        System.out.println("Eureka port: " + port + ". " + System.currentTimeMillis() +". Not including delta apps in /apps response, as delta has not been sent.");
=======
                        System.out.println("Eureka port: " + port + ". " + System.currentTimeMillis() + ". Not including delta apps in /apps response, as delta has not been sent.");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;<<<<<<< MINE
            if(!handled) {
=======
            if (!handled) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b276656_00a016c/rev_b276656-00a016c/eureka-client/src/test/java/com/netflix/discovery/converters/InstanceInfoGenerator.java;<<<<<<< MINE
=======
package com.netflix.discovery.converters;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.Builder;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.appinfo.InstanceInfo.PortType;
import com.netflix.appinfo.LeaseInfo;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;

/**
 * @author Tomasz Bak
 */
public class InstanceInfoGenerator {

    public static final int RENEW_INTERVAL = 30000;

    private final int instanceCount;
    private final int applicationCount;
    private final boolean withMetaData;

    public InstanceInfoGenerator(int instanceCount, int applicationCount, boolean withMetaData) {
        this.instanceCount = instanceCount;
        this.applicationCount = applicationCount;
        this.withMetaData = withMetaData;
    }

    public Iterator<InstanceInfo> serviceIterator() {
        return new Iterator<InstanceInfo>() {

            private int returned;
            private final int[] appInstanceIds = new int[applicationCount];
            private int currentApp;

            @Override
            public boolean hasNext() {
                return returned < instanceCount;
            }

            @Override
            public InstanceInfo next() {
                if (!hasNext()) {
                    throw new NoSuchElementException("no more InstanceInfo elements");
                }
                InstanceInfo toReturn = generateInstanceInfo(currentApp, appInstanceIds[currentApp]);
                appInstanceIds[currentApp]++;
                currentApp = (currentApp + 1) % applicationCount;
                returned++;
                return toReturn;
            }

            @Override
            public void remove() {
                throw new IllegalStateException("method not supported");
            }
        };
    }

    public Applications toApplications() {
        Map<String, Application> appsByName = new HashMap<String, Application>();
        Iterator<InstanceInfo> it = serviceIterator();
        while (it.hasNext()) {
            InstanceInfo instanceInfo = it.next();
            Application instanceApp = appsByName.get(instanceInfo.getAppName());
            if (instanceApp == null) {
                instanceApp = new Application(instanceInfo.getAppName());
                appsByName.put(instanceInfo.getAppName(), instanceApp);
            }
            instanceApp.addInstance(instanceInfo);
        }

        // Do not pass application list to the constructor, as it does not initialize properly Applications
        // data structure.
        Applications applications = new Applications();
        for (Application app : appsByName.values()) {
            applications.addApplication(app);
        }

        applications.setAppsHashCode(applications.getReconcileHashCode());

        return applications;
    }

    private InstanceInfo generateInstanceInfo(int appIndex, int appInstanceId) {
        String hostName = "instance" + appInstanceId + ".application" + appIndex + ".com";
        String publicIp = "20.0." + appIndex + '.' + appInstanceId;
        String privateIp = "192.168." + appIndex + '.' + appInstanceId;

        AmazonInfo dataCenterInfo = AmazonInfo.Builder.newBuilder()
                .addMetadata(MetaDataKey.accountId, "testAccountId")
                .addMetadata(MetaDataKey.amiId, String.format("ami-%04d%04d", appIndex, appInstanceId))
                .addMetadata(MetaDataKey.availabilityZone, "us-east1c")
                .addMetadata(MetaDataKey.instanceId, String.format("i-%04d%04d", appIndex, appInstanceId))
                .addMetadata(MetaDataKey.instanceType, "m2.xlarge")
                .addMetadata(MetaDataKey.localIpv4, privateIp)
                .addMetadata(MetaDataKey.publicHostname, hostName)
                .addMetadata(MetaDataKey.publicIpv4, publicIp)
                .build();

        String unsecureURL = "http://" + hostName + ":8080";
        String secureURL = "https://" + hostName + ":8081";

        LeaseInfo leaseInfo = LeaseInfo.Builder.newBuilder()
                .setDurationInSecs(RENEW_INTERVAL)
                .setRenewalIntervalInSecs(RENEW_INTERVAL)
                .build();

        Builder builder = InstanceInfo.Builder.newBuilder()
                .setAppGroupName("AppGroup" + appIndex)
                .setAppName("App" + appIndex)
                .setASGName("ASG" + appIndex)
                .setHostName(hostName)
                .setIPAddr(publicIp)
                .setPort(8080)
                .setSecurePort(8081)
                .enablePort(PortType.SECURE, true)
                .setHealthCheckUrls("/healthcheck", unsecureURL + "/healthcheck", secureURL + "/healthcheck")
                .setHomePageUrl("/homepage", unsecureURL + "/homepage")
                .setStatusPageUrl("/status", unsecureURL + "/status")
                .setLeaseInfo(leaseInfo)
                .setStatus(InstanceStatus.UP)
                .setVIPAddress(hostName + ":8080")
                .setSecureVIPAddress(hostName + ":8081")
                .setDataCenterInfo(dataCenterInfo)
                .setLastUpdatedTimestamp(System.currentTimeMillis() - 100)
                .setLastDirtyTimestamp(System.currentTimeMillis() - 100)
                .setIsCoordinatingDiscoveryServer(true)
                .enablePort(PortType.UNSECURE, true);
        if (withMetaData) {
            builder.add("appKey" + appIndex, Integer.toString(appInstanceId));
        }
        return builder.build();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7ac504a_578f4c0/rev_7ac504a-578f4c0/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
public interface InstanceRegistry extends LeaseManager<InstanceInfo>, LookupService<String> {
=======
public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,
        LookupService<String> {

    private static final Logger logger = LoggerFactory
            .getLogger(InstanceRegistry.class);
    private static final EurekaServerConfig EUREKA_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final String[] EMPTY_STR_ARRAY = new String[0];
    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();
    private Timer evictionTimer = new Timer("Eureka-EvictionTimer", true);
    private volatile MeasuredRate renewsLastMin;
    protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
            .newBuilder().initialCapacity(500)
            .expireAfterAccess(1, TimeUnit.HOURS)
            .<String, InstanceStatus>build().asMap();

    // CircularQueues here for debugging/statistics purposes only
    private final CircularQueue<Pair<Long, String>> recentRegisteredQueue;
    private final CircularQueue<Pair<Long, String>> recentCanceledQueue;
    private Timer deltaRetentionTimer = new Timer("Eureka-DeltaRetentionTimer",
            true);
    private ConcurrentLinkedQueue<RecentlyChangedItem> recentlyChangedQueue = new ConcurrentLinkedQueue<RecentlyChangedItem>();
    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock read = readWriteLock.readLock();
    private final Lock write = readWriteLock.writeLock();
    protected Map<String, RemoteRegionRegistry> regionNameVSRemoteRegistry = new HashMap<String, RemoteRegionRegistry>();
    protected String[] allKnownRemoteRegions = EMPTY_STR_ARRAY;
    protected final Object lock = new Object();
    protected volatile int numberOfRenewsPerMinThreshold;
    protected volatile int expectedNumberOfRenewsPerMin;
    protected static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();

    private static final AtomicReference<EvictionTask> EVICTION_TASK = new AtomicReference<EvictionTask>();


    /**
     * Create a new, empty instance registry.
     */
    protected InstanceRegistry() {
        recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);
        recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);
        deltaRetentionTimer.schedule(getDeltaRetentionTask(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs());
    }

    /**
     * Completely clear the registry.
     */
    public void clearRegistry() {
        overriddenInstanceStatusMap.clear();
        recentCanceledQueue.clear();
        recentRegisteredQueue.clear();
        recentlyChangedQueue.clear();
        registry.clear();

    }

    /**
     * Registers a new instance with a given duration.
     *
     * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object,
     * int, boolean)
     */
    public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
        try {
            read.lock();
            Map<String, Lease<InstanceInfo>> gMap = registry.get(r
                    .getAppName());
            REGISTER.increment(isReplication);
            if (gMap == null) {
                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap =
                        new ConcurrentHashMap<String, Lease<InstanceInfo>>();
                gMap = registry.putIfAbsent(r.getAppName(), gNewMap);
                if (gMap == null) {
                    gMap = gNewMap;
                }
            }
            Lease<InstanceInfo> existingLease = gMap.get(r.getId());
            // Retain the last dirty timestamp without overwriting it, if there
            // is already a lease
            if (existingLease != null && (existingLease.getHolder() != null)) {
                Long existingLastDirtyTimestamp = existingLease.getHolder()
                        .getLastDirtyTimestamp();
                Long registrationLastDirtyTimestamp = r.getLastDirtyTimestamp();
                if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                    logger.warn(
                            "There is an existing lease and the existing lease's dirty timestamp {} is greater than "
                                    + "the one that is being registered {}", existingLastDirtyTimestamp,
                            registrationLastDirtyTimestamp);
                    r.setLastDirtyTimestamp(existingLastDirtyTimestamp);
                }
            } else {
                // The lease does not exist and hence it is a new registration
                synchronized (lock) {
                    if (this.expectedNumberOfRenewsPerMin > 0) {
                        // Since the client wants to cancel it, reduce the threshold
                        // (1
                        // for 30 seconds, 2 for a minute)
                        this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;
                        this.numberOfRenewsPerMinThreshold =
                                (int) (this.expectedNumberOfRenewsPerMin
                                        * EUREKA_SERVER_CONFIG.getRenewalPercentThreshold());
                    }
                }
            }
            Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                    leaseDuration);
            if (existingLease != null) {
                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
            }
            gMap.put(r.getId(), lease);
            synchronized (recentRegisteredQueue) {
                recentRegisteredQueue.add(new Pair<Long, String>(System.currentTimeMillis(), r.getAppName()
                        + "(" + r.getId() + ")"));
            }
            // This is where the initial state transfer of overridden status
            // happens
            if (!InstanceStatus.UNKNOWN.equals(r.getOverriddenStatus())) {
                logger.debug(
                        "Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                                + "overrides", r.getOverriddenStatus(), r.getId());
                if (!overriddenInstanceStatusMap.containsKey(r.getId())) {
                    logger.info(
                            "Not found overridden id {} and hence adding it",
                            r.getId());
                    overriddenInstanceStatusMap.put(r.getId(),
                            r.getOverriddenStatus());
                }
            }
            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(r.getId());
            if (overriddenStatusFromMap != null) {
                logger.info(
                        "Storing overridden status {} from map", overriddenStatusFromMap);
                r.setOverriddenStatus(overriddenStatusFromMap);
            }

            // Set the status based on the overridden status rules
            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(
                    r, existingLease, isReplication);
            r.setStatusWithoutDirty(overriddenInstanceStatus);

            // If the lease is registered with UP status, set lease service up timestamp
            if (InstanceStatus.UP.equals(r.getStatus())) {
                lease.serviceUp();
            }
            r.setActionType(ActionType.ADDED);
            recentlyChangedQueue.add(new RecentlyChangedItem(lease));
            r.setLastUpdatedTimestamp();
            invalidateCache(r.getAppName(), r.getVIPAddress(), r.getSecureVipAddress());
            logger.info("Registered instance id {} with status {}", r.getId(),
                    r.getStatus().toString());
            logger.debug("DS: Registry: registered " + r.getAppName() + " - "
                    + r.getId());
        } finally {
            read.unlock();
        }
    }

    /**
     * Cancels the registration of an instance.
     *
     * <p>
     * This is normally invoked by a client when it shuts down informing the
     * server to remove the instance from traffic.
     * </p>
     *
     * @param appName
     *            the application name of the application.
     * @param id
     *            the unique identifier of the instance.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the instance was removed from the
     *         {@link InstanceRegistry} successfully, false otherwise.
     */
    public boolean cancel(String appName, String id, boolean isReplication) {
        try {
            read.lock();
            CANCEL.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> leaseToCancel = null;
            if (gMap != null) {
                leaseToCancel = gMap.remove(id);
            }
            synchronized (recentCanceledQueue) {
                recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
            }
            InstanceStatus instanceStatus = overriddenInstanceStatusMap
                    .remove(id);
            if (instanceStatus != null) {
                logger.debug(
                        "Removed instance id {} from the overridden map which has value {}",
                        id, instanceStatus.name());
            }
            if (leaseToCancel == null) {
                CANCEL_NOT_FOUND.increment(isReplication);
                logger.warn("DS: Registry: cancel failed because Lease is not registered for: "
                        + appName + ":" + id);
                return false;
            } else {
                leaseToCancel.cancel();
                InstanceInfo instanceInfo = leaseToCancel.getHolder();
                String vip = null;
                String svip = null;
                if (instanceInfo != null) {
                    instanceInfo.setActionType(ActionType.DELETED);
                    recentlyChangedQueue.add(new RecentlyChangedItem(
                            leaseToCancel));
                    instanceInfo.setLastUpdatedTimestamp();
                    vip = instanceInfo.getVIPAddress();
                    svip = instanceInfo.getSecureVipAddress();
                }
                invalidateCache(appName, vip, svip);
                logger.debug("DS: Registry: canceled lease: " + appName + " - "
                        + id);
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Marks the given instance of the given app name as renewed, and also marks whether it originated from
     * replication.
     *
     * @see com.netflix.eureka.lease.LeaseManager#renew(java.lang.String,
     * java.lang.String, boolean)
     */
    public boolean renew(String appName, String id, boolean isReplication) {
        RENEW.increment(isReplication);
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        Lease<InstanceInfo> leaseToRenew = null;
        if (gMap != null) {
            leaseToRenew = gMap.get(id);
        }
        if (leaseToRenew == null) {
            RENEW_NOT_FOUND.increment(isReplication);
            logger.warn("DS: Registry: lease doesn't exist, registering resource: "
                    + appName + " - " + id);
            return false;
        } else {
            InstanceInfo instanceInfo = leaseToRenew.getHolder();
            if (instanceInfo != null) {
                // touchASGCache(instanceInfo.getASGName());
                InstanceStatus overriddenInstanceStatus = this
                        .getOverriddenInstanceStatus(instanceInfo,
                                leaseToRenew, isReplication);
                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
                    logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                            + "; re-register required", instanceInfo.getId());
                    RENEW_NOT_FOUND.increment(isReplication);
                    return false;
                }
                if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
                    Object[] args = {instanceInfo.getStatus().name(),
                            instanceInfo.getOverriddenStatus().name(),
                            instanceInfo.getId()};
                    logger.info(
                            "The instance status {} is different from overridden instance status {} for instance {}. "
                                    + "Hence setting the status to overridden status", args);
                    instanceInfo.setStatus(overriddenInstanceStatus);
                }
            }
            renewsLastMin.increment();
            leaseToRenew.renew();
            return true;
        }
    }

    /**
     * Stores overridden status if it is not already there. This happens during
     * a reconciliation process during renewal requests.
     *
     * @param id
     *            the unique identifier of the instance.
     * @param overriddenStatus
     *            Overridden status if any.
     */
    public void storeOverriddenStatusIfRequired(String id,
                                                InstanceStatus overriddenStatus) {
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.get(id);
        if ((instanceStatus == null)
                || (!overriddenStatus.equals(instanceStatus))) {
            // We might not have the overridden status if the server got
            // restarted -this will help us maintain the overridden state
            // from the replica
            logger.info(
                    "Adding overridden status for instance id {} and the value is {}",
                    id, overriddenStatus.name());
            overriddenInstanceStatusMap.put(id, overriddenStatus);
            List<InstanceInfo> instanceInfo = this.getInstancesById(id, false);
            if ((instanceInfo != null) && (!instanceInfo.isEmpty())) {
                instanceInfo.iterator().next().setOverriddenStatus(overriddenStatus);
                logger.info(
                        "Setting the overridden status for instance id {} and the value is {} ",
                        id, overriddenStatus.name());

            }
        }
    }

    /**
     * Updates the status of an instance. Normally happens to put an instance
     * between {@link InstanceStatus#OUT_OF_SERVICE} and
     * {@link InstanceStatus#UP} to put the instance in and out of traffic.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean statusUpdate(String appName, String id,
                                InstanceStatus newStatus, String lastDirtyTimestamp,
                                boolean isReplication) {
        try {
            read.lock();
            STATUS_UPDATE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                if ((info != null) && !(info.getStatus().equals(newStatus))) {
                    // Mark service as UP if needed
                    if (InstanceStatus.UP.equals(newStatus)) {
                        lease.serviceUp();
                    }
                    // This is NAC overriden status
                    overriddenInstanceStatusMap.put(id, newStatus);
                    // Set it for transfer of overridden status to replica on
                    // replica start up
                    info.setOverriddenStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                        info.setStatusWithoutDirty(newStatus);
                    } else {
                        info.setStatus(newStatus);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Removes status override for a give instance.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        try {
            read.lock();
            STATUS_OVERRIDE_DELETE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
                if (currentOverride != null && info != null) {
                    info.setOverriddenStatus(InstanceStatus.UNKNOWN);
                    info.setStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Evicts everything in the instance registry that has expired, if expiry is enabled.
     *
     * @see com.netflix.eureka.lease.LeaseManager#evict()
     */
    public void evict() {
        if (!isLeaseExpirationEnabled()) {
            logger.debug("DS: lease expiration is currently disabled.");
            return;
        }
        logger.debug("Running the evict task");
        for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
            Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
            if (leaseMap != null) {
                for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
                    Lease<InstanceInfo> lease = leaseEntry.getValue();
                    if (lease.isExpired() && lease.getHolder() != null) {
                        String appName = lease.getHolder().getAppName();
                        String id = lease.getHolder().getId();
                        EXPIRED.increment();
                        logger.warn("DS: Registry: expired lease for "
                                + appName + " - " + id);
                        cancel(appName, id, false);
                    }
                }
            }
        }
    }

    /**
     * Returns the given app that is in this instance only, falling back to other regions transparently only
     * if specified in this client configuration.
     *
     * @param appName
     *      - the application name of the application
     * @return the application
     *
     * @see
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
     */
    public Application getApplication(String appName) {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        return this.getApplication(appName, !disableTransparentFallback);
    }

    /**
     * Get application information.
     *
     * @param appName
     *            - The name of the application
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the application
     */
    public Application getApplication(String appName, boolean includeRemoteRegion) {
        Application app = null;

        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);

        if (leaseMap != null && leaseMap.size() > 0) {
            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {
                if (app == null) {
                    app = new Application(appName);
                }
                app.addInstance(decorateInstanceInfo(entry.getValue()));
            }
        } else if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application;
                }
            }
        }
        return app;
    }

    /**
     * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.
     *
     * @return the list of all known applications
     *
     * @see com.netflix.discovery.shared.LookupService#getApplications()
     */
    public Applications getApplications() {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        if (disableTransparentFallback) {
            return getApplicationsFromLocalRegionOnly();
        } else {
            return this.getApplications(true); // Behavior of falling back to remote region can be disabled.
        }
    }

    /**
     * Returns applications including instances from all remote regions. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with a <code>null</code> argument.
     */
    public Applications getApplicationsFromAllRemoteRegions() {
        return getApplicationsFromMultipleRegions(allKnownRemoteRegions);
    }

    /**
     * Returns applications including instances from local region only. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with an empty array.
     */
    public Applications getApplicationsFromLocalRegionOnly() {
        return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);
    }

    /**
     * This method will return applications with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     * The application instances for which this union will be done can be restricted to the names returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for every region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     * If you are not selectively requesting for a remote region, use {@link #getApplicationsFromAllRemoteRegions()}
     * or {@link #getApplicationsFromLocalRegionOnly()}
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> or empty no remote regions are
     *                      included.
     *
     * @return The applications with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be only for certain whitelisted apps as explained above.
     */
    public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {

        boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;

        logger.info("Fetching applications registry with remote regions: {}, Regions argument {}", includeRemoteRegion,
                Arrays.toString(remoteRegions));

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
        } else {
            GET_ALL_CACHE_MISS.increment();
        }
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }
                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                if (null != remoteRegistry) {
                    Applications remoteApps = remoteRegistry.getApplications();
                    for (Application application : remoteApps.getRegisteredApplications()) {
                        if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                            logger.info("Application {}  fetched from the remote region {}",
                                    application.getName(), remoteRegion);

                            Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                            if (appInstanceTillNow == null) {
                                appInstanceTillNow = new Application(application.getName());
                                apps.addApplication(appInstanceTillNow);
                            }
                            for (InstanceInfo instanceInfo : application.getInstances()) {
                                appInstanceTillNow.addInstance(instanceInfo);
                            }
                        } else {
                            logger.debug("Application {} not fetched from the remote region {} as there exists a "
                                            + "whitelist and this app is not in the whitelist.",
                                    application.getName(), remoteRegion);
                        }
                    }
                } else {
                    logger.warn("No remote registry available for the remote region {}", remoteRegion);
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {
        Set<String> whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(remoteRegion);
        if (null == whiteList) {
            whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(null); // see global whitelist.
        }
        return null == whiteList || whiteList.contains(appName);
    }

    /**
     * Get the registry information about all {@link Applications}.
     *
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return applications
     * @deprecated Use {@link #getApplicationsFromMultipleRegions(String[])} instead. This method has a flawed behavior
     * of transparently falling back to a remote region if no instances for an app is available locally. The new
     * behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplications(boolean includeRemoteRegion) {
        GET_ALL_CACHE_MISS.increment();
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {

                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();

                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }

                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Applications applications = remoteRegistry.getApplications();
                for (Application application : applications
                        .getRegisteredApplications()) {
                    Application appInLocalRegistry = apps
                            .getRegisteredApplications(application.getName());
                    if (appInLocalRegistry == null) {
                        apps.addApplication(application);
                    }
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    /**
     * Get the registry information about the delta changes. The deltas are
     * cached for a window specified by
     * {@link EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()}. Subsequent
     * requests for delta information may return the same information and client
     * must make sure this does not adversely affect them.
     *
     * @return all application deltas.
     * @deprecated use {@link #getApplicationDeltasFromMultipleRegions(String[])} instead. This method has a
     * flawed behavior of transparently falling back to a remote region if no instances for an app is available locally.
     * The new behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplicationDeltas() {
        GET_ALL_CACHE_MISS_DELTA.increment();
        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :"
                    + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();

            if (!disableTransparentFallback) {
                Applications allAppsInLocalRegion = getApplications(false);

                for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                    Applications applications = remoteRegistry.getApplicationDeltas();
                    for (Application application : applications.getRegisteredApplications()) {
                        Application appInLocalRegistry =
                                allAppsInLocalRegion.getRegisteredApplications(application.getName());
                        if (appInLocalRegistry == null) {
                            apps.addApplication(application);
                        }
                    }
                }
            }

            Applications allApps = getApplications(!disableTransparentFallback);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow =
                                            apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id) {
        return this.getInstanceByAppAndId(appName, id, true);
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id,
                                              boolean includeRemoteRegions) {
        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (leaseMap != null) {
            lease = leaseMap.get(id);
        }
        if (lease != null
                && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
            return decorateInstanceInfo(lease);
        } else if (includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application.getByInstanceId(id);
                }
            }
        }
        return null;
    }

    /**
     * Get all instances by ID, including automatically asking other regions if the ID is unknown.
     *
     * @see com.netflix.discovery.shared.LookupService#getInstancesById(String)
     */
    public List<InstanceInfo> getInstancesById(String id) {
        return this.getInstancesById(id, true);
    }

    /**
     * Get the list of instances by its unique id.
     *
     * @param id
     *            - the unique id of the instance
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return list of InstanceInfo objects.
     */
    public List<InstanceInfo> getInstancesById(String id,
                                               boolean includeRemoteRegions) {
        List<InstanceInfo> list = new ArrayList<InstanceInfo>();

        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = registry
                .entrySet().iterator(); iter.hasNext(); ) {

            Map<String, Lease<InstanceInfo>> leaseMap = iter.next().getValue();
            if (leaseMap != null) {
                Lease<InstanceInfo> lease = leaseMap.get(id);

                if (lease == null
                        || (isLeaseExpirationEnabled() && lease.isExpired())) {
                    continue;
                }

                if (list == Collections.EMPTY_LIST) {
                    list = new ArrayList<InstanceInfo>();
                }
                list.add(decorateInstanceInfo(lease));
            }
        }
        if (list.isEmpty() && includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                for (Application application : remoteRegistry.getApplications()
                        .getRegisteredApplications()) {
                    InstanceInfo instanceInfo = application.getByInstanceId(id);
                    if (instanceInfo != null) {
                        list.add(instanceInfo);
                        return list;
                    }
                }
            }
        }
        return list;
    }

    /**
     * Checks whether lease expiration is enabled.
     *
     * @return true if enabled
     */
    public abstract boolean isLeaseExpirationEnabled();

    private InstanceInfo decorateInstanceInfo(Lease<InstanceInfo> lease) {
        InstanceInfo info = lease.getHolder();

        // client app settings
        int renewalInterval = LeaseInfo.DEFAULT_LEASE_RENEWAL_INTERVAL;
        int leaseDuration = LeaseInfo.DEFAULT_LEASE_DURATION;

        // TODO: clean this up
        if (info.getLeaseInfo() != null) {
            renewalInterval = info.getLeaseInfo().getRenewalIntervalInSecs();
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }

        info.setLeaseInfo(LeaseInfo.Builder.newBuilder()
                .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                .setRenewalIntervalInSecs(renewalInterval)
                .setDurationInSecs(leaseDuration)
                .setEvictionTimestamp(lease.getEvictionTimestamp()).build());

        info.setIsCoordinatingDiscoveryServer();
        return info;
    }

    /**
     * Servo route; do not call.
     *
     * @return servo data
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsInLastMin",
            description = "Number of total heartbeats received in the last minute", type = DataSourceType.GAUGE)
    public long getNumOfRenewsInLastMin() {
        if (renewsLastMin != null) {
            return renewsLastMin.getCount();
        } else {
            return 0;
        }
    }

    /**
     * Get the N instances that are most recently registered.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNRegisteredInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();

        synchronized (recentRegisteredQueue) {
            for (Pair<Long, String> aRecentRegisteredQueue : recentRegisteredQueue) {
                list.add(aRecentRegisteredQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    /**
     * Get the N instances that have most recently canceled.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNCanceledInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();
        synchronized (recentCanceledQueue) {
            for (Pair<Long, String> aRecentCanceledQueue : recentCanceledQueue) {
                list.add(aRecentCanceledQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    private void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
        // invalidate cache
        ResponseCache.getInstance().invalidate(appName, vipAddress, secureVipAddress);
    }

    private static final class RecentlyChangedItem {
        private long lastUpdateTime;
        private Lease<InstanceInfo> leaseInfo;

        public RecentlyChangedItem(Lease<InstanceInfo> lease) {
            this.leaseInfo = lease;
            lastUpdateTime = System.currentTimeMillis();
        }

        public long getLastUpdateTime() {
            return this.lastUpdateTime;
        }

        public Lease<InstanceInfo> getLeaseInfo() {
            return this.leaseInfo;
        }
    }

    protected void postInit() {
        renewsLastMin = new MeasuredRate(1000 * 60 * 1);
        if (EVICTION_TASK.get() != null) {
            EVICTION_TASK.get().cancel();
        }
        EVICTION_TASK.set(new EvictionTask());
        evictionTimer.schedule(EVICTION_TASK.get(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs());
    }

    @com.netflix.servo.annotations.Monitor(name = "numOfElementsinInstanceCache", description = "Number of elements in the instance Cache", type = DataSourceType.GAUGE)
    public long getNumberofElementsininstanceCache() {
        return overriddenInstanceStatusMap.size();
    }

    private final class EvictionTask extends TimerTask {

        @Override
        public void run() {
            try {
                evict();
            } catch (Throwable e) {
                logger.error("Could not run the evict task", e);
            }
        }

    }


    private class CircularQueue<E> extends ConcurrentLinkedQueue<E> {
        private int size = 0;

        public CircularQueue(int size) {
            this.size = size;
        }

        @Override
        public boolean add(E e) {
            this.makeSpaceIfNotAvailable();
            return super.add(e);

        }

        private void makeSpaceIfNotAvailable() {
            if (this.size() == size) {
                this.remove();
            }
        }

        public boolean offer(E e) {
            this.makeSpaceIfNotAvailable();
            return super.offer(e);
        }
    }


    private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                       Lease<InstanceInfo> existingLease, boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance
        // says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat
        // failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed
        // as well since the service may be
        // currently in SERVICE
        if ((!InstanceStatus.UP.equals(r.getStatus()))
                && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug(
                    "Trusting the instance status {} from replica or instance for instance",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise
        // the ASG status
        if (overridden != null) {
            logger.debug(
                    "The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }
        // If the ASGName is present- check for its status
        boolean isASGDisabled = false;
        if (r.getASGName() != null) {
            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(
                    r.getASGName());
            logger.debug("The ASG name is specified {} and the value is {}",
                    r.getASGName(), isASGDisabled);
            if (isASGDisabled) {
                return InstanceStatus.OUT_OF_SERVICE;
            } else {
                return InstanceStatus.UP;
            }
        }
        // This is for backward compatibility until all applications have ASG
        // names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or
            // OUT_OF_SERVICE
            if ((existingStatus != null)
                    && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                    || InstanceStatus.UP.equals(existingStatus))) {
                logger.debug(
                        "There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug(
                "Returning the default instance status {} for instance {},",
                r.getStatus(), r.getId());
        return r.getStatus();
    }

    private TimerTask getDeltaRetentionTask() {
        return new TimerTask() {

            @Override
            public void run() {
                Iterator<RecentlyChangedItem> it = recentlyChangedQueue.iterator();
                while (it.hasNext()) {
                    if (it.next().getLastUpdateTime() <
                            System.currentTimeMillis() - EUREKA_CONFIG.getRetentionTimeInMSInDeltaQueue()) {
                        it.remove();
                    } else {
                        break;
                    }
                }
            }

        };
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_81aaebd_756bcd9/rev_81aaebd-756bcd9/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
public interface PeerAwareInstanceRegistry extends InstanceRegistry {
    void register(InstanceInfo info, boolean isReplication);
=======
public class PeerAwareInstanceRegistry extends InstanceRegistry {
    private static final String US_EAST_1 = "us-east-1";

    private static final int PRIME_PEER_NODES_RETRY_MS = 30000;

    private static final int REGISTRY_SYNC_RETRY_MS = 30000;

    private static final Logger logger = LoggerFactory
            .getLogger(PeerAwareInstanceRegistry.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final EurekaClientConfig EUREKA_CLIENT_CONFIG = DiscoveryManager
            .getInstance().getEurekaClientConfig();

    private long startupTime = 0;
    private boolean peerInstancesTransferEmptyOnStartup = true;
    private static final Timer timerReplicaNodes = new Timer(
            "Eureka-PeerNodesUpdater", true);

    public enum Action {
        Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;

        private com.netflix.servo.monitor.Timer timer = Monitors.newTimer(this
                .name());

        public com.netflix.servo.monitor.Timer getTimer() {
            return this.timer;
        }

    }

    private static final Comparator<Application> APP_COMPARATOR = new Comparator<Application>() {
        public int compare(Application l, Application r) {
            return l.getName().compareTo(r.getName());
        }
    };

    private final MeasuredRate numberOfReplicationsLastMin = new MeasuredRate(
            1000 * 60 * 1);


    private AtomicReference<List<PeerEurekaNode>> peerEurekaNodes;

    private Timer timer = new Timer(
            "ReplicaAwareInstanceRegistry - RenewalThresholdUpdater", true);

    private static final PeerAwareInstanceRegistry instance = new PeerAwareInstanceRegistry();

    PeerAwareInstanceRegistry() {
        // Make it an atomic reference since this could be updated in the
        // background.
        peerEurekaNodes = new AtomicReference<List<PeerEurekaNode>>();
        peerEurekaNodes.set(new ArrayList<PeerEurekaNode>());
        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn(
                    "Cannot register the JMX monitor for the InstanceRegistry :",
                    e);
        }
        init();
    }

    public static PeerAwareInstanceRegistry getInstance() {
        return instance;
    }

    /**
     * Set up replica nodes and the task that updates the threshold
     * periodically.
     */
    private void init() {
        setupPeerEurekaNodes();
        scheduleRenewalThresholdUpdateTask();
    }

    /**
     * Schedule the task that updates <em>renewal threshold</em> periodically.
     * The renewal threshold would be used to determine if the renewals drop
     * dramatically because of network partition and to protect expiring too
     * many instances at a time.
     *
     */
    private void scheduleRenewalThresholdUpdateTask() {
        timer.schedule(new TimerTask() {

                           @Override
                           public void run() {
                               updateRenewalThreshold();

                           }

                       }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
                EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs());
    }

    /**
     * Set up a schedule task to update peer eureka node information
     * periodically to determine if a node has been removed or added to the
     * list.
     */
    private void setupPeerEurekaNodes() {
        try {
            updatePeerEurekaNodes();
            timerReplicaNodes.schedule(new TimerTask() {

                                           @Override
                                           public void run() {
                                               try {
                                                   updatePeerEurekaNodes();
                                               } catch (Throwable e) {
                                                   logger.error("Cannot update the replica Nodes", e);
                                               }

                                           }
                                       }, EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs(),
                    EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs());

        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    /**
     * Update information about peer eureka nodes.
     */
    private void updatePeerEurekaNodes() {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();

        EurekaClientConfig clientConfig = DiscoveryManager.getInstance().getEurekaClientConfig();
        String zone = InstanceInfo.getZone(
                clientConfig.getAvailabilityZones(clientConfig.getRegion()),
                myInfo);

        List<String> replicaUrls = DiscoveryManager.getInstance().getEurekaClient().getDiscoveryServiceUrls(zone);

        List<PeerEurekaNode> replicaNodes = new ArrayList<PeerEurekaNode>();
        for (String replicaUrl : replicaUrls) {
            if (!isThisMe(replicaUrl)) {
                logger.info("Adding replica node: " + replicaUrl);
                replicaNodes.add(new PeerEurekaNode(replicaUrl));
            }
        }
        if (replicaNodes.isEmpty()) {
            logger.warn("The replica size seems to be empty. Check the route 53 DNS Registry");
            return;
        }
        List<PeerEurekaNode> existingReplicaNodes = peerEurekaNodes.get();
        if (!replicaNodes.equals(existingReplicaNodes)) {
            List<String> previousServiceUrls = new ArrayList<String>();
            for (PeerEurekaNode node : existingReplicaNodes) {
                previousServiceUrls.add(node.getServiceUrl());
            }
            List<String> currentServiceUrls = new ArrayList<String>();
            for (PeerEurekaNode node : replicaNodes) {
                currentServiceUrls.add(node.getServiceUrl());
            }
            logger.info(
                    "Updating the replica nodes as they seem to have changed from {} to {} ",
                    previousServiceUrls, currentServiceUrls);
            peerEurekaNodes.set(replicaNodes);
            for (PeerEurekaNode existingReplicaNode : existingReplicaNodes) {
                existingReplicaNode.destroyResources();
            }
        } else {
            for (PeerEurekaNode replicaNode : replicaNodes) {
                replicaNode.destroyResources();
            }
        }
    }

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        LookupService lookupService = DiscoveryManager.getInstance()
                .getLookupService();
        int count = 0;

        for (int i = 0; ((i < EUREKA_SERVER_CONFIG.getRegistrySyncRetries()) && (count == 0)); i++) {
            Applications apps = lookupService.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {

                            register(instance, instance.getLeaseInfo()
                                    .getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
            if (count == 0) {
                try {
                    Thread.sleep(REGISTRY_SYNC_RETRY_MS);
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
        }
        return count;
    }

    public void openForTraffic(int count) {
        // Renewals happen every 30 seconds and for a minute it should be a
        // factor of 2.
        this.expectedNumberOfRenewsPerMin = count * 2;
        this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                .getRenewalPercentThreshold());
        logger.info("Got " + count + " instances from neighboring DS node");
        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
        this.startupTime = System.currentTimeMillis();
        if (count > 0) {
            this.peerInstancesTransferEmptyOnStartup = false;
        }
        boolean isAws = (Name.Amazon.equals(ApplicationInfoManager
                .getInstance().getInfo().getDataCenterInfo().getName()));
        if (isAws && EUREKA_SERVER_CONFIG.shouldPrimeAwsReplicaConnections()) {
            logger.info("Priming AWS connections for all replicas..");
            primeAwsReplicas();
        }
        logger.info("Changing status to UP");
        ApplicationInfoManager.getInstance().setInstanceStatus(
                InstanceStatus.UP);
        super.postInit();
    }

    /**
     * Prime connections for Aws replicas.
     * <p>
     * Sometimes when the eureka servers comes up, AWS firewall may not allow
     * the network connections immediately. This will cause the outbound
     * connections to fail, but the inbound connections continue to work. What
     * this means is the clients would have switched to this node (after EIP
     * binding) and so the other eureka nodes will expire all instances that
     * have been switched because of the lack of outgoing heartbeats from this
     * instance.
     * </p>
     * <p>
     * The best protection in this scenario is to block and wait until we are
     * able to ping all eureka nodes successfully atleast once. Until then we
     * won't open up the traffic.
     * </p>
     */
    private void primeAwsReplicas() {
        boolean areAllPeerNodesPrimed = false;
        while (!areAllPeerNodesPrimed) {
            String peerHostName = null;
            try {
                Application eurekaApps = this.getApplication(
                        ApplicationInfoManager.getInstance().getInfo()
                                .getAppName(), false);
                if (eurekaApps == null) {
                    areAllPeerNodesPrimed = true;
                }
                for (PeerEurekaNode node : peerEurekaNodes.get()) {
                    for (InstanceInfo peerInstanceInfo : eurekaApps
                            .getInstances()) {
                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();
                        // If the lease is expired - do not worry about priming
                        if (System.currentTimeMillis() > (leaseInfo
                                .getRenewalTimestamp() + (leaseInfo
                                .getDurationInSecs() * 1000))
                                + (2 * 60 * 1000)) {
                            continue;
                        }
                        peerHostName = peerInstanceInfo.getHostName();
                        logger.info(
                                "Trying to send heartbeat for the eureka server at {} to make sure the network "
                                        + "channels are open", peerHostName);
                        // Only try to contact the eureka nodes that are in this
                        // instance's registry - because
                        // the other instances may be legitimately down
                        if (peerHostName.equalsIgnoreCase(new URI(node
                                .getServiceUrl()).getHost())) {
                            node.heartbeat(peerInstanceInfo.getAppName(),
                                    peerInstanceInfo.getId(), peerInstanceInfo,
                                    null, true);
                        }
                    }
                }
                areAllPeerNodesPrimed = true;
            } catch (Throwable e) {
                logger.error("Could not contact " + peerHostName, e);
                try {
                    Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                } catch (InterruptedException e1) {
                    logger.warn("Interrupted while priming : ", e1);
                    areAllPeerNodesPrimed = true;
                }
            }
        }
    }

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, o otherwise returns
     *         true
     */
    public boolean shouldAllowAccess(boolean remoteRegionRequired) {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (!(System.currentTimeMillis() > this.startupTime
                    + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
                return false;
            }
        }
        if (remoteRegionRequired) {
            for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
                if (!remoteRegionRegistry.isReadyForServingData()) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean shouldAllowAccess() {
        return shouldAllowAccess(true);
    }

    /**
     * Gets the list of peer eureka nodes which is the list to replicate
     * information to.
     *
     * @return the list of replica nodes.
     */
    public List<PeerEurekaNode> getReplicaNodes() {
        return Collections.unmodifiableList(peerEurekaNodes.get());
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#cancel(java.lang.String,
     * java.lang.String, long, boolean)
     */
    @Override
    public boolean cancel(final String appName, final String id,
                          final boolean isReplication) {
        if (super.cancel(appName, id, isReplication)) {
            replicateToPeers(Action.Cancel, appName, id, null, null,
                    isReplication);
            synchronized (lock) {
                if (this.expectedNumberOfRenewsPerMin > 0) {
                    // Since the client wants to cancel it, reduce the threshold
                    // (1
                    // for 30 seconds, 2 for a minute)
                    this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2;
                    this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Registers the information about the {@link InstanceInfo} and replicates
     * this information to all peer eureka nodes. If this is replication event
     * from other replica nodes then it is not replicated.
     *
     * @param info
     *            the {@link InstanceInfo} to be registered and replicated.
     * @param isReplication
     *            true if this is a replication event from other replica nodes,
     *            false otherwise.
     */
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null
                && info.getLeaseInfo().getDurationInSecs() > 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(),
                info, null, isReplication);
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#renew(java.lang.String,
     * java.lang.String, long, boolean)
     */
    public boolean renew(final String appName, final String id,
                         final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null,
                    isReplication);
            return true;
        }
        return false;
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String,
     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,
     * java.lang.String, boolean)
     */
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp,
                isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus,
                    isReplication);
            return true;
        }
        return false;
    }

    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /**
     * Replicate the <em>ASG status</em> updates to peer eureka nodes. If this
     * event is a replication from other nodes, then it is not replicated to
     * other nodes.
     *
     * @param asgName
     *            the asg name for which the status needs to be replicated.
     * @param newStatus
     *            the {@link ASGStatus} information that needs to be replicated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     */
    public void statusUpdate(final String asgName, final ASGStatus newStatus,
                             final boolean isReplication) {
        // If this is replicated from an other node, do not try to replicate
        // again.
        if (isReplication) {
            return;
        }
        for (final PeerEurekaNode node : peerEurekaNodes.get()) {
            replicateASGInfoToReplicaNodes(asgName, newStatus, node);

        }

    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#isLeaseExpirationEnabled()
     */
    @Override
    public boolean isLeaseExpirationEnabled() {
        boolean leaseExpirationEnabled = (numberOfRenewsPerMinThreshold > 0)
                && (getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold);
        boolean isSelfPreservationModeEnabled = isSelfPreservationModeEnabled();
        if ((!leaseExpirationEnabled)) {
            if (!isSelfPreservationModeEnabled) {
                logger.warn("The self preservation mode is disabled!. Hence allowing the instances to expire.");
                leaseExpirationEnabled = true;
            }
        }
        return leaseExpirationEnabled;
    }

    /**
     * Checks to see if the self-preservation mode is enabled.
     *
     * <p>
     * The self-preservation mode is enabled if the expected number of renewals
     * per minute {@link #getNumOfRenewsInLastMin()} is lesser than the expected
     * threshold which is determined by {@link #getNumOfRenewsPerMinThreshold()}
     * . Eureka perceives this as a danger and stops expiring instances as this
     * is most likely because of a network event. The mode is disabled only when
     * the renewals get back to above the threshold or if the flag
     * {@link EurekaServerConfig#shouldEnableSelfPreservation()} is set to
     * false.
     * </p>
     *
     * @return true if the self-preservation mode is enabled, false otherwise.
     */
    public boolean isSelfPreservationModeEnabled() {
        return EUREKA_SERVER_CONFIG.shouldEnableSelfPreservation();
    }

    /**
     * Perform all cleanup and shutdown operations.
     */
    void shutdown() {
        try {
            DefaultMonitorRegistry.getInstance().unregister(
                    Monitors.newObjectMonitor(this));
        } catch (Throwable t) {
            logger.error("Cannot shutdown monitor registry", t);
        }
        try {
            for (PeerEurekaNode node : this.peerEurekaNodes.get()) {
                node.shutDown();
            }
        } catch (Throwable t) {
            logger.error("Cannot shutdown ReplicaAwareInstanceRegistry", t);
        }
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String virtualHostname,
                                                boolean secure) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Updates the <em>renewal threshold</em> based on the current number of
     * renewals. The threshold is a percentage as specified in
     * {@link EurekaServerConfig#getRenewalPercentThreshold()} of renewals
     * received per minute {@link #getNumOfRenewsInLastMin()}.
     */
    private void updateRenewalThreshold() {
        try {
            LookupService lookupService = DiscoveryManager.getInstance()
                    .getLookupService();
            Applications apps = lookupService.getApplications();
            int count = 0;
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    if (this.isRegisterable(instance)) {
                        ++count;
                    }
                }
            }
            synchronized (lock) {
                // Update threshold only if the threshold is greater than the
                // current expected threshold of if the self preservation is disabled.
                if ((count * 2) > (EUREKA_SERVER_CONFIG
                        .getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
                        || (!this.isSelfPreservationModeEnabled())) {
                    this.expectedNumberOfRenewsPerMin = count * 2;
                    this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            logger.info("Current renewal threshold is : {}",
                    numberOfRenewsPerMinThreshold);
        } catch (Throwable e) {
            logger.error("Cannot update renewal threshold", e);
        }
    }

    /**
     * Gets the list of all {@link Applications} from the registry in sorted
     * lexical order of {@link Application#getName()}.
     *
     * @return the list of {@link Applications} in lexical order.
     */
    public List<Application> getSortedApplications() {
        List<Application> apps = new ArrayList<Application>(getApplications()
                .getRegisteredApplications());
        Collections.sort(apps, APP_COMPARATOR);
        return apps;
    }

    /**
     * Gets the number of <em>renewals</em> in the last minute.
     *
     * @return a long value representing the number of <em>renewals</em> in the
     *         last minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfReplicationsInLastMin",
            description = "Number of total replications received in the last minute",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public long getNumOfReplicationsInLastMin() {
        return numberOfReplicationsLastMin.getCount();
    }

    /**
     * Checks if the number of renewals is lesser than threshold. This method is for servo metrics only.
     *
     * @return 0 if the renewals are greater than threshold, 1 otherwise.
     */
    @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public int isBelowRenewThresold() {
        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Gets the threshold for the renewals per minute.
     *
     * @return the integer representing the threshold for the renewals per
     *         minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsPerMinThreshold", type = DataSourceType.GAUGE)
    public int getNumOfRenewsPerMinThreshold() {
        return numberOfRenewsPerMinThreshold;
    }


    /**
     * Checks if an instance is registerable in this region. Instances from
     * other regions are rejected.
     *
     * @param instanceInfo
     *            - the instance info information of the instance
     * @return - true, if it can be registered in this server, false otherwise.
     */
    public boolean isRegisterable(InstanceInfo instanceInfo) {
        DataCenterInfo datacenterInfo = instanceInfo.getDataCenterInfo();
        String serverRegion = EUREKA_CLIENT_CONFIG.getRegion();
        if (AmazonInfo.class.isInstance(datacenterInfo)) {
            AmazonInfo info = AmazonInfo.class.cast(instanceInfo
                    .getDataCenterInfo());
            String availabilityZone = info.get(MetaDataKey.availabilityZone);
            // Can be null for dev environments in non-AWS data center
            if (availabilityZone == null
                    && US_EAST_1.equalsIgnoreCase(serverRegion)) {
                return true;
            } else if ((availabilityZone != null)
                    && (availabilityZone.contains(serverRegion))) {
                // If in the same region as server, then consider it
                // registerable
                return true;
            }
        }
        return true; // Everything non-amazon is registrable.
    }

    /**
     * Checks if the given service url contains the current host which is trying
     * to replicate. Only after the EIP binding is done the host has a chance to
     * identify itself in the list of replica nodes and needs to take itself out
     * of replication traffic.
     *
     * @param url
     *            the service url of the replica node that the check is made.
     * @return true, if the url represents the current node which is trying to
     *         replicate, false otherwise.
     */
    private boolean isThisMe(String url) {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();
        try {
            URI uri = new URI(url);
            return (uri.getHost().equals(myInfo.getHostName()));
        } catch (URISyntaxException e) {
            logger.error("Error in syntax", e);
            return false;
        }
    }

    /**
     * Replicates all eureka actions to peer eureka nodes except for replication
     * traffic to this node.
     *
     */
    private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {

            if (isReplication) {
                numberOfReplicationsLastMin.increment();
            }
            // If it is a replication already, do not replicate again as this
            // will create a poison replication
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.get()) {
                // If the url represents this host, do not replicate
                // to yourself.
                if (isThisMe(node.getServiceUrl())) {
                    continue;
                }
                replicateInstanceActionsToPeers(action, appName, id, info,
                        newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }

    /**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                            .get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                            false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error(
                    "Cannot replicate information to " + node.getServiceUrl()
                            + " for action " + action.name(), t);
        }
    }

    /**
     * Replicates all ASG status changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateASGInfoToReplicaNodes(final String asgName,
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
        CurrentRequestVersion.set(Version.V2);
        try {
            node.statusUpdate(asgName, newStatus);

        } catch (Throwable e) {
            logger.error(
                    "Cannot replicate ASG status information to "
                            + node.getServiceUrl(), e);
        }

    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_491cca0_3f69679/rev_491cca0-3f69679/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
public interface InstanceRegistry extends LeaseManager<InstanceInfo>, LookupService<String> {
=======
public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,
        LookupService<String> {

    private static final Logger logger = LoggerFactory
            .getLogger(InstanceRegistry.class);
    private static final EurekaServerConfig EUREKA_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final String[] EMPTY_STR_ARRAY = new String[0];
    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();
    private Timer evictionTimer = new Timer("Eureka-EvictionTimer", true);
    private volatile MeasuredRate renewsLastMin;
    protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
            .newBuilder().initialCapacity(500)
            .expireAfterAccess(1, TimeUnit.HOURS)
            .<String, InstanceStatus>build().asMap();

    // CircularQueues here for debugging/statistics purposes only
    private final CircularQueue<Pair<Long, String>> recentRegisteredQueue;
    private final CircularQueue<Pair<Long, String>> recentCanceledQueue;
    private Timer deltaRetentionTimer = new Timer("Eureka-DeltaRetentionTimer",
            true);
    private ConcurrentLinkedQueue<RecentlyChangedItem> recentlyChangedQueue = new ConcurrentLinkedQueue<RecentlyChangedItem>();
    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock read = readWriteLock.readLock();
    private final Lock write = readWriteLock.writeLock();
    protected Map<String, RemoteRegionRegistry> regionNameVSRemoteRegistry = new HashMap<String, RemoteRegionRegistry>();
    protected String[] allKnownRemoteRegions = EMPTY_STR_ARRAY;
    protected final Object lock = new Object();
    protected volatile int numberOfRenewsPerMinThreshold;
    protected volatile int expectedNumberOfRenewsPerMin;
    protected static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();

    private static final AtomicReference<EvictionTask> EVICTION_TASK = new AtomicReference<EvictionTask>();


    /**
     * Create a new, empty instance registry.
     */
    protected InstanceRegistry() {
        recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);
        recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);
        deltaRetentionTimer.schedule(getDeltaRetentionTask(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs());
    }

    /**
     * Completely clear the registry.
     */
    public void clearRegistry() {
        overriddenInstanceStatusMap.clear();
        recentCanceledQueue.clear();
        recentRegisteredQueue.clear();
        recentlyChangedQueue.clear();
        registry.clear();

    }

    /**
     * Registers a new instance with a given duration.
     *
     * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object,
     * int, boolean)
     */
    public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
        try {
            read.lock();
            Map<String, Lease<InstanceInfo>> gMap = registry.get(r
                    .getAppName());
            REGISTER.increment(isReplication);
            if (gMap == null) {
                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap =
                        new ConcurrentHashMap<String, Lease<InstanceInfo>>();
                gMap = registry.putIfAbsent(r.getAppName(), gNewMap);
                if (gMap == null) {
                    gMap = gNewMap;
                }
            }
            Lease<InstanceInfo> existingLease = gMap.get(r.getId());
            // Retain the last dirty timestamp without overwriting it, if there
            // is already a lease
            if (existingLease != null && (existingLease.getHolder() != null)) {
                Long existingLastDirtyTimestamp = existingLease.getHolder()
                        .getLastDirtyTimestamp();
                Long registrationLastDirtyTimestamp = r.getLastDirtyTimestamp();
                if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                    logger.warn(
                            "There is an existing lease and the existing lease's dirty timestamp {} is greater than "
                                    + "the one that is being registered {}", existingLastDirtyTimestamp,
                            registrationLastDirtyTimestamp);
                    r.setLastDirtyTimestamp(existingLastDirtyTimestamp);
                }
            } else {
                // The lease does not exist and hence it is a new registration
                synchronized (lock) {
                    if (this.expectedNumberOfRenewsPerMin > 0) {
                        // Since the client wants to cancel it, reduce the threshold
                        // (1
                        // for 30 seconds, 2 for a minute)
                        this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;
                        this.numberOfRenewsPerMinThreshold =
                                (int) (this.expectedNumberOfRenewsPerMin
                                        * EUREKA_SERVER_CONFIG.getRenewalPercentThreshold());
                    }
                }
            }
            Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                    leaseDuration);
            if (existingLease != null) {
                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
            }
            gMap.put(r.getId(), lease);
            synchronized (recentRegisteredQueue) {
                recentRegisteredQueue.add(new Pair<Long, String>(System.currentTimeMillis(), r.getAppName()
                        + "(" + r.getId() + ")"));
            }
            // This is where the initial state transfer of overridden status
            // happens
            if (!InstanceStatus.UNKNOWN.equals(r.getOverriddenStatus())) {
                logger.debug(
                        "Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                                + "overrides", r.getOverriddenStatus(), r.getId());
                if (!overriddenInstanceStatusMap.containsKey(r.getId())) {
                    logger.info(
                            "Not found overridden id {} and hence adding it",
                            r.getId());
                    overriddenInstanceStatusMap.put(r.getId(),
                            r.getOverriddenStatus());
                }
            }
            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(r.getId());
            if (overriddenStatusFromMap != null) {
                logger.info(
                        "Storing overridden status {} from map", overriddenStatusFromMap);
                r.setOverriddenStatus(overriddenStatusFromMap);
            }

            // Set the status based on the overridden status rules
            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(
                    r, existingLease, isReplication);
            r.setStatusWithoutDirty(overriddenInstanceStatus);

            // If the lease is registered with UP status, set lease service up timestamp
            if (InstanceStatus.UP.equals(r.getStatus())) {
                lease.serviceUp();
            }
            r.setActionType(ActionType.ADDED);
            recentlyChangedQueue.add(new RecentlyChangedItem(lease));
            r.setLastUpdatedTimestamp();
            invalidateCache(r.getAppName(), r.getVIPAddress(), r.getSecureVipAddress());
            logger.info("Registered instance id {} with status {}", r.getId(),
                    r.getStatus().toString());
            logger.debug("DS: Registry: registered " + r.getAppName() + " - "
                    + r.getId());
        } finally {
            read.unlock();
        }
    }

    /**
     * Cancels the registration of an instance.
     *
     * <p>
     * This is normally invoked by a client when it shuts down informing the
     * server to remove the instance from traffic.
     * </p>
     *
     * @param appName
     *            the application name of the application.
     * @param id
     *            the unique identifier of the instance.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the instance was removed from the
     *         {@link InstanceRegistry} successfully, false otherwise.
     */
    public boolean cancel(String appName, String id, boolean isReplication) {
        try {
            read.lock();
            CANCEL.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> leaseToCancel = null;
            if (gMap != null) {
                leaseToCancel = gMap.remove(id);
            }
            synchronized (recentCanceledQueue) {
                recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
            }
            InstanceStatus instanceStatus = overriddenInstanceStatusMap
                    .remove(id);
            if (instanceStatus != null) {
                logger.debug(
                        "Removed instance id {} from the overridden map which has value {}",
                        id, instanceStatus.name());
            }
            if (leaseToCancel == null) {
                CANCEL_NOT_FOUND.increment(isReplication);
                logger.warn("DS: Registry: cancel failed because Lease is not registered for: "
                        + appName + ":" + id);
                return false;
            } else {
                leaseToCancel.cancel();
                InstanceInfo instanceInfo = leaseToCancel.getHolder();
                String vip = null;
                String svip = null;
                if (instanceInfo != null) {
                    instanceInfo.setActionType(ActionType.DELETED);
                    recentlyChangedQueue.add(new RecentlyChangedItem(
                            leaseToCancel));
                    instanceInfo.setLastUpdatedTimestamp();
                    vip = instanceInfo.getVIPAddress();
                    svip = instanceInfo.getSecureVipAddress();
                }
                invalidateCache(appName, vip, svip);
                logger.debug("DS: Registry: canceled lease: " + appName + " - "
                        + id);
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Marks the given instance of the given app name as renewed, and also marks whether it originated from
     * replication.
     *
     * @see com.netflix.eureka.lease.LeaseManager#renew(java.lang.String,
     * java.lang.String, boolean)
     */
    public boolean renew(String appName, String id, boolean isReplication) {
        RENEW.increment(isReplication);
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        Lease<InstanceInfo> leaseToRenew = null;
        if (gMap != null) {
            leaseToRenew = gMap.get(id);
        }
        if (leaseToRenew == null) {
            RENEW_NOT_FOUND.increment(isReplication);
            logger.warn("DS: Registry: lease doesn't exist, registering resource: "
                    + appName + " - " + id);
            return false;
        } else {
            InstanceInfo instanceInfo = leaseToRenew.getHolder();
            if (instanceInfo != null) {
                // touchASGCache(instanceInfo.getASGName());
                InstanceStatus overriddenInstanceStatus = this
                        .getOverriddenInstanceStatus(instanceInfo,
                                leaseToRenew, isReplication);
                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
                    logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                            + "; re-register required", instanceInfo.getId());
                    RENEW_NOT_FOUND.increment(isReplication);
                    return false;
                }
                if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
                    Object[] args = {instanceInfo.getStatus().name(),
                            instanceInfo.getOverriddenStatus().name(),
                            instanceInfo.getId()};
                    logger.info(
                            "The instance status {} is different from overridden instance status {} for instance {}. "
                                    + "Hence setting the status to overridden status", args);
                    instanceInfo.setStatus(overriddenInstanceStatus);
                }
            }
            renewsLastMin.increment();
            leaseToRenew.renew();
            return true;
        }
    }

    /**
     * Stores overridden status if it is not already there. This happens during
     * a reconciliation process during renewal requests.
     *
     * @param id
     *            the unique identifier of the instance.
     * @param overriddenStatus
     *            Overridden status if any.
     */
    public void storeOverriddenStatusIfRequired(String id,
                                                InstanceStatus overriddenStatus) {
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.get(id);
        if ((instanceStatus == null)
                || (!overriddenStatus.equals(instanceStatus))) {
            // We might not have the overridden status if the server got
            // restarted -this will help us maintain the overridden state
            // from the replica
            logger.info(
                    "Adding overridden status for instance id {} and the value is {}",
                    id, overriddenStatus.name());
            overriddenInstanceStatusMap.put(id, overriddenStatus);
            List<InstanceInfo> instanceInfo = this.getInstancesById(id, false);
            if ((instanceInfo != null) && (!instanceInfo.isEmpty())) {
                instanceInfo.iterator().next().setOverriddenStatus(overriddenStatus);
                logger.info(
                        "Setting the overridden status for instance id {} and the value is {} ",
                        id, overriddenStatus.name());

            }
        }
    }

    /**
     * Updates the status of an instance. Normally happens to put an instance
     * between {@link InstanceStatus#OUT_OF_SERVICE} and
     * {@link InstanceStatus#UP} to put the instance in and out of traffic.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean statusUpdate(String appName, String id,
                                InstanceStatus newStatus, String lastDirtyTimestamp,
                                boolean isReplication) {
        try {
            read.lock();
            STATUS_UPDATE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                if ((info != null) && !(info.getStatus().equals(newStatus))) {
                    // Mark service as UP if needed
                    if (InstanceStatus.UP.equals(newStatus)) {
                        lease.serviceUp();
                    }
                    // This is NAC overriden status
                    overriddenInstanceStatusMap.put(id, newStatus);
                    // Set it for transfer of overridden status to replica on
                    // replica start up
                    info.setOverriddenStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                        info.setStatusWithoutDirty(newStatus);
                    } else {
                        info.setStatus(newStatus);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Removes status override for a give instance.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        try {
            read.lock();
            STATUS_OVERRIDE_DELETE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
                if (currentOverride != null && info != null) {
                    info.setOverriddenStatus(InstanceStatus.UNKNOWN);
                    info.setStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Evicts everything in the instance registry that has expired, if expiry is enabled.
     *
     * @see com.netflix.eureka.lease.LeaseManager#evict()
     */
    public void evict() {
        if (!isLeaseExpirationEnabled()) {
            logger.debug("DS: lease expiration is currently disabled.");
            return;
        }
        logger.debug("Running the evict task");
        for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
            Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
            if (leaseMap != null) {
                for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
                    Lease<InstanceInfo> lease = leaseEntry.getValue();
                    if (lease.isExpired() && lease.getHolder() != null) {
                        String appName = lease.getHolder().getAppName();
                        String id = lease.getHolder().getId();
                        EXPIRED.increment();
                        logger.warn("DS: Registry: expired lease for "
                                + appName + " - " + id);
                        cancel(appName, id, false);
                    }
                }
            }
        }
    }

    /**
     * Returns the given app that is in this instance only, falling back to other regions transparently only
     * if specified in this client configuration.
     *
     * @param appName
     *      - the application name of the application
     * @return the application
     *
     * @see
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
     */
    public Application getApplication(String appName) {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        return this.getApplication(appName, !disableTransparentFallback);
    }

    /**
     * Get application information.
     *
     * @param appName
     *            - The name of the application
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the application
     */
    public Application getApplication(String appName, boolean includeRemoteRegion) {
        Application app = null;

        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);

        if (leaseMap != null && leaseMap.size() > 0) {
            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {
                if (app == null) {
                    app = new Application(appName);
                }
                app.addInstance(decorateInstanceInfo(entry.getValue()));
            }
        } else if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application;
                }
            }
        }
        return app;
    }

    /**
     * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.
     *
     * @return the list of all known applications
     *
     * @see com.netflix.discovery.shared.LookupService#getApplications()
     */
    public Applications getApplications() {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        if (disableTransparentFallback) {
            return getApplicationsFromLocalRegionOnly();
        } else {
            return this.getApplications(true); // Behavior of falling back to remote region can be disabled.
        }
    }

    /**
     * Returns applications including instances from all remote regions. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with a <code>null</code> argument.
     */
    public Applications getApplicationsFromAllRemoteRegions() {
        return getApplicationsFromMultipleRegions(allKnownRemoteRegions);
    }

    /**
     * Returns applications including instances from local region only. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with an empty array.
     */
    public Applications getApplicationsFromLocalRegionOnly() {
        return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);
    }

    /**
     * This method will return applications with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     * The application instances for which this union will be done can be restricted to the names returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for every region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     * If you are not selectively requesting for a remote region, use {@link #getApplicationsFromAllRemoteRegions()}
     * or {@link #getApplicationsFromLocalRegionOnly()}
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> or empty no remote regions are
     *                      included.
     *
     * @return The applications with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be only for certain whitelisted apps as explained above.
     */
    public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {

        boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;

        logger.info("Fetching applications registry with remote regions: {}, Regions argument {}", includeRemoteRegion,
                Arrays.toString(remoteRegions));

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
        } else {
            GET_ALL_CACHE_MISS.increment();
        }
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }
                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                if (null != remoteRegistry) {
                    Applications remoteApps = remoteRegistry.getApplications();
                    for (Application application : remoteApps.getRegisteredApplications()) {
                        if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                            logger.info("Application {}  fetched from the remote region {}",
                                    application.getName(), remoteRegion);

                            Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                            if (appInstanceTillNow == null) {
                                appInstanceTillNow = new Application(application.getName());
                                apps.addApplication(appInstanceTillNow);
                            }
                            for (InstanceInfo instanceInfo : application.getInstances()) {
                                appInstanceTillNow.addInstance(instanceInfo);
                            }
                        } else {
                            logger.debug("Application {} not fetched from the remote region {} as there exists a "
                                            + "whitelist and this app is not in the whitelist.",
                                    application.getName(), remoteRegion);
                        }
                    }
                } else {
                    logger.warn("No remote registry available for the remote region {}", remoteRegion);
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {
        Set<String> whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(remoteRegion);
        if (null == whiteList) {
            whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(null); // see global whitelist.
        }
        return null == whiteList || whiteList.contains(appName);
    }

    /**
     * Get the registry information about all {@link Applications}.
     *
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return applications
     * @deprecated Use {@link #getApplicationsFromMultipleRegions(String[])} instead. This method has a flawed behavior
     * of transparently falling back to a remote region if no instances for an app is available locally. The new
     * behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplications(boolean includeRemoteRegion) {
        GET_ALL_CACHE_MISS.increment();
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {

                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();

                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }

                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Applications applications = remoteRegistry.getApplications();
                for (Application application : applications
                        .getRegisteredApplications()) {
                    Application appInLocalRegistry = apps
                            .getRegisteredApplications(application.getName());
                    if (appInLocalRegistry == null) {
                        apps.addApplication(application);
                    }
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    /**
     * Get the registry information about the delta changes. The deltas are
     * cached for a window specified by
     * {@link EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()}. Subsequent
     * requests for delta information may return the same information and client
     * must make sure this does not adversely affect them.
     *
     * @return all application deltas.
     * @deprecated use {@link #getApplicationDeltasFromMultipleRegions(String[])} instead. This method has a
     * flawed behavior of transparently falling back to a remote region if no instances for an app is available locally.
     * The new behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplicationDeltas() {
        GET_ALL_CACHE_MISS_DELTA.increment();
        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :"
                    + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();

            if (!disableTransparentFallback) {
                Applications allAppsInLocalRegion = getApplications(false);

                for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                    Applications applications = remoteRegistry.getApplicationDeltas();
                    for (Application application : applications.getRegisteredApplications()) {
                        Application appInLocalRegistry =
                                allAppsInLocalRegion.getRegisteredApplications(application.getName());
                        if (appInLocalRegistry == null) {
                            apps.addApplication(application);
                        }
                    }
                }
            }

            Applications allApps = getApplications(!disableTransparentFallback);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow =
                                            apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id) {
        return this.getInstanceByAppAndId(appName, id, true);
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id,
                                              boolean includeRemoteRegions) {
        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (leaseMap != null) {
            lease = leaseMap.get(id);
        }
        if (lease != null
                && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
            return decorateInstanceInfo(lease);
        } else if (includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application.getByInstanceId(id);
                }
            }
        }
        return null;
    }

    /**
     * Get all instances by ID, including automatically asking other regions if the ID is unknown.
     *
     * @see com.netflix.discovery.shared.LookupService#getInstancesById(String)
     */
    public List<InstanceInfo> getInstancesById(String id) {
        return this.getInstancesById(id, true);
    }

    /**
     * Get the list of instances by its unique id.
     *
     * @param id
     *            - the unique id of the instance
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return list of InstanceInfo objects.
     */
    public List<InstanceInfo> getInstancesById(String id,
                                               boolean includeRemoteRegions) {
        List<InstanceInfo> list = new ArrayList<InstanceInfo>();

        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = registry
                .entrySet().iterator(); iter.hasNext(); ) {

            Map<String, Lease<InstanceInfo>> leaseMap = iter.next().getValue();
            if (leaseMap != null) {
                Lease<InstanceInfo> lease = leaseMap.get(id);

                if (lease == null
                        || (isLeaseExpirationEnabled() && lease.isExpired())) {
                    continue;
                }

                if (list == Collections.EMPTY_LIST) {
                    list = new ArrayList<InstanceInfo>();
                }
                list.add(decorateInstanceInfo(lease));
            }
        }
        if (list.isEmpty() && includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                for (Application application : remoteRegistry.getApplications()
                        .getRegisteredApplications()) {
                    InstanceInfo instanceInfo = application.getByInstanceId(id);
                    if (instanceInfo != null) {
                        list.add(instanceInfo);
                        return list;
                    }
                }
            }
        }
        return list;
    }

    /**
     * Checks whether lease expiration is enabled.
     *
     * @return true if enabled
     */
    public abstract boolean isLeaseExpirationEnabled();

    private InstanceInfo decorateInstanceInfo(Lease<InstanceInfo> lease) {
        InstanceInfo info = lease.getHolder();

        // client app settings
        int renewalInterval = LeaseInfo.DEFAULT_LEASE_RENEWAL_INTERVAL;
        int leaseDuration = LeaseInfo.DEFAULT_LEASE_DURATION;

        // TODO: clean this up
        if (info.getLeaseInfo() != null) {
            renewalInterval = info.getLeaseInfo().getRenewalIntervalInSecs();
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }

        info.setLeaseInfo(LeaseInfo.Builder.newBuilder()
                .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                .setRenewalIntervalInSecs(renewalInterval)
                .setDurationInSecs(leaseDuration)
                .setEvictionTimestamp(lease.getEvictionTimestamp()).build());

        info.setIsCoordinatingDiscoveryServer();
        return info;
    }

    /**
     * Servo route; do not call.
     *
     * @return servo data
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsInLastMin",
            description = "Number of total heartbeats received in the last minute", type = DataSourceType.GAUGE)
    public long getNumOfRenewsInLastMin() {
        if (renewsLastMin != null) {
            return renewsLastMin.getCount();
        } else {
            return 0;
        }
    }

    /**
     * Get the N instances that are most recently registered.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNRegisteredInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();

        synchronized (recentRegisteredQueue) {
            for (Pair<Long, String> aRecentRegisteredQueue : recentRegisteredQueue) {
                list.add(aRecentRegisteredQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    /**
     * Get the N instances that have most recently canceled.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNCanceledInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();
        synchronized (recentCanceledQueue) {
            for (Pair<Long, String> aRecentCanceledQueue : recentCanceledQueue) {
                list.add(aRecentCanceledQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    private void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
        // invalidate cache
        ResponseCache.getInstance().invalidate(appName, vipAddress, secureVipAddress);
    }

    private static final class RecentlyChangedItem {
        private long lastUpdateTime;
        private Lease<InstanceInfo> leaseInfo;

        public RecentlyChangedItem(Lease<InstanceInfo> lease) {
            this.leaseInfo = lease;
            lastUpdateTime = System.currentTimeMillis();
        }

        public long getLastUpdateTime() {
            return this.lastUpdateTime;
        }

        public Lease<InstanceInfo> getLeaseInfo() {
            return this.leaseInfo;
        }
    }

    protected void postInit() {
        renewsLastMin = new MeasuredRate(1000 * 60 * 1);
        if (EVICTION_TASK.get() != null) {
            EVICTION_TASK.get().cancel();
        }
        EVICTION_TASK.set(new EvictionTask());
        evictionTimer.schedule(EVICTION_TASK.get(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs());
    }

    @com.netflix.servo.annotations.Monitor(name = "numOfElementsinInstanceCache", description = "Number of elements in the instance Cache", type = DataSourceType.GAUGE)
    public long getNumberofElementsininstanceCache() {
        return overriddenInstanceStatusMap.size();
    }

    private final class EvictionTask extends TimerTask {

        @Override
        public void run() {
            try {
                evict();
            } catch (Throwable e) {
                logger.error("Could not run the evict task", e);
            }
        }

    }


    private class CircularQueue<E> extends ConcurrentLinkedQueue<E> {
        private int size = 0;

        public CircularQueue(int size) {
            this.size = size;
        }

        @Override
        public boolean add(E e) {
            this.makeSpaceIfNotAvailable();
            return super.add(e);

        }

        private void makeSpaceIfNotAvailable() {
            if (this.size() == size) {
                this.remove();
            }
        }

        public boolean offer(E e) {
            this.makeSpaceIfNotAvailable();
            return super.offer(e);
        }
    }


    private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                       Lease<InstanceInfo> existingLease, boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance
        // says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat
        // failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed
        // as well since the service may be
        // currently in SERVICE
        if ((!InstanceStatus.UP.equals(r.getStatus()))
                && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug(
                    "Trusting the instance status {} from replica or instance for instance",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise
        // the ASG status
        if (overridden != null) {
            logger.debug(
                    "The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }
        // If the ASGName is present- check for its status
        boolean isASGDisabled = false;
        if (r.getASGName() != null) {
            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(r);
            logger.debug("The ASG name is specified {} and the value is {}",
                    r.getASGName(), isASGDisabled);
            if (isASGDisabled) {
                return InstanceStatus.OUT_OF_SERVICE;
            } else {
                return InstanceStatus.UP;
            }
        }
        // This is for backward compatibility until all applications have ASG
        // names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or
            // OUT_OF_SERVICE
            if ((existingStatus != null)
                    && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                    || InstanceStatus.UP.equals(existingStatus))) {
                logger.debug(
                        "There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug(
                "Returning the default instance status {} for instance {},",
                r.getStatus(), r.getId());
        return r.getStatus();
    }

    private TimerTask getDeltaRetentionTask() {
        return new TimerTask() {

            @Override
            public void run() {
                Iterator<RecentlyChangedItem> it = recentlyChangedQueue.iterator();
                while (it.hasNext()) {
                    if (it.next().getLastUpdateTime() <
                            System.currentTimeMillis() - EUREKA_CONFIG.getRetentionTimeInMSInDeltaQueue()) {
                        it.remove();
                    } else {
                        break;
                    }
                }
            }

        };
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_491cca0_3f69679/rev_491cca0-3f69679/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
    private Set<String> getASGNames() {
        Set<String> asgNames = new HashSet<String>();
        Applications apps = PeerAwareInstanceRegistryImpl.getInstance().getApplications(false);
=======
    private Set<CacheKey> getCacheKeys() {
        Set<CacheKey> cacheKeys = new HashSet<CacheKey>();
        Applications apps = PeerAwareInstanceRegistry.getInstance().getApplications(false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_6ad0339_bac3649/rev_6ad0339-bac3649/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
=======
import com.netflix.appinfo.DataCenterInfo;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c9f6ea_0d7c1b1/rev_7c9f6ea-0d7c1b1/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
            .expireAfterAccess(10, TimeUnit.MINUTES)
=======
            .expireAfterAccess(eurekaConfig.getASGCacheExpiryTimeoutMs(), TimeUnit.MILLISECONDS)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import com.netflix.config.DynamicPropertyFactory;
import com.netflix.discovery.converters.CodecWrapper;
import com.netflix.discovery.converters.CodecWrapper.CodecType;
import com.netflix.discovery.provider.DiscoveryJerseyProvider;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
        @Inject(optional = true)
        private Collection<ClientFilter> additionalFilters;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        public DiscoveryClientOptionalArgs(EventBus eventBus, Provider<HealthCheckCallback> healthCheckCallbackProvider, Provider<HealthCheckHandler> healthCheckHandlerProvider) {
=======
        public void setEventBus(EventBus eventBus) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
        }

        public void setHealthCheckCallbackProvider(Provider<HealthCheckCallback> healthCheckCallbackProvider) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
        }

        public void setHealthCheckHandlerProvider(Provider<HealthCheckHandler> healthCheckHandlerProvider) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        private Collection<ClientFilter> additionalFilters;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
=======
package com.netflix.discovery.shared;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.netflix.discovery.provider.DiscoveryJerseyProvider;
import com.netflix.servo.monitor.BasicCounter;
import com.netflix.servo.monitor.BasicTimer;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.MonitorConfig;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.discovery.util.DiscoveryBuildInfo.buildVersion;

/**
 * @author Tomasz Bak
 */
public class EurekaJerseyClient {

    private static final Logger s_logger = LoggerFactory.getLogger(EurekaJerseyClient.class);

    private static final int HTTP_CONNECTION_CLEANER_INTERVAL_MS = 30 * 1000;

    private static final String PROTOCOL = "https";
    private static final String PROTOCOL_SCHEME = "SSL";
    private static final int HTTPS_PORT = 443;
    private static final String KEYSTORE_TYPE = "JKS";

    private final ApacheHttpClient4 apacheHttpClient;

    ClientConfig jerseyClientConfig;

    private final ScheduledExecutorService eurekaConnCleaner =
            Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {

                private final AtomicInteger threadNumber = new AtomicInteger(1);

                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
                }
            });

    public EurekaJerseyClient(int connectionTimeout, int readTimeout, final int connectionIdleTimeout,
                              ClientConfig clientConfig) {
        try {
            jerseyClientConfig = clientConfig;
            jerseyClientConfig.getClasses().add(DiscoveryJerseyProvider.class);
            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);
            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();

            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);
            HttpConnectionParams.setSoTimeout(params, readTimeout);

            eurekaConnCleaner.scheduleWithFixedDelay(
                    new ConnectionCleanerTask(connectionIdleTimeout), HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    TimeUnit.MILLISECONDS);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client", e);
        }
    }

    public ApacheHttpClient4 getClient() {
        return apacheHttpClient;
    }

    /**
     * Clean up resources.
     */
    public void destroyResources() {
        if (eurekaConnCleaner != null) {
            eurekaConnCleaner.shutdown();
        }
        if (apacheHttpClient != null) {
            apacheHttpClient.destroy();
        }
    }

    public static class EurekaJerseyClientBuilder {

        private boolean systemSSL;
        private String clientName;
        private int maxConnectionsPerHost;
        private int maxTotalConnections;
        private String trustStoreFileName;
        private String trustStorePassword;
        private String userAgent;
        private String proxyUserName;
        private String proxyPassword;
        private String proxyHost;
        private String proxyPort;
        private int connectionTimeout;
        private int readTimeout;
        private int connectionIdleTimeout;

        public EurekaJerseyClientBuilder withClientName(String clientName) {
            this.clientName = clientName;
            return this;
        }

        public EurekaJerseyClientBuilder withUserAgent(String userAgent) {
            this.userAgent = userAgent;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionTimeout(int connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withReadTimeout(int readTimeout) {
            this.readTimeout = readTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionIdleTimeout(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxConnectionsPerHost(int maxConnectionsPerHost) {
            this.maxConnectionsPerHost = maxConnectionsPerHost;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxTotalConnections(int maxTotalConnections) {
            this.maxTotalConnections = maxTotalConnections;
            return this;
        }

        public EurekaJerseyClientBuilder withProxy(String proxyHost, String proxyPort, String user, String password) {
            this.proxyHost = proxyHost;
            this.proxyPort = proxyPort;
            this.proxyUserName = user;
            this.proxyPassword = password;
            return this;
        }

        public EurekaJerseyClientBuilder withSystemSSLConfiguration() {
            this.systemSSL = true;
            return this;
        }

        public EurekaJerseyClientBuilder withTrustStoreFile(String trustStoreFileName, String trustStorePassword) {
            this.trustStoreFileName = trustStoreFileName;
            this.trustStorePassword = trustStorePassword;
            return this;
        }

        public EurekaJerseyClient build() {
            MyDefaultApacheHttpClient4Config config = new MyDefaultApacheHttpClient4Config();
            try {
                return new EurekaJerseyClient(connectionTimeout, readTimeout, connectionIdleTimeout, config);
            } catch (Throwable e) {
                throw new RuntimeException("Cannot create Jersey client ", e);
            }
        }

        class MyDefaultApacheHttpClient4Config extends DefaultApacheHttpClient4Config {
            MyDefaultApacheHttpClient4Config() {
                MonitoredConnectionManager cm;

                if (systemSSL) {
                    cm = createSystemSslCM();
                } else if (trustStoreFileName != null) {
                    cm = createCustomSslCM();
                } else {
                    cm = new MonitoredConnectionManager(clientName);
                }

                if (proxyHost != null) {
                    addProxyConfiguration(cm);
                }

                // Common properties to all clients
                cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
                cm.setMaxTotal(maxTotalConnections);
                getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);

                String fullUserAgentName = (userAgent == null ? clientName : userAgent) + "/v" + buildVersion();
                getProperties().put(CoreProtocolPNames.USER_AGENT, fullUserAgentName);

                // To pin a client to specific server in case redirect happens, we handle redirects directly
                // (see DiscoveryClient.makeRemoteCall methods).
                getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
                getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);

            }

            private void addProxyConfiguration(MonitoredConnectionManager cm) {
                if (proxyUserName != null && proxyPassword != null) {
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
                } else {
                    // Due to bug in apache client, user name/password must always be set.
                    // Otherwise proxy configuration is ignored.
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
                }
                getProperties().put(DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI, "http://" + proxyHost + ":" + proxyPort);
            }

            private MonitoredConnectionManager createSystemSslCM() {
                MonitoredConnectionManager cm;
                SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
                SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));
                cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                return cm;
            }

            private MonitoredConnectionManager createCustomSslCM() {
                FileInputStream fin = null;
                try {
                    SSLContext sslContext = SSLContext.getInstance(PROTOCOL_SCHEME);
                    KeyStore sslKeyStore = KeyStore.getInstance(KEYSTORE_TYPE);

                    fin = new FileInputStream(trustStoreFileName);
                    sslKeyStore.load(fin, trustStorePassword.toCharArray());

                    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    factory.init(sslKeyStore);

                    TrustManager[] trustManagers = factory.getTrustManagers();

                    sslContext.init(null, trustManagers, null);
                    SSLSocketFactory sslSocketFactory = new SSLSocketFactory(sslContext);
                    sslSocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
                    SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                    sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

                    return new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                } catch (Exception ex) {
                    throw new IllegalStateException("SSL configuration issue", ex);
                } finally {
                    if (fin != null) {
                        try {
                            fin.close();
                        } catch (IOException ignore) {
                        }
                    }
                }
            }
        }
    }

    private class ConnectionCleanerTask implements Runnable {

        private final int connectionIdleTimeout;
        private final BasicTimer executionTimeStats;
        private final Counter cleanupFailed;

        private ConnectionCleanerTask(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            MonitorConfig.Builder monitorConfigBuilder = MonitorConfig.builder("Eureka-Connection-Cleaner-Time");
            executionTimeStats = new BasicTimer(monitorConfigBuilder.build());
            cleanupFailed = new BasicCounter(MonitorConfig.builder("Eureka-Connection-Cleaner-Failure").build());
            try {
                Monitors.registerObject(this);
            } catch (Exception e) {
                s_logger.error("Unable to register with servo.", e);
            }
        }

        @Override
        public void run() {
            Stopwatch start = executionTimeStats.start();
            try {
                apacheHttpClient
                        .getClientHandler()
                        .getHttpClient()
                        .getConnectionManager()
                        .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
            } catch (Throwable e) {
                s_logger.error("Cannot clean connections", e);
                cleanupFailed.increment();
            } finally {
                if (null != start) {
                    start.stop();
                }
            }

        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private final EurekaAccept clientAccept;
    private final JerseyClient discoveryJerseyClient;
=======
    private String appPathIdentifier;
    private boolean isRegisteredWithDiscovery = false;
    private EurekaJerseyClient discoveryJerseyClient;
    private AtomicReference<String> lastQueryRedirect = new AtomicReference<String>();
    private AtomicReference<String> lastRegisterRedirect = new AtomicReference<String>();
    private ApacheHttpClient4 discoveryApacheClient;
    protected static EurekaClientConfig clientConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private InstanceInfoReplicator instanceInfoReplicator;

=======
    private volatile long lastSuccessfulRegistryFetchTimestamp = -1;
    private volatile long lastSuccessfulHeartbeatTimestamp = -1;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_6e0b19f_9415eda/rev_6e0b19f-9415eda/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private InstanceInfoReplicator instanceInfoReplicator;
=======
    private final ThresholdLevelsMetric heartbeatStalenessMonitor;
    private final ThresholdLevelsMetric registryStalenessMonitor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a6b86ea_e879aa1/rev_a6b86ea-e879aa1/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
import com.netflix.eureka.resources.ServerCodecs;
=======
import com.sun.jersey.api.client.Client;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.netflix.eureka;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;
import java.net.InetAddress;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.ActionType;
import com.netflix.discovery.EurekaIdentityHeaderFilter;
import com.netflix.discovery.TimedSupervisorTask;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.transport.jersey.EurekaJerseyClient;
import com.netflix.discovery.shared.transport.jersey.EurekaJerseyClientImpl.EurekaJerseyClientBuilder;
import com.netflix.discovery.shared.LookupService;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.filter.GZIPContentEncodingFilter;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Handles all registry operations that needs to be done on a eureka service running in an other region.
 *
 * The primary operations include fetching registry information from remote region and fetching delta information
 * on a periodic basis.
 *
 * @author Karthik Ranganathan
 *
 */
public class RemoteRegionRegistry implements LookupService<String> {
    private static final Logger logger = LoggerFactory.getLogger(RemoteRegionRegistry.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG =
            EurekaServerConfigurationManager.getInstance().getConfiguration();

    private final ApacheHttpClient4 discoveryApacheClient;
    private final EurekaJerseyClient discoveryJerseyClient;
    private final com.netflix.servo.monitor.Timer fetchRegistryTimer;
    private final URL remoteRegionURL;

    private final ScheduledExecutorService scheduler;
    // monotonically increasing generation counter to ensure stale threads do not reset registry to an older version
    private final AtomicLong fullRegistryGeneration = new AtomicLong(0);
    private final AtomicLong deltaGeneration = new AtomicLong(0);

    private final AtomicReference<Applications> applications = new AtomicReference<Applications>();
    private final AtomicReference<Applications> applicationsDelta = new AtomicReference<Applications>();
    private volatile boolean readyForServingData;

    public RemoteRegionRegistry(String regionName, URL remoteRegionURL) {
        this.remoteRegionURL = remoteRegionURL;
        this.fetchRegistryTimer = Monitors.newTimer(this.remoteRegionURL.toString() + "_FetchRegistry");

        EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                .withUserAgent("Java-EurekaClient-RemoteRegion")
                .withConnectionTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionConnectTimeoutMs())
                .withReadTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionReadTimeoutMs())
                .withMaxConnectionsPerHost(EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnectionsPerHost())
                .withMaxTotalConnections(EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnections())
                .withConnectionIdleTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionConnectionIdleTimeoutSeconds());

        if (remoteRegionURL.getProtocol().equals("http")) {
            clientBuilder.withClientName("Discovery-RemoteRegionClient-" + regionName);
        } else if ("true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
            clientBuilder.withClientName("Discovery-RemoteRegionSystemSecureClient-" + regionName)
                    .withSystemSSLConfiguration();
        } else {
            clientBuilder.withClientName("Discovery-RemoteRegionSecureClient-" + regionName)
                    .withTrustStoreFile(
                            EUREKA_SERVER_CONFIG.getRemoteRegionTrustStore(),
                            EUREKA_SERVER_CONFIG.getRemoteRegionTrustStorePassword()
                    );
        }
        discoveryJerseyClient = clientBuilder.build();
        discoveryApacheClient = discoveryJerseyClient.getClient();

        // should we enable GZip decoding of responses based on Response
        // Headers?
        if (EUREKA_SERVER_CONFIG.shouldGZipContentFromRemoteRegion()) {
            // compressed only if there exists a 'Content-Encoding' header
            // whose value is "gzip"
            discoveryApacheClient
                    .addFilter(new GZIPContentEncodingFilter(false));
        }

        String ip = null;
        try {
            ip = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn("Cannot find localhost ip", e);
        }
        EurekaServerIdentity identity = new EurekaServerIdentity(ip);
        discoveryApacheClient.addFilter(new EurekaIdentityHeaderFilter(identity));

        applications.set(new Applications());
        try {
            if (fetchRegistry()) {
                this.readyForServingData = true;
            } else {
                logger.warn("Failed to fetch remote registry. This means this eureka server is not ready for serving "
                        + "traffic.");
            }
        } catch (Throwable e) {
            logger.error("Problem fetching registry information :", e);
        }

        // remote region fetch
        Runnable remoteRegionFetchTask = new Runnable() {
            @Override
            public void run() {
                try {
                    if (fetchRegistry()) {
                        readyForServingData = true;
                    } else {
                        logger.warn("Failed to fetch remote registry. This means this eureka server is not "
                                + "ready for serving traffic.");
                    }
                } catch (Throwable e) {
                    logger.error(
                            "Error getting from remote registry :", e);
                }
            }
        };

        ThreadPoolExecutor remoteRegionFetchExecutor = new ThreadPoolExecutor(
                1, EUREKA_SERVER_CONFIG.getRemoteRegionFetchThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());  // use direct handoff

        scheduler = Executors.newScheduledThreadPool(1,
                new ThreadFactoryBuilder()
                        .setNameFormat("Eureka-RemoteRegionCacheRefresher_" + regionName + "-%d")
                        .setDaemon(true)
                        .build());

        scheduler.schedule(
                new TimedSupervisorTask(
                        "RemoteRegionFetch_" + regionName,
                        scheduler,
                        remoteRegionFetchExecutor,
                        EUREKA_SERVER_CONFIG.getRemoteRegionRegistryFetchInterval(),
                        TimeUnit.SECONDS,
                        5,  // exponential backoff bound
                        remoteRegionFetchTask
                ),
                EUREKA_SERVER_CONFIG.getRemoteRegionRegistryFetchInterval(), TimeUnit.SECONDS);
    }

    /**
     * Check if this registry is ready for serving data.
     * @return true if ready, false otherwise.
     */
    public boolean isReadyForServingData() {
        return readyForServingData;
    }

    /**
     * Fetch the registry information from the remote region.
     * @return true, if the fetch was successful, false otherwise.
     */
    private boolean fetchRegistry() {
        ClientResponse response = null;
        Stopwatch tracer = fetchRegistryTimer.start();

        try {
            // If the delta is disabled or if it is the first time, get all
            // applications
            if (EUREKA_SERVER_CONFIG.shouldDisableDeltaForRemoteRegions()
                    || (getApplications() == null)
                    || (getApplications().getRegisteredApplications().size() == 0)) {
                logger.info("Disable delta property : {}", EUREKA_SERVER_CONFIG
                        .shouldDisableDeltaForRemoteRegions());
                logger.info("Application is null : {}",
                        (getApplications() == null));
                logger.info(
                        "Registered Applications size is zero : {}",
                        (getApplications().getRegisteredApplications().size() == 0));
                response = storeFullRegistry();
            } else {
                long currDeltaGeneration = deltaGeneration.get();
                Applications delta = null;
                response = fetchRemoteRegistry(true);
                if (null != response) {
                    if (response.getStatus() == Status.OK.getStatusCode()) {
                        delta = response.getEntity(Applications.class);
                        if (delta == null) {
                            logger.error("The delta is null for some reason. Not storing this information");
                        } else if (deltaGeneration.compareAndSet(currDeltaGeneration, currDeltaGeneration + 1)) {
                            this.applicationsDelta.set(delta);
                        } else {
                            delta = null;  // set the delta to null so we don't use it
                            logger.warn("Not updating delta as another thread is updating it already");
                        }
                    }
                    if (delta == null) {
                        logger.warn("The server does not allow the delta revision to be applied because it is not "
                                + "safe. Hence got the full registry.");
                        this.closeResponse(response);
                        response = fetchRemoteRegistry(true);
                    } else {
                        updateDelta(delta);
                        String reconcileHashCode = getApplications()
                                .getReconcileHashCode();
                        // There is a diff in number of instances for some reason
                        if ((!reconcileHashCode.equals(delta.getAppsHashCode()))) {
                            response = reconcileAndLogDifference(response, delta, reconcileHashCode);

                        }
                    }
                }
            }
            logTotalInstances();

            logger.debug("Remote Registry Fetch Status : {}", null == response ? null : response.getStatus());
        } catch (Throwable e) {
            logger.error(
                    "Unable to fetch registry information from the remote registry "
                            + this.remoteRegionURL.toString(), e);
            return false;

        } finally {
            if (tracer != null) {
                tracer.stop();
            }
            closeResponse(response);
        }
        return null != response;
    }

    /**
     * Updates the delta information fetches from the eureka server into the
     * local cache.
     *
     * @param delta
     *            the delta information received from eureka server in the last
     *            poll cycle.
     */
    private void updateDelta(Applications delta) {
        int deltaCount = 0;
        for (Application app : delta.getRegisteredApplications()) {
            for (InstanceInfo instance : app.getInstances()) {
                ++deltaCount;
                if (ActionType.ADDED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Added instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);
                } else if (ActionType.MODIFIED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Modified instance {} to the existing apps ",
                            instance.getId());

                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);

                } else if (ActionType.DELETED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Deleted instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).removeInstance(instance);
                }
            }
        }
        logger.debug(
                "The total number of instances fetched by the delta processor : {}",
                deltaCount);

    }

    /**
     * Close HTTP response object and its respective resources.
     *
     * @param response
     *            the HttpResponse object.
     */
    private void closeResponse(ClientResponse response) {
        if (response != null) {
            try {
                response.close();
            } catch (Throwable th) {
                logger.error("Cannot release response resource :", th);
            }
        }
    }

    /**
     * Gets the full registry information from the eureka server and stores it
     * locally.
     *
     * @return the full registry information.
     */
    public ClientResponse storeFullRegistry() {
        long currentUpdateGeneration = fullRegistryGeneration.get();
        ClientResponse response = fetchRemoteRegistry(false);
        if (response == null) {
            logger.error("The response is null.");
            return null;
        }
        Applications apps = response.getEntity(Applications.class);
        if (apps == null) {
            logger.error("The application is null for some reason. Not storing this information");
        } else if (fullRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {
            applications.set(apps);
        } else {
            logger.warn("Not updating applications as another thread is updating it already");
        }
        logger.info("The response status is {}", response.getStatus());
        return response;
    }

    /**
     * Fetch registry information from the remote region.
     * @param delta - true, if the fetch needs to get deltas, false otherwise
     * @return - response which has information about the data.
     */
    private ClientResponse fetchRemoteRegistry(boolean delta) {
        logger.info(
                "Getting instance registry info from the eureka server : {} , delta : {}",
                this.remoteRegionURL, delta);
        ClientResponse response = null;
        try {

            String urlPath = delta ? "apps/delta" : "apps/";

            response = discoveryApacheClient
                    .resource(this.remoteRegionURL.toString() + urlPath)
                    .accept(MediaType.APPLICATION_JSON_TYPE)
                    .get(ClientResponse.class);
            int httpStatus = response.getStatus();
            if (httpStatus >= 200 && httpStatus < 300) {
                logger.debug("Got the data successfully : {}", httpStatus);
            } else {
                logger.warn("Cannot get the data from {} : {}", this.remoteRegionURL.toString(), httpStatus);
                return null; // To short circuit entity evaluation.
            }

        } catch (Throwable t) {
            logger.error("Can't get a response from " + this.remoteRegionURL, t);

        }
        return response;
    }

    /**
     * Reconciles the delta information fetched to see if the hashcodes match.
     *
     * @param response - the response of the delta fetch.
     * @param delta - the delta information fetched previously for reconcililation.
     * @param reconcileHashCode - the hashcode for comparison.
     * @return - response
     * @throws Throwable
     */
    private ClientResponse reconcileAndLogDifference(ClientResponse response,
                                                     Applications delta, String reconcileHashCode) throws Throwable {
        logger.warn(
                "The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry",
                reconcileHashCode, delta.getAppsHashCode());

        this.closeResponse(response);
        response = this.fetchRemoteRegistry(false);
        if (null == response) {
            logger.warn("Response is null while fetching remote registry during reconcile difference.");
            return null;
        }
        Applications serverApps = response.getEntity(Applications.class);
        Map<String, List<String>> reconcileDiffMap = getApplications()
                .getReconcileMapDiff(serverApps);
        String reconcileString = "";
        for (Map.Entry<String, List<String>> mapEntry : reconcileDiffMap
                .entrySet()) {
            reconcileString = reconcileString + mapEntry.getKey() + ": ";
            for (String displayString : mapEntry.getValue()) {
                reconcileString = reconcileString + displayString;
            }
            reconcileString = reconcileString + "\n";
        }
        logger.warn("The reconcile string is {}", reconcileString);
        applications.set(serverApps);
        applicationsDelta.set(serverApps);
        logger.warn(
                "The Reconcile hashcodes after complete sync up, client : {}, server : {}.",
                getApplications().getReconcileHashCode(),
                delta.getAppsHashCode());
        return response;
    }

    /**
     * Logs the total number of non-filtered instances stored locally.
     */
    private void logTotalInstances() {
        int totInstances = 0;
        for (Application application : getApplications().getRegisteredApplications()) {
            totInstances += application.getInstancesAsIsFromEureka().size();
        }
        logger.debug("The total number of all instances in the client now is {}", totInstances);
    }

    @Override
    public Applications getApplications() {
        return applications.get();
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String arg0, boolean arg1) {
        return null;
    }

    @Override
    public Application getApplication(String appName) {
        return this.applications.get().getRegisteredApplications(appName);
    }

    @Override
    public List<InstanceInfo> getInstancesById(String id) {
        List<InstanceInfo> list = Collections.emptyList();

        for (Application app : applications.get().getRegisteredApplications()) {
            InstanceInfo info = app.getByInstanceId(id);
            if (info != null) {
                list.add(info);
                return list;
            }
        }
        return list;
    }

    public Applications getApplicationDeltas() {
        return this.applicationsDelta.get();
    }

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
=======
import com.netflix.eureka.resources.ServerCodecs;
import com.sun.jersey.api.client.Client;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
    public JerseyReplicationClient(EurekaJerseyClient jerseyClient, String serviceUrl) {
        super(jerseyClient, serviceUrl);
        this.jerseyClient = jerseyClient;
        this.jerseyApacheClient = jerseyClient.getClient();
=======
    public JerseyReplicationClient(EurekaServerConfig config, ServerCodecs serverCodecs, String serviceUrl) {
        super(serviceUrl);
        String name = getClass().getSimpleName() + ": " + serviceUrl + "apps/: ";

        try {
            String hostname;
            try {
                hostname = new URL(serviceUrl).getHost();
            } catch (MalformedURLException e) {
                hostname = serviceUrl;
            }

            String jerseyClientName = "Discovery-PeerNodeClient-" + hostname;
            EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                    .withClientName(jerseyClientName)
                    .withUserAgent("Java-EurekaClient-Replication")
                    .withEncoderWrapper(serverCodecs.getFullJsonCodec())
                    .withDecoderWrapper(serverCodecs.getFullJsonCodec())
                    .withConnectionTimeout(config.getPeerNodeConnectTimeoutMs())
                    .withReadTimeout(config.getPeerNodeReadTimeoutMs())
                    .withMaxConnectionsPerHost(config.getPeerNodeTotalConnectionsPerHost())
                    .withMaxTotalConnections(config.getPeerNodeTotalConnections())
                    .withConnectionIdleTimeout(config.getPeerNodeConnectionIdleTimeoutSeconds());

            if (serviceUrl.startsWith("https://") &&
                    "true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
                clientBuilder.withSystemSSLConfiguration();
            }
            jerseyClient = clientBuilder.build();
            jerseyApacheClient = jerseyClient.getClient();
            jerseyApacheClient.addFilter(new DynamicGZIPContentEncodingFilter(config));
        } catch (Throwable e) {
            throw new RuntimeException("Cannot Create new Replica Node :" + name, e);
        }

        String ip = null;
        try {
            ip = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn("Cannot find localhost ip", e);
        }
        EurekaServerIdentity identity = new EurekaServerIdentity(ip);
        jerseyApacheClient.addFilter(new EurekaIdentityHeaderFilter(identity));
    }

    @Override
    protected Client getJerseyClient() {
        return jerseyApacheClient;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;<<<<<<< MINE
=======
package com.netflix.discovery.shared;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.netflix.discovery.converters.wrappers.CodecWrappers;
import com.netflix.discovery.converters.wrappers.DecoderWrapper;
import com.netflix.discovery.converters.wrappers.EncoderWrapper;
import com.netflix.discovery.provider.DiscoveryJerseyProvider;
import com.netflix.servo.monitor.BasicCounter;
import com.netflix.servo.monitor.BasicTimer;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.MonitorConfig;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.discovery.util.DiscoveryBuildInfo.buildVersion;

/**
 * @author Tomasz Bak
 */
public class EurekaJerseyClientImpl implements EurekaJerseyClient {

    private static final Logger s_logger = LoggerFactory.getLogger(EurekaJerseyClientImpl.class);

    private static final int HTTP_CONNECTION_CLEANER_INTERVAL_MS = 30 * 1000;

    private static final String PROTOCOL = "https";
    private static final String PROTOCOL_SCHEME = "SSL";
    private static final int HTTPS_PORT = 443;
    private static final String KEYSTORE_TYPE = "JKS";

    private final ApacheHttpClient4 apacheHttpClient;

    ClientConfig jerseyClientConfig;

    private final ScheduledExecutorService eurekaConnCleaner =
            Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {

                private final AtomicInteger threadNumber = new AtomicInteger(1);

                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
                }
            });

    public EurekaJerseyClientImpl(int connectionTimeout, int readTimeout, final int connectionIdleTimeout,
                              ClientConfig clientConfig) {
        try {
            jerseyClientConfig = clientConfig;
            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);
            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();

            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);
            HttpConnectionParams.setSoTimeout(params, readTimeout);

            eurekaConnCleaner.scheduleWithFixedDelay(
                    new ConnectionCleanerTask(connectionIdleTimeout), HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    TimeUnit.MILLISECONDS);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client", e);
        }
    }

    @Override
    public ApacheHttpClient4 getClient() {
        return apacheHttpClient;
    }

    /**
     * Clean up resources.
     */
    @Override
    public void destroyResources() {
        if (eurekaConnCleaner != null) {
            eurekaConnCleaner.shutdown();
        }
        if (apacheHttpClient != null) {
            apacheHttpClient.destroy();
        }
    }

    public static class EurekaJerseyClientBuilder {

        private boolean systemSSL;
        private String clientName;
        private int maxConnectionsPerHost;
        private int maxTotalConnections;
        private String trustStoreFileName;
        private String trustStorePassword;
        private String userAgent;
        private String proxyUserName;
        private String proxyPassword;
        private String proxyHost;
        private String proxyPort;
        private int connectionTimeout;
        private int readTimeout;
        private int connectionIdleTimeout;
        private EncoderWrapper encoderWrapper;
        private DecoderWrapper decoderWrapper;

        public EurekaJerseyClientBuilder withClientName(String clientName) {
            this.clientName = clientName;
            return this;
        }

        public EurekaJerseyClientBuilder withUserAgent(String userAgent) {
            this.userAgent = userAgent;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionTimeout(int connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withReadTimeout(int readTimeout) {
            this.readTimeout = readTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionIdleTimeout(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxConnectionsPerHost(int maxConnectionsPerHost) {
            this.maxConnectionsPerHost = maxConnectionsPerHost;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxTotalConnections(int maxTotalConnections) {
            this.maxTotalConnections = maxTotalConnections;
            return this;
        }

        public EurekaJerseyClientBuilder withProxy(String proxyHost, String proxyPort, String user, String password) {
            this.proxyHost = proxyHost;
            this.proxyPort = proxyPort;
            this.proxyUserName = user;
            this.proxyPassword = password;
            return this;
        }

        public EurekaJerseyClientBuilder withSystemSSLConfiguration() {
            this.systemSSL = true;
            return this;
        }

        public EurekaJerseyClientBuilder withTrustStoreFile(String trustStoreFileName, String trustStorePassword) {
            this.trustStoreFileName = trustStoreFileName;
            this.trustStorePassword = trustStorePassword;
            return this;
        }

        public EurekaJerseyClientBuilder withEncoder(String encoderName) {
            return this.withEncoderWrapper(CodecWrappers.getEncoder(encoderName));
        }

        public EurekaJerseyClientBuilder withEncoderWrapper(EncoderWrapper encoderWrapper) {
            this.encoderWrapper = encoderWrapper;
            return this;
        }

        public EurekaJerseyClientBuilder withDecoder(String decoderName, String clientDataAccept) {
            return this.withDecoderWrapper(CodecWrappers.resolveDecoder(decoderName, clientDataAccept));
        }

        public EurekaJerseyClientBuilder withDecoderWrapper(DecoderWrapper decoderWrapper) {
            this.decoderWrapper = decoderWrapper;
            return this;
        }

        public EurekaJerseyClient build() {
            MyDefaultApacheHttpClient4Config config = new MyDefaultApacheHttpClient4Config();
            try {
                return new EurekaJerseyClientImpl(connectionTimeout, readTimeout, connectionIdleTimeout, config);
            } catch (Throwable e) {
                throw new RuntimeException("Cannot create Jersey client ", e);
            }
        }

        class MyDefaultApacheHttpClient4Config extends DefaultApacheHttpClient4Config {
            MyDefaultApacheHttpClient4Config() {
                MonitoredConnectionManager cm;

                if (systemSSL) {
                    cm = createSystemSslCM();
                } else if (trustStoreFileName != null) {
                    cm = createCustomSslCM();
                } else {
                    cm = new MonitoredConnectionManager(clientName);
                }

                if (proxyHost != null) {
                    addProxyConfiguration(cm);
                }

                DiscoveryJerseyProvider discoveryJerseyProvider = new DiscoveryJerseyProvider(encoderWrapper, decoderWrapper);
                getSingletons().add(discoveryJerseyProvider);

                // Common properties to all clients
                cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
                cm.setMaxTotal(maxTotalConnections);
                getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);

                String fullUserAgentName = (userAgent == null ? clientName : userAgent) + "/v" + buildVersion();
                getProperties().put(CoreProtocolPNames.USER_AGENT, fullUserAgentName);

                // To pin a client to specific server in case redirect happens, we handle redirects directly
                // (see DiscoveryClient.makeRemoteCall methods).
                getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
                getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);
            }

            private void addProxyConfiguration(MonitoredConnectionManager cm) {
                if (proxyUserName != null && proxyPassword != null) {
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
                } else {
                    // Due to bug in apache client, user name/password must always be set.
                    // Otherwise proxy configuration is ignored.
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
                }
                getProperties().put(DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI, "http://" + proxyHost + ":" + proxyPort);
            }

            private MonitoredConnectionManager createSystemSslCM() {
                MonitoredConnectionManager cm;
                SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
                SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));
                cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                return cm;
            }

            private MonitoredConnectionManager createCustomSslCM() {
                FileInputStream fin = null;
                try {
                    SSLContext sslContext = SSLContext.getInstance(PROTOCOL_SCHEME);
                    KeyStore sslKeyStore = KeyStore.getInstance(KEYSTORE_TYPE);

                    fin = new FileInputStream(trustStoreFileName);
                    sslKeyStore.load(fin, trustStorePassword.toCharArray());

                    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    factory.init(sslKeyStore);

                    TrustManager[] trustManagers = factory.getTrustManagers();

                    sslContext.init(null, trustManagers, null);
                    SSLSocketFactory sslSocketFactory = new SSLSocketFactory(sslContext);
                    sslSocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
                    SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                    sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

                    return new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                } catch (Exception ex) {
                    throw new IllegalStateException("SSL configuration issue", ex);
                } finally {
                    if (fin != null) {
                        try {
                            fin.close();
                        } catch (IOException ignore) {
                        }
                    }
                }
            }
        }
    }

    private class ConnectionCleanerTask implements Runnable {

        private final int connectionIdleTimeout;
        private final BasicTimer executionTimeStats;
        private final Counter cleanupFailed;

        private ConnectionCleanerTask(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            MonitorConfig.Builder monitorConfigBuilder = MonitorConfig.builder("Eureka-Connection-Cleaner-Time");
            executionTimeStats = new BasicTimer(monitorConfigBuilder.build());
            cleanupFailed = new BasicCounter(MonitorConfig.builder("Eureka-Connection-Cleaner-Failure").build());
            try {
                Monitors.registerObject(this);
            } catch (Exception e) {
                s_logger.error("Unable to register with servo.", e);
            }
        }

        @Override
        public void run() {
            Stopwatch start = executionTimeStats.start();
            try {
                apacheHttpClient
                        .getClientHandler()
                        .getHttpClient()
                        .getConnectionManager()
                        .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
            } catch (Throwable e) {
                s_logger.error("Cannot clean connections", e);
                cleanupFailed.increment();
            } finally {
                if (null != start) {
                    start.stop();
                }
            }

        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-client/src/test/java/com/netflix/discovery/converters/EurekaJacksonCodecTest.java;<<<<<<< MINE
        InstanceInfo noMetaDataInfo = InstanceInfoGenerator.takeOne();
=======
        InstanceInfo noMetaDataInfo = InstanceInfoGenerator.newBuilder(1, 1).withMetaData(false).build().serviceIterator().next();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-client/src/test/java/com/netflix/discovery/converters/EurekaJsonAndXmlJacksonCodecTest.java;<<<<<<< MINE
    public void testInstanceInfoWithNoMetaEncodeDecodeWithJson() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaJsonJacksonCodec().getObjectMapper());
    }

    @Test
    public void testInstanceInfoWithNoMetaEncodeDecodeWithXml() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaXmlJacksonCodec().getObjectMapper());
    }

    private void doInstanceInfoWithNoMetaEncodeDecode(ObjectMapper mapper) throws Exception {
        InstanceInfo noMetaDataInfo = new InstanceInfo.Builder(infoIterator.next()).setMetadata(null).build();

        String encodedString = mapper.writeValueAsString(noMetaDataInfo);
        InstanceInfo decodedValue = mapper.readValue(encodedString, InstanceInfo.class);

        assertThat(decodedValue.getId(), is(equalTo(noMetaDataInfo.getId())));
    }

    @Test
=======
    public void testInstanceInfoWithNoMetaEncodeDecodeWithJson() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaJsonJacksonCodec().getObjectMapper(), true);
    }

    @Test
    public void testInstanceInfoWithNoMetaEncodeDecodeWithXml() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaXmlJacksonCodec().getObjectMapper(), false);
    }

    private void doInstanceInfoWithNoMetaEncodeDecode(ObjectMapper mapper, boolean json) throws Exception {
        InstanceInfo noMetaDataInfo = new InstanceInfo.Builder(infoIterator.next()).setMetadata(null).build();

        String encodedString = mapper.writeValueAsString(noMetaDataInfo);

        // Backward compatibility with old codec
        if (json) {
            assertThat(encodedString.contains("\"@class\":\"java.util.Collections$EmptyMap\""), is(true));
        }

        InstanceInfo decodedValue = mapper.readValue(encodedString, InstanceInfo.class);
        assertThat(decodedValue.getId(), is(equalTo(noMetaDataInfo.getId())));
        assertThat(decodedValue.getMetadata().isEmpty(), is(true));
    }

    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_90eea3b_1837e04/rev_90eea3b-1837e04/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;<<<<<<< MINE
            jerseyClientConfig.getClasses().add(DiscoveryJerseyProvider.class);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java;<<<<<<< MINE
        jerseyReplicationClient = new JerseyReplicationClient(eurekaServerConfig, eurekaServiceUrl);
=======

        ServerCodecs serverCodecs = new DefaultServerCodecs(eurekaServerConfig);
        jerseyReplicationClient = new JerseyReplicationClient(eurekaServerConfig, serverCodecs, eurekaServiceUrl);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java;<<<<<<< MINE
=======
import com.netflix.eureka.EurekaServerConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java;<<<<<<< MINE
=======
import com.netflix.eureka.resources.DefaultServerCodecs;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java;<<<<<<< MINE
        JerseyReplicationClient client = new JerseyReplicationClient(new DefaultEurekaServerConfig("eureka."), discoveryURL);
=======
        EurekaServerConfig serverConfig = new DefaultEurekaServerConfig("eureka.");
        JerseyReplicationClient client = new JerseyReplicationClient(
                serverConfig,
                new DefaultServerCodecs(serverConfig),
                discoveryURL);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/RemoteRegionRegistry.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.netflix.eureka.registry;

import javax.inject.Inject;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;
import java.net.InetAddress;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.ActionType;
import com.netflix.discovery.EurekaIdentityHeaderFilter;
import com.netflix.discovery.TimedSupervisorTask;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClientImpl.EurekaJerseyClientBuilder;
import com.netflix.discovery.shared.LookupService;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.EurekaServerIdentity;
import com.netflix.eureka.resources.ServerCodecs;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.filter.GZIPContentEncodingFilter;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Handles all registry operations that needs to be done on a eureka service running in an other region.
 *
 * The primary operations include fetching registry information from remote region and fetching delta information
 * on a periodic basis.
 *
 * @author Karthik Ranganathan
 *
 */
public class RemoteRegionRegistry implements LookupService<String> {
    private static final Logger logger = LoggerFactory.getLogger(RemoteRegionRegistry.class);

    private final ApacheHttpClient4 discoveryApacheClient;
    private final EurekaJerseyClient discoveryJerseyClient;
    private final com.netflix.servo.monitor.Timer fetchRegistryTimer;
    private final URL remoteRegionURL;

    private final ScheduledExecutorService scheduler;
    // monotonically increasing generation counter to ensure stale threads do not reset registry to an older version
    private final AtomicLong fullRegistryGeneration = new AtomicLong(0);
    private final AtomicLong deltaGeneration = new AtomicLong(0);

    private final AtomicReference<Applications> applications = new AtomicReference<Applications>();
    private final AtomicReference<Applications> applicationsDelta = new AtomicReference<Applications>();
    private final EurekaServerConfig serverConfig;
    private volatile boolean readyForServingData;

    @Inject
    public RemoteRegionRegistry(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, String regionName, URL remoteRegionURL) {
        this.serverConfig = serverConfig;
        this.remoteRegionURL = remoteRegionURL;
        this.fetchRegistryTimer = Monitors.newTimer(this.remoteRegionURL.toString() + "_FetchRegistry");

        EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                .withUserAgent("Java-EurekaClient-RemoteRegion")
                .withEncoderWrapper(serverCodecs.getFullJsonCodec())
                .withDecoderWrapper(serverCodecs.getFullJsonCodec())
                .withConnectionTimeout(serverConfig.getRemoteRegionConnectTimeoutMs())
                .withReadTimeout(serverConfig.getRemoteRegionReadTimeoutMs())
                .withMaxConnectionsPerHost(serverConfig.getRemoteRegionTotalConnectionsPerHost())
                .withMaxTotalConnections(serverConfig.getRemoteRegionTotalConnections())
                .withConnectionIdleTimeout(serverConfig.getRemoteRegionConnectionIdleTimeoutSeconds());

        if (remoteRegionURL.getProtocol().equals("http")) {
            clientBuilder.withClientName("Discovery-RemoteRegionClient-" + regionName);
        } else if ("true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
            clientBuilder.withClientName("Discovery-RemoteRegionSystemSecureClient-" + regionName)
                    .withSystemSSLConfiguration();
        } else {
            clientBuilder.withClientName("Discovery-RemoteRegionSecureClient-" + regionName)
                    .withTrustStoreFile(
                            serverConfig.getRemoteRegionTrustStore(),
                            serverConfig.getRemoteRegionTrustStorePassword()
                    );
        }
        discoveryJerseyClient = clientBuilder.build();
        discoveryApacheClient = discoveryJerseyClient.getClient();

        // should we enable GZip decoding of responses based on Response Headers?
        if (serverConfig.shouldGZipContentFromRemoteRegion()) {
            // compressed only if there exists a 'Content-Encoding' header whose value is "gzip"
            discoveryApacheClient.addFilter(new GZIPContentEncodingFilter(false));
        }

        String ip = null;
        try {
            ip = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn("Cannot find localhost ip", e);
        }
        EurekaServerIdentity identity = new EurekaServerIdentity(ip);
        discoveryApacheClient.addFilter(new EurekaIdentityHeaderFilter(identity));

        applications.set(new Applications());
        try {
            if (fetchRegistry()) {
                this.readyForServingData = true;
            } else {
                logger.warn("Failed to fetch remote registry. This means this eureka server is not ready for serving "
                        + "traffic.");
            }
        } catch (Throwable e) {
            logger.error("Problem fetching registry information :", e);
        }

        // remote region fetch
        Runnable remoteRegionFetchTask = new Runnable() {
            @Override
            public void run() {
                try {
                    if (fetchRegistry()) {
                        readyForServingData = true;
                    } else {
                        logger.warn("Failed to fetch remote registry. This means this eureka server is not "
                                + "ready for serving traffic.");
                    }
                } catch (Throwable e) {
                    logger.error(
                            "Error getting from remote registry :", e);
                }
            }
        };

        ThreadPoolExecutor remoteRegionFetchExecutor = new ThreadPoolExecutor(
                1, serverConfig.getRemoteRegionFetchThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());  // use direct handoff

        scheduler = Executors.newScheduledThreadPool(1,
                new ThreadFactoryBuilder()
                        .setNameFormat("Eureka-RemoteRegionCacheRefresher_" + regionName + "-%d")
                        .setDaemon(true)
                        .build());

        scheduler.schedule(
                new TimedSupervisorTask(
                        "RemoteRegionFetch_" + regionName,
                        scheduler,
                        remoteRegionFetchExecutor,
                        serverConfig.getRemoteRegionRegistryFetchInterval(),
                        TimeUnit.SECONDS,
                        5,  // exponential backoff bound
                        remoteRegionFetchTask
                ),
                serverConfig.getRemoteRegionRegistryFetchInterval(), TimeUnit.SECONDS);
    }

    /**
     * Check if this registry is ready for serving data.
     * @return true if ready, false otherwise.
     */
    public boolean isReadyForServingData() {
        return readyForServingData;
    }

    /**
     * Fetch the registry information from the remote region.
     * @return true, if the fetch was successful, false otherwise.
     */
    private boolean fetchRegistry() {
        ClientResponse response = null;
        Stopwatch tracer = fetchRegistryTimer.start();

        try {
            // If the delta is disabled or if it is the first time, get all
            // applications
            if (serverConfig.shouldDisableDeltaForRemoteRegions()
                    || (getApplications() == null)
                    || (getApplications().getRegisteredApplications().size() == 0)) {
                logger.info("Disable delta property : {}", serverConfig
                        .shouldDisableDeltaForRemoteRegions());
                logger.info("Application is null : {}",
                        (getApplications() == null));
                logger.info(
                        "Registered Applications size is zero : {}",
                        (getApplications().getRegisteredApplications().size() == 0));
                response = storeFullRegistry();
            } else {
                long currDeltaGeneration = deltaGeneration.get();
                Applications delta = null;
                response = fetchRemoteRegistry(true);
                if (null != response) {
                    if (response.getStatus() == Status.OK.getStatusCode()) {
                        delta = response.getEntity(Applications.class);
                        if (delta == null) {
                            logger.error("The delta is null for some reason. Not storing this information");
                        } else if (deltaGeneration.compareAndSet(currDeltaGeneration, currDeltaGeneration + 1)) {
                            this.applicationsDelta.set(delta);
                        } else {
                            delta = null;  // set the delta to null so we don't use it
                            logger.warn("Not updating delta as another thread is updating it already");
                        }
                    }
                    if (delta == null) {
                        logger.warn("The server does not allow the delta revision to be applied because it is not "
                                + "safe. Hence got the full registry.");
                        this.closeResponse(response);
                        response = fetchRemoteRegistry(true);
                    } else {
                        updateDelta(delta);
                        String reconcileHashCode = getApplications()
                                .getReconcileHashCode();
                        // There is a diff in number of instances for some reason
                        if ((!reconcileHashCode.equals(delta.getAppsHashCode()))) {
                            response = reconcileAndLogDifference(response, delta, reconcileHashCode);

                        }
                    }
                }
            }
            logTotalInstances();

            logger.debug("Remote Registry Fetch Status : {}", null == response ? null : response.getStatus());
        } catch (Throwable e) {
            logger.error(
                    "Unable to fetch registry information from the remote registry "
                            + this.remoteRegionURL.toString(), e);
            return false;

        } finally {
            if (tracer != null) {
                tracer.stop();
            }
            closeResponse(response);
        }
        return null != response;
    }

    /**
     * Updates the delta information fetches from the eureka server into the
     * local cache.
     *
     * @param delta
     *            the delta information received from eureka server in the last
     *            poll cycle.
     */
    private void updateDelta(Applications delta) {
        int deltaCount = 0;
        for (Application app : delta.getRegisteredApplications()) {
            for (InstanceInfo instance : app.getInstances()) {
                ++deltaCount;
                if (ActionType.ADDED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Added instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);
                } else if (ActionType.MODIFIED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Modified instance {} to the existing apps ",
                            instance.getId());

                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);

                } else if (ActionType.DELETED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Deleted instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).removeInstance(instance);
                }
            }
        }
        logger.debug(
                "The total number of instances fetched by the delta processor : {}",
                deltaCount);

    }

    /**
     * Close HTTP response object and its respective resources.
     *
     * @param response
     *            the HttpResponse object.
     */
    private void closeResponse(ClientResponse response) {
        if (response != null) {
            try {
                response.close();
            } catch (Throwable th) {
                logger.error("Cannot release response resource :", th);
            }
        }
    }

    /**
     * Gets the full registry information from the eureka server and stores it
     * locally.
     *
     * @return the full registry information.
     */
    public ClientResponse storeFullRegistry() {
        long currentUpdateGeneration = fullRegistryGeneration.get();
        ClientResponse response = fetchRemoteRegistry(false);
        if (response == null) {
            logger.error("The response is null.");
            return null;
        }
        Applications apps = response.getEntity(Applications.class);
        if (apps == null) {
            logger.error("The application is null for some reason. Not storing this information");
        } else if (fullRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {
            applications.set(apps);
        } else {
            logger.warn("Not updating applications as another thread is updating it already");
        }
        logger.info("The response status is {}", response.getStatus());
        return response;
    }

    /**
     * Fetch registry information from the remote region.
     * @param delta - true, if the fetch needs to get deltas, false otherwise
     * @return - response which has information about the data.
     */
    private ClientResponse fetchRemoteRegistry(boolean delta) {
        logger.info(
                "Getting instance registry info from the eureka server : {} , delta : {}",
                this.remoteRegionURL, delta);
        ClientResponse response = null;
        try {

            String urlPath = delta ? "apps/delta" : "apps/";

            response = discoveryApacheClient
                    .resource(this.remoteRegionURL.toString() + urlPath)
                    .accept(MediaType.APPLICATION_JSON_TYPE)
                    .get(ClientResponse.class);
            int httpStatus = response.getStatus();
            if (httpStatus >= 200 && httpStatus < 300) {
                logger.debug("Got the data successfully : {}", httpStatus);
            } else {
                logger.warn("Cannot get the data from {} : {}", this.remoteRegionURL.toString(), httpStatus);
                return null; // To short circuit entity evaluation.
            }

        } catch (Throwable t) {
            logger.error("Can't get a response from " + this.remoteRegionURL, t);

        }
        return response;
    }

    /**
     * Reconciles the delta information fetched to see if the hashcodes match.
     *
     * @param response - the response of the delta fetch.
     * @param delta - the delta information fetched previously for reconcililation.
     * @param reconcileHashCode - the hashcode for comparison.
     * @return - response
     * @throws Throwable
     */
    private ClientResponse reconcileAndLogDifference(ClientResponse response,
                                                     Applications delta, String reconcileHashCode) throws Throwable {
        logger.warn(
                "The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry",
                reconcileHashCode, delta.getAppsHashCode());

        this.closeResponse(response);
        response = this.fetchRemoteRegistry(false);
        if (null == response) {
            logger.warn("Response is null while fetching remote registry during reconcile difference.");
            return null;
        }
        Applications serverApps = response.getEntity(Applications.class);
        Map<String, List<String>> reconcileDiffMap = getApplications()
                .getReconcileMapDiff(serverApps);
        String reconcileString = "";
        for (Map.Entry<String, List<String>> mapEntry : reconcileDiffMap
                .entrySet()) {
            reconcileString = reconcileString + mapEntry.getKey() + ": ";
            for (String displayString : mapEntry.getValue()) {
                reconcileString = reconcileString + displayString;
            }
            reconcileString = reconcileString + "\n";
        }
        logger.warn("The reconcile string is {}", reconcileString);
        applications.set(serverApps);
        applicationsDelta.set(serverApps);
        logger.warn(
                "The Reconcile hashcodes after complete sync up, client : {}, server : {}.",
                getApplications().getReconcileHashCode(),
                delta.getAppsHashCode());
        return response;
    }

    /**
     * Logs the total number of non-filtered instances stored locally.
     */
    private void logTotalInstances() {
        int totInstances = 0;
        for (Application application : getApplications().getRegisteredApplications()) {
            totInstances += application.getInstancesAsIsFromEureka().size();
        }
        logger.debug("The total number of all instances in the client now is {}", totInstances);
    }

    @Override
    public Applications getApplications() {
        return applications.get();
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String arg0, boolean arg1) {
        return null;
    }

    @Override
    public Application getApplication(String appName) {
        return this.applications.get().getRegisteredApplications(appName);
    }

    @Override
    public List<InstanceInfo> getInstancesById(String id) {
        List<InstanceInfo> list = Collections.emptyList();

        for (Application app : applications.get().getRegisteredApplications()) {
            InstanceInfo info = app.getByInstanceId(id);
            if (info != null) {
                list.add(info);
                return list;
            }
        }
        return list;
    }

    public Applications getApplicationDeltas() {
        return this.applicationsDelta.get();
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/ResponseCacheImpl.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka.registry;

import javax.annotation.Nullable;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.zip.GZIPOutputStream;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Supplier;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.cache.RemovalListener;
import com.google.common.cache.RemovalNotification;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multimaps;
import com.netflix.appinfo.EurekaAccept;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.converters.wrappers.EncoderWrapper;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.Version;
import com.netflix.eureka.resources.CurrentRequestVersion;
import com.netflix.eureka.resources.ServerCodecs;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.annotations.Monitor;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.netflix.servo.monitor.Timer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * The class that is responsible for caching registry information that will be
 * queried by the clients.
 *
 * <p>
 * The cache is maintained in compressed and non-compressed form for three
 * categories of requests - all applications, delta changes and for individual
 * applications. The compressed form is probably the most efficient in terms of
 * network traffic especially when querying all applications.
 *
 * The cache also maintains separate pay load for <em>JSON</em> and <em>XML</em>
 * formats and for multiple versions too.
 * </p>
 *
 * @author Karthik Ranganathan, Greg Kim
 */
public class ResponseCacheImpl implements ResponseCache {

    private static final Logger logger = LoggerFactory.getLogger(ResponseCacheImpl.class);

    public static final String ALL_APPS = "ALL_APPS";
    public static final String ALL_APPS_DELTA = "ALL_APPS_DELTA";

    // FIXME deprecated, here for backwards compatibility.
    private static final AtomicLong versionDeltaLegacy = new AtomicLong(0);
    private static final AtomicLong versionDeltaWithRegionsLegacy = new AtomicLong(0);

    private static final String EMPTY_PAYLOAD = "";
    private final java.util.Timer timer = new java.util.Timer("Eureka-CacheFillTimer", true);
    private final AtomicLong versionDelta = new AtomicLong(0);
    private final AtomicLong versionDeltaWithRegions = new AtomicLong(0);

    private final Timer serializeAllAppsTimer = Monitors.newTimer("serialize-all");
    private final Timer serializeDeltaAppsTimer = Monitors.newTimer("serialize-all-delta");
    private final Timer serializeAllAppsWithRemoteRegionTimer = Monitors.newTimer("serialize-all_remote_region");
    private final Timer serializeDeltaAppsWithRemoteRegionTimer = Monitors.newTimer("serialize-all-delta_remote_region");
    private final Timer serializeOneApptimer = Monitors.newTimer("serialize-one");
    private final Timer serializeViptimer = Monitors.newTimer("serialize-one-vip");
    private final Timer compressPayloadTimer = Monitors.newTimer("compress-payload");

    /**
     * This map holds mapping of keys without regions to a list of keys with region (provided by clients)
     * Since, during invalidation, triggered by a change in registry for local region, we do not know the regions
     * requested by clients, we use this mapping to get all the keys with regions to be invalidated.
     * If we do not do this, any cached user requests containing region keys will not be invalidated and will stick
     * around till expiry. Github issue: https://github.com/Netflix/eureka/issues/118
     */
    private final Multimap<Key, Key> regionSpecificKeys =
            Multimaps.newListMultimap(new ConcurrentHashMap<Key, Collection<Key>>(), new Supplier<List<Key>>() {
                @Override
                public List<Key> get() {
                    return new CopyOnWriteArrayList<Key>();
                }
            });

    private final ConcurrentMap<Key, Value> readOnlyCacheMap = new ConcurrentHashMap<Key, Value>();

    private final LoadingCache<Key, Value> readWriteCacheMap;
    private final boolean shouldUseReadOnlyResponseCache;
    private final AbstractInstanceRegistry registry;
    private final EurekaServerConfig serverConfig;
    private final ServerCodecs serverCodecs;

    ResponseCacheImpl(EurekaServerConfig serverConfig, ServerCodecs serverCodecs, AbstractInstanceRegistry registry) {
        this.serverConfig = serverConfig;
        this.serverCodecs = serverCodecs;
        this.shouldUseReadOnlyResponseCache = serverConfig.shouldUseReadOnlyResponseCache();
        this.registry = registry;

        long responseCacheUpdateIntervalMs = serverConfig.getResponseCacheUpdateIntervalMs();
        this.readWriteCacheMap =
                CacheBuilder.newBuilder().initialCapacity(1000)
                        .expireAfterWrite(serverConfig.getResponseCacheAutoExpirationInSeconds(), TimeUnit.SECONDS)
                        .removalListener(new RemovalListener<Key, Value>() {
                            @Override
                            public void onRemoval(RemovalNotification<Key, Value> notification) {
                                Key removedKey = notification.getKey();
                                if (removedKey.hasRegions()) {
                                    Key cloneWithNoRegions = removedKey.cloneWithoutRegions();
                                    regionSpecificKeys.remove(cloneWithNoRegions, removedKey);
                                }
                            }
                        })
                        .build(new CacheLoader<Key, Value>() {
                            @Override
                            public Value load(Key key) throws Exception {
                                if (key.hasRegions()) {
                                    Key cloneWithNoRegions = key.cloneWithoutRegions();
                                    regionSpecificKeys.put(cloneWithNoRegions, key);
                                }
                                Value value = generatePayload(key);
                                return value;
                            }
                        });

        if (shouldUseReadOnlyResponseCache) {
            timer.schedule(getCacheUpdateTask(),
                    new Date(((System.currentTimeMillis() / responseCacheUpdateIntervalMs) * responseCacheUpdateIntervalMs)
                            + responseCacheUpdateIntervalMs),
                    responseCacheUpdateIntervalMs);
        }

        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn("Cannot register the JMX monitor for the InstanceRegistry", e);
        }
    }

    private TimerTask getCacheUpdateTask() {
        return new TimerTask() {
            @Override
            public void run() {
                logger.debug("Updating the client cache from response cache");
                for (Key key : readOnlyCacheMap.keySet()) {
                    if (logger.isDebugEnabled()) {
                        Object[] args = {key.getEntityType(), key.getName(), key.getVersion(), key.getType()};
                        logger.debug("Updating the client cache from response cache for key : {} {} {} {}", args);
                    }
                    try {
                        CurrentRequestVersion.set(key.getVersion());
                        Value cacheValue = readWriteCacheMap.get(key);
                        Value currentCacheValue = readOnlyCacheMap.get(key);
                        if (cacheValue != currentCacheValue) {
                            readOnlyCacheMap.put(key, cacheValue);
                        }
                    } catch (Throwable th) {
                        logger.error("Error while updating the client cache from response cache", th);
                    }
                }
            }
        };
    }

    /**
     * Get the cached information about applications.
     *
     * <p>
     * If the cached information is not available it is generated on the first
     * request. After the first request, the information is then updated
     * periodically by a background thread.
     * </p>
     *
     * @param key the key for which the cached information needs to be obtained.
     * @return payload which contains information about the applications.
     */
    public String get(final Key key) {
        return get(key, shouldUseReadOnlyResponseCache);
    }

    @VisibleForTesting
    String get(final Key key, boolean useReadOnlyCache) {
        Value payload = getValue(key, useReadOnlyCache);
        if (payload == null || payload.getPayload().equals(EMPTY_PAYLOAD)) {
            return null;
        } else {
            return payload.getPayload();
        }
    }

    /**
     * Get the compressed information about the applications.
     *
     * @param key
     *            the key for which the compressed cached information needs to
     *            be obtained.
     * @return compressed payload which contains information about the
     *         applications.
     */
    public byte[] getGZIP(Key key) {
        Value payload = getValue(key, shouldUseReadOnlyResponseCache);
        if (payload == null) {
            return null;
        }
        return payload.getGzipped();
    }

    /**
     * Invalidate the cache of a particular application.
     *
     * @param appName the application name of the application.
     */
    @Override
    public void invalidate(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
        for (Key.KeyType type : Key.KeyType.values()) {
            for (Version v : Version.values()) {
                invalidate(
                        new Key(Key.EntityType.Application, appName, type, v, EurekaAccept.full),
                        new Key(Key.EntityType.Application, appName, type, v, EurekaAccept.compact),
                        new Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.full),
                        new Key(Key.EntityType.Application, ALL_APPS, type, v, EurekaAccept.compact),
                        new Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.full),
                        new Key(Key.EntityType.Application, ALL_APPS_DELTA, type, v, EurekaAccept.compact)
                );
                if (null != vipAddress) {
                    invalidate(new Key(Key.EntityType.VIP, vipAddress, type, v, EurekaAccept.full));
                }
                if (null != secureVipAddress) {
                    invalidate(new Key(Key.EntityType.SVIP, secureVipAddress, type, v, EurekaAccept.full));
                }
            }
        }
    }

    /**
     * Invalidate the cache information given the list of keys.
     *
     * @param keys the list of keys for which the cache information needs to be invalidated.
     */
    public void invalidate(Key... keys) {
        for (Key key : keys) {
            logger.debug("Invalidating the response cache key : {} {} {} {}, {}",
                    key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());

            readWriteCacheMap.invalidate(key);
            Collection<Key> keysWithRegions = regionSpecificKeys.get(key);
            if (null != keysWithRegions && !keysWithRegions.isEmpty()) {
                for (Key keysWithRegion : keysWithRegions) {
                    logger.debug("Invalidating the response cache key : {} {} {} {} {}",
                            key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());
                    readWriteCacheMap.invalidate(keysWithRegion);
                }
            }
        }
    }

    /**
     * Gets the version number of the cached data.
     *
     * @return teh version number of the cached data.
     */
    @Override
    public AtomicLong getVersionDelta() {
        return versionDelta;
    }

    /**
     * Gets the version number of the cached data with remote regions.
     *
     * @return teh version number of the cached data with remote regions.
     */
    @Override
    public AtomicLong getVersionDeltaWithRegions() {
        return versionDeltaWithRegions;
    }

    /**
     * @deprecated use instance method {@link #getVersionDelta()}
     *
     * Gets the version number of the cached data.
     *
     * @return teh version number of the cached data.
     */
    @Deprecated
    public static AtomicLong getVersionDeltaStatic() {
        return versionDeltaLegacy;
    }

    /**
     * @deprecated use instance method {@link #getVersionDeltaWithRegions()}
     *
     * Gets the version number of the cached data with remote regions.
     *
     * @return teh version number of the cached data with remote regions.
     */
    @Deprecated
    public static AtomicLong getVersionDeltaWithRegionsLegacy() {
        return versionDeltaWithRegionsLegacy;
    }

    /**
     * Get the number of items in the response cache.
     *
     * @return int value representing the number of items in response cache.
     */
    @Monitor(name = "responseCacheSize", type = DataSourceType.GAUGE)
    public int getCurrentSize() {
        return readWriteCacheMap.asMap().size();
    }

    /**
     * Get the payload in both compressed and uncompressed form.
     */
    @VisibleForTesting
    Value getValue(final Key key, boolean useReadOnlyCache) {
        Value payload = null;
        try {
            if (useReadOnlyCache) {
                final Value currentPayload = readOnlyCacheMap.get(key);
                if (currentPayload != null) {
                    payload = currentPayload;
                } else {
                    payload = readWriteCacheMap.get(key);
                    readOnlyCacheMap.put(key, payload);
                }
            } else {
                payload = readWriteCacheMap.get(key);
            }
        } catch (Throwable t) {
            logger.error("Cannot get value for key :" + key, t);
        }
        return payload;
    }

    /**
     * Generate pay load with both JSON and XML formats for all applications.
     */
    private String getPayLoad(Key key, Applications apps) {
        EncoderWrapper encoderWrapper = serverCodecs.getEncoder(key.getType(), key.getEurekaAccept());
        String result;
        try {
            result = encoderWrapper.encode(apps);
        } catch (Exception e) {
            logger.error("Failed to encode the payload for all apps", e);
            return "";
        }
        if(logger.isDebugEnabled()) {
            logger.debug("New application cache entry {} with apps hashcode {}", key.toStringCompact(), apps.getAppsHashCode());
        }
        return result;
    }

    /**
     * Generate pay load with both JSON and XML formats for a given application.
     */
    private String getPayLoad(Key key, Application app) {
        if (app == null) {
            return EMPTY_PAYLOAD;
        }

        EncoderWrapper encoderWrapper = serverCodecs.getEncoder(key.getType(), key.getEurekaAccept());
        try {
            return encoderWrapper.encode(app);
        } catch (Exception e) {
            logger.error("Failed to encode the payload for application {}", app.getName(), e);
            return "";
        }
    }

    /*
     * Generate pay load for the given key.
     */
    private Value generatePayload(Key key) {
        Stopwatch tracer = null;
        try {
            String payload;
            switch (key.getEntityType()) {
                case Application:
                    boolean isRemoteRegionRequested = key.hasRegions();

                    if (ALL_APPS.equals(key.getName())) {
                        if (isRemoteRegionRequested) {
                            tracer = serializeAllAppsWithRemoteRegionTimer.start();
                            payload = getPayLoad(key, registry.getApplicationsFromMultipleRegions(key.getRegions()));
                        } else {
                            tracer = serializeAllAppsTimer.start();
                            payload = getPayLoad(key, registry.getApplications());
                        }
                    } else if (ALL_APPS_DELTA.equals(key.getName())) {
                        if (isRemoteRegionRequested) {
                            tracer = serializeDeltaAppsWithRemoteRegionTimer.start();
                            versionDeltaWithRegions.incrementAndGet();
                            versionDeltaWithRegionsLegacy.incrementAndGet();
                            payload = getPayLoad(key,
                                    registry.getApplicationDeltasFromMultipleRegions(key.getRegions()));
                        } else {
                            tracer = serializeDeltaAppsTimer.start();
                            versionDelta.incrementAndGet();
                            versionDeltaLegacy.incrementAndGet();
                            payload = getPayLoad(key, registry.getApplicationDeltas());
                        }
                    } else {
                        tracer = serializeOneApptimer.start();
                        payload = getPayLoad(key, registry.getApplication(key.getName()));
                    }
                    break;
                case VIP:
                case SVIP:
                    tracer = serializeViptimer.start();
                    payload = getPayLoad(key, getApplicationsForVip(key, registry));
                    break;
                default:
                    logger.error("Unidentified entity type: " + key.getEntityType() + " found in the cache key.");
                    payload = "";
                    break;
            }
            return new Value(payload);
        } finally {
            if (tracer != null) {
                tracer.stop();
            }
        }
    }

    private static Applications getApplicationsForVip(Key key, AbstractInstanceRegistry registry) {
        Object[] args = {key.getEntityType(), key.getName(), key.getVersion(), key.getType()};
        logger.debug(
                "Retrieving applications from registry for key : {} {} {} {}",
                args);
        Applications toReturn = new Applications();
        Applications applications = registry.getApplications();
        for (Application application : applications.getRegisteredApplications()) {
            Application appToAdd = null;
            for (InstanceInfo instanceInfo : application.getInstances()) {
                String vipAddress;
                if (Key.EntityType.VIP.equals(key.getEntityType())) {
                    vipAddress = instanceInfo.getVIPAddress();
                } else if (Key.EntityType.SVIP.equals(key.getEntityType())) {
                    vipAddress = instanceInfo.getSecureVipAddress();
                } else {
                    // should not happen, but just in case.
                    continue;
                }

                if (null != vipAddress) {
                    String[] vipAddresses = vipAddress.split(",");
                    Arrays.sort(vipAddresses);
                    if (Arrays.binarySearch(vipAddresses, key.getName()) >= 0) {
                        if (null == appToAdd) {
                            appToAdd = new Application(application.getName());
                            toReturn.addApplication(appToAdd);
                        }
                        appToAdd.addInstance(instanceInfo);
                    }
                }
            }
        }
        toReturn.setAppsHashCode(toReturn.getReconcileHashCode());
        args = new Object[]{key.getEntityType(), key.getName(), key.getVersion(), key.getType(),
                toReturn.getReconcileHashCode()};
        logger.debug(
                "Retrieved applications from registry for key : {} {} {} {}, reconcile hashcode: {}",
                args);
        return toReturn;
    }

    /**
     * The class that stores payload in both compressed and uncompressed form.
     *
     */
    public class Value {
        private final String payload;
        private byte[] gzipped;

        public Value(String payload) {
            this.payload = payload;
            if (!EMPTY_PAYLOAD.equals(payload)) {
                Stopwatch tracer = compressPayloadTimer.start();
                try {
                    ByteArrayOutputStream bos = new ByteArrayOutputStream();
                    GZIPOutputStream out = new GZIPOutputStream(bos);
                    byte[] rawBytes = payload.getBytes();
                    out.write(rawBytes);
                    // Finish creation of gzip file
                    out.finish();
                    out.close();
                    bos.close();
                    gzipped = bos.toByteArray();
                } catch (IOException e) {
                    gzipped = null;
                } finally {
                    if (tracer != null) {
                        tracer.stop();
                    }
                }
            } else {
                gzipped = null;
            }
        }

        public String getPayload() {
            return payload;
        }

        public byte[] getGzipped() {
            return gzipped;
        }

    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/Key.java;<<<<<<< MINE
=======
package com.netflix.eureka.registry;

import com.netflix.appinfo.EurekaAccept;
import com.netflix.eureka.Version;

import javax.annotation.Nullable;
import java.util.Arrays;

public class Key {

    public enum KeyType {
        JSON, XML
    }

    /**
     * An enum to define the entity that is stored in this cache for this key.
     */
    public enum EntityType {
        Application, VIP, SVIP
    }

    private final String entityName;
    private final String[] regions;
    private final KeyType requestType;
    private final Version requestVersion;
    private final String hashKey;
    private final EntityType entityType;
    private final EurekaAccept eurekaAccept;

    public Key(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept) {
        this(entityType, entityName, type, v, eurekaAccept, null);
    }

    public Key(EntityType entityType, String entityName, KeyType type, Version v, EurekaAccept eurekaAccept, @Nullable String[] regions) {
        this.regions = regions;
        this.entityType = entityType;
        this.entityName = entityName;
        this.requestType = type;
        this.requestVersion = v;
        this.eurekaAccept = eurekaAccept;
        hashKey = this.entityType + this.entityName + (null != this.regions ? Arrays.toString(this.regions) : "")
                + requestType.name() + requestVersion.name() + this.eurekaAccept.name();
    }

    public String getName() {
        return entityName;
    }

    public String getHashKey() {
        return hashKey;
    }

    public KeyType getType() {
        return requestType;
    }

    public Version getVersion() {
        return requestVersion;
    }

    public EurekaAccept getEurekaAccept() {
        return eurekaAccept;
    }

    public EntityType getEntityType() {
        return entityType;
    }

    public boolean hasRegions() {
        return null != regions && regions.length != 0;
    }

    public String[] getRegions() {
        return regions;
    }

    public Key cloneWithoutRegions() {
        return new Key(entityType, entityName, requestType, requestVersion, eurekaAccept);
    }

    @Override
    public int hashCode() {
        String hashKey = getHashKey();
        return hashKey.hashCode();
    }

    @Override
    public boolean equals(Object other) {
        if (other instanceof Key) {
            return getHashKey().equals(((Key) other).getHashKey());
        } else {
            return false;
        }
    }

    public String toStringCompact() {
        StringBuilder sb = new StringBuilder();
        sb.append("{name=").append(entityName).append(", type=").append(entityType).append(", format=").append(requestType);
        if(regions != null) {
            sb.append(", regions=").append(Arrays.toString(regions));
        }
        sb.append('}');
        return sb.toString();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/ResponseCache.java;<<<<<<< MINE
=======
package com.netflix.eureka.registry;

import javax.annotation.Nullable;
import java.util.concurrent.atomic.AtomicLong;

/**
 * @author David Liu
 */
public interface ResponseCache {

    void invalidate(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress);

    AtomicLong getVersionDelta();

    AtomicLong getVersionDeltaWithRegions();

    /**
     * Get the cached information about applications.
     *
     * <p>
     * If the cached information is not available it is generated on the first
     * request. After the first request, the information is then updated
     * periodically by a background thread.
     * </p>
     *
     * @param key the key for which the cached information needs to be obtained.
     * @return payload which contains information about the applications.
     */
     String get(Key key);

    /**
     * Get the compressed information about the applications.
     *
     * @param key the key for which the compressed cached information needs to be obtained.
     * @return compressed payload which contains information about the applications.
     */
    byte[] getGZIP(Key key);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/AwsInstanceRegistry.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka.registry;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.EurekaClient;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.aws.AwsAsgUtil;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.lease.Lease;
import com.netflix.eureka.resources.ServerCodecs;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Override some methods with aws specific usecases.
 *
 * @author David Liu
 */
@Singleton
public class AwsInstanceRegistry extends PeerAwareInstanceRegistryImpl {
    private static final Logger logger = LoggerFactory.getLogger(AwsInstanceRegistry.class);

    private AwsAsgUtil awsAsgUtil;

    @Inject
    public AwsInstanceRegistry(EurekaServerConfig serverConfig,
                               EurekaClientConfig clientConfig,
                               ServerCodecs serverCodecs,
                               EurekaClient eurekaClient) {
        super(serverConfig, clientConfig, serverCodecs, eurekaClient);
    }

    @Override
    public void init(PeerEurekaNodes peerEurekaNodes) throws Exception {
        super.init(peerEurekaNodes);
        this.awsAsgUtil = new AwsAsgUtil(serverConfig, clientConfig, this);
    }

    public AwsAsgUtil getAwsAsgUtil() {
        return awsAsgUtil;
    }

    /**
     * override base method to add asg lookup
     */
    @Override
    protected InstanceInfo.InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                                      Lease<InstanceInfo> existingLease,
                                                                      boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed as well since the service may be
        // currently in SERVICE
        if (
                (!InstanceInfo.InstanceStatus.UP.equals(r.getStatus()))
                        && (!InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug("Trusting the instance status {} from replica or instance for instance {}",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceInfo.InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise the ASG status
        if (overridden != null) {
            logger.debug("The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }
        // If the ASGName is present- check for its status
        boolean isASGDisabled = false;
        if (r.getASGName() != null) {
            isASGDisabled = !awsAsgUtil.isASGEnabled(r);
            logger.debug("The ASG name is specified {} and the value is {}", r.getASGName(), isASGDisabled);
            if (isASGDisabled) {
                return InstanceInfo.InstanceStatus.OUT_OF_SERVICE;
            } else {
                return InstanceInfo.InstanceStatus.UP;
            }
        }
        // This is for backward compatibility until all applications have ASG names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceInfo.InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or OUT_OF_SERVICE
            if (
                    (existingStatus != null)
                            && (InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                            || InstanceInfo.InstanceStatus.UP.equals(existingStatus))) {
                logger.debug("There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug("Returning the default instance status {} for instance {}",
                r.getStatus(), r.getId());
        return r.getStatus();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/InstanceRegistry.java;<<<<<<< MINE
=======
package com.netflix.eureka.registry;

import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.LookupService;
import com.netflix.discovery.shared.Pair;
import com.netflix.eureka.lease.LeaseManager;

import java.util.List;
import java.util.Map;

/**
 * @author Tomasz Bak
 */
public interface InstanceRegistry extends LeaseManager<InstanceInfo>, LookupService<String> {

    void openForTraffic(ApplicationInfoManager applicationInfoManager, int count);

    void shutdown();

    @Deprecated
    void storeOverriddenStatusIfRequired(String id, InstanceStatus overriddenStatus);

    void storeOverriddenStatusIfRequired(String appName, String id, InstanceStatus overriddenStatus);

    boolean statusUpdate(String appName, String id, InstanceStatus newStatus,
                         String lastDirtyTimestamp, boolean isReplication);

    boolean deleteStatusOverride(String appName, String id, InstanceStatus newStatus,
                                 String lastDirtyTimestamp, boolean isReplication);

    Map<String, InstanceStatus> overriddenInstanceStatusesSnapshot();

    Applications getApplicationsFromLocalRegionOnly();

    List<Application> getSortedApplications();

    /**
     * Get application information.
     *
     * @param appName The name of the application
     * @param includeRemoteRegion true, if we need to include applications from remote regions
     *                            as indicated by the region {@link java.net.URL} by this property
     *                            {@link com.netflix.eureka.EurekaServerConfig#getRemoteRegionUrls()}, false otherwise
     * @return the application
     */
    Application getApplication(String appName, boolean includeRemoteRegion);

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName the application name for which the information is requested.
     * @param id the unique identifier of the instance.
     * @return the information about the instance.
     */
    InstanceInfo getInstanceByAppAndId(String appName, String id);

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName the application name for which the information is requested.
     * @param id the unique identifier of the instance.
     * @param includeRemoteRegions true, if we need to include applications from remote regions
     *                             as indicated by the region {@link java.net.URL} by this property
     *                             {@link com.netflix.eureka.EurekaServerConfig#getRemoteRegionUrls()}, false otherwise
     * @return the information about the instance.
     */
    InstanceInfo getInstanceByAppAndId(String appName, String id, boolean includeRemoteRegions);

    void clearRegistry();

    void initializedResponseCache();

    ResponseCache getResponseCache();

    long getNumOfRenewsInLastMin();

    int getNumOfRenewsPerMinThreshold();

    int isBelowRenewThresold();

    List<Pair<Long, String>> getLastNRegisteredInstances();

    List<Pair<Long, String>> getLastNCanceledInstances();

    /**
     * Checks whether lease expiration is enabled.
     * @return true if enabled
     */
    boolean isLeaseExpirationEnabled();

    boolean isSelfPreservationModeEnabled();

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistry.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka.registry;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.shared.Application;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.resources.ASGResource;

import java.util.List;

/**
 * @author Tomasz Bak
 */
public interface PeerAwareInstanceRegistry extends InstanceRegistry {

    void init(PeerEurekaNodes peerEurekaNodes) throws Exception;

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    int syncUp();

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link com.netflix.eureka.EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, otherwise returns true
     */
     boolean shouldAllowAccess(boolean remoteRegionRequired);

     void register(InstanceInfo info, boolean isReplication);

     void statusUpdate(final String asgName, final ASGResource.ASGStatus newStatus, final boolean isReplication);
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka.registry;

import java.net.URI;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.DataCenterInfo;
import com.netflix.appinfo.DataCenterInfo.Name;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.appinfo.LeaseInfo;
import com.netflix.discovery.EurekaClient;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.eureka.resources.CurrentRequestVersion;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.Version;
import com.netflix.eureka.cluster.PeerEurekaNode;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.lease.Lease;
import com.netflix.eureka.resources.ASGResource.ASGStatus;
import com.netflix.eureka.resources.ServerCodecs;
import com.netflix.eureka.util.MeasuredRate;
import com.netflix.servo.DefaultMonitorRegistry;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Handles replication of all operations to {@link AbstractInstanceRegistry} to peer
 * <em>Eureka</em> nodes to keep them all in sync.
 *
 * <p>
 * Primary operations that are replicated are the
 * <em>Registers,Renewals,Cancels,Expirations and Status Changes</em>
 * </p>
 *
 * <p>
 * When the eureka server starts up it tries to fetch all the registry
 * information from the peer eureka nodes.If for some reason this operation
 * fails, the server does not allow the user to get the registry information for
 * a period specified in
 * {@link com.netflix.eureka.EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}.
 * </p>
 *
 * <p>
 * One important thing to note about <em>renewals</em>.If the renewal drops more
 * than the specified threshold as specified in
 * {@link com.netflix.eureka.EurekaServerConfig#getRenewalPercentThreshold()} within a period of
 * {@link com.netflix.eureka.EurekaServerConfig#getRenewalThresholdUpdateIntervalMs()}, eureka
 * perceives this as a danger and stops expiring instances.
 * </p>
 *
 * @author Karthik Ranganathan, Greg Kim
 *
 */
@Singleton
public class PeerAwareInstanceRegistryImpl extends AbstractInstanceRegistry implements PeerAwareInstanceRegistry {
    private static final Logger logger = LoggerFactory.getLogger(PeerAwareInstanceRegistryImpl.class);

    private static final String US_EAST_1 = "us-east-1";
    private static final int PRIME_PEER_NODES_RETRY_MS = 30000;

    private long startupTime = 0;
    private boolean peerInstancesTransferEmptyOnStartup = true;

    public enum Action {
        Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;

        private com.netflix.servo.monitor.Timer timer = Monitors.newTimer(this.name());

        public com.netflix.servo.monitor.Timer getTimer() {
            return this.timer;
        }
    }

    private static final Comparator<Application> APP_COMPARATOR = new Comparator<Application>() {
        public int compare(Application l, Application r) {
            return l.getName().compareTo(r.getName());
        }
    };

    private final MeasuredRate numberOfReplicationsLastMin = new MeasuredRate(1000 * 60 * 1);

    protected final EurekaClientConfig clientConfig;
    protected final ServerCodecs serverCodecs;
    protected final EurekaClient eurekaClient;
    protected volatile PeerEurekaNodes peerEurekaNodes;

    private Timer timer = new Timer(
            "ReplicaAwareInstanceRegistry - RenewalThresholdUpdater", true);

    @Inject
    public PeerAwareInstanceRegistryImpl(
            EurekaServerConfig serverConfig,
            EurekaClientConfig clientConfig,
            ServerCodecs serverCodecs,
            EurekaClient eurekaClient
    ) {
        super(serverConfig, serverCodecs);
        this.clientConfig = clientConfig;
        this.serverCodecs = serverCodecs;
        this.eurekaClient = eurekaClient;
    }

    @Override
    public void init(PeerEurekaNodes peerEurekaNodes) throws Exception {
        this.peerEurekaNodes = peerEurekaNodes;
        initializedResponseCache();
        scheduleRenewalThresholdUpdateTask();
        initRemoteRegionRegistry();

        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn("Cannot register the JMX monitor for the InstanceRegistry :", e);
        }
    }

    /**
     * Perform all cleanup and shutdown operations.
     */
    @Override
    public void shutdown() {
        try {
            DefaultMonitorRegistry.getInstance().unregister(Monitors.newObjectMonitor(this));
        } catch (Throwable t) {
            logger.error("Cannot shutdown monitor registry", t);
        }
        try {
        peerEurekaNodes.shutdown();
        } catch (Throwable t) {
            logger.error("Cannot shutdown ReplicaAwareInstanceRegistry", t);
        }
        super.shutdown();
    }

    /**
     * Schedule the task that updates <em>renewal threshold</em> periodically.
     * The renewal threshold would be used to determine if the renewals drop
     * dramatically because of network partition and to protect expiring too
     * many instances at a time.
     *
     */
    private void scheduleRenewalThresholdUpdateTask() {
        timer.schedule(new TimerTask() {
                           @Override
                           public void run() {
                               updateRenewalThreshold();
                           }
                       }, serverConfig.getRenewalThresholdUpdateIntervalMs(),
                serverConfig.getRenewalThresholdUpdateIntervalMs());
    }

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    @Override
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        int count = 0;

        for (int i = 0; ((i < serverConfig.getRegistrySyncRetries()) && (count == 0)); i++) {
            Applications apps = eurekaClient.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {
                            register(instance, instance.getLeaseInfo().getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
            if (count == 0) {
                try {
                    Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
        }
        return count;
    }

    @Override
    public void openForTraffic(ApplicationInfoManager applicationInfoManager, int count) {
        // Renewals happen every 30 seconds and for a minute it should be a factor of 2.
        this.expectedNumberOfRenewsPerMin = count * 2;
        this.numberOfRenewsPerMinThreshold =
                (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());
        logger.info("Got " + count + " instances from neighboring DS node");
        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
        this.startupTime = System.currentTimeMillis();
        if (count > 0) {
            this.peerInstancesTransferEmptyOnStartup = false;
        }
        DataCenterInfo.Name selfName = applicationInfoManager.getInfo().getDataCenterInfo().getName();
        boolean isAws = Name.Amazon == selfName;
        if (isAws && serverConfig.shouldPrimeAwsReplicaConnections()) {
            logger.info("Priming AWS connections for all replicas..");
            primeAwsReplicas(applicationInfoManager);
        }
        logger.info("Changing status to UP");
        applicationInfoManager.setInstanceStatus(InstanceStatus.UP);
        super.postInit();
    }

    /**
     * Prime connections for Aws replicas.
     * <p>
     * Sometimes when the eureka servers comes up, AWS firewall may not allow
     * the network connections immediately. This will cause the outbound
     * connections to fail, but the inbound connections continue to work. What
     * this means is the clients would have switched to this node (after EIP
     * binding) and so the other eureka nodes will expire all instances that
     * have been switched because of the lack of outgoing heartbeats from this
     * instance.
     * </p>
     * <p>
     * The best protection in this scenario is to block and wait until we are
     * able to ping all eureka nodes successfully atleast once. Until then we
     * won't open up the traffic.
     * </p>
     */
    private void primeAwsReplicas(ApplicationInfoManager applicationInfoManager) {
        boolean areAllPeerNodesPrimed = false;
        while (!areAllPeerNodesPrimed) {
            String peerHostName = null;
            try {
                Application eurekaApps = this.getApplication(applicationInfoManager.getInfo().getAppName(), false);
                if (eurekaApps == null) {
                    areAllPeerNodesPrimed = true;
                    logger.info("No peers needed to prime.");
                    return;
                }
                for (PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                    for (InstanceInfo peerInstanceInfo : eurekaApps.getInstances()) {
                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();
                        // If the lease is expired - do not worry about priming
                        if (System.currentTimeMillis() > (leaseInfo
                                .getRenewalTimestamp() + (leaseInfo
                                .getDurationInSecs() * 1000))
                                + (2 * 60 * 1000)) {
                            continue;
                        }
                        peerHostName = peerInstanceInfo.getHostName();
                        logger.info("Trying to send heartbeat for the eureka server at {} to make sure the " +
                                "network channels are open", peerHostName);
                        // Only try to contact the eureka nodes that are in this instance's registry - because
                        // the other instances may be legitimately down
                        if (peerHostName.equalsIgnoreCase(new URI(node.getServiceUrl()).getHost())) {
                            node.heartbeat(
                                    peerInstanceInfo.getAppName(),
                                    peerInstanceInfo.getId(),
                                    peerInstanceInfo,
                                    null,
                                    true);
                        }
                    }
                }
                areAllPeerNodesPrimed = true;
            } catch (Throwable e) {
                logger.error("Could not contact " + peerHostName, e);
                try {
                    Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                } catch (InterruptedException e1) {
                    logger.warn("Interrupted while priming : ", e1);
                    areAllPeerNodesPrimed = true;
                }
            }
        }
    }

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, otherwise returns true
     */
    @Override
    public boolean shouldAllowAccess(boolean remoteRegionRequired) {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (!(System.currentTimeMillis() > this.startupTime + serverConfig.getWaitTimeInMsWhenSyncEmpty())) {
                return false;
            }
        }
        if (remoteRegionRequired) {
            for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
                if (!remoteRegionRegistry.isReadyForServingData()) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean shouldAllowAccess() {
        return shouldAllowAccess(true);
    }

    /**
     * @deprecated use {@link com.netflix.eureka.cluster.PeerEurekaNodes#getPeerEurekaNodes()} directly.
     *
     * Gets the list of peer eureka nodes which is the list to replicate
     * information to.
     *
     * @return the list of replica nodes.
     */
    @Deprecated
    public List<PeerEurekaNode> getReplicaNodes() {
        return Collections.unmodifiableList(peerEurekaNodes.getPeerEurekaNodes());
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.registry.InstanceRegistry#cancel(java.lang.String,
     * java.lang.String, long, boolean)
     */
    @Override
    public boolean cancel(final String appName, final String id,
                          final boolean isReplication) {
        if (super.cancel(appName, id, isReplication)) {
            replicateToPeers(Action.Cancel, appName, id, null, null, isReplication);
            synchronized (lock) {
                if (this.expectedNumberOfRenewsPerMin > 0) {
                    // Since the client wants to cancel it, reduce the threshold (1 for 30 seconds, 2 for a minute)
                    this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2;
                    this.numberOfRenewsPerMinThreshold =
                            (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Registers the information about the {@link InstanceInfo} and replicates
     * this information to all peer eureka nodes. If this is replication event
     * from other replica nodes then it is not replicated.
     *
     * @param info
     *            the {@link InstanceInfo} to be registered and replicated.
     * @param isReplication
     *            true if this is a replication event from other replica nodes,
     *            false otherwise.
     */
    @Override
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null && info.getLeaseInfo().getDurationInSecs() > 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.registry.InstanceRegistry#renew(java.lang.String,
     * java.lang.String, long, boolean)
     */
    public boolean renew(final String appName, final String id, final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.registry.InstanceRegistry#statusUpdate(java.lang.String,
     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,
     * java.lang.String, boolean)
     */
    @Override
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus, isReplication);
            return true;
        }
        return false;
    }

    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /**
     * Replicate the <em>ASG status</em> updates to peer eureka nodes. If this
     * event is a replication from other nodes, then it is not replicated to
     * other nodes.
     *
     * @param asgName the asg name for which the status needs to be replicated.
     * @param newStatus the {@link ASGStatus} information that needs to be replicated.
     * @param isReplication true if this is a replication event from other nodes, false otherwise.
     */
    @Override
    public void statusUpdate(final String asgName, final ASGStatus newStatus, final boolean isReplication) {
        // If this is replicated from an other node, do not try to replicate again.
        if (isReplication) {
            return;
        }
        for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
            replicateASGInfoToReplicaNodes(asgName, newStatus, node);

        }

    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.registry.InstanceRegistry#isLeaseExpirationEnabled()
     */
    @Override
    public boolean isLeaseExpirationEnabled() {
        boolean leaseExpirationEnabled = (numberOfRenewsPerMinThreshold > 0)
                && (getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold);
        boolean isSelfPreservationModeEnabled = isSelfPreservationModeEnabled();
        if ((!leaseExpirationEnabled)) {
            if (!isSelfPreservationModeEnabled) {
                logger.warn("The self preservation mode is disabled!. Hence allowing the instances to expire.");
                leaseExpirationEnabled = true;
            }
        }
        return leaseExpirationEnabled;
    }

    /**
     * Checks to see if the self-preservation mode is enabled.
     *
     * <p>
     * The self-preservation mode is enabled if the expected number of renewals
     * per minute {@link #getNumOfRenewsInLastMin()} is lesser than the expected
     * threshold which is determined by {@link #getNumOfRenewsPerMinThreshold()}
     * . Eureka perceives this as a danger and stops expiring instances as this
     * is most likely because of a network event. The mode is disabled only when
     * the renewals get back to above the threshold or if the flag
     * {@link EurekaServerConfig#shouldEnableSelfPreservation()} is set to
     * false.
     * </p>
     *
     * @return true if the self-preservation mode is enabled, false otherwise.
     */
    @Override
    public boolean isSelfPreservationModeEnabled() {
        return serverConfig.shouldEnableSelfPreservation();
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String virtualHostname, boolean secure) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Updates the <em>renewal threshold</em> based on the current number of
     * renewals. The threshold is a percentage as specified in
     * {@link EurekaServerConfig#getRenewalPercentThreshold()} of renewals
     * received per minute {@link #getNumOfRenewsInLastMin()}.
     */
    private void updateRenewalThreshold() {
        try {
            Applications apps = eurekaClient.getApplications();
            int count = 0;
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    if (this.isRegisterable(instance)) {
                        ++count;
                    }
                }
            }
            synchronized (lock) {
                // Update threshold only if the threshold is greater than the
                // current expected threshold of if the self preservation is disabled.
                if ((count * 2) > (serverConfig.getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
                        || (!this.isSelfPreservationModeEnabled())) {
                    this.expectedNumberOfRenewsPerMin = count * 2;
                    this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * serverConfig.getRenewalPercentThreshold());
                }
            }
            logger.info("Current renewal threshold is : {}", numberOfRenewsPerMinThreshold);
        } catch (Throwable e) {
            logger.error("Cannot update renewal threshold", e);
        }
    }

    /**
     * Gets the list of all {@link Applications} from the registry in sorted
     * lexical order of {@link Application#getName()}.
     *
     * @return the list of {@link Applications} in lexical order.
     */
    @Override
    public List<Application> getSortedApplications() {
        List<Application> apps = new ArrayList<Application>(getApplications().getRegisteredApplications());
        Collections.sort(apps, APP_COMPARATOR);
        return apps;
    }

    /**
     * Gets the number of <em>renewals</em> in the last minute.
     *
     * @return a long value representing the number of <em>renewals</em> in the last minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfReplicationsInLastMin",
            description = "Number of total replications received in the last minute",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public long getNumOfReplicationsInLastMin() {
        return numberOfReplicationsLastMin.getCount();
    }

    /**
     * Checks if the number of renewals is lesser than threshold.
     *
     * @return 0 if the renewals are greater than threshold, 1 otherwise.
     */
    @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    @Override
    public int isBelowRenewThresold() {
        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                &&
                ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime + (serverConfig.getWaitTimeInMsWhenSyncEmpty())))) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Checks if an instance is registerable in this region. Instances from other regions are rejected.
     *
     * @param instanceInfo  th instance info information of the instance
     * @return true, if it can be registered in this server, false otherwise.
     */
    public boolean isRegisterable(InstanceInfo instanceInfo) {
        DataCenterInfo datacenterInfo = instanceInfo.getDataCenterInfo();
        String serverRegion = clientConfig.getRegion();
        if (AmazonInfo.class.isInstance(datacenterInfo)) {
            AmazonInfo info = AmazonInfo.class.cast(instanceInfo.getDataCenterInfo());
            String availabilityZone = info.get(MetaDataKey.availabilityZone);
            // Can be null for dev environments in non-AWS data center
            if (availabilityZone == null && US_EAST_1.equalsIgnoreCase(serverRegion)) {
                return true;
            } else if ((availabilityZone != null) && (availabilityZone.contains(serverRegion))) {
                // If in the same region as server, then consider it registerable
                return true;
            }
        }
        return true; // Everything non-amazon is registrable.
    }

    /**
     * Replicates all eureka actions to peer eureka nodes except for replication
     * traffic to this node.
     *
     */
    private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {
            if (isReplication) {
                numberOfReplicationsLastMin.increment();
            }
            // If it is a replication already, do not replicate again as this will create a poison replication
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                // If the url represents this host, do not replicate to yourself.
                if (peerEurekaNodes.isThisMe(node.getServiceUrl())) {
                    continue;
                }
                replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }

    /**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error("Cannot replicate information to {} for action {}", node.getServiceUrl(), action.name(), t);
        }
    }

    /**
     * Replicates all ASG status changes to peer eureka nodes except for
     * replication traffic to this node.
     */
    private void replicateASGInfoToReplicaNodes(final String asgName,
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
        CurrentRequestVersion.set(Version.V2);
        try {
            node.statusUpdate(asgName, newStatus);
        } catch (Throwable e) {
            logger.error("Cannot replicate ASG status information to {}", node.getServiceUrl(), e);
        }
    }

    @Override
    @com.netflix.servo.annotations.Monitor(name = "localRegistrySize",
            description = "Current registry size", type = DataSourceType.GAUGE)
    public long getLocalRegistrySize() {
        return super.getLocalRegistrySize();
    }

    @Override
    protected InstanceInfo.InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                                      Lease<InstanceInfo> existingLease,
                                                                      boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed as well since the service may be
        // currently in SERVICE
        if (
                (!InstanceInfo.InstanceStatus.UP.equals(r.getStatus()))
                        && (!InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug("Trusting the instance status {} from replica or instance for instance {}",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceInfo.InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise the ASG status
        if (overridden != null) {
            logger.debug("The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }

        // This is for backward compatibility until all applications have ASG
        // names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceInfo.InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or OUT_OF_SERVICE
            if (
                    (existingStatus != null)
                            && (InstanceInfo.InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                            || InstanceInfo.InstanceStatus.UP.equals(existingStatus))) {
                logger.debug("There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug("Returning the default instance status {} for instance {}",
                r.getStatus(), r.getId());
        return r.getStatus();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/lease/LeaseManager.java;<<<<<<< MINE
import com.netflix.eureka.AbstractInstanceRegistry;
=======
import com.netflix.eureka.registry.AbstractInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/lease/Lease.java;<<<<<<< MINE
import com.netflix.eureka.AbstractInstanceRegistry;
=======
import com.netflix.eureka.registry.AbstractInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
=======
import javax.inject.Inject;
import javax.inject.Singleton;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
=======
@Singleton
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
=======
    private EurekaServerConfig serverConfig;

    @Inject
    public ServerRequestAuthFilter(EurekaServerContext server) {
        this.serverConfig = server.getServerConfig();
    }

    // for non-DI use
    public ServerRequestAuthFilter() {
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
        // nothing to do here
=======
        if (serverConfig == null) {
            EurekaServerContext serverContext = (EurekaServerContext) filterConfig.getServletContext()
                    .getAttribute(EurekaServerContext.class.getName());
            serverConfig = serverContext.getServerConfig();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;<<<<<<< MINE
        if (EurekaServerConfigurationManager.getInstance().getConfiguration().shouldLogIdentityHeaders()) {
=======
        if (serverConfig.shouldLogIdentityHeaders()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
import javax.servlet.ServletContext;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
import java.util.Timer;
import java.util.TimerTask;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
import com.netflix.appinfo.DataCenterInfo.Name;
=======
import com.netflix.appinfo.DataCenterInfo;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
import com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
import com.netflix.config.DeploymentContext;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
import com.netflix.discovery.DiscoveryManager;
=======
import com.netflix.discovery.DiscoveryClient;
import com.netflix.discovery.EurekaClient;
import com.netflix.discovery.EurekaClientConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
import com.netflix.eureka.cluster.PeerEurekaNode;
import com.netflix.eureka.util.EIPManager;
=======
import com.netflix.eureka.aws.EIPManager;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.registry.AwsInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl;
import com.netflix.eureka.resources.DefaultServerCodecs;
import com.netflix.eureka.resources.ServerCodecs;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
 * @author Karthik Ranganathan, Greg Kim
=======
 * @author Karthik Ranganathan, Greg Kim, David Liu
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
    private static final Logger logger = LoggerFactory.getLogger(EurekaBootStrap.class);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
    private static final Logger logger = LoggerFactory.getLogger(EurekaBootStrap.class);

    private static final int EIP_BIND_SLEEP_TIME_MS = 1000;
    private static final Timer timer = new Timer("Eureka-EIPBinder", true);
=======
    protected volatile EurekaServerContext serverContext;
    protected volatile EIPManager eipManager;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
            initEurekaServerContext();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
            // For backward compatibility
            JsonXStream.getInstance().registerConverter(
                    new V1AwareInstanceInfoConverter(),
                    XStream.PRIORITY_VERY_HIGH);
            XmlXStream.getInstance().registerConverter(
                    new V1AwareInstanceInfoConverter(),
                    XStream.PRIORITY_VERY_HIGH);
            InstanceInfo info = ApplicationInfoManager.getInstance().getInfo();

            PeerAwareInstanceRegistryImpl registry = PeerAwareInstanceRegistryImpl.getInstance();

            // Copy registry from neighboring eureka node
            int registryCount = registry.syncUp();
            registry.openForTraffic(registryCount);

            // Only in AWS, enable the binding functionality
            if (Name.Amazon.equals(info.getDataCenterInfo().getName())) {
                handleEIPBinding(registry);
            }
            // Initialize available remote registry
            PeerAwareInstanceRegistryImpl.getInstance().initRemoteRegionRegistry();
            // Register all monitoring statistics.
            EurekaMonitors.registerAllStats();

            for (PeerEurekaNode node : registry.getReplicaNodes()) {
                logger.info("Replica node URL:  " + node.getServiceUrl());
            }

=======
            ServletContext sc = event.getServletContext();
            sc.setAttribute(EurekaServerContext.class.getName(), serverContext);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
    protected void initEurekaEnvironment() {
=======
    protected void initEurekaEnvironment() throws Exception {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
        EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();
        EurekaServerConfigurationManager.getInstance().setConfiguration(
                eurekaServerConfig);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
        String dataCenter = ConfigurationManager.getConfigInstance()
                .getString(EUREKA_DATACENTER);
=======
        String dataCenter = ConfigurationManager.getConfigInstance().getString(EUREKA_DATACENTER);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
            ConfigurationManager.getConfigInstance().setProperty(
                    ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);
=======
            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, DEFAULT);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
            ConfigurationManager.getConfigInstance().setProperty(
                    ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);
=======
            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_DATACENTER, dataCenter);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
            ConfigurationManager.getConfigInstance().setProperty(
                    ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);
=======
            ConfigurationManager.getConfigInstance().setProperty(ARCHAIUS_DEPLOYMENT_ENVIRONMENT, TEST);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
        EurekaInstanceConfig config;
        if (CLOUD.equals(ConfigurationManager.getDeploymentContext()
                .getDeploymentDatacenter())) {
            config = new CloudInstanceConfig();
=======
    }

    /**
     * init hook for server context. Override for custom logic.
     */
    protected void initEurekaServerContext() throws Exception {
        EurekaServerConfig eurekaServerConfig = new DefaultEurekaServerConfig();

        // For backward compatibility
        JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
        XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);

        EurekaInstanceConfig instanceConfig = isCloud(ConfigurationManager.getDeploymentContext())
                ? new CloudInstanceConfig()
                : new MyDataCenterInstanceConfig();

        logger.info("Initializing the eureka client...");
        ServerCodecs serverCodecs = new DefaultServerCodecs(eurekaServerConfig);

        ApplicationInfoManager applicationInfoManager = new ApplicationInfoManager(
                instanceConfig, new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());

        EurekaClientConfig eurekaClientConfig = new DefaultEurekaClientConfig();
        EurekaClient eurekaClient = new DiscoveryClient(applicationInfoManager, eurekaClientConfig);

        PeerAwareInstanceRegistry registry;
        if (isAws(applicationInfoManager.getInfo())) {
            registry = new AwsInstanceRegistry(
                    eurekaServerConfig,
                    eurekaClientConfig,
                    serverCodecs,
                    eurekaClient
            );
            eipManager = new EIPManager(eurekaServerConfig, eurekaClientConfig, registry, applicationInfoManager);
            eipManager.start();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
            config = new MyDataCenterInstanceConfig();
        }
        logger.info("Initializing the eureka client...");
=======
            registry = new PeerAwareInstanceRegistryImpl(
                    eurekaServerConfig,
                    eurekaClientConfig,
                    serverCodecs,
                    eurekaClient
            );
        }

        PeerEurekaNodes peerEurekaNodes = new PeerEurekaNodes(
                registry,
                eurekaServerConfig,
                eurekaClientConfig,
                serverCodecs,
                applicationInfoManager
        );

        serverContext = new DefaultEurekaServerContext(
                eurekaServerConfig,
                serverCodecs,
                registry,
                peerEurekaNodes,
                applicationInfoManager
        );

        EurekaServerContextHolder.initialize(serverContext);

        serverContext.initialize();
        logger.info("Initialized server context");

        // Copy registry from neighboring eureka node
        int registryCount = registry.syncUp();
        registry.openForTraffic(applicationInfoManager, registryCount);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
        DiscoveryManager.getInstance().initComponent(config,
                new DefaultEurekaClientConfig());
=======
        // Register all monitoring statistics.
        EurekaMonitors.registerAllStats();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
=======
    @Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
            logger.info(new Date().toString()
                    + " Shutting down Eureka Server..");
            InstanceInfo info = ApplicationInfoManager.getInstance().getInfo();
            // Unregister all MBeans associated w/ DSCounters
            EurekaMonitors.shutdown();
            for (int i = 0; i < EurekaServerConfigurationManager.getInstance()
                    .getConfiguration().getEIPBindRebindRetries(); i++) {
                try {
                    if (Name.Amazon.equals(info.getDataCenterInfo().getName())) {
                        EIPManager.getInstance().unbindEIP();
                    }
                    break;
                } catch (Throwable e) {
                    logger.warn("Cannot unbind the EIP from the instance");
                    Thread.sleep(1000);
                }
            }
            PeerAwareInstanceRegistryImpl.getInstance().shutdown();
=======
            logger.info("{} Shutting down Eureka Server..", new Date().toString());
            ServletContext sc = event.getServletContext();
            sc.removeAttribute(EurekaServerContext.class.getName());

            destroyEurekaServerContext();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
        logger.info(new Date().toString()
                + " Eureka Service is now shutdown...");
=======
        logger.info("{} Eureka Service is now shutdown...", new Date().toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
     * Users can override to clean up the environment themselves.
=======
     * Server context shutdown hook. Override for custom logic
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
    protected void destroyEurekaEnvironment() {

=======
    protected void destroyEurekaServerContext() throws Exception {
        EurekaMonitors.shutdown();
        if (eipManager != null) {
            eipManager.shutdown();
        }
        if (serverContext != null) {
            serverContext.shutdown();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
     * Handles EIP binding process in AWS Cloud.
     *
     * @throws InterruptedException
=======
     * Users can override to clean up the environment themselves.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
    private void handleEIPBinding(PeerAwareInstanceRegistryImpl registry)
            throws InterruptedException {
        EurekaServerConfig eurekaServerConfig = EurekaServerConfigurationManager.getInstance().getConfiguration();
        int retries = eurekaServerConfig.getEIPBindRebindRetries();
        // Bind to EIP if needed
        EIPManager eipManager = EIPManager.getInstance();
        for (int i = 0; i < retries; i++) {
            try {
                if (eipManager.isEIPBound()) {
                    break;
                } else {
                    eipManager.bindEIP();
                }
            } catch (Throwable e) {
                logger.error("Cannot bind to EIP", e);
                Thread.sleep(EIP_BIND_SLEEP_TIME_MS);
            }
        }
        // Schedule a timer which periodically checks for EIP binding.
        scheduleEIPBindTask(eurekaServerConfig, registry);
=======
    protected void destroyEurekaEnvironment() throws Exception {

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE
    /**
     * Schedules a EIP binding timer task which constantly polls for EIP in the
     * same zone and binds it to itself.If the EIP is taken away for some
     * reason, this task tries to get the EIP back. Hence it is advised to take
     * one EIP assignment per instance in a zone.
     *
     * @param eurekaServerConfig
     *            the Eureka Server Configuration.
     */
    private void scheduleEIPBindTask(
            EurekaServerConfig eurekaServerConfig, final PeerAwareInstanceRegistryImpl registry) {
        timer.schedule(new TimerTask() {

                           @Override
                           public void run() {
                               try {
                                   // If the EIP is not bound, the registry could  be stale
                                   // First sync up the registry from the neighboring node before
                                   // trying to bind the EIP
                                   EIPManager eipManager = EIPManager.getInstance();
                                   if (!eipManager.isEIPBound()) {
                                       registry.clearRegistry();
                                       int count = registry.syncUp();
                                       registry.openForTraffic(count);
                                   } else {
                                       // An EIP is already bound
                                       return;
                                   }
                                   eipManager.bindEIP();
                               } catch (Throwable e) {
                                   logger.error("Could not bind to EIP", e);
                               }
                           }
                       }, eurekaServerConfig.getEIPBindingRetryIntervalMs(),
                eurekaServerConfig.getEIPBindingRetryIntervalMs());
=======
    protected boolean isAws(InstanceInfo selfInstanceInfo) {
        boolean result = DataCenterInfo.Name.Amazon == selfInstanceInfo.getDataCenterInfo().getName();
        logger.info("isAws returned {}", result);
        return result;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;<<<<<<< MINE

=======
    protected boolean isCloud(DeploymentContext deploymentContext) {
        logger.info("Deployment datacenter is {}", deploymentContext.getDeploymentDatacenter());
        return CLOUD.equals(deploymentContext.getDeploymentDatacenter());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerContext.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka;

import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.resources.ServerCodecs;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * Represent the local server context and exposes getters to components of the
 * local server such as the registry.
 *
 * @author David Liu
 */
@Singleton
public class DefaultEurekaServerContext implements EurekaServerContext {
    private static final Logger logger = LoggerFactory.getLogger(DefaultEurekaServerContext.class);

    private final EurekaServerConfig serverConfig;
    private final ServerCodecs serverCodecs;
    private final PeerAwareInstanceRegistry registry;
    private final PeerEurekaNodes peerEurekaNodes;
    private final ApplicationInfoManager applicationInfoManager;

    @Inject
    public DefaultEurekaServerContext(EurekaServerConfig serverConfig,
                               ServerCodecs serverCodecs,
                               PeerAwareInstanceRegistry registry,
                               PeerEurekaNodes peerEurekaNodes,
                               ApplicationInfoManager applicationInfoManager) {
        this.serverConfig = serverConfig;
        this.serverCodecs = serverCodecs;
        this.registry = registry;
        this.peerEurekaNodes = peerEurekaNodes;
        this.applicationInfoManager = applicationInfoManager;
    }

    @PostConstruct
    @Override
    public void initialize() throws Exception {
        logger.info("Initializing ...");
        peerEurekaNodes.start();
        registry.init(peerEurekaNodes);
        logger.info("Initialized");
    }

    @PreDestroy
    @Override
    public void shutdown() throws Exception {
        logger.info("Shutting down ...");
        registry.shutdown();
        peerEurekaNodes.shutdown();
        logger.info("Shut down");
    }

    @Override
    public EurekaServerConfig getServerConfig() {
        return serverConfig;
    }

    @Override
    public PeerEurekaNodes getPeerEurekaNodes() {
        return peerEurekaNodes;
    }

    @Override
    public ServerCodecs getServerCodecs() {
        return serverCodecs;
    }

    @Override
    public PeerAwareInstanceRegistry getRegistry() {
        return registry;
    }

    @Override
    public ApplicationInfoManager getApplicationInfoManager() {
        return applicationInfoManager;
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
=======
import javax.inject.Inject;
import javax.inject.Singleton;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
=======
@Singleton
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
=======
    private EurekaServerConfig serverConfig;

    @Inject
    public RateLimitingFilter(EurekaServerContext server) {
        this.serverConfig = server.getServerConfig();
    }

    // for non-DI use
    public RateLimitingFilter() {
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
=======
        if (serverConfig == null) {
            EurekaServerContext serverContext = (EurekaServerContext) filterConfig.getServletContext()
                    .getAttribute(EurekaServerContext.class.getName());
            serverConfig = serverContext.getServerConfig();
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
            if (config().isRateLimiterEnabled()) {
=======
            if (serverConfig.isRateLimiterEnabled()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
    private static boolean isRateLimited(HttpServletRequest request, Target target) {
=======
    private boolean isRateLimited(HttpServletRequest request, Target target) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
    private static boolean isPrivileged(HttpServletRequest request) {
        if (config().isRateLimiterThrottleStandardClients()) {
=======
    private boolean isPrivileged(HttpServletRequest request) {
        if (serverConfig.isRateLimiterThrottleStandardClients()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
        Set<String> privilegedClients = config().getRateLimiterPrivilegedClients();
=======
        Set<String> privilegedClients = serverConfig.getRateLimiterPrivilegedClients();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
    private static boolean isOverloaded(Target target) {
        int maxInWindow = config().getRateLimiterBurstSize();
        int fetchWindowSize = config().getRateLimiterRegistryFetchAverageRate();
=======
    private boolean isOverloaded(Target target) {
        int maxInWindow = serverConfig.getRateLimiterBurstSize();
        int fetchWindowSize = serverConfig.getRateLimiterRegistryFetchAverageRate();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
            int fullFetchWindowSize = config().getRateLimiterFullFetchAverageRate();
=======
            int fullFetchWindowSize = serverConfig.getRateLimiterFullFetchAverageRate();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
    private static void incrementStats(Target target) {
        if (config().isRateLimiterEnabled()) {
=======
    private void incrementStats(Target target) {
        if (serverConfig.isRateLimiterEnabled()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;<<<<<<< MINE
    private static EurekaServerConfig config() {
        return EurekaServerConfigurationManager.getInstance().getConfiguration();
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerContext.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka;

import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.resources.ServerCodecs;

/**
 * @author David Liu
 */
public interface EurekaServerContext {

    void initialize() throws Exception;

    void shutdown() throws Exception;

    EurekaServerConfig getServerConfig();

    PeerEurekaNodes getPeerEurekaNodes();

    ServerCodecs getServerCodecs();

    PeerAwareInstanceRegistry getRegistry();

    ApplicationInfoManager getApplicationInfoManager();

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/V1AwareInstanceInfoConverter.java;<<<<<<< MINE
=======
import com.netflix.eureka.resources.CurrentRequestVersion;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE
     * The {@link com.netflix.eureka.resources.ResponseCache} currently uses a two level caching
=======
     * The {@link com.netflix.eureka.registry.ResponseCache} currently uses a two level caching
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE
=======
     * Get the wait/sleep time between each retry sync attempts, if the prev retry failed and there are
     * more retries to attempt.
     *
     * @return the wait time in ms between each sync retries
     */
    long getRegistrySyncRetryWaitMs();

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerContextHolder.java;<<<<<<< MINE
=======
/*
 * Copyright 2015 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka;

/**
 * A static holder for the server context for use in non-DI cases.
 *
 * @author David Liu
 */
public class EurekaServerContextHolder {

    private final EurekaServerContext serverContext;

    private EurekaServerContextHolder(EurekaServerContext serverContext) {
        this.serverContext = serverContext;
    }

    public EurekaServerContext getServerContext() {
        return this.serverContext;
    }

    private static EurekaServerContextHolder holder;

    public static synchronized void initialize(EurekaServerContext serverContext) {
        holder = new EurekaServerContextHolder(serverContext);
    }

    public static EurekaServerContextHolder getInstance() {
        return holder;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/AsgReplicationTask.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistry;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstance.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/InstanceReplicationTask.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
=======
import com.netflix.eureka.resources.ServerCodecs;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
    public JerseyReplicationClient(EurekaServerConfig config, String serviceUrl) {
=======
    public JerseyReplicationClient(EurekaServerConfig config, ServerCodecs serverCodecs, String serviceUrl) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
=======
                    .withEncoderWrapper(serverCodecs.getFullJsonCodec())
                    .withDecoderWrapper(serverCodecs.getFullJsonCodec())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka.aws;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.auth.InstanceProfileCredentialsProvider;
import com.amazonaws.services.ec2.AmazonEC2;
import com.amazonaws.services.ec2.AmazonEC2Client;
import com.amazonaws.services.ec2.model.Address;
import com.amazonaws.services.ec2.model.AssociateAddressRequest;
import com.amazonaws.services.ec2.model.DescribeAddressesRequest;
import com.amazonaws.services.ec2.model.DescribeAddressesResult;
import com.amazonaws.services.ec2.model.DisassociateAddressRequest;
import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.DataCenterInfo.Name;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.discovery.endpoint.EndpointUtils;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.servo.monitor.Monitors;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * An AWS specific <em>elastic ip</em> binding utility for binding eureka
 * servers for a well known <code>IP address</code>.
 *
 * <p>
 * <em>Eureka</em> clients talk to <em>Eureka</em> servers bound with well known
 * <code>IP addresses</code> since that is the most reliable mechanism to
 * discover the <em>Eureka</em> servers. When Eureka servers come up they bind
 * themselves to a well known <em>elastic ip</em>
 * </p>
 *
 * <p>
 * This binding mechanism gravitates towards one eureka server per zone for
 * resilience.Atleast one elastic ip should be slotted for each eureka server in
 * a zone. If more than eureka server is launched per zone and there are not
 * enough elastic ips slotted, the server tries to pick a free EIP slotted for other
 * zones and if it still cannot find a free EIP, waits and keeps trying.
 * </p>
 *
 * @author Karthik Ranganathan, Greg Kim
 *
 */
@Singleton
public class EIPManager {
    private static final Logger logger = LoggerFactory.getLogger(EIPManager.class);

    private static final String US_EAST_1 = "us-east-1";
    private static final int EIP_BIND_SLEEP_TIME_MS = 1000;
    private static final Timer timer = new Timer("Eureka-EIPBinder", true);

    private final EurekaServerConfig serverConfig;
    private final EurekaClientConfig clientConfig;
    private final PeerAwareInstanceRegistry registry;
    private final ApplicationInfoManager applicationInfoManager;

    @Inject
    public EIPManager(EurekaServerConfig serverConfig,
                      EurekaClientConfig clientConfig,
                      PeerAwareInstanceRegistry registry,
                      ApplicationInfoManager applicationInfoManager) {
        this.serverConfig = serverConfig;
        this.clientConfig = clientConfig;
        this.registry = registry;
        this.applicationInfoManager = applicationInfoManager;
        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn("Cannot register the JMX monitor for the InstanceRegistry", e);
        }
    }

    @PostConstruct
    public void start() throws Exception {
        handleEIPBinding();
    }

    @PreDestroy
    public void shutdown() throws Exception {
        timer.cancel();
        for (int i = 0; i < serverConfig.getEIPBindRebindRetries(); i++) {
            try {
                unbindEIP();
                break;
            } catch (Exception e) {
                logger.warn("Cannot unbind the EIP from the instance");
                Thread.sleep(1000);
            }
        }
    }


    /**
     * Handles EIP binding process in AWS Cloud.
     *
     * @throws InterruptedException
     */
    private void handleEIPBinding() throws InterruptedException {
        int retries = serverConfig.getEIPBindRebindRetries();
        // Bind to EIP if needed
        for (int i = 0; i < retries; i++) {
            try {
                if (isEIPBound()) {
                    break;
                } else {
                    bindEIP();
                }
            } catch (Throwable e) {
                logger.error("Cannot bind to EIP", e);
                Thread.sleep(EIP_BIND_SLEEP_TIME_MS);
            }
        }
        // Schedule a timer which periodically checks for EIP binding.
        scheduleEIPBindTask();
    }

    /**
     * Schedules a EIP binding timer task which constantly polls for EIP in the
     * same zone and binds it to itself.If the EIP is taken away for some
     * reason, this task tries to get the EIP back. Hence it is advised to take
     * one EIP assignment per instance in a zone.
     *
     */
    private void scheduleEIPBindTask() {
        timer.schedule(new TimerTask() {
                           @Override
                           public void run() {
                               try {
                                   // If the EIP is not bound, the registry could  be stale
                                   // First sync up the registry from the neighboring node before
                                   // trying to bind the EIP
                                   if (!isEIPBound()) {
                                       registry.clearRegistry();
                                       int count = registry.syncUp();
                                       registry.openForTraffic(applicationInfoManager, count);
                                   } else {
                                       // An EIP is already bound
                                       return;
                                   }
                                   bindEIP();
                               } catch (Throwable e) {
                                   logger.error("Could not bind to EIP", e);
                               }
                           }
                       }, serverConfig.getEIPBindingRetryIntervalMs(),
                serverConfig.getEIPBindingRetryIntervalMs());
    }

    /**
     * Checks if an EIP is already bound to the instance.
     * @return true if an EIP is bound, false otherwise
     */
    public boolean isEIPBound() {
        InstanceInfo myInfo = applicationInfoManager.getInfo();
        String myInstanceId = ((AmazonInfo) myInfo.getDataCenterInfo()).get(MetaDataKey.instanceId);
        String myZone = ((AmazonInfo) myInfo.getDataCenterInfo()).get(MetaDataKey.availabilityZone);
        String myPublicIP = ((AmazonInfo) myInfo.getDataCenterInfo()).get(MetaDataKey.publicIpv4);

        Collection<String> candidateEIPs = getCandidateEIPs(myInstanceId, myZone);
        for (String eipEntry : candidateEIPs) {
            if (eipEntry.equals(myPublicIP)) {
                logger.info("My instance {} seems to be already associated with the public ip {}",
                        myInstanceId, myPublicIP);
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if an EIP is bound and optionally binds the EIP.
     *
     * The list of EIPs are arranged with the EIPs allocated in the zone first
     * followed by other EIPs.
     *
     * If an EIP is already bound to this instance this method simply returns. Otherwise, this method tries to find
     * an unused EIP based on information from AWS. If it cannot find any unused EIP this method, it will be retried
     * for a specified interval.
     *
     * One of the following scenarios can happen here :
     *
     *  1) If the instance is already bound to an EIP as deemed by AWS, no action is taken.
     *  2) If an EIP is already bound to another instance as deemed by AWS, that EIP is skipped.
     *  3) If an EIP is not already bound to an instance and if this instance is not bound to an EIP, then
     *     the EIP is bound to this instance.
     */
    public void bindEIP() {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();
        String myInstanceId = ((AmazonInfo) myInfo.getDataCenterInfo()).get(MetaDataKey.instanceId);
        String myZone = ((AmazonInfo) myInfo.getDataCenterInfo()).get(MetaDataKey.availabilityZone);

        Collection<String> candidateEIPs = getCandidateEIPs(myInstanceId, myZone);

        AmazonEC2 ec2Service = getEC2Service();
        boolean isMyinstanceAssociatedWithEIP = false;
        Address selectedEIP = null;

        for (String eipEntry : candidateEIPs) {
            try {
                String associatedInstanceId;

                // Check with AWS, if this EIP is already been used by another instance
                DescribeAddressesRequest describeAddressRequest = new DescribeAddressesRequest().withPublicIps(eipEntry);
                DescribeAddressesResult result = ec2Service.describeAddresses(describeAddressRequest);
                if ((result.getAddresses() != null) && (!result.getAddresses().isEmpty())) {
                    Address eipAddress = result.getAddresses().get(0);
                    associatedInstanceId = eipAddress.getInstanceId();
                    // This EIP is not used by any other instance, hence mark it for selection if it is not
                    // already marked.
                    if (((associatedInstanceId == null) || (associatedInstanceId.isEmpty()))) {
                        if (selectedEIP == null) {
                            selectedEIP = eipAddress;
                        }
                    } else if (isMyinstanceAssociatedWithEIP = (associatedInstanceId.equals(myInstanceId))) {
                        // This EIP is associated with an instance, check if this is the same as the current instance.
                        // If it is the same, stop searching for an EIP as this instance is already associated with an
                        // EIP
                        selectedEIP = eipAddress;
                        break;
                    } else {
                        // The EIP is used by some other instance, hence skip it
                        logger.warn("The selected EIP {} is associated with another instance {} according to AWS," +
                                " hence skipping this", eipEntry, associatedInstanceId);
                    }
                }
            } catch (Throwable t) {
                logger.error("Failed to bind elastic IP: {} to {}", eipEntry, myInstanceId, t);
            }
        }
        if (null != selectedEIP) {
            String publicIp = selectedEIP.getPublicIp();
            // Only bind if the EIP is not already associated
            if (!isMyinstanceAssociatedWithEIP) {

                AssociateAddressRequest associateAddressRequest = new AssociateAddressRequest()
                        .withInstanceId(myInstanceId);

                String domain = selectedEIP.getDomain();
                if ("vpc".equals(domain)) {
                    associateAddressRequest.setAllocationId(selectedEIP.getAllocationId());
                } else {
                    associateAddressRequest.setPublicIp(publicIp);
                }

                ec2Service.associateAddress(associateAddressRequest);
                logger.info("\n\n\nAssociated {} running in zone: {} to elastic IP: {}", myInstanceId, myZone, publicIp);
            }
            logger.info("My instance {} seems to be already associated with the EIP {}", myInstanceId, publicIp);
        } else {
            logger.info("No EIP is free to be associated with this instance. Candidate EIPs are: {}", candidateEIPs);
        }
    }

    /**
     * Unbind the EIP that this instance is associated with.
     */
    public void unbindEIP() throws Exception {
        InstanceInfo myInfo = applicationInfoManager.getInfo();
        String myPublicIP = null;
        if (myInfo != null
                && myInfo.getDataCenterInfo().getName() == Name.Amazon) {
            myPublicIP = ((AmazonInfo) myInfo.getDataCenterInfo())
                    .get(MetaDataKey.publicIpv4);
            try {
                AmazonEC2 ec2Service = getEC2Service();
                DescribeAddressesRequest describeAddressRequest = new DescribeAddressesRequest()
                        .withPublicIps(myPublicIP);
                DescribeAddressesResult result = ec2Service.describeAddresses(describeAddressRequest);
                if ((result.getAddresses() != null) && (!result.getAddresses().isEmpty())) {
                    Address eipAddress = result.getAddresses().get(0);
                    DisassociateAddressRequest dissociateRequest = new DisassociateAddressRequest();
                    String domain = eipAddress.getDomain();
                    if ("vpc".equals(domain)) {
                        dissociateRequest.setAssociationId(eipAddress.getAssociationId());
                    } else {
                        dissociateRequest.setPublicIp(eipAddress.getPublicIp());
                    }

                    ec2Service.disassociateAddress(dissociateRequest);
                    logger.info("Dissociated the EIP {} from this instance", myPublicIP);
                }
            } catch (Throwable e) {
                throw new RuntimeException("Cannot dissociate address from this instance", e);
            }
        }

    }

    /**
     * Get the list of EIPs in the order of preference depending on instance zone.
     *
     * @param myInstanceId
     *            the instance id for this instance
     * @param myZone
     *            the zone where this instance is in
     * @return Collection containing the list of available EIPs
     */
    public Collection<String> getCandidateEIPs(String myInstanceId, String myZone) {

        if (myZone == null) {
            myZone = "us-east-1d";
        }

        Collection<String> eipCandidates = clientConfig.shouldUseDnsForFetchingServiceUrls()
                        ? getEIPsForZoneFromDNS(myZone)
                        : getEIPsForZoneFromConfig(myZone);

        if (eipCandidates == null || eipCandidates.size() == 0) {
            throw new RuntimeException("Could not get any elastic ips from the EIP pool for zone :" + myZone);
        }

        return eipCandidates;
    }

    /**
     * Get the list of EIPs from the configuration.
     *
     * @param myZone
     *            - the zone in which the instance resides.
     * @return collection of EIPs to choose from for binding.
     */
    private Collection<String> getEIPsForZoneFromConfig(String myZone) {
        List<String> ec2Urls = clientConfig.getEurekaServerServiceUrls(myZone);
        return getEIPsFromServiceUrls(ec2Urls);
    }

    /**
     * Get the list of EIPs from the ec2 urls.
     *
     * @param ec2Urls
     *            the ec2urls for which the EIP needs to be obtained.
     * @return collection of EIPs.
     */
    private Collection<String> getEIPsFromServiceUrls(List<String> ec2Urls) {
        List<String> returnedUrls = new ArrayList<String>();
        String region = clientConfig.getRegion();
        String regionPhrase = "";
        if (!US_EAST_1.equals(region)) {
            regionPhrase = "." + region;
        }
        for (String cname : ec2Urls) {
            int beginIndex = cname.indexOf("ec2-") + 4;
            int endIndex = cname.indexOf(regionPhrase + ".compute");
            String eipStr = cname.substring(beginIndex, endIndex);
            String eip = eipStr.replaceAll("\\-", ".");
            returnedUrls.add(eip);
        }
        return returnedUrls;
    }

    /**
     * Get the list of EIPS from the DNS.
     *
     * <p>
     * This mechanism looks for the EIP pool in the zone the instance is in by
     * looking up the DNS name <code>{zone}.{region}.{domainName}</code>. The
     * zone is fetched from the {@link InstanceInfo} object;the region is picked
     * up from the specified configuration
     * {@link com.netflix.discovery.EurekaClientConfig#getRegion()};the domain name is picked up from
     * the specified configuration {@link com.netflix.discovery.EurekaClientConfig#getEurekaServerDNSName()}
     * with a "txt." prefix (see {@link com.netflix.discovery.endpoint.EndpointUtils
     * #getZoneBasedDiscoveryUrlsFromRegion(com.netflix.discovery.EurekaClientConfig, String)}.
     * </p>
     *
     * @param myZone
     *            the zone where this instance exist in.
     * @return the collection of EIPs that exist in the zone this instance is
     *         in.
     */
    private Collection<String> getEIPsForZoneFromDNS(String myZone) {
        List<String> ec2Urls = EndpointUtils.getServiceUrlsFromDNS(
                clientConfig,
                myZone,
                true,
                new EndpointUtils.InstanceInfoBasedUrlRandomizer(applicationInfoManager.getInfo())
        );
        return getEIPsFromServiceUrls(ec2Urls);
    }

    /**
     * Gets the EC2 service object to call AWS APIs.
     *
     * @return the EC2 service object to call AWS APIs.
     */
    private AmazonEC2 getEC2Service() {
        String aWSAccessId = serverConfig.getAWSAccessId();
        String aWSSecretKey = serverConfig.getAWSSecretKey();

        AmazonEC2 ec2Service;
        if (null != aWSAccessId && !"".equals(aWSAccessId)
                && null != aWSSecretKey && !"".equals(aWSSecretKey)) {
            ec2Service = new AmazonEC2Client(new BasicAWSCredentials(aWSAccessId, aWSSecretKey));
        } else {
            ec2Service = new AmazonEC2Client(new InstanceProfileCredentialsProvider());
        }

        String region = clientConfig.getRegion();
        region = region.trim().toLowerCase();
        ec2Service.setEndpoint("ec2." + region + ".amazonaws.com");
        return ec2Service;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/aws/AwsAsgUtil.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka.aws;

import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import com.amazonaws.services.securitytoken.AWSSecurityTokenService;
import com.amazonaws.services.securitytoken.AWSSecurityTokenServiceClient;
import com.amazonaws.services.securitytoken.model.AssumeRoleResult;
import com.amazonaws.services.securitytoken.model.Credentials;
import com.google.common.base.Strings;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.ListeningExecutorService;
import com.google.common.util.concurrent.MoreExecutors;
import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.eureka.registry.InstanceRegistry;
import com.netflix.appinfo.DataCenterInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.amazonaws.ClientConfiguration;
import com.amazonaws.auth.BasicAWSCredentials;
import com.amazonaws.auth.BasicSessionCredentials;
import com.amazonaws.auth.InstanceProfileCredentialsProvider;
import com.amazonaws.services.autoscaling.AmazonAutoScaling;
import com.amazonaws.services.autoscaling.AmazonAutoScalingClient;
import com.amazonaws.services.autoscaling.model.AutoScalingGroup;
import com.amazonaws.services.autoscaling.model.DescribeAutoScalingGroupsRequest;
import com.amazonaws.services.autoscaling.model.DescribeAutoScalingGroupsResult;
import com.amazonaws.services.autoscaling.model.SuspendedProcess;
import com.amazonaws.services.securitytoken.model.AssumeRoleRequest;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * A utility class for querying and updating information about amazon
 * autoscaling groups using the AWS APIs.
 *
 * @author Karthik Ranganathan
 *
 */
@Singleton
public class AwsAsgUtil {
    private static final Logger logger = LoggerFactory.getLogger(AwsAsgUtil.class);

    private static final String PROP_ADD_TO_LOAD_BALANCER = "AddToLoadBalancer";

    private static final String accountId = getAccountId();

    private Map<String, Credentials> stsCredentials = new HashMap<String, Credentials>();

    private final ExecutorService cacheReloadExecutor = new ThreadPoolExecutor(
            1, 10, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(),
            new ThreadFactory() {
                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, "Eureka-AWS-isASGEnabled");
                    thread.setDaemon(true);
                    return thread;
                }
    });

    private ListeningExecutorService listeningCacheReloadExecutor = MoreExecutors.listeningDecorator(cacheReloadExecutor);

    // Cache for the AWS ASG information
    private final Timer timer = new Timer("Eureka-ASGCacheRefresh", true);
    private final com.netflix.servo.monitor.Timer loadASGInfoTimer = Monitors.newTimer("Eureka-loadASGInfo");

    private final EurekaServerConfig serverConfig;
    private final EurekaClientConfig clientConfig;
    private final InstanceRegistry registry;
    private final LoadingCache<CacheKey, Boolean> asgCache;
    private final AmazonAutoScaling awsClient;

    @Inject
    public AwsAsgUtil(EurekaServerConfig serverConfig,
                      EurekaClientConfig clientConfig,
                      InstanceRegistry registry) {
        this.serverConfig = serverConfig;
        this.clientConfig = clientConfig;
        this.registry = registry;
        this.asgCache = CacheBuilder
                .newBuilder().initialCapacity(500)
                .expireAfterAccess(serverConfig.getASGCacheExpiryTimeoutMs(), TimeUnit.MILLISECONDS)
                .build(new CacheLoader<CacheKey, Boolean>() {
                    @Override
                    public Boolean load(CacheKey key) throws Exception {
                        return isASGEnabledinAWS(key.asgAccountId, key.asgName);
                    }
                    @Override
                    public ListenableFuture<Boolean> reload(final CacheKey key, Boolean oldValue) throws Exception {
                        return listeningCacheReloadExecutor.submit(new Callable<Boolean>() {
                            @Override
                            public Boolean call() throws Exception {
                                return load(key);
                            }
                        });
                    }
                });

        this.awsClient = getAmazonAutoScalingClient();
        this.awsClient.setEndpoint("autoscaling." + clientConfig.getRegion() + ".amazonaws.com");
        this.timer.schedule(getASGUpdateTask(),
                serverConfig.getASGUpdateIntervalMs(),
                serverConfig.getASGUpdateIntervalMs());

        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn("Cannot register the JMX monitor :", e);
        }
    }

    /**
     * Return the status of the ASG whether is enabled or disabled for service.
     * The value is picked up from the cache except the very first time.
     *
     * @param instanceInfo the instanceInfo for the lookup
     * @return true if enabled, false otherwise
     */
    public boolean isASGEnabled(InstanceInfo instanceInfo) {
        CacheKey cacheKey = new CacheKey(getAccountId(instanceInfo, accountId), instanceInfo.getASGName());
        Boolean result = asgCache.getIfPresent(cacheKey);
        if (result != null) {
            return result;
        } else {
            logger.info("Cache value for asg {} does not exist yet, async refreshing.", cacheKey.asgName);
            // Only do an async refresh if it does not yet exist. Do this to refrain from calling aws api too much
            asgCache.refresh(cacheKey);
            return true;
        }
    }

    /**
     * Sets the status of the ASG.
     *
     * @param asgName The name of the ASG
     * @param enabled true to enable, false to disable
     */
    public void setStatus(String asgName, boolean enabled) {
        String asgAccountId = getASGAccount(asgName);
        asgCache.put(new CacheKey(asgAccountId, asgName), enabled);
    }

    /**
     * Check if the ASG is disabled. The amazon flag "AddToLoadBalancer" is
     * queried to figure out if it is or not.
     *
     * @param asgName
     *            - The name of the ASG for which the status needs to be queried
     * @return - true if the ASG is disabled, false otherwise
     */
    private boolean isAddToLoadBalancerSuspended(String asgAccountId, String asgName) {
        AutoScalingGroup asg;
        if(asgAccountId == null || asgAccountId.equals(accountId)) {
            asg = retrieveAutoScalingGroup(asgName);
        } else {
            asg = retrieveAutoScalingGroupCrossAccount(asgAccountId, asgName);
        }
        if (asg == null) {
            logger.warn("The ASG information for {} could not be found. So returning false.", asgName);
            return false;
        }
        return isAddToLoadBalancerSuspended(asg);
    }

    /**
     * Checks if the load balancer addition is disabled or not.
     *
     * @param asg
     *            - The ASG object for which the status needs to be checked
     * @return - true, if the load balancer addition is suspended, false
     *         otherwise.
     */
    private boolean isAddToLoadBalancerSuspended(AutoScalingGroup asg) {
        List<SuspendedProcess> suspendedProcesses = asg.getSuspendedProcesses();
        for (SuspendedProcess process : suspendedProcesses) {
            if (PROP_ADD_TO_LOAD_BALANCER.equals(process.getProcessName())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Queries AWS to get the autoscaling information given the asgName.
     *
     * @param asgName
     *            - The name of the ASG.
     * @return - The auto scaling group information.
     */
    private AutoScalingGroup retrieveAutoScalingGroup(String asgName) {
        if (Strings.isNullOrEmpty(asgName)) {
            logger.warn("null asgName specified, not attempting to retrieve AutoScalingGroup from AWS");
            return null;
        }
        // You can pass one name or a list of names in the request
        DescribeAutoScalingGroupsRequest request = new DescribeAutoScalingGroupsRequest()
                .withAutoScalingGroupNames(asgName);
        DescribeAutoScalingGroupsResult result = awsClient
                .describeAutoScalingGroups(request);
        List<AutoScalingGroup> asgs = result.getAutoScalingGroups();
        if (asgs.isEmpty()) {
            return null;
        } else {
            return asgs.get(0);
        }
    }

    private Credentials initializeStsSession(String asgAccount) {
        AWSSecurityTokenService sts = new AWSSecurityTokenServiceClient(new InstanceProfileCredentialsProvider());
        String region = clientConfig.getRegion();
        if (!region.equals("us-east-1")) {
            sts.setEndpoint("sts." + region + ".amazonaws.com");
        }

        String roleName = serverConfig.getListAutoScalingGroupsRoleName();
        String roleArn = "arn:aws:iam::" + asgAccount + ":role/" + roleName;

        AssumeRoleResult assumeRoleResult = sts.assumeRole(new AssumeRoleRequest()
                        .withRoleArn(roleArn)
                        .withRoleSessionName("sts-session-" + asgAccount)
        );

        return assumeRoleResult.getCredentials();
    }

    private AutoScalingGroup retrieveAutoScalingGroupCrossAccount(String asgAccount, String asgName) {
        logger.debug("Getting cross account ASG for asgName: " + asgName + ", asgAccount: " + asgAccount);

        Credentials credentials = stsCredentials.get(asgAccount);

        if (credentials == null || credentials.getExpiration().getTime() < System.currentTimeMillis() + 1000) {
            stsCredentials.put(asgAccount, initializeStsSession(asgAccount));
            credentials = stsCredentials.get(asgAccount);
        }

        ClientConfiguration clientConfiguration = new ClientConfiguration()
                .withConnectionTimeout(serverConfig.getASGQueryTimeoutMs());

        AmazonAutoScaling autoScalingClient = new AmazonAutoScalingClient(
                new BasicSessionCredentials(
                        credentials.getAccessKeyId(),
                        credentials.getSecretAccessKey(),
                        credentials.getSessionToken()
                ),
                clientConfiguration
        );

        String region = clientConfig.getRegion();
        if (!region.equals("us-east-1")) {
            autoScalingClient.setEndpoint("autoscaling." + region + ".amazonaws.com");
        }

        DescribeAutoScalingGroupsRequest request = new DescribeAutoScalingGroupsRequest()
                .withAutoScalingGroupNames(asgName);
        DescribeAutoScalingGroupsResult result = autoScalingClient.describeAutoScalingGroups(request);
        List<AutoScalingGroup> asgs = result.getAutoScalingGroups();
        if (asgs.isEmpty()) {
            return null;
        } else {
            return asgs.get(0);
        }
    }

    /**
     * Queries AWS to see if the load balancer flag is suspended.
     *
     * @param asgAccountid the accountId this asg resides in, if applicable (null will use the default accountId)
     * @param asgName the name of the asg
     * @return true, if the load balancer flag is not suspended, false otherwise.
     */
    private Boolean isASGEnabledinAWS(String asgAccountid, String asgName) {
        try {
            Stopwatch t = this.loadASGInfoTimer.start();
            boolean returnValue = !isAddToLoadBalancerSuspended(asgAccountid, asgName);
            t.stop();
            return returnValue;
        } catch (Throwable e) {
            logger.error("Could not get ASG information from AWS: ", e);
        }
        return Boolean.TRUE;
    }

    /**
     * Gets the number of elements in the ASG cache.
     *
     * @return the long value representing the number of elements in the ASG
     *         cache.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfElementsinASGCache",
            description = "Number of elements in the ASG Cache", type = DataSourceType.GAUGE)
    public long getNumberofElementsinASGCache() {
        return asgCache.size();
    }

    /**
     * Gets the number of ASG queries done in the period.
     *
     * @return the long value representing the number of ASG queries done in the
     *         period.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfASGQueries",
            description = "Number of queries made to AWS to retrieve ASG information", type = DataSourceType.COUNTER)
    public long getNumberofASGQueries() {
        return asgCache.stats().loadCount();
    }

    /**
     * Gets the number of ASG queries that failed because of some reason.
     *
     * @return the long value representing the number of ASG queries that failed
     *         because of some reason.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfASGQueryFailures",
            description = "Number of queries made to AWS to retrieve ASG information and that failed",
            type = DataSourceType.COUNTER)
    public long getNumberofASGQueryFailures() {
        return asgCache.stats().loadExceptionCount();
    }

    /**
     * Gets the task that updates the ASG information periodically.
     *
     * @return TimerTask that updates the ASG information periodically.
     */
    private TimerTask getASGUpdateTask() {
        return new TimerTask() {

            @Override
            public void run() {
                try {
                    // First get the active ASG names
                    Set<CacheKey> cacheKeys = getCacheKeys();
                    logger.debug("Trying to  refresh the keys for {}", Arrays.toString(cacheKeys.toArray()));
                    for (CacheKey key : cacheKeys) {
                        try {
                            asgCache.refresh(key);
                        } catch (Throwable e) {
                            logger.error("Error updating the ASG cache for {}", key, e);
                        }

                    }

                } catch (Throwable e) {
                    logger.error("Error updating the ASG cache", e);
                }

            }

        };
    }

    /**
     * Get the cacheKeys of all the ASG to which query AWS for.
     *
     * <p>
     * The names are obtained from the {@link com.netflix.eureka.registry.InstanceRegistry} which is then
     * used for querying the AWS.
     * </p>
     *
     * @return the set of ASG cacheKeys (asgName + accountId).
     */
    private Set<CacheKey> getCacheKeys() {
        Set<CacheKey> cacheKeys = new HashSet<CacheKey>();
        Applications apps = registry.getApplicationsFromLocalRegionOnly();
        for (Application app : apps.getRegisteredApplications()) {
            for (InstanceInfo instanceInfo : app.getInstances()) {
                String localAccountId = getAccountId(instanceInfo, accountId);
                String asgName = instanceInfo.getASGName();
                if (asgName != null) {
                    CacheKey key = new CacheKey(localAccountId, asgName);
                    cacheKeys.add(key);
                }
            }
        }

        return cacheKeys;
    }

    /**
     * Get the AWS account id where an ASG is created.
     * Warning: This is expensive as it loops through all instances currently registered.
     *
     * @param asgName The name of the ASG
     * @return the account id
     */
    private String getASGAccount(String asgName) {
        Applications apps = registry.getApplicationsFromLocalRegionOnly();

        for (Application app : apps.getRegisteredApplications()) {
            for (InstanceInfo instanceInfo : app.getInstances()) {
                String thisAsgName = instanceInfo.getASGName();
                if (thisAsgName != null && thisAsgName.equals(asgName)) {
                    String localAccountId = getAccountId(instanceInfo, null);
                    if (localAccountId != null) {
                        return localAccountId;
                    }
                }
            }
        }

        logger.info("Couldn't get the ASG account for {}, using the default accountId instead", asgName);
        return accountId;
    }

    private String getAccountId(InstanceInfo instanceInfo, String fallbackId) {
        String localAccountId = null;

        DataCenterInfo dataCenterInfo = instanceInfo.getDataCenterInfo();
        if (dataCenterInfo instanceof AmazonInfo) {
            localAccountId = ((AmazonInfo) dataCenterInfo).get(MetaDataKey.accountId);
        }

        return localAccountId == null ? fallbackId : localAccountId;
    }

    private AmazonAutoScaling getAmazonAutoScalingClient() {
        String aWSAccessId = serverConfig.getAWSAccessId();
        String aWSSecretKey = serverConfig.getAWSSecretKey();
        ClientConfiguration clientConfiguration = new ClientConfiguration()
                .withConnectionTimeout(serverConfig.getASGQueryTimeoutMs());

        if (null != aWSAccessId && !"".equals(aWSAccessId) && null != aWSSecretKey && !"".equals(aWSSecretKey)) {
            return new AmazonAutoScalingClient(
                    new BasicAWSCredentials(aWSAccessId, aWSSecretKey),
                    clientConfiguration);
        } else {
            return new AmazonAutoScalingClient(
                    new InstanceProfileCredentialsProvider(),
                    clientConfiguration);
        }
    }

    private static String getAccountId() {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();
        return ((AmazonInfo) myInfo.getDataCenterInfo()).get(MetaDataKey.accountId);
    }

    private static class CacheKey {
        final String asgAccountId;
        final String asgName;

        CacheKey(String asgAccountId, String asgName) {
            this.asgAccountId = asgAccountId;
            this.asgName = asgName;
        }

        @Override
        public String toString() {
            return "CacheKey{" +
                    "asgName='" + asgName + '\'' +
                    ", asgAccountId='" + asgAccountId + '\'' +
                    '}';
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof CacheKey)) return false;

            CacheKey cacheKey = (CacheKey) o;

            if (asgAccountId != null ? !asgAccountId.equals(cacheKey.asgAccountId) : cacheKey.asgAccountId != null)
                return false;
            if (asgName != null ? !asgName.equals(cacheKey.asgName) : cacheKey.asgName != null) return false;

            return true;
        }

        @Override
        public int hashCode() {
            int result = asgName != null ? asgName.hashCode() : 0;
            result = 31 * result + (asgAccountId != null ? asgAccountId.hashCode() : 0);
            return result;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;<<<<<<< MINE
=======
package com.netflix.eureka.util;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.shared.Application;
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.cluster.PeerEurekaNode;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.net.URI;

/**
 * @author David Liu
 */
public class StatusUtil {
    private static final Logger logger = LoggerFactory.getLogger(StatusUtil.class);

    private final String myAppName;
    private final PeerAwareInstanceRegistry registry;
    private final PeerEurekaNodes peerEurekaNodes;

    public StatusUtil(EurekaServerContext server) {
        this.myAppName = server.getApplicationInfoManager().getInfo().getAppName();
        this.registry = server.getRegistry();
        this.peerEurekaNodes = server.getPeerEurekaNodes();
    }

    public StatusInfo getStatusInfo() {
        StatusInfo.Builder builder = StatusInfo.Builder.newBuilder();
        // Add application level status
        StringBuilder upReplicas = new StringBuilder();
        StringBuilder downReplicas = new StringBuilder();

        StringBuilder replicaHostNames = new StringBuilder();

        for (PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
            if (replicaHostNames.length() > 0) {
                replicaHostNames.append(", ");
            }
            replicaHostNames.append(node.getServiceUrl());
            if (isReplicaAvailable(myAppName, node.getServiceUrl())) {
                upReplicas.append(node.getServiceUrl()).append(',');
            } else {
                downReplicas.append(node.getServiceUrl()).append(',');
            }
        }

        builder.add("registered-replicas", replicaHostNames.toString());
        builder.add("available-replicas", upReplicas.toString());
        builder.add("unavailable-replicas", downReplicas.toString());

        return builder.build();
    }

    private boolean isReplicaAvailable(String myAppName, String url) {

        try {
            String givenHostName = new URI(url).getHost();
            Application app = registry.getApplication(myAppName, false);
            for (InstanceInfo info : app.getInstances()) {
                if (info.getHostName().equals(givenHostName)) {
                    return true;
                }
            }
            givenHostName = new URI(url).getHost();
        } catch (Throwable e) {
            logger.error("Could not determine if the replica is available ", e);
        }
        return false;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;<<<<<<< MINE
=======
import javax.inject.Singleton;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;<<<<<<< MINE
=======
@Singleton
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;<<<<<<< MINE
        if (status != InstanceStatus.UP
                && response instanceof HttpServletResponse) {
=======
        if (status != InstanceStatus.UP && response instanceof HttpServletResponse) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;<<<<<<< MINE
import com.netflix.discovery.converters.wrappers.CodecWrappers;
import com.netflix.discovery.converters.wrappers.CodecWrappers.JacksonJsonMini;
import com.netflix.discovery.converters.wrappers.CodecWrappers.JacksonXmlMini;
import com.netflix.discovery.converters.wrappers.CodecWrappers.LegacyJacksonJson;
import com.netflix.discovery.converters.wrappers.CodecWrappers.XStreamXml;
=======
import com.netflix.discovery.converters.wrappers.CodecWrapper;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;<<<<<<< MINE
import com.netflix.eureka.EurekaServerConfig;
=======
import com.netflix.eureka.registry.Key;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;<<<<<<< MINE
public class ServerCodecs {
=======
public interface ServerCodecs {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;<<<<<<< MINE
    protected final EncoderWrapper fullJsonEncoder;
    protected final EncoderWrapper compactJsonEncoder;
=======
    CodecWrapper getFullJsonCodec();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;<<<<<<< MINE
    protected final EncoderWrapper fullXmlEncoder;
    protected final EncoderWrapper compactXmlEncoder;
=======
    CodecWrapper getCompactJsonCodec();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;<<<<<<< MINE
    protected ServerCodecs(EncoderWrapper fullJsonEncoder,
                         EncoderWrapper compactJsonEncoder,
                         EncoderWrapper fullXmlEncoder,
                         EncoderWrapper compactXmlEncoder) {
        this.fullJsonEncoder = fullJsonEncoder;
        this.compactJsonEncoder = compactJsonEncoder;
        this.fullXmlEncoder = fullXmlEncoder;
        this.compactXmlEncoder = compactXmlEncoder;
    }

    public EncoderWrapper getEncoder(ResponseCache.KeyType keyType, boolean compact) {
        switch (keyType) {
            case JSON:
                return compact ? compactJsonEncoder : fullJsonEncoder;
            case XML:
            default:
                return compact ? compactXmlEncoder : fullXmlEncoder;
        }
    }

    public EncoderWrapper getEncoder(ResponseCache.KeyType keyType, EurekaAccept eurekaAccept) {
        switch (eurekaAccept) {
            case compact:
                return getEncoder(keyType, true);
            case full:
            default:
                return getEncoder(keyType, false);
        }
    }

    public static class Builder {
        private EncoderWrapper fullJsonEncoder;
        private EncoderWrapper compactJsonEncoder;

        private EncoderWrapper fullXmlEncoder;
        private EncoderWrapper compactXmlEncoder;

        public Builder withFullJsonEncoder(EncoderWrapper fullJsonEncoder) {
            this.fullJsonEncoder = fullJsonEncoder;
            return this;
        }

        public Builder withCompactJsonEncoder(EncoderWrapper compactJsonEncoder) {
            this.compactJsonEncoder = compactJsonEncoder;
            return this;
        }

        public Builder withFullXmlnEncoder(EncoderWrapper fullXmlEncoder) {
            this.fullXmlEncoder = fullXmlEncoder;
            return this;
        }

        public Builder withCompactXmlEncoder(EncoderWrapper compactXmlEncoder) {
            this.compactXmlEncoder = compactXmlEncoder;
            return this;
        }

        public Builder withEurekaServerConfig(EurekaServerConfig config) {
            fullJsonEncoder = CodecWrappers.getEncoder(config.getJsonCodecName());
            fullXmlEncoder = CodecWrappers.getEncoder(config.getXmlCodecName());
            return this;
        }

        public ServerCodecs build() {
            if (fullJsonEncoder == null) {
                fullJsonEncoder = CodecWrappers.getEncoder(LegacyJacksonJson.class);
            }

            if (compactJsonEncoder == null) {
                compactJsonEncoder = CodecWrappers.getEncoder(JacksonJsonMini.class);
            }

            if (fullXmlEncoder == null) {
                fullXmlEncoder = CodecWrappers.getEncoder(XStreamXml.class);
            }

            if (compactXmlEncoder == null) {
                compactXmlEncoder = CodecWrappers.getEncoder(JacksonXmlMini.class);
            }

            return new ServerCodecs(
                    fullJsonEncoder,
                    compactJsonEncoder,
                    fullXmlEncoder,
                    compactXmlEncoder
            );
        }
    }
=======
    CodecWrapper getFullXmlCodec();

    CodecWrapper getCompactXmlCodecr();

    EncoderWrapper getEncoder(Key.KeyType keyType, boolean compact);

    EncoderWrapper getEncoder(Key.KeyType keyType, EurekaAccept eurekaAccept);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
import com.netflix.eureka.CurrentRequestVersion;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerContextHolder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.registry.ResponseCache;
import com.netflix.eureka.registry.Key;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
=======
    private final PeerAwareInstanceRegistry registry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
    /* For testing */ AbstractVIPResource(ResponseCache responseCache) {
        this.responseCache = responseCache;
=======
    AbstractVIPResource(EurekaServerContext server) {
        this.registry = server.getRegistry();
        this.responseCache = registry.getResponseCache();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
    protected AbstractVIPResource() {
        this(ResponseCache.getInstance());
=======
    AbstractVIPResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
                                      EurekaAccept eurekaAccept, ResponseCache.Key.EntityType entityType) {
        if (!PeerAwareInstanceRegistryImpl.getInstance().shouldAllowAccess(false)) {
=======
                                      EurekaAccept eurekaAccept, Key.EntityType entityType) {
        if (!registry.shouldAllowAccess(false)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
        ResponseCache.KeyType keyType = ResponseCache.KeyType.JSON;
=======
        Key.KeyType keyType = Key.KeyType.JSON;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
            keyType = ResponseCache.KeyType.XML;
=======
            keyType = Key.KeyType.XML;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;<<<<<<< MINE
        ResponseCache.Key cacheKey = new ResponseCache.Key(
=======
        Key cacheKey = new Key(
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
import java.net.URI;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.shared.Application;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
import com.netflix.eureka.cluster.PeerEurekaNode;
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerContextHolder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
import com.netflix.eureka.util.StatusInfo.Builder;
=======
import com.netflix.eureka.util.StatusUtil;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    private static final Logger logger = LoggerFactory
            .getLogger(StatusResource.class);
=======
    private static final Logger logger = LoggerFactory.getLogger(StatusResource.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    private final PeerAwareInstanceRegistryImpl registry = PeerAwareInstanceRegistryImpl
            .getInstance();
=======
    private final StatusUtil statusUtil;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    @GET
    public StatusInfo getStatusInfo() {
        Builder builder = Builder.newBuilder();
        // Add application level status
        StringBuilder upReplicas = new StringBuilder();
        StringBuilder downReplicas = new StringBuilder();

        StringBuilder replicaHostNames = new StringBuilder();
        String myAppName = ApplicationInfoManager.getInstance().getInfo()
                .getAppName();

        for (PeerEurekaNode node : registry.getReplicaNodes()) {
            if (replicaHostNames.length() > 0) {
                replicaHostNames.append(", ");
            }
            replicaHostNames.append(node.getServiceUrl());
            if (isReplicaAvailable(myAppName, node.getServiceUrl())) {
                upReplicas.append(node.getServiceUrl()).append(',');
            } else {
                downReplicas.append(node.getServiceUrl()).append(',');
            }
        }

        builder.add("registered-replicas", replicaHostNames.toString());
        builder.add("available-replicas", upReplicas.toString());
        builder.add("unavailable-replicas", downReplicas.toString());
=======
    @Inject
    StatusResource(EurekaServerContext server) {
        this.statusUtil = new StatusUtil(server);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
        return builder.build();
=======
    public StatusResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    private boolean isReplicaAvailable(String myAppName, String url) {

        try {
            String givenHostName = new URI(url).getHost();
            Application app = PeerAwareInstanceRegistryImpl.getInstance()
                    .getApplication(myAppName, false);
            for (InstanceInfo info : app.getInstances()) {
                if (info.getHostName().equals(givenHostName)) {
                    return true;
                }
            }
            givenHostName = new URI(url).getHost();
        } catch (Throwable e) {
            logger.error("Could not determine if the replica is available ", e);
        }
        return false;
=======
    @GET
    public StatusInfo getStatusInfo() {
        return statusUtil.getStatusInfo();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
import com.netflix.eureka.EurekaServerConfigurationManager;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
=======
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
    private final PeerAwareInstanceRegistryImpl registry;
=======
    private final PeerAwareInstanceRegistry registry;
    private final EurekaServerConfig serverConfig;
    private final String id;
    private final ApplicationResource app;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
    String id;
    ApplicationResource app;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
    /* For testing */ InstanceResource(ApplicationResource app, String id, PeerAwareInstanceRegistryImpl registry) {
=======
    InstanceResource(ApplicationResource app, String id, EurekaServerConfig serverConfig, PeerAwareInstanceRegistry registry) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
=======
        this.serverConfig = serverConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
    public InstanceResource(ApplicationResource app, String id) {
        this(app, id, PeerAwareInstanceRegistryImpl.getInstance());
    }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;<<<<<<< MINE
        if (lastDirtyTimestamp != null
                && EurekaServerConfigurationManager.getInstance().getConfiguration().shouldSyncWhenTimestampDiffers()) {
=======
        if (lastDirtyTimestamp != null && serverConfig.shouldSyncWhenTimestampDiffers()) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerContextHolder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
import com.netflix.eureka.util.AwsAsgUtil;
=======
import com.netflix.eureka.aws.AwsAsgUtil;
import com.netflix.eureka.registry.AwsInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE

    private static final Logger logger = LoggerFactory
            .getLogger(ASGResource.class);
=======
    private static final Logger logger = LoggerFactory.getLogger(ASGResource.class);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
            throw new RuntimeException(
                    "Cannot find ASG enum for the given string " + s);
=======
            throw new RuntimeException("Cannot find ASG enum for the given string " + s);
        }
    }

    protected final PeerAwareInstanceRegistry registry;
    protected final AwsAsgUtil awsAsgUtil;

    @Inject
    ASGResource(EurekaServerContext eurekaServer) {
        this.registry = eurekaServer.getRegistry();
        if (registry instanceof AwsInstanceRegistry) {
            this.awsAsgUtil = ((AwsInstanceRegistry) registry).getAwsAsgUtil();
        } else {
            this.awsAsgUtil = null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
=======
    public ASGResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
     * @param asgName
     *            the name of the ASG for which the status needs to be changed.
     * @param newStatus
     *            the new status {@link ASGStatus} of the ASG.
     * @param isReplication
     *            a header parameter containing information whether this is
     *            replicated from other nodes.
=======
     * @param asgName the name of the ASG for which the status needs to be changed.
     * @param newStatus the new status {@link ASGStatus} of the ASG.
     * @param isReplication a header parameter containing information whether this is replicated from other nodes.
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
=======
        if (awsAsgUtil == null) {
            return Response.status(400).build();
        }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
            logger.info("Trying to update ASG Status for ASG {} to {}",
                    asgName, newStatus);
=======
            logger.info("Trying to update ASG Status for ASG {} to {}", asgName, newStatus);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
            AwsAsgUtil.getInstance().setStatus(asgName,
                    (ASGStatus.DISABLED.equals(asgStatus) ? false : true));
            PeerAwareInstanceRegistryImpl.getInstance().statusUpdate(asgName,
                    asgStatus, Boolean.valueOf(isReplication));
            logger.debug("Updated ASG Status for ASG {} to {}", asgName,
                    asgStatus);
=======
            awsAsgUtil.setStatus(asgName, (!ASGStatus.DISABLED.equals(asgStatus)));
            registry.statusUpdate(asgName, asgStatus, Boolean.valueOf(isReplication));
            logger.debug("Updated ASG Status for ASG {} to {}", asgName, asgStatus);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;<<<<<<< MINE
            logger.error("Cannot update the status" + newStatus
                    + " for the ASG " + asgName, e);
=======
            logger.error("Cannot update the status {} for the ASG {}", newStatus, asgName, e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/CurrentRequestVersion.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka.resources;


import com.netflix.eureka.Version;

/**
 * A thread-scoped value that holds the "current {@link com.netflix.eureka.Version}" for the
 * request.
 *
 * <p>This is not intended as a general mechanism for passing data.
 * Rather it is here to support those cases where someplace deep in
 * a library we need to know about the context of the request that
 * initially triggered the current request.</p>
 *
 * @author Karthik Ranganathan, Greg Kim
 */
public final class CurrentRequestVersion {

    private static final ThreadLocal<Version> CURRENT_REQ_VERSION =
            new ThreadLocal<Version>();

    private CurrentRequestVersion() {
    }

    /**
     * Gets the current {@link Version}
     * Will return null if no current version has been set.
     */
    public static Version get() {
        return CURRENT_REQ_VERSION.get();
    }

    /**
     * Sets the current {@link Version}.
     */
    public static void set(Version version) {
        CURRENT_REQ_VERSION.set(version);
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE
import com.netflix.eureka.CurrentRequestVersion;
import com.netflix.eureka.AbstractInstanceRegistry;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerContextHolder;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;<<<<<<< MINE
    private final AbstractInstanceRegistry registry = PeerAwareInstanceRegistryImpl
            .getInstance();
=======
    private final PeerAwareInstanceRegistry registry;

    @Inject
    InstancesResource(EurekaServerContext server) {
        this.registry = server.getRegistry();
    }

    public InstancesResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/DefaultServerCodecs.java;<<<<<<< MINE
=======
package com.netflix.eureka.resources;

import com.netflix.appinfo.EurekaAccept;
import com.netflix.discovery.converters.wrappers.CodecWrapper;
import com.netflix.discovery.converters.wrappers.CodecWrappers;
import com.netflix.discovery.converters.wrappers.EncoderWrapper;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.Key;

import javax.inject.Inject;
import javax.inject.Singleton;

/**
 * @author David Liu
 */
@Singleton
public class DefaultServerCodecs implements ServerCodecs {

    protected final CodecWrapper fullJsonCodec;
    protected final CodecWrapper compactJsonCodec;

    protected final CodecWrapper fullXmlCodec;
    protected final CodecWrapper compactXmlCodec;

    private static CodecWrapper getFullJson(EurekaServerConfig serverConfig) {
        CodecWrapper codec = CodecWrappers.getCodec(serverConfig.getJsonCodecName());
        return codec == null ? CodecWrappers.getCodec(CodecWrappers.LegacyJacksonJson.class) : codec;
    }

    private static CodecWrapper getFullXml(EurekaServerConfig serverConfig) {
        CodecWrapper codec = CodecWrappers.getCodec(serverConfig.getXmlCodecName());
        return codec == null ? CodecWrappers.getCodec(CodecWrappers.XStreamXml.class) : codec;
    }

    @Inject
    public DefaultServerCodecs(EurekaServerConfig serverConfig) {
        this (
                getFullJson(serverConfig),
                CodecWrappers.getCodec(CodecWrappers.JacksonJsonMini.class),
                getFullXml(serverConfig),
                CodecWrappers.getCodec(CodecWrappers.JacksonXmlMini.class)
        );
    }

    protected DefaultServerCodecs(CodecWrapper fullJsonCodec,
                                  CodecWrapper compactJsonCodec,
                                  CodecWrapper fullXmlCodec,
                                  CodecWrapper compactXmlCodec) {
        this.fullJsonCodec = fullJsonCodec;
        this.compactJsonCodec = compactJsonCodec;
        this.fullXmlCodec = fullXmlCodec;
        this.compactXmlCodec = compactXmlCodec;
    }

    @Override
    public CodecWrapper getFullJsonCodec() {
        return fullJsonCodec;
    }

    @Override
    public CodecWrapper getCompactJsonCodec() {
        return compactJsonCodec;
    }

    @Override
    public CodecWrapper getFullXmlCodec() {
        return fullXmlCodec;
    }

    @Override
    public CodecWrapper getCompactXmlCodecr() {
        return compactXmlCodec;
    }

    @Override
    public EncoderWrapper getEncoder(Key.KeyType keyType, boolean compact) {
        switch (keyType) {
            case JSON:
                return compact ? compactJsonCodec : fullJsonCodec;
            case XML:
            default:
                return compact ? compactXmlCodec : fullXmlCodec;
        }
    }

    @Override
    public EncoderWrapper getEncoder(Key.KeyType keyType, EurekaAccept eurekaAccept) {
        switch (eurekaAccept) {
            case compact:
                return getEncoder(keyType, true);
            case full:
            default:
                return getEncoder(keyType, false);
        }
    }

    public static Builder builder() {
        return new Builder();
    }

    public static class Builder {
        protected CodecWrapper fullJsonCodec;
        protected CodecWrapper compactJsonCodec;

        protected CodecWrapper fullXmlCodec;
        protected CodecWrapper compactXmlCodec;

        protected Builder() {}

        public Builder withFullJsonCodec(CodecWrapper fullJsonCodec) {
            this.fullJsonCodec = fullJsonCodec;
            return this;
        }

        public Builder withCompactJsonCodec(CodecWrapper compactJsonCodec) {
            this.compactJsonCodec = compactJsonCodec;
            return this;
        }

        public Builder withFullXmlCodec(CodecWrapper fullXmlCodec) {
            this.fullXmlCodec = fullXmlCodec;
            return this;
        }

        public Builder withCompactXmlCodec(CodecWrapper compactXmlEncoder) {
            this.compactXmlCodec = compactXmlEncoder;
            return this;
        }

        public Builder withEurekaServerConfig(EurekaServerConfig config) {
            fullJsonCodec = CodecWrappers.getCodec(config.getJsonCodecName());
            fullXmlCodec = CodecWrappers.getCodec(config.getXmlCodecName());
            return this;
        }

        public ServerCodecs build() {
            if (fullJsonCodec == null) {
                fullJsonCodec = CodecWrappers.getCodec(CodecWrappers.LegacyJacksonJson.class);
            }

            if (compactJsonCodec == null) {
                compactJsonCodec = CodecWrappers.getCodec(CodecWrappers.JacksonJsonMini.class);
            }

            if (fullXmlCodec == null) {
                fullXmlCodec = CodecWrappers.getCodec(CodecWrappers.XStreamXml.class);
            }

            if (compactXmlCodec == null) {
                compactXmlCodec = CodecWrappers.getCodec(CodecWrappers.JacksonXmlMini.class);
            }

            return new DefaultServerCodecs(
                    fullJsonCodec,
                    compactJsonCodec,
                    fullXmlCodec,
                    compactXmlCodec
            );
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
import com.netflix.eureka.CurrentRequestVersion;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
=======
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
import com.netflix.eureka.resources.ResponseCache.Key;
import com.netflix.eureka.resources.ResponseCache.KeyType;
=======
import com.netflix.eureka.registry.ResponseCache;
import com.netflix.eureka.registry.Key.KeyType;
import com.netflix.eureka.registry.Key;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
    private final PeerAwareInstanceRegistryImpl registry;
=======
    private final EurekaServerConfig serverConfig;
    private final PeerAwareInstanceRegistry registry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
    /* For testing */ ApplicationResource(String appName, PeerAwareInstanceRegistryImpl registry, ResponseCache responseCache) {
=======
    ApplicationResource(String appName,
                        EurekaServerConfig serverConfig,
                        PeerAwareInstanceRegistry registry) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
=======
        this.serverConfig = serverConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
        this.responseCache = responseCache;
    }

    public ApplicationResource(String appName) {
        this(appName, PeerAwareInstanceRegistryImpl.getInstance(), ResponseCache.getInstance());
=======
        this.responseCache = registry.getResponseCache();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
        KeyType keyType = KeyType.JSON;
=======
        KeyType keyType = Key.KeyType.JSON;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
            keyType = KeyType.XML;
=======
            keyType = Key.KeyType.XML;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;<<<<<<< MINE
        return new InstanceResource(this, id);
=======
        return new InstanceResource(this, id, serverConfig, registry);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerInfoResource.java;<<<<<<< MINE
import com.netflix.eureka.AbstractInstanceRegistry;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerContextHolder;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerInfoResource.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerInfoResource.java;<<<<<<< MINE
    private final AbstractInstanceRegistry registry = PeerAwareInstanceRegistryImpl.getInstance();
=======
    private final PeerAwareInstanceRegistry registry;

    @Inject
    ServerInfoResource(EurekaServerContext server) {
        this.registry = server.getRegistry();
    }

    public ServerInfoResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;<<<<<<< MINE
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerContextHolder;
import com.netflix.eureka.registry.Key;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;<<<<<<< MINE
=======
    @Inject
    VIPResource(EurekaServerContext server) {
        super(server);
    }

    public VIPResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;<<<<<<< MINE
                EurekaAccept.fromString(eurekaAccept), ResponseCache.Key.EntityType.VIP);
=======
                EurekaAccept.fromString(eurekaAccept), Key.EntityType.VIP);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.EurekaServerContextHolder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
=======
    private final EurekaServerConfig serverConfig;
    private final PeerAwareInstanceRegistry registry;

    @Inject
    PeerReplicationResource(EurekaServerContext server) {
        this.serverConfig = server.getServerConfig();
        this.registry = server.getRegistry();
    }

    public PeerReplicationResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
        return new ApplicationResource(instanceInfo.getAppName());
=======
        return new ApplicationResource(instanceInfo.getAppName(), serverConfig, registry);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;<<<<<<< MINE
        return new InstanceResource(applicationResource, instanceInfo.getId());
=======
        return new InstanceResource(applicationResource, instanceInfo.getId(), serverConfig, registry);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;<<<<<<< MINE
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerContextHolder;
import com.netflix.eureka.registry.Key;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;<<<<<<< MINE
=======
import javax.inject.Inject;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;<<<<<<< MINE
=======
    @Inject
    SecureVIPResource(EurekaServerContext server) {
        super(server);
    }

    public SecureVIPResource() {
        this(EurekaServerContextHolder.getInstance().getServerContext());
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;<<<<<<< MINE
                EurekaAccept.fromString(eurekaAccept), ResponseCache.Key.EntityType.SVIP);
=======
                EurekaAccept.fromString(eurekaAccept), Key.EntityType.SVIP);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
import javax.inject.Singleton;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
@Singleton
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE
=======
    public long getRegistrySyncRetryWaitMs() {
        return configInstance.getIntProperty(
                namespace + "registrySyncRetryWaitMs", 30 * 1000).get();
    }

    @Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/registry/ResponseCacheTest.java;<<<<<<< MINE
=======
package com.netflix.eureka.registry;

import com.netflix.appinfo.EurekaAccept;
import com.netflix.discovery.DefaultEurekaClientConfig;
import com.netflix.eureka.AbstractTester;
import com.netflix.eureka.DefaultEurekaServerConfig;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.Version;
import com.netflix.eureka.resources.DefaultServerCodecs;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;

/**
 * @author Nitesh Kant
 */
public class ResponseCacheTest extends AbstractTester {

    private static final String REMOTE_REGION = "myremote";

    private PeerAwareInstanceRegistry testRegistry;

    @Override
    @Before
    public void setUp() throws Exception {
        super.setUp();
        // create a new registry that is sync'ed up with the default registry in the AbstractTester,
        // but disable transparent fetch to the remote for gets
        EurekaServerConfig serverConfig = spy(new DefaultEurekaServerConfig());
        doReturn(true).when(serverConfig).disableTransparentFallbackToOtherRegion();

        testRegistry = new PeerAwareInstanceRegistryImpl(
                serverConfig,
                new DefaultEurekaClientConfig(),
                new DefaultServerCodecs(serverConfig),
                client
        );
        testRegistry.init(serverContext.getPeerEurekaNodes());
        testRegistry.syncUp();
    }

    @Test
    public void testInvalidate() throws Exception {
        ResponseCacheImpl cache = (ResponseCacheImpl) testRegistry.getResponseCache();
        Key key = new Key(Key.EntityType.Application, REMOTE_REGION_APP_NAME,
                Key.KeyType.JSON, Version.V1, EurekaAccept.full);
        String response = cache.get(key, false);
        Assert.assertNotNull("Cache get returned null.", response);

        testRegistry.cancel(REMOTE_REGION_APP_NAME, REMOTE_REGION_INSTANCE_1_HOSTNAME, true);
        Assert.assertNull("Cache after invalidate did not return null for write view.", cache.get(key, true));
    }

    @Test
    public void testInvalidateWithRemoteRegion() throws Exception {
        ResponseCacheImpl cache = (ResponseCacheImpl) testRegistry.getResponseCache();
        Key key = new Key(
                Key.EntityType.Application,
                REMOTE_REGION_APP_NAME,
                Key.KeyType.JSON, Version.V1, EurekaAccept.full, new String[]{REMOTE_REGION}
        );

        Assert.assertNotNull("Cache get returned null.", cache.get(key, false));

        testRegistry.cancel(REMOTE_REGION_APP_NAME, REMOTE_REGION_INSTANCE_1_HOSTNAME, true);
        Assert.assertNull("Cache after invalidate did not return null.", cache.get(key));
    }

    @Test
    public void testInvalidateWithMultipleRemoteRegions() throws Exception {
        ResponseCacheImpl cache = (ResponseCacheImpl) testRegistry.getResponseCache();
        Key key1 = new Key(
                Key.EntityType.Application,
                REMOTE_REGION_APP_NAME,
                Key.KeyType.JSON, Version.V1, EurekaAccept.full, new String[]{REMOTE_REGION, "myregion2"}
        );
        Key key2 = new Key(
                Key.EntityType.Application,
                REMOTE_REGION_APP_NAME,
                Key.KeyType.JSON, Version.V1, EurekaAccept.full, new String[]{REMOTE_REGION}
        );

        Assert.assertNotNull("Cache get returned null.", cache.get(key1, false));
        Assert.assertNotNull("Cache get returned null.", cache.get(key2, false));

        testRegistry.cancel(REMOTE_REGION_APP_NAME, REMOTE_REGION_INSTANCE_1_HOSTNAME, true);

        Assert.assertNull("Cache after invalidate did not return null.", cache.get(key1, true));
        Assert.assertNull("Cache after invalidate did not return null.", cache.get(key2, true));
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/registry/InstanceRegistryTest.java;<<<<<<< MINE
=======
package com.netflix.eureka.registry;

import java.util.List;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.Pair;
import com.netflix.eureka.AbstractTester;
import org.junit.Assert;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.junit.Assert.assertThat;

/**
 * @author Nitesh Kant
 */
public class InstanceRegistryTest extends AbstractTester {

    @Test
    public void testSoftDepRemoteUp() throws Exception {
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(false));
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(true));
    }

    @Test
    public void testGetAppsFromAllRemoteRegions() throws Exception {
        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from remote registry", REMOTE_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsDeltaFromAllRemoteRegions() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME)); /// local delta
        waitForDeltaToBeRetrieved();
        Applications appDelta = registry.getApplicationDeltasFromMultipleRegions(null);
        List<Application> registeredApplications = appDelta.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 2, registeredApplications.size());
        Application localApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                localApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app in delta.", localApplication);
        Assert.assertEquals("Local registry app instance count in delta not as expected.", 1,
                localApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app in delta", remApplication);
        Assert.assertEquals("Remote registry app instance count  in delta not as expected.", 1,
                remApplication.getInstances().size());
    }

    @Test
    public void testAppsHashCodeAfterRefresh() throws InterruptedException {
        Assert.assertEquals("UP_1_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());

        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        waitForDeltaToBeRetrieved();

        Assert.assertEquals("UP_2_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());
    }

    private void waitForDeltaToBeRetrieved() throws InterruptedException {
        int count = 0;
        System.out.println("Sleeping up to 35 seconds to let the remote registry fetch delta.");
        while (count++ < 35 && !mockRemoteEurekaServer.isSentDelta()) {
            Thread.sleep(1000);
        }
        if (!mockRemoteEurekaServer.isSentDelta()) {
            System.out.println("Waited for 35 seconds but remote server did not send delta");
        }
        // Wait 2 seconds more to be sure the delta was processed
        Thread.sleep(2000);
    }

    @Test
    public void testGetAppsFromLocalRegionOnly() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromLocalRegionOnly();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from local region do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from local registry", LOCAL_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsFromBothRegions() throws Exception {
        registerInstanceLocally(createRemoteInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from both regions do not match", 2, registeredApplications.size());
        Application locaApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                locaApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app", locaApplication);
        Assert.assertEquals("Local registry app instance count not as expected.", 1,
                locaApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app", remApplication);
        Assert.assertEquals("Remote registry app instance count not as expected.", 2,
                remApplication.getInstances().size());

    }

    @Test
    public void testStatusOverrideSetAndRemoval() throws Exception {
        // Regular registration first
        InstanceInfo myInstance = createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME);
        registerInstanceLocally(myInstance);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);

        // Override status
        boolean statusResult = registry.statusUpdate(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.OUT_OF_SERVICE, "0", false);
        assertThat("Couldn't override instance status", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Now remove override
        statusResult = registry.deleteStatusOverride(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.DOWN, "0", false);
        assertThat("Couldn't remove status override", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.DOWN);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);
    }

    private void verifyLocalInstanceStatus(String id, InstanceStatus status) {
        InstanceInfo instanceInfo = registry.getApplication(LOCAL_REGION_APP_NAME).getByInstanceId(id);
        assertThat("InstanceInfo with id " + id + " not found", instanceInfo, is(notNullValue()));
        assertThat("Invalid InstanceInfo state", instanceInfo.getStatus(), is(equalTo(status)));
    }

    private void registerInstanceLocally(InstanceInfo remoteInstance) {
        registry.register(remoteInstance, 10000000, false);
        registeredApps.add(new Pair<String, String>(LOCAL_REGION_APP_NAME, LOCAL_REGION_APP_NAME));
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;<<<<<<< MINE
=======
import static org.mockito.Mockito.mock;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;<<<<<<< MINE
    private final RateLimitingFilter filter = new RateLimitingFilter();
=======
    private RateLimitingFilter filter;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;<<<<<<< MINE
        ApplicationInfoManager.getInstance().initComponent(new MyDataCenterInstanceConfig());
=======
        ApplicationInfoManager applicationInfoManager = new ApplicationInfoManager(new MyDataCenterInstanceConfig());
        DefaultEurekaServerConfig config = new DefaultEurekaServerConfig();
        EurekaServerContext mockServer = mock(EurekaServerContext.class);
        when(mockServer.getServerConfig()).thenReturn(config);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;<<<<<<< MINE
        DefaultEurekaServerConfig config = new DefaultEurekaServerConfig();
        EurekaServerConfigurationManager.getInstance().setConfiguration(config);
=======
        filter = new RateLimitingFilter(mockServer);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
import com.netflix.eureka.DefaultEurekaServerConfig;
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.EurekaServerConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
=======
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;<<<<<<< MINE
        handler.addFilterWithMapping(ServerRequestAuthFilter.class, "/*", 1);
        handler.addFilterWithMapping(RateLimitingFilter.class, "/*", 1);
=======
        EurekaServerConfig serverConfig = new DefaultEurekaServerConfig();
        EurekaServerContext serverContext = mock(EurekaServerContext.class);
        when(serverContext.getServerConfig()).thenReturn(serverConfig);

        handler.addFilterWithMapping(ServerRequestAuthFilter.class, "/*", 1).setFilter(new ServerRequestAuthFilter(serverContext));
        handler.addFilterWithMapping(RateLimitingFilter.class, "/*", 1).setFilter(new RateLimitingFilter(serverContext));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java;<<<<<<< MINE
=======
import com.netflix.eureka.resources.DefaultServerCodecs;
import com.netflix.eureka.resources.ServerCodecs;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java;<<<<<<< MINE

=======
    private final ServerCodecs serverCodecs = new DefaultServerCodecs(config);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java;<<<<<<< MINE
        replicationClient = new JerseyReplicationClient(config, "http://localhost:" + serverMockRule.getHttpPort() + "/eureka/v2");
=======
        replicationClient = new JerseyReplicationClient(config, serverCodecs,
                "http://localhost:" + serverMockRule.getHttpPort() + "/eureka/v2");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/ReplicationTaskProcessorTest.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistry;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java;<<<<<<< MINE
import static org.mockito.Mockito.times;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/ClusterSampleData.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/util/AwsAsgUtilTest.java;<<<<<<< MINE
=======
package com.netflix.eureka.util;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.LeaseInfo;
import com.netflix.appinfo.MyDataCenterInstanceConfig;
import com.netflix.config.ConfigurationManager;
import com.netflix.discovery.DefaultEurekaClientConfig;
import com.netflix.discovery.DiscoveryClient;
import com.netflix.eureka.DefaultEurekaServerConfig;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.aws.AwsAsgUtil;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import java.util.UUID;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

/**
 * @author David Liu
 */
public class AwsAsgUtilTest {

    private ApplicationInfoManager applicationInfoManager;
    private PeerAwareInstanceRegistry registry;
    private DiscoveryClient client;
    private AwsAsgUtil awsAsgUtil;

    @Before
    public void setUp() throws Exception {
        ConfigurationManager.getConfigInstance().setProperty("eureka.awsAccessId", "fakeId");
        ConfigurationManager.getConfigInstance().setProperty("eureka.awsSecretKey", "fakeKey");

        AmazonInfo dataCenterInfo = mock(AmazonInfo.class);

        EurekaServerConfig serverConfig = new DefaultEurekaServerConfig();
        InstanceInfo.Builder builder = InstanceInfo.Builder.newBuilder();
        builder.setIPAddr("10.10.101.00");
        builder.setHostName("fakeHost");
        builder.setAppName("fake-" + UUID.randomUUID());
        builder.setLeaseInfo(LeaseInfo.Builder.newBuilder().build());
        builder.setDataCenterInfo(dataCenterInfo);

        applicationInfoManager = new ApplicationInfoManager(new MyDataCenterInstanceConfig(), builder.build());
        DefaultEurekaClientConfig clientConfig = new DefaultEurekaClientConfig();
        // setup config in advance, used in initialize converter
        client = mock(DiscoveryClient.class);
        registry = mock(PeerAwareInstanceRegistry.class);

        awsAsgUtil = spy(new AwsAsgUtil(serverConfig, clientConfig, registry));
    }

    @After
    public void tearDown() throws Exception {
        ConfigurationManager.getConfigInstance().clear();
    }

    @Test
    public void testAsyncLoadingFromCache() {

    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
import com.netflix.discovery.DiscoveryManager;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
import com.netflix.discovery.EurekaClientConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
import com.netflix.eureka.cluster.PeerEurekaNodes;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl;
import com.netflix.eureka.resources.DefaultServerCodecs;
import com.netflix.eureka.resources.ServerCodecs;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
    public static final String REMOTE_ZONE = "us-east-1c";

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
    protected EurekaServerConfig serverConfig;
    protected EurekaServerContext serverContext;
    protected EurekaClient client;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
    protected EurekaClient client;
    public static final String REMOTE_ZONE = "us-east-1c";
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
        EurekaServerConfig serverConfig = new DefaultEurekaServerConfig();
        EurekaServerConfigurationManager.getInstance().setConfiguration(serverConfig);
=======
        serverConfig = spy(new DefaultEurekaServerConfig());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
                "http://localhost:" + mockRemoteEurekaServer.getPort() +
                        MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
=======
                "http://localhost:" + mockRemoteEurekaServer.getPort() + MockRemoteEurekaServer.EUREKA_API_BASE_PATH);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
        DefaultEurekaClientConfig config = new DefaultEurekaClientConfig();
=======
        DefaultEurekaClientConfig clientConfig = new DefaultEurekaClientConfig();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
        DiscoveryManager.getInstance().setEurekaClientConfig(config);
        client = new DiscoveryClient(applicationInfoManager, config);
        registry = new TestPeerAwareInstanceRegistry();
        registry.initRemoteRegionRegistry();
=======

        client = new DiscoveryClient(applicationInfoManager, clientConfig);

        ServerCodecs serverCodecs = new DefaultServerCodecs(serverConfig);
        registry = new TestPeerAwareInstanceRegistry(serverConfig, clientConfig, serverCodecs, client);
        serverContext = new DefaultEurekaServerContext(
                serverConfig,
                serverCodecs,
                registry,
                mock(PeerEurekaNodes.class),
                applicationInfoManager
        );

        serverContext.initialize();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
        registry.shutdown();
=======
        serverContext.shutdown();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;<<<<<<< MINE
=======
        public TestPeerAwareInstanceRegistry(EurekaServerConfig serverConfig,
                                             EurekaClientConfig clientConfig,
                                             ServerCodecs serverCodecs,
                                             EurekaClient eurekaClient) {
            super(serverConfig, clientConfig, serverCodecs, eurekaClient);
        }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RemoteRegionSoftDependencyTest.java;<<<<<<< MINE
=======
import org.junit.Before;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RemoteRegionSoftDependencyTest.java;<<<<<<< MINE
=======
import static org.mockito.Mockito.doReturn;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RemoteRegionSoftDependencyTest.java;<<<<<<< MINE
=======
    @Override
    @Before
    public void setUp() throws Exception {
        super.setUp();
        doReturn(10).when(serverConfig).getWaitTimeInMsWhenSyncEmpty();
        doReturn(1).when(serverConfig).getRegistrySyncRetries();
        doReturn(1l).when(serverConfig).getRegistrySyncRetryWaitMs();
        registry.syncUp();
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationsResourceTest.java;<<<<<<< MINE
        applicationsResource = new ApplicationsResource(registry, new ResponseCache(registry));
=======
        applicationsResource = new ApplicationsResource(serverContext);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationsResourceTest.java;<<<<<<< MINE
                InstanceInfo changed = new InstanceInfo.Builder(instanceInfo)
                        .setASGName(null).build();  // null asgName to get around AwsAsgUtil check
                registry.register(changed, false);
=======
                registry.register(instanceInfo, false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;<<<<<<< MINE
=======
import com.netflix.eureka.registry.Key;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;<<<<<<< MINE
        resource = new AbstractVIPResource(new ResponseCache(registry)) {
=======
        resource = new AbstractVIPResource(serverContext) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;<<<<<<< MINE
            protected Response getVipResponse(String version, String entityName, String acceptHeader, EurekaAccept eurekaAccept, ResponseCache.Key.EntityType entityType) {
=======
            protected Response getVipResponse(String version, String entityName, String acceptHeader, EurekaAccept eurekaAccept, Key.EntityType entityType) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;<<<<<<< MINE
                ResponseCache.Key.EntityType.VIP
=======
                Key.EntityType.VIP
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;<<<<<<< MINE
                ResponseCache.Key.EntityType.VIP
=======
                Key.EntityType.VIP
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/InstanceResourceTest.java;<<<<<<< MINE
        applicationResource = new ApplicationResource(testInstanceInfo.getAppName());
        instanceResource = new InstanceResource(applicationResource, testInstanceInfo.getId(), registry);
=======
        applicationResource = new ApplicationResource(testInstanceInfo.getAppName(), serverContext.getServerConfig(), serverContext.getRegistry());
        instanceResource = new InstanceResource(applicationResource, testInstanceInfo.getId(), serverContext.getServerConfig(), serverContext.getRegistry());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationResourceTest.java;<<<<<<< MINE
        applicationResource = new ApplicationResource(testApplication.getName(), registry, new ResponseCache(registry));
=======
        applicationResource = new ApplicationResource(testApplication.getName(), serverContext.getServerConfig(), serverContext.getRegistry());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationResourceTest.java;<<<<<<< MINE
            InstanceInfo changed = new InstanceInfo.Builder(instanceInfo)
                    .setASGName(null).build();  // null asgName to get around AwsAsgUtil check
            registry.register(changed, false);
=======
            registry.register(instanceInfo, false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/PeerReplicationResourceTest.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/PeerReplicationResourceTest.java;<<<<<<< MINE
    private final PeerReplicationResource peerReplicationResource = new PeerReplicationResource() {
=======
    private final PeerReplicationResource peerReplicationResource = new PeerReplicationResource(mock(EurekaServerContext.class)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/guice/EurekaServerModule.java;<<<<<<< MINE
=======
package com.netflix.eureka.guice;

import com.google.inject.AbstractModule;
import com.google.inject.Scopes;
import com.netflix.discovery.guice.EurekaModule;
import com.netflix.eureka.DefaultEurekaServerConfig;
import com.netflix.eureka.DefaultEurekaServerContext;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.aws.EIPManager;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.registry.AbstractInstanceRegistry;
import com.netflix.eureka.registry.AwsInstanceRegistry;
import com.netflix.eureka.registry.InstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.resources.DefaultServerCodecs;
import com.netflix.eureka.resources.ServerCodecs;

/**
 * @author David Liu
 */
public class EurekaServerModule extends AbstractModule {
    @Override
    protected void configure() {
        install(new EurekaModule());

        bind(EurekaServerConfig.class).to(DefaultEurekaServerConfig.class).in(Scopes.SINGLETON);
        bind(PeerEurekaNodes.class).in(Scopes.SINGLETON);

        bind(EIPManager.class).asEagerSingleton();

        // registry and interfaces
        bind(AwsInstanceRegistry.class).asEagerSingleton();
        bind(InstanceRegistry.class).to(AwsInstanceRegistry.class);
        bind(AbstractInstanceRegistry.class).to(AwsInstanceRegistry.class);
        bind(PeerAwareInstanceRegistry.class).to(AwsInstanceRegistry.class);

        bind(ServerCodecs.class).to(DefaultServerCodecs.class).in(Scopes.SINGLETON);

        bind(EurekaServerContext.class).to(DefaultEurekaServerContext.class).in(Scopes.SINGLETON);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/guice/LocalEurekaServerModule.java;<<<<<<< MINE
=======
package com.netflix.eureka.guice;

import com.google.inject.AbstractModule;
import com.google.inject.Scopes;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.EurekaInstanceConfig;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.providers.EurekaConfigBasedInstanceInfoProvider;
import com.netflix.appinfo.providers.MyDataCenterInstanceConfigProvider;
import com.netflix.discovery.DiscoveryClient;
import com.netflix.discovery.EurekaClient;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.discovery.providers.DefaultEurekaClientConfigProvider;
import com.netflix.eureka.DefaultEurekaServerConfig;
import com.netflix.eureka.DefaultEurekaServerContext;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.EurekaServerContext;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.registry.AbstractInstanceRegistry;
import com.netflix.eureka.registry.InstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl;
import com.netflix.eureka.resources.DefaultServerCodecs;
import com.netflix.eureka.resources.ServerCodecs;

/**
 * @author David Liu
 */
public class LocalEurekaServerModule extends AbstractModule {
    @Override
    protected void configure() {
        // don't install the client module, bind the specific components for local use
        bind(ApplicationInfoManager.class).asEagerSingleton();

        bind(EurekaInstanceConfig.class).toProvider(MyDataCenterInstanceConfigProvider.class).in(Scopes.SINGLETON);
        bind(EurekaClientConfig.class).toProvider(DefaultEurekaClientConfigProvider.class).in(Scopes.SINGLETON);

        bind(InstanceInfo.class).toProvider(EurekaConfigBasedInstanceInfoProvider.class).in(Scopes.SINGLETON);
        bind(EurekaClient.class).to(DiscoveryClient.class).in(Scopes.SINGLETON);

        // server bindings
        bind(EurekaServerConfig.class).to(DefaultEurekaServerConfig.class).in(Scopes.SINGLETON);
        bind(PeerEurekaNodes.class).in(Scopes.SINGLETON);

        // registry and interfaces
        bind(PeerAwareInstanceRegistryImpl.class).asEagerSingleton();
        bind(InstanceRegistry.class).to(PeerAwareInstanceRegistryImpl.class);
        bind(AbstractInstanceRegistry.class).to(PeerAwareInstanceRegistryImpl.class);
        bind(PeerAwareInstanceRegistry.class).to(PeerAwareInstanceRegistryImpl.class);

        bind(ServerCodecs.class).to(DefaultServerCodecs.class).in(Scopes.SINGLETON);

        bind(EurekaServerContext.class).to(DefaultEurekaServerContext.class).in(Scopes.SINGLETON);
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/EurekaInjectorCreator.java;<<<<<<< MINE
=======
package com.netflix.eureka;

import com.netflix.archaius.guice.ArchaiusModule;
import com.netflix.eureka.guice.LocalEurekaServerModule;
import com.netflix.governator.GovernatorFeatures;
import com.netflix.governator.LifecycleInjector;
import com.netflix.governator.ProvisionDebugModule;
import com.netflix.governator.guice.annotations.Bootstrap;
import com.netflix.governator.guice.jetty.JettyModule;
import com.netflix.karyon.DefaultKaryonConfiguration;
import com.netflix.karyon.Karyon;
import com.netflix.karyon.archaius.ArchaiusKaryonConfiguration;
import com.sun.jersey.api.core.PackagesResourceConfig;
import com.sun.jersey.guice.JerseyServletModule;
import com.sun.jersey.guice.spi.container.servlet.GuiceContainer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.HashMap;
import java.util.Map;

/**
 * @author David Liu
 */
public class EurekaInjectorCreator {
    private static final Logger logger = LoggerFactory.getLogger(EurekaInjectorCreator.class);

    private static final String CONFIG_NAME = "eureka-server";

    public static LifecycleInjector createInjector(boolean embedded) {
        try {
            return Karyon.createInjector(
                    createInjectorBuilder(embedded).build()
            );
        } catch (Exception e) {
            logger.error("Failed to create the injector", e);
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    private static DefaultKaryonConfiguration.Builder<?> createInjectorBuilder(boolean embedded) {
        return  ArchaiusKaryonConfiguration.builder()
                .withConfigName(CONFIG_NAME)
                .disable(GovernatorFeatures.SHUTDOWN_ON_ERROR)
                .addModules(
                        new LocalEurekaServerModule(),  // server
                        new ArchaiusModule(),
                        new ProvisionDebugModule(),
                        new JerseyServletModule() {
                            @Override
                            protected void configureServlets() {
                                filter("/*").through(StatusFilter.class);
                                filter("/*").through(ServerRequestAuthFilter.class);
                                filter("/v2/apps", "/v2/apps/*").through(GzipEncodingEnforcingFilter.class);
                                //filter("/*").through(RateLimitingFilter.class);  // enable if needed

                                // REST
                                Map<String, String> params = new HashMap<String, String>();
                                params.put(PackagesResourceConfig.PROPERTY_PACKAGES, "com.sun.jersey");
                                params.put(PackagesResourceConfig.PROPERTY_PACKAGES, "com.netflix");
                                params.put("com.sun.jersey.config.property.WebPageContentRegex", "/(flex|images|js|css|jsp)/.*");
                                params.put("com.sun.jersey.spi.container.ContainerRequestFilters", "com.sun.jersey.api.container.filter.GZIPContentEncodingFilter");
                                params.put("com.sun.jersey.spi.container.ContainerResponseFilters", "com.sun.jersey.api.container.filter.GZIPContentEncodingFilter");
                                filter("/*").through(GuiceContainer.class, params);
                                bind(GuiceContainer.class).asEagerSingleton();
                            }
                        },
                        embedded ? new JettyModule() : new Bootstrap.NullModule()
                );
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/EurekaContextListener.java;<<<<<<< MINE
=======
package com.netflix.eureka;

import com.netflix.discovery.converters.JsonXStream;
import com.netflix.discovery.converters.XmlXStream;
import com.netflix.eureka.util.EurekaMonitors;
import com.netflix.governator.LifecycleInjector;
import com.netflix.governator.guice.servlet.GovernatorServletContextListener;
import com.thoughtworks.xstream.XStream;

import javax.servlet.ServletContext;
import javax.servlet.ServletContextEvent;

/**
 * @author David Liu
 */
public class EurekaContextListener extends GovernatorServletContextListener {

    private EurekaServerContext serverContext;

    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        super.contextInitialized(servletContextEvent);
        ServletContext sc = servletContextEvent.getServletContext();
        sc.setAttribute(EurekaServerContext.class.getName(), serverContext);

        // Copy registry from neighboring eureka node
        int registryCount = serverContext.getRegistry().syncUp();
        serverContext.getRegistry().openForTraffic(serverContext.getApplicationInfoManager(), registryCount);

        // Register all monitoring statistics.
        EurekaMonitors.registerAllStats();
    }

    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        EurekaMonitors.shutdown();

        ServletContext sc = servletContextEvent.getServletContext();
        sc.removeAttribute(EurekaServerContext.class.getName());
        super.contextDestroyed(servletContextEvent);
    }

    @Override
    protected LifecycleInjector createInjector() {
        // For backward compatibility
        JsonXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
        XmlXStream.getInstance().registerConverter(new V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);

        LifecycleInjector injector = EurekaInjectorCreator.createInjector(false);
        serverContext = injector.getInstance(EurekaServerContext.class);
        return injector;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;<<<<<<< MINE
=======
    public ApplicationInfoManager(EurekaInstanceConfig config) {
        this(config, new EurekaConfigBasedInstanceInfoProvider(config).get());
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;<<<<<<< MINE
            throw new RuntimeException(
                    "Failed to initialize ApplicationInfoManager", e);
=======
            throw new RuntimeException("Failed to initialize ApplicationInfoManager", e);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;<<<<<<< MINE
            jerseyClientConfig.getClasses().add(DiscoveryJerseyProvider.class);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/endpoint/DnsResolver.java;<<<<<<< MINE
=======
package com.netflix.discovery.endpoint;

import javax.naming.NamingException;
import javax.naming.directory.Attribute;
import javax.naming.directory.Attributes;
import javax.naming.directory.DirContext;
import javax.naming.directory.InitialDirContext;
import java.util.Collections;
import java.util.Hashtable;
import java.util.Set;
import java.util.TreeSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author Tomasz Bak
 */
public final class DnsResolver {

    private static final Logger logger = LoggerFactory.getLogger(DnsResolver.class);

    private static final String DNS_PROVIDER_URL = "dns:";
    private static final String DNS_NAMING_FACTORY = "com.sun.jndi.dns.DnsContextFactory";
    private static final String JAVA_NAMING_FACTORY_INITIAL = "java.naming.factory.initial";
    private static final String JAVA_NAMING_PROVIDER_URL = "java.naming.provider.url";

    private static final String A_RECORD_TYPE = "A";
    private static final String CNAME_RECORD_TYPE = "CNAME";
    private static final String TXT_RECORD_TYPE = "TXT";

    static final DirContext dirContext = getDirContext();

    private DnsResolver() {
    }

    /**
     * Load up the DNS JNDI context provider.
     */
    public static DirContext getDirContext() {
        Hashtable<String, String> env = new Hashtable<String, String>();
        env.put(JAVA_NAMING_FACTORY_INITIAL, DNS_NAMING_FACTORY);
        env.put(JAVA_NAMING_PROVIDER_URL, DNS_PROVIDER_URL);

        try {
            return new InitialDirContext(env);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot get dir context for some reason", e);
        }
    }

    /**
     * Resolve host part of the given URI to the bottom A-Record or the latest available CNAME
     *
     * @return URI identical to the one provided, with host name swapped with the resolved value
     */
    public static String resolve(String originalHost) {
        String currentHost = originalHost;
        if (isLocalOrIp(currentHost)) {
            return originalHost;
        }
        try {
            String targetHost = null;
            do {
                Attributes attrs = dirContext.getAttributes(currentHost, new String[]{A_RECORD_TYPE, CNAME_RECORD_TYPE});
                Attribute attr = attrs.get(A_RECORD_TYPE);
                if (attr != null) {
                    targetHost = attr.get().toString();
                }
                attr = attrs.get(CNAME_RECORD_TYPE);
                if (attr != null) {
                    currentHost = attr.get().toString();
                } else {
                    targetHost = currentHost;
                }

            } while (targetHost == null);
            return targetHost;
        } catch (NamingException e) {
            logger.warn("Cannot resolve discovery server address " + currentHost + "; returning original value " + originalHost, e);
            return originalHost;
        }
    }

    private static boolean isLocalOrIp(String currentHost) {
        if ("localhost".equals(currentHost)) {
            return true;
        }
        if ("127.0.0.1".equals(currentHost)) {
            return true;
        }
        return false;
    }

    /**
     * Looks up the DNS name provided in the JNDI context.
     */
    public static Set<String> getCNamesFromTxtRecord(String discoveryDnsName) throws NamingException {
        Attributes attrs = dirContext.getAttributes(discoveryDnsName, new String[]{TXT_RECORD_TYPE});
        Attribute attr = attrs.get(TXT_RECORD_TYPE);
        String txtRecord = null;
        if (attr != null) {
            txtRecord = attr.get().toString();
        }

        Set<String> cnamesSet = new TreeSet<String>();
        if (txtRecord == null || txtRecord.trim().isEmpty()) {
            return cnamesSet;
        }
        String[] cnames = txtRecord.split(" ");
        Collections.addAll(cnamesSet, cnames);
        return cnamesSet;
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/endpoint/EndpointUtils.java;<<<<<<< MINE
=======
package com.netflix.discovery.endpoint;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.discovery.EurekaClientConfig;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

/**
 * This class contains some of the utility functions previously found in DiscoveryClient, but should be elsewhere.
 * It *does not yet* clean up the moved code.
 */
public class EndpointUtils {
    private static final Logger logger = LoggerFactory.getLogger(EndpointUtils.class);

    public static final String DEFAULT_REGION = "default";
    public static final String DEFAULT_ZONE = "default";

    public enum DiscoveryUrlType {
        CNAME, A
    }

    public static interface ServiceUrlRandomizer {
        void randomize(List<String> urlList);
    }

    public static class InstanceInfoBasedUrlRandomizer implements ServiceUrlRandomizer {
        private final InstanceInfo instanceInfo;

        public InstanceInfoBasedUrlRandomizer(InstanceInfo instanceInfo) {
            this.instanceInfo = instanceInfo;
        }

        @Override
        public void randomize(List<String> urlList) {
            int listSize = 0;
            if (urlList != null) {
                listSize = urlList.size();
            }
            if ((instanceInfo == null) || (listSize == 0)) {
                return;
            }
            // Find the hashcode of the instance hostname and use it to find an entry
            // and then arrange the rest of the entries after this entry.
            int instanceHashcode = instanceInfo.getHostName().hashCode();
            if (instanceHashcode < 0) {
                instanceHashcode = instanceHashcode * -1;
            }
            int backupInstance = instanceHashcode % listSize;
            for (int i = 0; i < backupInstance; i++) {
                String zone = urlList.remove(0);
                urlList.add(zone);
            }
        }
    }

    /**
     * Get the list of all eureka service urls for the eureka client to talk to.
     *
     * @param clientConfig the clientConfig to use
     * @param zone the zone in which the client resides
     * @param randomizer a randomizer to randomized returned urls, if loading from dns
     *
     * @return The list of all eureka service urls for the eureka client to talk to.
     */
    public static List<String> getDiscoveryServiceUrls(EurekaClientConfig clientConfig, String zone, ServiceUrlRandomizer randomizer) {
        boolean shouldUseDns = clientConfig.shouldUseDnsForFetchingServiceUrls();
        if (shouldUseDns) {
            return getServiceUrlsFromDNS(clientConfig, zone, clientConfig.shouldPreferSameZoneEureka(), randomizer);
        }
        return getServiceUrlsFromConfig(clientConfig, zone, clientConfig.shouldPreferSameZoneEureka());
    }

    /**
     * Get the list of all eureka service urls from DNS for the eureka client to
     * talk to. The client picks up the service url from its zone and then fails over to
     * other zones randomly. If there are multiple servers in the same zone, the client once
     * again picks one randomly. This way the traffic will be distributed in the case of failures.
     *
     * @param clientConfig the clientConfig to use
     * @param instanceZone The zone in which the client resides.
     * @param preferSameZone true if we have to prefer the same zone as the client, false otherwise.
     * @param randomizer a randomizer to randomized returned urls
     *
     * @return The list of all eureka service urls for the eureka client to talk to.
     */
    public static List<String> getServiceUrlsFromDNS(EurekaClientConfig clientConfig, String instanceZone, boolean preferSameZone, ServiceUrlRandomizer randomizer) {
        String region = getRegion(clientConfig);
        // Get zone-specific DNS names for the given region so that we can get a
        // list of available zones
        Map<String, List<String>> zoneDnsNamesMap = getZoneBasedDiscoveryUrlsFromRegion(clientConfig, region);
        Set<String> availableZones = zoneDnsNamesMap.keySet();
        List<String> zones = new ArrayList<String>(availableZones);
        if (zones.isEmpty()) {
            throw new RuntimeException("No available zones configured for the instanceZone " + instanceZone);
        }
        int zoneIndex = 0;
        boolean zoneFound = false;
        for (String zone : zones) {
            logger.debug("Checking if the instance zone {} is the same as the zone from DNS {}", instanceZone, zone);
            if (preferSameZone) {
                if (instanceZone.equalsIgnoreCase(zone)) {
                    zoneFound = true;
                }
            } else {
                if (!instanceZone.equalsIgnoreCase(zone)) {
                    zoneFound = true;
                }
            }
            if (zoneFound) {
                Object[] args = {zones, instanceZone, zoneIndex};
                logger.debug("The zone index from the list {} that matches the instance zone {} is {}", args);
                break;
            }
            zoneIndex++;
        }
        if (zoneIndex >= zones.size()) {
            logger.warn("No match for the zone {} in the list of available zones {}",
                    instanceZone, Arrays.toString(zones.toArray()));
        } else {
            // Rearrange the zones with the instance zone first
            for (int i = 0; i < zoneIndex; i++) {
                String zone = zones.remove(0);
                zones.add(zone);
            }
        }

        // Now get the eureka urls for all the zones in the order and return it
        List<String> serviceUrls = new ArrayList<String>();
        for (String zone : zones) {
            for (String zoneCname : zoneDnsNamesMap.get(zone)) {
                List<String> ec2Urls = new ArrayList<String>(getEC2DiscoveryUrlsFromZone(zoneCname, DiscoveryUrlType.CNAME));
                // Rearrange the list to distribute the load in case of
                // multiple servers
                if (ec2Urls.size() > 1) {
                    randomizer.randomize(ec2Urls);
                }
                for (String ec2Url : ec2Urls) {
                    String serviceUrl = "http://" + ec2Url + ":"
                            + clientConfig.getEurekaServerPort()
                            + "/" + clientConfig.getEurekaServerURLContext()
                            + "/";
                    logger.debug("The EC2 url is {}", serviceUrl);
                    serviceUrls.add(serviceUrl);
                }
            }
        }
        // Rearrange the fail over server list to distribute the load
        String primaryServiceUrl = serviceUrls.remove(0);
        randomizer.randomize(serviceUrls);
        serviceUrls.add(0, primaryServiceUrl);

        logger.debug("This client will talk to the following serviceUrls in order : {} ",
                Arrays.toString(serviceUrls.toArray()));
        return serviceUrls;
    }

    /**
     * Get the list of all eureka service urls from properties file for the eureka client to talk to.
     *
     * @param clientConfig the clientConfig to use
     * @param instanceZone The zone in which the client resides
     * @param preferSameZone true if we have to prefer the same zone as the client, false otherwise
     * @return The list of all eureka service urls for the eureka client to talk to
     */
    public static List<String> getServiceUrlsFromConfig(EurekaClientConfig clientConfig, String instanceZone, boolean preferSameZone) {
        List<String> orderedUrls = new ArrayList<String>();
        String region = getRegion(clientConfig);
        String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
        if (availZones == null || availZones.length == 0) {
            availZones = new String[1];
            availZones[0] = DEFAULT_ZONE;
        }
        logger.debug("The availability zone for the given region {} are {}", region, Arrays.toString(availZones));
        int myZoneOffset = getZoneOffset(instanceZone, preferSameZone, availZones);

        List<String> serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[myZoneOffset]);
        if (serviceUrls != null) {
            orderedUrls.addAll(serviceUrls);
        }
        int currentOffset = myZoneOffset == (availZones.length - 1) ? 0 : (myZoneOffset + 1);
        while (currentOffset != myZoneOffset) {
            serviceUrls = clientConfig.getEurekaServerServiceUrls(availZones[currentOffset]);
            if (serviceUrls != null) {
                orderedUrls.addAll(serviceUrls);
            }
            if (currentOffset == (availZones.length - 1)) {
                currentOffset = 0;
            } else {
                currentOffset++;
            }
        }

        if (orderedUrls.size() < 1) {
            throw new IllegalArgumentException("DiscoveryClient: invalid serviceUrl specified!");
        }
        return orderedUrls;
    }


    /**
     * Get the list of EC2 URLs given the zone name.
     *
     * @param dnsName The dns name of the zone-specific CNAME
     * @param type CNAME or EIP that needs to be retrieved
     * @return The list of EC2 URLs associated with the dns name
     */
    public static Set<String> getEC2DiscoveryUrlsFromZone(String dnsName, DiscoveryUrlType type) {
        Set<String> eipsForZone = null;
        try {
            dnsName = "txt." + dnsName;
            logger.debug("The zone url to be looked up is {} :", dnsName);
            Set<String> ec2UrlsForZone = DnsResolver.getCNamesFromTxtRecord(dnsName);
            for (String ec2Url : ec2UrlsForZone) {
                logger.debug("The eureka url for the dns name {} is {}", dnsName, ec2Url);
                ec2UrlsForZone.add(ec2Url);
            }
            if (DiscoveryUrlType.CNAME.equals(type)) {
                return ec2UrlsForZone;
            }
            eipsForZone = new TreeSet<String>();
            for (String cname : ec2UrlsForZone) {
                String[] tokens = cname.split("\\.");
                String ec2HostName = tokens[0];
                String[] ips = ec2HostName.split("-");
                StringBuilder eipBuffer = new StringBuilder();
                for (int ipCtr = 1; ipCtr < 5; ipCtr++) {
                    eipBuffer.append(ips[ipCtr]);
                    if (ipCtr < 4) {
                        eipBuffer.append(".");
                    }
                }
                eipsForZone.add(eipBuffer.toString());
            }
            logger.debug("The EIPS for {} is {} :", dnsName, eipsForZone);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot get cnames bound to the region:" + dnsName, e);
        }
        return eipsForZone;
    }

    /**
     * Get the zone based CNAMES that are bound to a region.
     *
     * @param region
     *            - The region for which the zone names need to be retrieved
     * @return - The list of CNAMES from which the zone-related information can
     *         be retrieved
     */
    public static Map<String, List<String>> getZoneBasedDiscoveryUrlsFromRegion(EurekaClientConfig clientConfig, String region) {
        String discoveryDnsName = null;
        try {
            discoveryDnsName = "txt." + region + "." + clientConfig.getEurekaServerDNSName();

            logger.debug("The region url to be looked up is {} :", discoveryDnsName);
            Set<String> zoneCnamesForRegion = new TreeSet<String>(DnsResolver.getCNamesFromTxtRecord(discoveryDnsName));
            Map<String, List<String>> zoneCnameMapForRegion = new TreeMap<String, List<String>>();
            for (String zoneCname : zoneCnamesForRegion) {
                String zone = null;
                if (isEC2Url(zoneCname)) {
                    throw new RuntimeException(
                            "Cannot find the right DNS entry for "
                                    + discoveryDnsName
                                    + ". "
                                    + "Expected mapping of the format <aws_zone>.<domain_name>");
                } else {
                    String[] cnameTokens = zoneCname.split("\\.");
                    zone = cnameTokens[0];
                    logger.debug("The zoneName mapped to region {} is {}", region, zone);
                }
                List<String> zoneCnamesSet = zoneCnameMapForRegion.get(zone);
                if (zoneCnamesSet == null) {
                    zoneCnamesSet = new ArrayList<String>();
                    zoneCnameMapForRegion.put(zone, zoneCnamesSet);
                }
                zoneCnamesSet.add(zoneCname);
            }
            return zoneCnameMapForRegion;
        } catch (Throwable e) {
            throw new RuntimeException("Cannot get cnames bound to the region:" + discoveryDnsName, e);
        }
    }

    /**
     * Get the region that this particular instance is in.
     *
     * @return - The region in which the particular instance belongs to.
     */
    public static String getRegion(EurekaClientConfig clientConfig) {
        String region = clientConfig.getRegion();
        if (region == null) {
            region = DEFAULT_REGION;
        }
        region = region.trim().toLowerCase();
        return region;
    }

    // FIXME this is no valid for vpc
    private static boolean isEC2Url(String zoneCname) {
        return zoneCname.startsWith("ec2");
    }

    /**
     * Gets the zone to pick up for this instance.
     */
    private static int getZoneOffset(String myZone, boolean preferSameZone, String[] availZones) {
        for (int i = 0; i < availZones.length; i++) {
            if (myZone != null && (availZones[i].equalsIgnoreCase(myZone.trim()) == preferSameZone)) {
                return i;
            }
        }
        logger.warn("DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - {}," +
                " preferSameZone- {}. Defaulting to " + availZones[0], myZone, preferSameZone);

        return 0;
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/PropertyBasedAzToRegionMapper.java;<<<<<<< MINE
    private final EurekaClientConfig clientConfig;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/PropertyBasedAzToRegionMapper.java;<<<<<<< MINE
        this.clientConfig = clientConfig;
=======
        super(clientConfig);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;<<<<<<< MINE
=======
    protected final EurekaClientConfig clientConfig;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;<<<<<<< MINE
    protected AbstractAzToRegionMapper() {
=======
    protected AbstractAzToRegionMapper(EurekaClientConfig clientConfig) {
        this.clientConfig = clientConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DNSBasedAzToRegionMapper.java;<<<<<<< MINE
=======
import com.netflix.discovery.endpoint.EndpointUtils;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DNSBasedAzToRegionMapper.java;<<<<<<< MINE
=======
    public DNSBasedAzToRegionMapper(EurekaClientConfig clientConfig) {
        super(clientConfig);
    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DNSBasedAzToRegionMapper.java;<<<<<<< MINE
        Map<String, List<String>> zoneBasedDiscoveryUrlsFromRegion =
                DiscoveryClient.getZoneBasedDiscoveryUrlsFromRegion(region);
=======
        Map<String, List<String>> zoneBasedDiscoveryUrlsFromRegion = EndpointUtils
                .getZoneBasedDiscoveryUrlsFromRegion(clientConfig, region);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
    // =======
     * @deprecated see {@link com.netflix.discovery.endpoint.EndpointUtils} for replacement
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
=======
     * @deprecated see {@link com.netflix.discovery.endpoint.EndpointUtils} for replacement
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
=======
     * @deprecated see {@link com.netflix.discovery.endpoint.EndpointUtils} for replacement
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/converters/wrappers/CodecWrapper.java;<<<<<<< MINE
=======
package com.netflix.discovery.converters.wrappers;

/**
 * Interface for more useable reference
 *
 * @author David Liu
 */
public interface CodecWrapper extends EncoderWrapper, DecoderWrapper {
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import java.util.TreeSet;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
import com.netflix.discovery.endpoint.DnsResolver;
import com.netflix.discovery.endpoint.EndpointUtils;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    private final EndpointUtils.ServiceUrlRandomizer urlRandomizer;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            final String zone = getZone(myInfo);
            eurekaServiceUrls.set(getDiscoveryServiceUrls(zone));
=======
            instanceInfo = myInfo;
            if (myInfo != null) {
                appPathIdentifier = instanceInfo.getAppName() + "/" + instanceInfo.getId();
            } else {
                logger.warn("Setting instanceInfo to a passed in null value");
            }

            this.urlRandomizer = new EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);
            String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
            final String zone = InstanceInfo.getZone(availZones, myInfo);
            eurekaServiceUrls.set(timedGetDiscoveryServiceUrls(zone));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            instanceInfo = myInfo;
            if (myInfo != null) {
                appPathIdentifier = instanceInfo.getAppName() + "/"
                        + instanceInfo.getId();
            } else {
                logger.warn("Setting instanceInfo to a passed in null value");
            }

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                azToRegionMapper = new DNSBasedAzToRegionMapper();
=======
                azToRegionMapper = new DNSBasedAzToRegionMapper(clientConfig);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
     * @deprecated see replacement in {@link com.netflix.discovery.endpoint.EndpointUtils}
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        List<String> orderedUrls = new ArrayList<String>();
        String region = getRegion();
        String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
        if (availZones == null || availZones.length == 0) {
            availZones = new String[1];
            availZones[0] = "default";
        }
        logger.debug("The availability zone for the given region {} are {}",
                region, Arrays.toString(availZones));
        int myZoneOffset = getZoneOffset(instanceZone, preferSameZone,
                availZones);

        List<String> serviceUrls = clientConfig
                .getEurekaServerServiceUrls(availZones[myZoneOffset]);
        if (serviceUrls != null) {
            orderedUrls.addAll(serviceUrls);
        }
        int currentOffset = myZoneOffset == (availZones.length - 1) ? 0
                : (myZoneOffset + 1);
        while (currentOffset != myZoneOffset) {
            serviceUrls = clientConfig
                    .getEurekaServerServiceUrls(availZones[currentOffset]);
            if (serviceUrls != null) {
                orderedUrls.addAll(serviceUrls);
            }
            if (currentOffset == (availZones.length - 1)) {
                currentOffset = 0;
            } else {
                currentOffset++;
            }
        }

        if (orderedUrls.size() < 1) {
            throw new IllegalArgumentException(
                    "DiscoveryClient: invalid serviceUrl specified!");
        }
        return orderedUrls;
=======
        return EndpointUtils.getServiceUrlsFromConfig(clientConfig, instanceZone, preferSameZone);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        List<String> orderedUrls = new ArrayList<String>();
        String region = getRegion();
        String[] availZones = clientConfig.getAvailabilityZones(clientConfig.getRegion());
        if (availZones == null || availZones.length == 0) {
            availZones = new String[1];
            availZones[0] = "default";
        }
        logger.debug("The availability zone for the given region {} are {}",
                region, Arrays.toString(availZones));
        int myZoneOffset = getZoneOffset(instanceZone, preferSameZone,
                availZones);

        List<String> serviceUrls = clientConfig
                .getEurekaServerServiceUrls(availZones[myZoneOffset]);
        if (serviceUrls != null) {
            orderedUrls.addAll(serviceUrls);
        }
        int currentOffset = myZoneOffset == (availZones.length - 1) ? 0
                : (myZoneOffset + 1);
        while (currentOffset != myZoneOffset) {
            serviceUrls = clientConfig
                    .getEurekaServerServiceUrls(availZones[currentOffset]);
            if (serviceUrls != null) {
                orderedUrls.addAll(serviceUrls);
            }
            if (currentOffset == (availZones.length - 1)) {
                currentOffset = 0;
            } else {
                currentOffset++;
            }
        }

        if (orderedUrls.size() < 1) {
            throw new IllegalArgumentException(
                    "DiscoveryClient: invalid serviceUrl specified!");
        }
        return orderedUrls;
=======
        return EndpointUtils.getServiceUrlsFromConfig(clientConfig, instanceZone, preferSameZone);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
     * @deprecated see replacement in {@link com.netflix.discovery.endpoint.EndpointUtils}
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        Stopwatch t = GET_SERVICE_URLS_DNS_TIMER.start();
        String region = getRegion();
        // Get zone-specific DNS names for the given region so that we can get a
        // list of available zones
        Map<String, List<String>> zoneDnsNamesMap = getZoneBasedDiscoveryUrlsFromRegion(region);
        Set<String> availableZones = zoneDnsNamesMap.keySet();
        List<String> zones = new ArrayList<String>(availableZones);
        if (zones.isEmpty()) {
            throw new RuntimeException("No available zones configured for the instanceZone " + instanceZone);
        }
        int zoneIndex = 0;
        boolean zoneFound = false;
        for (String zone : zones) {
            logger.debug(
                    "Checking if the instance zone {} is the same as the zone from DNS {}",
                    instanceZone, zone);
            if (preferSameZone) {
                if (instanceZone.equalsIgnoreCase(zone)) {
                    zoneFound = true;
                }
            } else {
                if (!instanceZone.equalsIgnoreCase(zone)) {
                    zoneFound = true;
                }
            }
            if (zoneFound) {
                Object[] args = {zones, instanceZone, zoneIndex};
                logger.debug(
                        "The zone index from the list {} that matches the instance zone {} is {}",
                        args);
                break;
            }
            zoneIndex++;
        }
        if (zoneIndex >= zones.size()) {
            logger.warn(
                    "No match for the zone {} in the list of available zones {}",
                    instanceZone, Arrays.toString(zones.toArray()));
        } else {
            // Rearrange the zones with the instance zone first
            for (int i = 0; i < zoneIndex; i++) {
                String zone = zones.remove(0);
                zones.add(zone);
            }
        }

        // Now get the eureka urls for all the zones in the order and return it
        List<String> serviceUrls = new ArrayList<String>();
        for (String zone : zones) {
            for (String zoneCname : zoneDnsNamesMap.get(zone)) {
                List<String> ec2Urls = new ArrayList<String>(
                        getEC2DiscoveryUrlsFromZone(zoneCname,
                                DiscoveryUrlType.CNAME));
                // Rearrange the list to distribute the load in case of
                // multiple servers
                if (ec2Urls.size() > 1) {
                    this.arrangeListBasedonHostname(ec2Urls);
                }
                for (String ec2Url : ec2Urls) {
                    String serviceUrl = "http://" + ec2Url + ":"
                            + clientConfig.getEurekaServerPort()

                            + "/" + clientConfig.getEurekaServerURLContext()
                            + "/";
                    logger.debug("The EC2 url is {}", serviceUrl);
                    serviceUrls.add(serviceUrl);
                }
            }
        }
        // Rearrange the fail over server list to distribute the load
        String primaryServiceUrl = serviceUrls.remove(0);
        arrangeListBasedonHostname(serviceUrls);
        serviceUrls.add(0, primaryServiceUrl);

        logger.debug(
                "This client will talk to the following serviceUrls in order : {} ",
                Arrays.toString(serviceUrls.toArray()));
        t.stop();
        return serviceUrls;
=======
        return EndpointUtils.getServiceUrlsFromDNS(clientConfig, instanceZone, preferSameZone, urlRandomizer);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    /**
     * @deprecated see replacement in {@link com.netflix.discovery.endpoint.EndpointUtils}
     */
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
        return EndpointUtils.getDiscoveryServiceUrls(clientConfig, zone, urlRandomizer);
    }

    private List<String> timedGetDiscoveryServiceUrls(String zone) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            return getServiceUrlsFromDNS(zone, clientConfig.shouldPreferSameZoneEureka());
=======
            Stopwatch t = GET_SERVICE_URLS_DNS_TIMER.start();
            List<String> result = EndpointUtils.getServiceUrlsFromDNS(
                    clientConfig, zone, clientConfig.shouldPreferSameZoneEureka(), urlRandomizer);
            t.stop();
            return result;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
        return getServiceUrlsFromConfig(zone, clientConfig.shouldPreferSameZoneEureka());
    }

    public enum DiscoveryUrlType {
        CNAME, A
=======
        return EndpointUtils.getServiceUrlsFromConfig(clientConfig, zone, clientConfig.shouldPreferSameZoneEureka());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
     * @deprecated see replacement in {@link com.netflix.discovery.endpoint.EndpointUtils}
     *
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
     * Get the zone based CNAMES that are bound to a region.
=======
     * @deprecated see replacement in {@link com.netflix.discovery.endpoint.EndpointUtils}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
     * @param region
     *            - The region for which the zone names need to be retrieved
     * @return - The list of CNAMES from which the zone-related information can
     *         be retrieved
     */
    static Map<String, List<String>> getZoneBasedDiscoveryUrlsFromRegion(
            String region) {
        String discoveryDnsName = null;
        try {
            discoveryDnsName = "txt." + region + "."
                    + clientConfig.getEurekaServerDNSName();

            logger.debug("The region url to be looked up is {} :",
                    discoveryDnsName);
            Set<String> zoneCnamesForRegion = new TreeSet<String>(
                    DnsResolver.getCNamesFromTxtRecord(discoveryDnsName));
            Map<String, List<String>> zoneCnameMapForRegion = new TreeMap<String, List<String>>();
            for (String zoneCname : zoneCnamesForRegion) {
                String zone = null;
                if (isEC2Url(zoneCname)) {
                    throw new RuntimeException(
                            "Cannot find the right DNS entry for "
                                    + discoveryDnsName
                                    + ". "
                                    + "Expected mapping of the format <aws_zone>.<domain_name>");
                } else {
                    String[] cnameTokens = zoneCname.split("\\.");
                    zone = cnameTokens[0];
                    logger.debug("The zoneName mapped to region {} is {}",
                            region, zone);
                }
                List<String> zoneCnamesSet = zoneCnameMapForRegion.get(zone);
                if (zoneCnamesSet == null) {
                    zoneCnamesSet = new ArrayList<String>();
                    zoneCnameMapForRegion.put(zone, zoneCnamesSet);
                }
                zoneCnamesSet.add(zoneCname);
            }
            return zoneCnameMapForRegion;
        } catch (Throwable e) {
            throw new RuntimeException("Cannot get cnames bound to the region:"
                    + discoveryDnsName, e);
        }
    }

    private static boolean isEC2Url(String zoneCname) {
        return zoneCname.startsWith("ec2");
    }

    /**
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
     * @param dnsName
     *            - The dns name of the zone-specific CNAME
     * @param type
     *            - CNAME or EIP that needs to be retrieved
     * @return - The list of EC2 URLs associated with the dns name
=======
     * @param dnsName The dns name of the zone-specific CNAME
     * @param type CNAME or EIP that needs to be retrieved
     * @return The list of EC2 URLs associated with the dns name
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
=======
    @Deprecated
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                                                          DiscoveryUrlType type) {
        Set<String> eipsForZone = null;
        try {
            dnsName = "txt." + dnsName;
            logger.debug("The zone url to be looked up is {} :", dnsName);
            Set<String> ec2UrlsForZone = DnsResolver.getCNamesFromTxtRecord(dnsName);
            for (String ec2Url : ec2UrlsForZone) {
                logger.debug("The eureka url for the dns name {} is {}",
                        dnsName, ec2Url);
                ec2UrlsForZone.add(ec2Url);
            }
            if (DiscoveryUrlType.CNAME.equals(type)) {
                return ec2UrlsForZone;
            }
            eipsForZone = new TreeSet<String>();
            for (String cname : ec2UrlsForZone) {
                String[] tokens = cname.split("\\.");
                String ec2HostName = tokens[0];
                String[] ips = ec2HostName.split("-");
                StringBuffer eipBuffer = new StringBuffer();
                for (int ipCtr = 1; ipCtr < 5; ipCtr++) {
                    eipBuffer.append(ips[ipCtr]);
                    if (ipCtr < 4) {
                        eipBuffer.append(".");
                    }
                }
                eipsForZone.add(eipBuffer.toString());
            }
            logger.debug("The EIPS for {} is {} :", dnsName, eipsForZone);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot get cnames bound to the region:"
                    + dnsName, e);
        }
        return eipsForZone;
    }

    /**
     * Gets the zone to pick up for this instance.
     *
     */
    private static int getZoneOffset(String myZone, boolean preferSameZone,
                                     String[] availZones) {
        for (int i = 0; i < availZones.length; i++) {
            if (myZone != null
                    && (availZones[i].equalsIgnoreCase(myZone.trim()) == preferSameZone)) {
                return i;
            }
        }
        logger.warn(
                "DISCOVERY: Could not pick a zone based on preferred zone settings. My zone - {}, preferSameZone- {}. "
                        + "Defaulting to " + availZones[0], myZone, preferSameZone);
        return 0;
=======
                                                          EndpointUtils.DiscoveryUrlType type) {
        return EndpointUtils.getEC2DiscoveryUrlsFromZone(dnsName, type);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
                    List<String> serviceUrlList = getDiscoveryServiceUrls(zone);
=======
                    List<String> serviceUrlList = timedGetDiscoveryServiceUrls(zone);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private void arrangeListBasedonHostname(List<String> list) {
        int listSize = 0;
        if (list != null) {
            listSize = list.size();
        }
        if ((this.instanceInfo == null) || (listSize == 0)) {
            return;
        }
        // Find the hashcode of the instance hostname and use it to find an entry
        // and then arrange the rest of the entries after this entry.
        int instanceHashcode = this.instanceInfo.getHostName().hashCode();
        if (instanceHashcode < 0) {
            instanceHashcode = instanceHashcode * -1;
        }
        int backupInstance = instanceHashcode % listSize;
        for (int i = 0; i < backupInstance; i++) {
            String zone = list.remove(0);
            list.add(zone);
        }
    }


=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;<<<<<<< MINE
        throw new UnsupportedOperationException("Backup registry not implemented.");
=======
        return null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;<<<<<<< MINE
        throw new UnsupportedOperationException("Backup registry not implemented.");
=======
        return null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/test/java/com/netflix/discovery/converters/wrappers/CodecWrappersTest.java;<<<<<<< MINE
=======
package com.netflix.discovery.converters.wrappers;

import junit.framework.Assert;
import org.junit.Test;

import javax.ws.rs.core.MediaType;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * @author David Liu
 */
public class CodecWrappersTest {

    private static String testWrapperName = "FOO_WRAPPER";

    @Test
    public void testRegisterNewWrapper() {
        Assert.assertNull(CodecWrappers.getEncoder(testWrapperName));
        Assert.assertNull(CodecWrappers.getDecoder(testWrapperName));

        CodecWrappers.registerWrapper(new TestWrapper());

        Assert.assertNotNull(CodecWrappers.getEncoder(testWrapperName));
        Assert.assertNotNull(CodecWrappers.getDecoder(testWrapperName));
    }

    private final class TestWrapper implements CodecWrapper {

        @Override
        public <T> T decode(String textValue, Class<T> type) throws IOException {
            return null;
        }

        @Override
        public <T> T decode(InputStream inputStream, Class<T> type) throws IOException {
            return null;
        }

        @Override
        public <T> String encode(T object) throws IOException {
            return null;
        }

        @Override
        public <T> void encode(T object, OutputStream outputStream) throws IOException {

        }

        @Override
        public String codecName() {
            return testWrapperName;
        }

        @Override
        public boolean support(MediaType mediaType) {
            return false;
        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE


    /**
     * Get the configured binding strategy EIP or Route53.
     * @return the configured binding strategy
     */
    AwsBindingStrategy getBindingStrategy();

    /**
     *
     * @return the ttl used to set up the route53 domain if new
     */
    long getRoute53DomainTTL();

    /**
     * Gets the number of times the server should try to bind to the candidate
     * Route53 domain.
     *
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the number of times the server should try to bind to the
     *         candidate Route53 domain.
     */
    int getRoute53BindRebindRetries();

    /**
     * Gets the interval with which the server should check if the Route53 domain is bound
     * and should try to bind in the case if it is already not bound.
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the time in milliseconds.
     */
    int getRoute53BindingRetryIntervalMs();
=======

    /**
     * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
     * the corresponding configuration can be put into experimental configuration section.
     *
     * @return a property of experimental feature
     */
    String getExperimental(String name);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistryImpl.java;<<<<<<< MINE
=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka;

import java.net.URI;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.DataCenterInfo;
import com.netflix.appinfo.DataCenterInfo.Name;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.appinfo.LeaseInfo;
import com.netflix.discovery.DiscoveryManager;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.LookupService;
import com.netflix.eureka.cluster.PeerEurekaNode;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.lease.Lease;
import com.netflix.eureka.resources.ASGResource.ASGStatus;
import com.netflix.eureka.util.MeasuredRate;
import com.netflix.servo.DefaultMonitorRegistry;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.eureka.cluster.PeerEurekaNodes.isThisMe;

/**
 * Handles replication of all operations to {@link AbstractInstanceRegistry} to peer
 * <em>Eureka</em> nodes to keep them all in sync.
 *
 * <p>
 * Primary operations that are replicated are the
 * <em>Registers,Renewals,Cancels,Expirations and Status Changes</em>
 * </p>
 *
 * <p>
 * When the eureka server starts up it tries to fetch all the registry
 * information from the peer eureka nodes.If for some reason this operation
 * fails, the server does not allow the user to get the registry information for
 * a period specified in
 * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}.
 * </p>
 *
 * <p>
 * One important thing to note about <em>renewals</em>.If the renewal drops more
 * than the specified threshold as specified in
 * {@link EurekaServerConfig#getRenewalPercentThreshold()} within a period of
 * {@link EurekaServerConfig#getRenewalThresholdUpdateIntervalMs()}, eureka
 * perceives this as a danger and stops expiring instances.
 * </p>
 *
 * @author Karthik Ranganathan, Greg Kim
 *
 */
public class PeerAwareInstanceRegistryImpl extends AbstractInstanceRegistry implements PeerAwareInstanceRegistry {
    private static final String US_EAST_1 = "us-east-1";

    private static final int PRIME_PEER_NODES_RETRY_MS = 30000;

    private static final int REGISTRY_SYNC_RETRY_MS = 30000;

    private static final Logger logger = LoggerFactory.getLogger(PeerAwareInstanceRegistryImpl.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final EurekaClientConfig EUREKA_CLIENT_CONFIG = DiscoveryManager
            .getInstance().getEurekaClientConfig();

    private long startupTime = 0;
    private boolean peerInstancesTransferEmptyOnStartup = true;

    public enum Action {
        Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;

        private com.netflix.servo.monitor.Timer timer = Monitors.newTimer(this.name());

        public com.netflix.servo.monitor.Timer getTimer() {
            return this.timer;
        }

    }

    private static final Comparator<Application> APP_COMPARATOR = new Comparator<Application>() {
        public int compare(Application l, Application r) {
            return l.getName().compareTo(r.getName());
        }
    };

    private final MeasuredRate numberOfReplicationsLastMin = new MeasuredRate(1000 * 60 * 1);


    private final PeerEurekaNodes peerEurekaNodes;

    private Timer timer = new Timer(
            "ReplicaAwareInstanceRegistry - RenewalThresholdUpdater", true);

    private static final PeerAwareInstanceRegistryImpl instance = new PeerAwareInstanceRegistryImpl();

    PeerAwareInstanceRegistryImpl() {
        this.peerEurekaNodes = new PeerEurekaNodes(this, EUREKA_SERVER_CONFIG);

        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn(
                    "Cannot register the JMX monitor for the InstanceRegistry :",
                    e);
        }
        init();
    }

    public static PeerAwareInstanceRegistryImpl getInstance() {
        return instance;
    }

    /**
     * Set up replica nodes and the task that updates the threshold
     * periodically.
     */
    private void init() {
        peerEurekaNodes.start();
        scheduleRenewalThresholdUpdateTask();
    }

    /**
     * Schedule the task that updates <em>renewal threshold</em> periodically.
     * The renewal threshold would be used to determine if the renewals drop
     * dramatically because of network partition and to protect expiring too
     * many instances at a time.
     *
     */
    private void scheduleRenewalThresholdUpdateTask() {
        timer.schedule(new TimerTask() {

                           @Override
                           public void run() {
                               updateRenewalThreshold();

                           }

                       }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
                EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs());
    }

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        LookupService lookupService = DiscoveryManager.getInstance()
                .getLookupService();
        int count = 0;

        for (int i = 0; ((i < EUREKA_SERVER_CONFIG.getRegistrySyncRetries()) && (count == 0)); i++) {
            Applications apps = lookupService.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {

                            register(instance, instance.getLeaseInfo()
                                    .getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
            if (count == 0) {
                try {
                    Thread.sleep(REGISTRY_SYNC_RETRY_MS);
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
        }
        return count;
    }

    public void openForTraffic(int count) {
        // Renewals happen every 30 seconds and for a minute it should be a
        // factor of 2.
        this.expectedNumberOfRenewsPerMin = count * 2;
        this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                .getRenewalPercentThreshold());
        logger.info("Got " + count + " instances from neighboring DS node");
        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
        this.startupTime = System.currentTimeMillis();
        if (count > 0) {
            this.peerInstancesTransferEmptyOnStartup = false;
        }
        boolean isAws = (Name.Amazon.equals(ApplicationInfoManager
                .getInstance().getInfo().getDataCenterInfo().getName()));
        if (isAws && EUREKA_SERVER_CONFIG.shouldPrimeAwsReplicaConnections()) {
            logger.info("Priming AWS connections for all replicas..");
            primeAwsReplicas();
        }
        logger.info("Changing status to UP");
        ApplicationInfoManager.getInstance().setInstanceStatus(
                InstanceStatus.UP);
        super.postInit();
    }

    /**
     * Prime connections for Aws replicas.
     * <p>
     * Sometimes when the eureka servers comes up, AWS firewall may not allow
     * the network connections immediately. This will cause the outbound
     * connections to fail, but the inbound connections continue to work. What
     * this means is the clients would have switched to this node (after EIP
     * binding) and so the other eureka nodes will expire all instances that
     * have been switched because of the lack of outgoing heartbeats from this
     * instance.
     * </p>
     * <p>
     * The best protection in this scenario is to block and wait until we are
     * able to ping all eureka nodes successfully atleast once. Until then we
     * won't open up the traffic.
     * </p>
     */
    private void primeAwsReplicas() {
        boolean areAllPeerNodesPrimed = false;
        while (!areAllPeerNodesPrimed) {
            String peerHostName = null;
            try {
                Application eurekaApps = this.getApplication(
                        ApplicationInfoManager.getInstance().getInfo()
                                .getAppName(), false);
                if (eurekaApps == null) {
                    areAllPeerNodesPrimed = true;
                }
                for (PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                    for (InstanceInfo peerInstanceInfo : eurekaApps
                            .getInstances()) {
                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();
                        // If the lease is expired - do not worry about priming
                        if (System.currentTimeMillis() > (leaseInfo
                                .getRenewalTimestamp() + (leaseInfo
                                .getDurationInSecs() * 1000))
                                + (2 * 60 * 1000)) {
                            continue;
                        }
                        peerHostName = peerInstanceInfo.getHostName();
                        logger.info(
                                "Trying to send heartbeat for the eureka server at {} to make sure the network "
                                        + "channels are open", peerHostName);
                        // Only try to contact the eureka nodes that are in this
                        // instance's registry - because
                        // the other instances may be legitimately down
                        if (peerHostName.equalsIgnoreCase(new URI(node
                                .getServiceUrl()).getHost())) {
                            node.heartbeat(peerInstanceInfo.getAppName(),
                                    peerInstanceInfo.getId(), peerInstanceInfo,
                                    null, true);
                        }
                    }
                }
                areAllPeerNodesPrimed = true;
            } catch (Throwable e) {
                logger.error("Could not contact " + peerHostName, e);
                try {
                    Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                } catch (InterruptedException e1) {
                    logger.warn("Interrupted while priming : ", e1);
                    areAllPeerNodesPrimed = true;
                }
            }
        }
    }

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, o otherwise returns
     *         true
     */
    public boolean shouldAllowAccess(boolean remoteRegionRequired) {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (!(System.currentTimeMillis() > this.startupTime
                    + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
                return false;
            }
        }
        if (remoteRegionRequired) {
            for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
                if (!remoteRegionRegistry.isReadyForServingData()) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean shouldAllowAccess() {
        return shouldAllowAccess(true);
    }

    /**
     * Gets the list of peer eureka nodes which is the list to replicate
     * information to.
     *
     * @return the list of replica nodes.
     */
    public List<PeerEurekaNode> getReplicaNodes() {
        return Collections.unmodifiableList(peerEurekaNodes.getPeerEurekaNodes());
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#cancel(java.lang.String,
     * java.lang.String, long, boolean)
     */
    @Override
    public boolean cancel(final String appName, final String id,
                          final boolean isReplication) {
        if (super.cancel(appName, id, isReplication)) {
            replicateToPeers(Action.Cancel, appName, id, null, null,
                    isReplication);
            synchronized (lock) {
                if (this.expectedNumberOfRenewsPerMin > 0) {
                    // Since the client wants to cancel it, reduce the threshold
                    // (1
                    // for 30 seconds, 2 for a minute)
                    this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2;
                    this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Registers the information about the {@link InstanceInfo} and replicates
     * this information to all peer eureka nodes. If this is replication event
     * from other replica nodes then it is not replicated.
     *
     * @param info
     *            the {@link InstanceInfo} to be registered and replicated.
     * @param isReplication
     *            true if this is a replication event from other replica nodes,
     *            false otherwise.
     */
    @Override
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null
                && info.getLeaseInfo().getDurationInSecs() > 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(),
                info, null, isReplication);
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#renew(java.lang.String,
     * java.lang.String, long, boolean)
     */
    public boolean renew(final String appName, final String id,
                         final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null,
                    isReplication);
            return true;
        }
        return false;
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String,
     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,
     * java.lang.String, boolean)
     */
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp,
                isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus,
                    isReplication);
            return true;
        }
        return false;
    }

    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /**
     * Replicate the <em>ASG status</em> updates to peer eureka nodes. If this
     * event is a replication from other nodes, then it is not replicated to
     * other nodes.
     *
     * @param asgName
     *            the asg name for which the status needs to be replicated.
     * @param newStatus
     *            the {@link ASGStatus} information that needs to be replicated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     */
    public void statusUpdate(final String asgName, final ASGStatus newStatus,
                             final boolean isReplication) {
        // If this is replicated from an other node, do not try to replicate
        // again.
        if (isReplication) {
            return;
        }
        for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
            replicateASGInfoToReplicaNodes(asgName, newStatus, node);

        }
    }

    @Override
    public boolean isLeaseExpirationEnabled() {
        if (!isSelfPreservationModeEnabled()) {
            // The self preservation mode is disabled, hence allowing the instances to expire.
            return true;
        }
        return numberOfRenewsPerMinThreshold > 0 && getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold;
    }

    /**
     * Checks to see if the self-preservation mode is enabled.
     *
     * <p>
     * The self-preservation mode is enabled if the expected number of renewals
     * per minute {@link #getNumOfRenewsInLastMin()} is lesser than the expected
     * threshold which is determined by {@link #getNumOfRenewsPerMinThreshold()}
     * . Eureka perceives this as a danger and stops expiring instances as this
     * is most likely because of a network event. The mode is disabled only when
     * the renewals get back to above the threshold or if the flag
     * {@link EurekaServerConfig#shouldEnableSelfPreservation()} is set to
     * false.
     * </p>
     *
     * @return true if the self-preservation mode is enabled, false otherwise.
     */
    public boolean isSelfPreservationModeEnabled() {
        return EUREKA_SERVER_CONFIG.shouldEnableSelfPreservation();
    }

    /**
     * Perform all cleanup and shutdown operations.
     */
    void shutdown() {
        try {
            DefaultMonitorRegistry.getInstance().unregister(
                    Monitors.newObjectMonitor(this));
        } catch (Throwable t) {
            logger.error("Cannot shutdown monitor registry", t);
        }
        try {
            for (PeerEurekaNode node : this.peerEurekaNodes.getPeerEurekaNodes()) {
                node.shutDown();
            }
        } catch (Throwable t) {
            logger.error("Cannot shutdown ReplicaAwareInstanceRegistry", t);
        }
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String virtualHostname,
                                                boolean secure) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Updates the <em>renewal threshold</em> based on the current number of
     * renewals. The threshold is a percentage as specified in
     * {@link EurekaServerConfig#getRenewalPercentThreshold()} of renewals
     * received per minute {@link #getNumOfRenewsInLastMin()}.
     */
    private void updateRenewalThreshold() {
        try {
            LookupService lookupService = DiscoveryManager.getInstance()
                    .getLookupService();
            Applications apps = lookupService.getApplications();
            int count = 0;
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    if (this.isRegisterable(instance)) {
                        ++count;
                    }
                }
            }
            synchronized (lock) {
                // Update threshold only if the threshold is greater than the
                // current expected threshold of if the self preservation is disabled.
                if ((count * 2) > (EUREKA_SERVER_CONFIG
                        .getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
                        || (!this.isSelfPreservationModeEnabled())) {
                    this.expectedNumberOfRenewsPerMin = count * 2;
                    this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            logger.info("Current renewal threshold is : {}",
                    numberOfRenewsPerMinThreshold);
        } catch (Throwable e) {
            logger.error("Cannot update renewal threshold", e);
        }
    }

    /**
     * Gets the list of all {@link Applications} from the registry in sorted
     * lexical order of {@link Application#getName()}.
     *
     * @return the list of {@link Applications} in lexical order.
     */
    public List<Application> getSortedApplications() {
        List<Application> apps = new ArrayList<Application>(getApplications()
                .getRegisteredApplications());
        Collections.sort(apps, APP_COMPARATOR);
        return apps;
    }

    /**
     * Gets the number of <em>renewals</em> in the last minute.
     *
     * @return a long value representing the number of <em>renewals</em> in the
     *         last minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfReplicationsInLastMin",
            description = "Number of total replications received in the last minute",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public long getNumOfReplicationsInLastMin() {
        return numberOfReplicationsLastMin.getCount();
    }

    /**
     * Checks if the number of renewals is lesser than threshold.
     *
     * @return 0 if the renewals are greater than threshold, 1 otherwise.
     */
    @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public int isBelowRenewThresold() {
        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Gets the threshold for the renewals per minute.
     *
     * @return the integer representing the threshold for the renewals per
     *         minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsPerMinThreshold", type = DataSourceType.GAUGE)
    public int getNumOfRenewsPerMinThreshold() {
        return numberOfRenewsPerMinThreshold;
    }


    /**
     * Checks if an instance is registerable in this region. Instances from
     * other regions are rejected.
     *
     * @param instanceInfo
     *            - the instance info information of the instance
     * @return - true, if it can be registered in this server, false otherwise.
     */
    public boolean isRegisterable(InstanceInfo instanceInfo) {
        DataCenterInfo datacenterInfo = instanceInfo.getDataCenterInfo();
        String serverRegion = EUREKA_CLIENT_CONFIG.getRegion();
        if (AmazonInfo.class.isInstance(datacenterInfo)) {
            AmazonInfo info = AmazonInfo.class.cast(instanceInfo
                    .getDataCenterInfo());
            String availabilityZone = info.get(MetaDataKey.availabilityZone);
            // Can be null for dev environments in non-AWS data center
            if (availabilityZone == null
                    && US_EAST_1.equalsIgnoreCase(serverRegion)) {
                return true;
            } else if ((availabilityZone != null)
                    && (availabilityZone.contains(serverRegion))) {
                // If in the same region as server, then consider it
                // registerable
                return true;
            }
        }
        return true; // Everything non-amazon is registrable.
    }

    /**
     * Replicates all eureka actions to peer eureka nodes except for replication
     * traffic to this node.
     *
     */
    private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {

            if (isReplication) {
                numberOfReplicationsLastMin.increment();
            }
            // If it is a replication already, do not replicate again as this
            // will create a poison replication
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                // If the url represents this host, do not replicate
                // to yourself.
                if (isThisMe(node.getServiceUrl())) {
                    continue;
                }
                replicateInstanceActionsToPeers(action, appName, id, info,
                        newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }

    /**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                            .get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                            false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error(
                    "Cannot replicate information to " + node.getServiceUrl()
                            + " for action " + action.name(), t);
        }
    }

    /**
     * Replicates all ASG status changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateASGInfoToReplicaNodes(final String asgName,
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
        CurrentRequestVersion.set(Version.V2);
        try {
            node.statusUpdate(asgName, newStatus);

        } catch (Throwable e) {
            logger.error(
                    "Cannot replicate ASG status information to "
                            + node.getServiceUrl(), e);
        }
    }

    @Override
    @com.netflix.servo.annotations.Monitor(name = "localRegistrySize",
            description = "Current registry size", type = DataSourceType.GAUGE)
    public long getLocalRegistrySize() {
        return super.getLocalRegistrySize();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE

    @Override
    public int getRoute53BindRebindRetries() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetries", 3).get();

    }

    @Override
    public int getRoute53BindingRetryIntervalMs() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetryIntervalMs", (5 * 60 * 1000))
                .get();
    }

    @Override
    public long getRoute53DomainTTL() {
        return configInstance.getLongProperty(
                namespace + "route53DomainTTL", 30l)
                .get();
    }

    @Override
    public AwsBindingStrategy getBindingStrategy() {
        return AwsBindingStrategy.valueOf(configInstance.getStringProperty(namespace + "awsBindingStrategy", AwsBindingStrategy.EIP.name()).get().toUpperCase());
    }
=======

    @Override
    public String getExperimental(String name) {
        return configInstance.getStringProperty(namespace + "experimental." + name, null).get();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/test/java/com/netflix/eureka/InstanceRegistryTest.java;<<<<<<< MINE
=======
package com.netflix.eureka;

import java.util.List;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.Pair;
import org.junit.Assert;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

/**
 * @author Nitesh Kant
 */
public class InstanceRegistryTest extends AbstractTester {

    @Test
    public void testSoftDepRemoteUp() throws Exception {
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(false));
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(true));
    }

    @Test
    public void testGetAppsFromAllRemoteRegions() throws Exception {
        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from remote registry", REMOTE_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsDeltaFromAllRemoteRegions() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME)); /// local delta
        waitForDeltaToBeRetrieved();
        Applications appDelta = registry.getApplicationDeltasFromMultipleRegions(null);
        List<Application> registeredApplications = appDelta.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 2, registeredApplications.size());
        Application localApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                localApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app in delta.", localApplication);
        Assert.assertEquals("Local registry app instance count in delta not as expected.", 1,
                localApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app in delta", remApplication);
        Assert.assertEquals("Remote registry app instance count  in delta not as expected.", 1,
                remApplication.getInstances().size());
    }

    @Test
    public void testAppsHashCodeAfterRefresh() throws InterruptedException {
        Assert.assertEquals("UP_1_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());

        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        waitForDeltaToBeRetrieved();

        Assert.assertEquals("UP_2_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());
    }

    private void waitForDeltaToBeRetrieved() throws InterruptedException {
        int count = 0;
        System.out.println("Sleeping up to 35 seconds to let the remote registry fetch delta.");
        while (count++ < 35 && !mockRemoteEurekaServer.isSentDelta()) {
            Thread.sleep(1000);
        }
        if (!mockRemoteEurekaServer.isSentDelta()) {
            System.out.println("Waited for 35 seconds but remote server did not send delta");
        }
        // Wait 2 seconds more to be sure the delta was processed
        Thread.sleep(2000);
    }

    @Test
    public void testGetAppsFromLocalRegionOnly() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromLocalRegionOnly();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from local region do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from local registry", LOCAL_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsFromBothRegions() throws Exception {
        registerInstanceLocally(createRemoteInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from both regions do not match", 2, registeredApplications.size());
        Application locaApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                locaApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app", locaApplication);
        Assert.assertEquals("Local registry app instance count not as expected.", 1,
                locaApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app", remApplication);
        Assert.assertEquals("Remote registry app instance count not as expected.", 2,
                remApplication.getInstances().size());

    }

    @Test
    public void testStatusOverrideSetAndRemoval() throws Exception {
        // Regular registration first
        InstanceInfo myInstance = createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME);
        registerInstanceLocally(myInstance);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);

        // Override status
        boolean statusResult = registry.statusUpdate(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.OUT_OF_SERVICE, "0", false);
        assertThat("Couldn't override instance status", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Now remove override
        statusResult = registry.deleteStatusOverride(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.DOWN, "0", false);
        assertThat("Couldn't remove status override", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.DOWN);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);
    }

    @Test
    public void testEvictionTaskCompensationTime() throws Exception {
        long evictionTaskPeriodNanos = EurekaServerConfigurationManager.getInstance().getConfiguration()
                .getEvictionIntervalTimerInMs() * 1000000;

        AbstractInstanceRegistry.EvictionTask testTask = spy(registry.new EvictionTask());

        when(testTask.getCurrentTimeNano())
                .thenReturn(1l)  // less than the period
                .thenReturn(1l + evictionTaskPeriodNanos)  // exactly 1 period
                .thenReturn(1l + evictionTaskPeriodNanos*2 + 10000000l)  // 10ms longer than 1 period
                .thenReturn(1l + evictionTaskPeriodNanos*3 - 1l);  // less than 1 period

        assertThat(testTask.getCompensationTimeMs(), is(0l));
        assertThat(testTask.getCompensationTimeMs(), is(0l));
        assertThat(testTask.getCompensationTimeMs(), is(10l));
        assertThat(testTask.getCompensationTimeMs(), is(0l));
    }

    private void verifyLocalInstanceStatus(String id, InstanceStatus status) {
        InstanceInfo instanceInfo = registry.getApplication(LOCAL_REGION_APP_NAME).getByInstanceId(id);
        assertThat("InstanceInfo with id " + id + " not found", instanceInfo, is(notNullValue()));
        assertThat("Invalid InstanceInfo state", instanceInfo.getStatus(), is(equalTo(status)));
    }

    private void registerInstanceLocally(InstanceInfo remoteInstance) {
        registry.register(remoteInstance, 10000000, false);
        registeredApps.add(new Pair<String, String>(LOCAL_REGION_APP_NAME, LOCAL_REGION_APP_NAME));
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_aa986ae_507bb14/rev_aa986ae-507bb14/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_aa986ae_507bb14/rev_aa986ae-507bb14/eureka-core/src/test/java/com/netflix/eureka/cluster/ReplicationTaskProcessorTest.java;<<<<<<< MINE
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
import com.netflix.eureka.cluster.ReplicationTask.ProcessingState;
import org.junit.After;
=======
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
import com.netflix.eureka.cluster.TestableInstanceReplicationTask.ProcessingState;
import com.netflix.eureka.util.batcher.TaskProcessor.ProcessingResult;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_aa986ae_507bb14/rev_aa986ae-507bb14/eureka-core/src/test/java/com/netflix/eureka/cluster/ClusterSampleData.java;<<<<<<< MINE
    public static final long MAX_PROCESSING_DELAY_MS = 50;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE

    /**
     * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
     * the corresponding configuration can be put into experimental configuration section.
     *
     * @return a property of experimental feature
     */
    String getExperimental(String name);
=======

    /**
     * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
     * the corresponding configuration can be put into experimental configuration section.
     *
     * @return a property of experimental feature
     */
    String getExperimental(String name);


    /**
     * Get the configured binding strategy EIP or Route53.
     * @return the configured binding strategy
     */
    AwsBindingStrategy getBindingStrategy();

    /**
     *
     * @return the ttl used to set up the route53 domain if new
     */
    long getRoute53DomainTTL();

    /**
     * Gets the number of times the server should try to bind to the candidate
     * Route53 domain.
     *
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the number of times the server should try to bind to the
     *         candidate Route53 domain.
     */
    int getRoute53BindRebindRetries();

    /**
     * Gets the interval with which the server should check if the Route53 domain is bound
     * and should try to bind in the case if it is already not bound.
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the time in milliseconds.
     */
    int getRoute53BindingRetryIntervalMs();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE
import com.netflix.discovery.shared.transport.EurekaHttpResponse;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.discovery.shared.EurekaHttpClient.HttpResponse;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE
    public void shutdown() {
        batcher.stop();
    }

    private void executeSingle(List<ReplicationTask> tasks) {
        for (ReplicationTask task : tasks) {
            long lastNetworkErrorTime = 0;
            boolean done;
            do {
                done = true;
                try {
                    if (isLate(task)) {
                        continue;
                    }
                    DynamicCounter.increment("Single_" + task.getAction().name() + "_tries");

                    EurekaHttpResponse<?> httpResponse = task.execute();
                    int statusCode = httpResponse.getStatusCode();
                    Object entity = httpResponse.getEntity();
                    if (logger.isDebugEnabled()) {
                        logger.debug("Replication task {} completed with status {}, (includes entity {})", task.getTaskName(), statusCode, entity != null);
                    }
                    if (isSuccess(statusCode)) {
                        DynamicCounter.increment("Single_" + task.getAction().name() + "_success");
                        task.handleSuccess();
                    } else {
                        DynamicCounter.increment("Single_" + task.getAction().name() + "_failure");
                        task.handleFailure(statusCode, entity);
                    }
                } catch (Throwable e) {
                    if (isNetworkConnectException(e)) {
                        long now = System.currentTimeMillis();
                        // We want to retry eagerly, but without flooding log file with tons of error entries.
                        // As tasks are executed by a pool of threads the error logging multiplies. For example:
                        // 20 threads * 100ms delay == 200 error entries / sec worst case
                        // Still we would like to see the exception samples, so we print samples at regular intervals.
                        if (now - lastNetworkErrorTime > 10000) {
                            lastNetworkErrorTime = now;
                            logger.error("Network level connection to peer " + peerId + " for task " + task.getTaskName() + "; retrying after delay", e);
                        }
                        try {
                            Thread.sleep(retrySleepTimeMs);
                        } catch (InterruptedException ignore) {
                        }
                        DynamicCounter.increment(task.getAction().name() + "_retries");
                        done = false;
                    } else {
                        logger.error(peerId + ": " + task.getTaskName() + "Not re-trying this exception because it does not seem to be a network exception", e);
                    }
=======
    @Override
    public ProcessingResult process(List<ReplicationTask> tasks) {
        ReplicationList list = createReplicationListOf(tasks);
        try {
            HttpResponse<ReplicationListResponse> response = replicationClient.submitBatchUpdates(list);
            int statusCode = response.getStatusCode();
            if (!isSuccess(statusCode)) {
                if (statusCode == 503) {
                    logger.warn("Server busy (503) HTTP status code received from the peer {}; rescheduling tasks after delay", peerId);
                    return ProcessingResult.Congestion;
                } else {
                    // Unexpected error returned from the server. This should ideally never happen.
                    logger.error("Batch update failure with HTTP status code {}; discarding {} replication tasks", statusCode, tasks.size());
                    return ProcessingResult.PermanentError;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE

        Action action = list.getReplicationList().get(0).getAction();
        DynamicCounter.increment("Batch_" + action + "_tries");

        long lastNetworkErrorTime = 0;
        boolean done;
        do {
            done = true;
            try {
                EurekaHttpResponse<ReplicationListResponse> response = replicationClient.submitBatchUpdates(list);
                int statusCode = response.getStatusCode();
                if (!isSuccess(statusCode)) {
                    if (statusCode == 503) {
                        logger.warn("Server busy (503) HTTP status code received from the peer {}; rescheduling tasks after delay", peerId);
                        rescheduleAfterDelay(tasks);
                    } else {
                        // Unexpected error returned from the server. This should ideally never happen.
                        logger.error("Batch update failure with HTTP status code {}; discarding {} replication tasks", statusCode, tasks.size());
                    }
                    return;
                }
                DynamicCounter.increment("Batch_" + action + "_success");

                handleBatchResponse(tasks, response.getEntity().getResponseList());
            } catch (Throwable e) {
                if (isNetworkConnectException(e)) {
                    long now = System.currentTimeMillis();
                    // We want to retry eagerly, but without flooding log file with tons of error entries.
                    // As tasks are executed by a pool of threads the error logging multiplies. For example:
                    // 20 threads * 100ms delay == 200 error entries / sec worst case
                    // Still we would like to see the exception samples, so we print samples at regular intervals
                    if (now - lastNetworkErrorTime > 10000) {
                        lastNetworkErrorTime = now;
                        logger.error("Network level connection to peer " + peerId + "; retrying after delay", e);
                    }

                    try {
                        Thread.sleep(retrySleepTimeMs);
                    } catch (InterruptedException ignore) {
                    }
                    done = false;
                    DynamicCounter.increment("Batch_" + action + "_retries");
                } else {
                    logger.error("Not re-trying this exception because it does not seem to be a network exception", e);
                }
            }
        } while (!done);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE

    @Override
    public String getExperimental(String name) {
        return configInstance.getStringProperty(namespace + "experimental." + name, null).get();
    }
=======

    @Override
    public String getExperimental(String name) {
        return configInstance.getStringProperty(namespace + "experimental." + name, null).get();
    }

    @Override
    public int getRoute53BindRebindRetries() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetries", 3).get();

    }

    @Override
    public int getRoute53BindingRetryIntervalMs() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetryIntervalMs", (5 * 60 * 1000))
                .get();
    }

    @Override
    public long getRoute53DomainTTL() {
        return configInstance.getLongProperty(
                namespace + "route53DomainTTL", 30l)
                .get();
    }

    @Override
    public AwsBindingStrategy getBindingStrategy() {
        return AwsBindingStrategy.valueOf(configInstance.getStringProperty(namespace + "awsBindingStrategy", AwsBindingStrategy.EIP.name()).get().toUpperCase());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
@Configuration(prefix="eureka")
=======
@Configuration(prefix = "eureka")
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    
    public boolean shouldGZipContent(){
=======

    public boolean shouldGZipContent() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public int getEurekaServerReadTimeoutSeconds(){
=======
    public int getEurekaServerReadTimeoutSeconds() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public int getEurekaServerConnectTimeoutSeconds(){
=======
    public int getEurekaServerConnectTimeoutSeconds() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public boolean allowRedirects(){
=======
    public boolean allowRedirects() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public boolean shouldLogDeltaDiff(){
=======
    public boolean shouldLogDeltaDiff() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
        
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
            ? Arrays.asList(serviceUrls.split(","))
            : Collections.<String>emptyList();
=======
                ? Arrays.asList(serviceUrls.split(","))
                : Collections.<String>emptyList();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public boolean shouldFilterOnlyUpInstances(){
=======
    public boolean shouldFilterOnlyUpInstances() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public boolean shouldFetchRegistry(){
=======
    public boolean shouldFetchRegistry() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public int getHeartbeatExecutorThreadPoolSize(){
=======
    public int getHeartbeatExecutorThreadPoolSize() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public int getHeartbeatExecutorExponentialBackOffBound(){
=======
    public int getHeartbeatExecutorExponentialBackOffBound() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public int getCacheRefreshExecutorThreadPoolSize(){
=======
    public int getCacheRefreshExecutorThreadPoolSize() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
    public int getCacheRefreshExecutorExponentialBackOffBound(){
=======
    public int getCacheRefreshExecutorExponentialBackOffBound() {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;<<<<<<< MINE
=======

    @Override
    public String getExperimental(String name) {
        return config.getString("experimental." + name);
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;<<<<<<< MINE
=======

    @Override
    public String getExperimental(String name) {
        return configInstance.getStringProperty(namespace + "experimental." + name, null).get();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;<<<<<<< MINE
=======

    /**
     * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
     * the corresponding configuration can be put into experimental configuration section.
     *
     * @return a property of experimental feature
     */
    String getExperimental(String name);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b49487b_7fadaa1/rev_b49487b-7fadaa1/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.PeerAwareInstanceRegistry;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
import com.netflix.eureka.lease.Lease;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b49487b_7fadaa1/rev_b49487b-7fadaa1/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    @GET
    public StatusInfo getStatusInfo() {
        return statusUtil.getStatusInfo();
=======
    private boolean isReplicaAvailable(String myAppName, String url) {

        try {
            String givenHostName = new URI(url).getHost();
            Application app = PeerAwareInstanceRegistryImpl.getInstance()
                    .getApplication(myAppName, false);
            if (app == null) {
                return false;
            }
            for (InstanceInfo info : app.getInstances()) {
                if (info.getHostName().equals(givenHostName)) {
                    return true;
                }
            }
            givenHostName = new URI(url).getHost();
        } catch (Throwable e) {
            logger.error("Could not determine if the replica is available ", e);
        }
        return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_0f89d2a_f35b620/rev_0f89d2a-f35b620/eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java;<<<<<<< MINE
            int endIndex = cname.indexOf(regionPhrase + ".compute");
            String eipStr = cname.substring(beginIndex, endIndex);
            String eip = eipStr.replaceAll("\\-", ".");
            returnedUrls.add(eip);
=======

            // Handle case where there are no cnames containing "ec2-"
            // Reasons include:
            //  Systems without public addresses - purely attached to corp lan via AWS Direct Connect
            if (-1 < beginIndex) {
                int endIndex = cname.indexOf(regionPhrase + ".compute");
                String eipStr = cname.substring(beginIndex, endIndex);
                String eip = eipStr.replaceAll("\\-", ".");
                returnedUrls.add(eip);
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_f35b620_0f89d2a/rev_f35b620-0f89d2a/eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java;<<<<<<< MINE
            int endIndex = cname.indexOf(regionPhrase + ".compute");
            String eipStr = cname.substring(beginIndex, endIndex);
            String eip = eipStr.replaceAll("\\-", ".");
            returnedUrls.add(eip);
=======

            // Handle case where there are no cnames containing "ec2-"
            // Reasons include:
            //  Systems without public addresses - purely attached to corp lan via AWS Direct Connect
            if (-1 < beginIndex) {
                int endIndex = cname.indexOf(regionPhrase + ".compute");
                String eipStr = cname.substring(beginIndex, endIndex);
                String eip = eipStr.replaceAll("\\-", ".");
                returnedUrls.add(eip);
            }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_e7062d2_5e462f7/rev_e7062d2-5e462f7/eureka-client/src/test/java/com/netflix/discovery/guice/EurekaModuleTest.java;<<<<<<< MINE
import com.google.inject.Binding;
import com.google.inject.Key;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_203fa01_9950fce/rev_203fa01-9950fce/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;<<<<<<< MINE
            String givenHostName = new URI(url).getHost();
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_203fa01_9950fce/rev_203fa01-9950fce/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;<<<<<<< MINE
                if (info.getHostName().equals(givenHostName)) {
=======
                if (peerEurekaNodes.isInstanceURL(url, info)) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_203fa01_9950fce/rev_203fa01-9950fce/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;<<<<<<< MINE
            givenHostName = new URI(url).getHost();
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/ghostdriver/revisions/rev_30d2ebf_3b872e9/rev_30d2ebf-3b872e9/test/src/test/java/ghostdriver/CookieTest.java;<<<<<<< MINE
import org.openqa.selenium.Cookie;
=======

import java.io.IOException;
import java.util.Date;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/ghostdriver/revisions/rev_30d2ebf_3b872e9/rev_30d2ebf-3b872e9/test/src/test/java/ghostdriver/CookieTest.java;<<<<<<< MINE
    public void shouldBeAbleToAddCookie() {
        WebDriver d = getDriver();
        d.get("http://www.github.com");
=======
    public void gettingAllCookiesOnANonCookieSettingPage() {
        server.setGetHandler(EMPTY_CALLBACK);
        goToPage();
        assertEquals(0, getCookies().length);
    }

    @Test
    public void deletingAllCookies() {
        server.setGetHandler(COOKIE_SETTING_CALLBACK);
        goToPage();
        driver.manage().deleteAllCookies();

        assertEquals(0, getCookies().length);
    }

    @Test
    public void deletingOneCookie() {
        server.setGetHandler(COOKIE_SETTING_CALLBACK);
        goToPage();

        driver.manage().deleteCookieNamed("test");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/ghostdriver/revisions/rev_30d2ebf_3b872e9/rev_30d2ebf-3b872e9/test/src/test/java/ghostdriver/CookieTest.java;<<<<<<< MINE
	@Test
=======
    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE

=======
        
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
        
        public boolean hidePermissionlessHelp()
	{
		return config.getBoolean("hide-permissionless-help", true);
	}          
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;<<<<<<< MINE
			page = 1;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;<<<<<<< MINE
		List<String> lines = getHelpLines(user);
=======
		List<String> lines = getHelpLines(user, match);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;<<<<<<< MINE
	private List<String> getHelpLines(User user) throws Exception
=======
	private List<String> getHelpLines(User user, String match) throws Exception
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;<<<<<<< MINE
					if ((!match.equalsIgnoreCase("")) && (!p.getDescription().getName().toLowerCase().contains(match))
									&& (!p.getDescription().getDescription().toLowerCase().contains(match)))
					{
						continue;
					}
					
=======
					if ((!match.equalsIgnoreCase("")) && (!p.getDescription().getName().toLowerCase().contains(match))
						&& (!p.getDescription().getDescription().toLowerCase().contains(match)))
					{
						continue;
					}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;<<<<<<< MINE
								retval.add("c" + k.getKey() + "7: " + value.get("description"));
=======
								if (!ess.getSettings().hidePermissionlessHelp())
								{
									retval.add("c" + k.getKey() + "7: " + value.get("description"));
								}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
	public void onPlayerRespawn(PlayerRespawnEvent event)
=======
	public void onPlayerRespawn(final PlayerRespawnEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
				if (home == null) {
=======
				if (home == null)
				{
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
		if (spawn == null) {
=======
		if (spawn == null)
		{
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
	public void onPlayerJoin(PlayerJoinEvent event)
=======
	public void onPlayerJoin(final PlayerJoinEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
		
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
		try {
			user.getTeleport().now(ess.getSpawn().getSpawn(ess.getSettings().getNewbieSpawn()));
		} catch (Exception ex) {
			Logger.getLogger("Minecraft").log(Level.WARNING, Util.i18n("teleportNewPlayerError"), ex);
		}
=======
		ess.scheduleSyncDelayedTask(new Runnable()
		{
			public void run()
			{
				try
				{
					user.getTeleport().now(ess.getSpawn().getSpawn(ess.getSettings().getNewbieSpawn()));
				}
				catch (Exception ex)
				{
					Logger.getLogger("Minecraft").log(Level.WARNING, Util.i18n("teleportNewPlayerError"), ex);
				}
			}
		});
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/api/Economy.java;<<<<<<< MINE
import com.earth2me.essentials.UserData;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/api/Economy.java;<<<<<<< MINE
		// Use UserData to avoid calls to iConomy and Register
		return ((UserData)user).getMoney();
=======
		return user.getMoney();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/api/Economy.java;<<<<<<< MINE
		// Use UserData to avoid calls to iConomy and Register
		((UserData)user).setMoney(balance);
=======
		user.setMoney(balance);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;<<<<<<< MINE
import org.bukkit.block.CreatureSpawner;
import org.bukkit.craftbukkit.block.CraftCreatureSpawner;
=======
import org.bukkit.craftbukkit.block.CraftCreatureSpawner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;<<<<<<< MINE
		if (args.length < 1)
=======
		if (args.length < 1 || args[0].length() < 2)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;<<<<<<< MINE
		Block target = user.getTarget().getTargetBlock();
=======
		final Block target = user.getTarget().getTargetBlock();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;<<<<<<< MINE
			((CreatureSpawner)target).setCreatureType(CreatureType.fromName(args[0]));
=======
			final String name = args[0].substring(0, 1).toUpperCase() +  args[0].substring(1).toLowerCase();
			new CraftCreatureSpawner(target).setCreatureType(CreatureType.fromName(name));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
import org.bukkit.craftbukkit.entity.CraftEntity;
import com.earth2me.essentials.Essentials;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
=======
import org.bukkit.entity.Entity;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		CraftEntity spawnedMob = null;
=======
		Entity spawnedMob = null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		CraftEntity spawnedMount = null;
=======
		Entity spawnedMount = null;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		WorldServer world = ((CraftWorld)user.getWorld()).getHandle();
		try
		{
			spawnedMob = mob.spawn(user, server);
		}
		catch (MobException e)
		{
			user.sendMessage(Util.i18n("unableToSpawnMob"));
			return;
		}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
				spawnedMount = mobMount.spawn(user, server);
=======
				spawnedMount = mobMount.spawn(user, server, loc);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
			spawnedMount.teleportTo(spawnedMob);
			spawnedMount.getHandle().setPassengerOf(spawnedMob.getHandle());
			world.addEntity(spawnedMount.getHandle());
=======
			spawnedMob.setPassenger(spawnedMount);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
					spawnedMob = mob.spawn(user, server);
					spawnedMob.teleportTo(loc);
					world.addEntity(spawnedMob.getHandle());
=======
					spawnedMob = mob.spawn(user, server, loc);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
							spawnedMount = mobMount.spawn(user, server);
=======
							spawnedMount = mobMount.spawn(user, server, loc);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
						spawnedMount.teleportTo(spawnedMob);
						spawnedMount.getHandle().setPassengerOf(spawnedMob.getHandle());
						world.addEntity(spawnedMount.getHandle());
=======
						spawnedMob.setPassenger(spawnedMount);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
				user.sendMessage(args[1] + " " + mob.name.toLowerCase() + mob.s + Util.i18n("spawned"));
=======
				user.sendMessage(args[1] + " " + mob.name.toLowerCase() + mob.suffix + Util.i18n("spawned"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
	private void changeMobData(String type, CraftEntity spawned, String data, User user) throws Exception
=======
	private void changeMobData(String type, Entity spawned, String data, User user) throws Exception
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
			wolf.d(true);
			wolf.a((PathEntity)null);
=======
			wolf.setTamed(true);
			wolf.setPathEntity((PathEntity)null);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
			wolf.a(user.getName());
=======
			wolf.setOwnerName(user.getName());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Essentials.java;<<<<<<< MINE
	public static final String AUTHORS = "Zenexer, ementalo, Aelux, Brettflan, KimKandor, snowleo, ceulemans and Xeology";
	public static final int minBukkitBuildVersion = 953;
	private static final Logger logger = Logger.getLogger("Minecraft");
	private Settings settings;
	private EssentialsPlayerListener playerListener;
	private EssentialsBlockListener blockListener;
	private EssentialsEntityListener entityListener;
	private JailPlayerListener jailPlayerListener;
	private static Essentials instance = null;
	private Spawn spawn;
	private Jail jail;
	private Warps warps;
	private Worth worth;
	private List<IConf> confList;
	public ArrayList bans = new ArrayList();
	public ArrayList bannedIps = new ArrayList();
	private Backup backup;
	private final Map<String, User> users = new HashMap<String, User>();
	private EssentialsTimer timer;
	private EssentialsUpdateTimer updateTimer;
	private boolean registerFallback = true;
	private final Methods paymentMethod = new Methods();
	private final static boolean enableErrorLogging = false;
	private final EssentialsErrorHandler errorHandler = new EssentialsErrorHandler();
=======
	public static final int BUKKIT_VERSION = 974;
	private static final Logger LOGGER = Logger.getLogger("Minecraft");
	private transient ISettings settings;
	private final transient TNTExplodeListener tntListener = new TNTExplodeListener(this);
	private transient Spawn spawn;
	private transient Jail jail;
	private transient Warps warps;
	private transient Worth worth;
	private transient List<IConf> confList;
	private transient Backup backup;
	private transient BanWorkaround bans;
	private transient ItemDb itemDb;
	private transient final Map<String, User> users = new HashMap<String, User>();
	private transient EssentialsUpdateTimer updateTimer;
	private transient final Methods paymentMethod = new Methods();
	private transient final static boolean enableErrorLogging = false;
	private transient final EssentialsErrorHandler errorHandler = new EssentialsErrorHandler();
	private transient IPermissionsHandler permissionsHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
import java.lang.reflect.Constructor;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
import net.minecraft.server.Entity;
import net.minecraft.server.WorldServer;
=======
import org.bukkit.Location;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
import org.bukkit.craftbukkit.entity.CraftEntity;
import org.bukkit.craftbukkit.CraftServer;
=======
import org.bukkit.entity.CreatureType;
import org.bukkit.entity.LivingEntity;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	CHICKEN("Chicken", Enemies.FRIENDLY),
	COW("Cow", Enemies.FRIENDLY),
	CREEPER("Creeper", Enemies.ENEMY),
	GHAST("Ghast", Enemies.ENEMY),
	GIANT("Giant", "GiantZombie", Enemies.ENEMY),
	PIG("Pig", Enemies.FRIENDLY),
	PIGZOMB("PigZombie", Enemies.NEUTRAL),
	SHEEP("Sheep", Enemies.FRIENDLY, ""),
	SKELETON("Skeleton", Enemies.ENEMY),
	SLIME("Slime", Enemies.ENEMY),
	SPIDER("Spider", Enemies.ENEMY),
	SQUID("Squid", Enemies.FRIENDLY),
	ZOMBIE("Zombie", Enemies.ENEMY),
	MONSTER("Monster", Enemies.ENEMY),
	WOLF("Wolf", Enemies.NEUTRAL);
=======
	CHICKEN("Chicken", Enemies.FRIENDLY, CreatureType.CHICKEN),
	COW("Cow", Enemies.FRIENDLY, CreatureType.COW),
	CREEPER("Creeper", Enemies.ENEMY, CreatureType.CREEPER),
	GHAST("Ghast", Enemies.ENEMY, CreatureType.GHAST),
	GIANT("Giant", Enemies.ENEMY, CreatureType.GIANT),
	PIG("Pig", Enemies.FRIENDLY, CreatureType.PIG),
	PIGZOMB("PigZombie", Enemies.NEUTRAL, CreatureType.PIG_ZOMBIE),
	SHEEP("Sheep", Enemies.FRIENDLY, "", CreatureType.SHEEP),
	SKELETON("Skeleton", Enemies.ENEMY, CreatureType.SKELETON),
	SLIME("Slime", Enemies.ENEMY, CreatureType.SLIME),
	SPIDER("Spider", Enemies.ENEMY, CreatureType.SPIDER),
	SQUID("Squid", Enemies.FRIENDLY, CreatureType.SQUID),
	ZOMBIE("Zombie", Enemies.ENEMY, CreatureType.ZOMBIE),
	MONSTER("Monster", Enemies.ENEMY, CreatureType.MONSTER),
	WOLF("Wolf", Enemies.NEUTRAL, CreatureType.WOLF);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	private Mob(String n, Enemies en, String s)
=======
	private Mob(String n, Enemies en, String s, CreatureType type)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
		this.s = s;
=======
		this.suffix = s;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
		this.craftClass = n;
		this.entityClass = n;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
=======
		this.bukkitType = type;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	private Mob(String n, Enemies en)
=======
	private Mob(String n, Enemies en, CreatureType type)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
		this.craftClass = n;
		this.entityClass = n;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
=======
		this.bukkitType = type;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	private Mob(String n, String ec, Enemies en)
	{
		this.name = n;
		this.craftClass = n;
		this.entityClass = ec;
		this.type = en;
	}

	private Mob(String n, String ec, String cc, Enemies en)
	{
		this.name = n;
		this.entityClass = ec;
		this.craftClass = cc;
		this.type = en;
	}
	public String s = "s";
	public String name;
	public Enemies type;
	private String entityClass;
	private String craftClass;
=======
	public String suffix = "s";
	final public String name;
	final public Enemies type;
	final private CreatureType bukkitType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	@SuppressWarnings(
=======
	public LivingEntity spawn(final Player player, final Server server, final Location loc) throws MobException
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
		"unchecked", "CallToThreadDumpStack"
	})
	public CraftEntity spawn(Player player, Server server) throws MobException
	{
		try
		{
			WorldServer world = ((org.bukkit.craftbukkit.CraftWorld)player.getWorld()).getHandle();
			Constructor<CraftEntity> craft = (Constructor<CraftEntity>)ClassLoader.getSystemClassLoader().loadClass("org.bukkit.craftbukkit.entity.Craft" + craftClass).getConstructors()[0];
			Constructor<Entity> entity = (Constructor<Entity>)ClassLoader.getSystemClassLoader().loadClass("net.minecraft.server.Entity" + entityClass).getConstructors()[0];
			return craft.newInstance((CraftServer)server, entity.newInstance(world));
		}
		catch (Exception ex)
=======

		final LivingEntity entity = player.getWorld().spawnCreature(loc, this.bukkitType);
		if (entity == null)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
			logger.log(Level.WARNING, Util.i18n("unableToSpawnMob"), ex);
			throw new MobException(ex);
=======
			logger.log(Level.WARNING, Util.i18n("unableToSpawnMob"));
			throw new MobException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
=======
		return entity;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
		private Enemies(String t)
=======
		private Enemies(final String t)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
		protected String type;
=======
		final protected String type;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE

		private MobException(Exception ex)
		{
			super(ex);
		}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
		if (size < 1 || size > getInventory().getSize())
=======
		if (size < 1 || (getInventory() != null && size > getInventory().getSize()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_34e23e6_daaf966/rev_34e23e6-daaf966/Essentials/src/com/earth2me/essentials/DescParseTickFormat.java;<<<<<<< MINE
	// =======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_34e23e6_daaf966/rev_34e23e6-daaf966/Essentials/src/com/earth2me/essentials/DescParseTickFormat.java;<<<<<<< MINE
=======
		
		if (desc.endsWith("pm") && hours != 12)
		{
			hours += 12;
		}
		
		if (desc.endsWith("am") && hours == 12)
		{
			hours -= 12;
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandpowertool.java;<<<<<<< MINE
					user.sendMessage(Util.format("powerToolList", powertools.toString(), itemName));
=======
					user.sendMessage(Util.format("powerToolList", Util.joinList(powertools), itemName));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandpowertool.java;<<<<<<< MINE
				user.sendMessage(Util.format("powerToolAttach", powertools.toString(), itemName));
=======
				user.sendMessage(Util.format("powerToolAttach", Util.joinList(powertools), itemName));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandjails.java;<<<<<<< MINE
=======
import com.earth2me.essentials.Util;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandjails.java;<<<<<<< MINE
		StringBuilder jailList = new StringBuilder();
		for (String j : ess.getJail().getJails())
		{
			jailList.append(j);
			jailList.append(' ');
		}
		sender.sendMessage("7" + jailList);
=======
		sender.sendMessage("7" + Util.joinList(" ", ess.getJail().getJails()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		Location loc = (new TargetBlock(user, 300, 0.2, ignore)).getTargetBlock().getLocation();
=======
		Block block = (new TargetBlock(user, 300, 0.2, ignore)).getTargetBlock();
		if(block == null) {
			user.sendMessage(Util.i18n("unableToSpawnMob"));
			return;
		}
		Location loc = block.getLocation();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandhome.java;<<<<<<< MINE
				user.sendMessage(Util.format("homes", homes.toString()));
=======
				user.sendMessage(Util.format("homes", Util.joinList(homes)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandwarp.java;<<<<<<< MINE
			final StringBuilder sb = new StringBuilder();
			for (int i = 0; i < Math.min(warpNameList.size() - warpPage, WARPS_PER_PAGE); i++)
			{
				if (i > 0)
				{
					sb.append(", ");
				}
				sb.append(warpNameList.get(i + warpPage));
			}
			user.sendMessage(sb.toString());
=======
			user.sendMessage(Util.joinList(warpNameList.subList(warpPage, warpPage+Math.min(warpNameList.size() - warpPage, WARPS_PER_PAGE))));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandrepair.java;<<<<<<< MINE
			if (armor.length() > 0)
			{
				if (itemList.length() > 0)
				{
					itemList.append(", ");
				}

				itemList.append(armor);
			}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandrepair.java;<<<<<<< MINE
				user.sendMessage(Util.format("repair", itemList.toString()));
=======
				user.sendMessage(Util.format("repair", Util.joinList(itemList)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
=======
import java.util.List;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
		final StringBuilder buf = new StringBuilder();
		boolean first = true;
=======
		return joinList(", ", list);
	}
	
	public static String joinList(String seperator, Object... list)
	{
		StringBuilder buf = new StringBuilder();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
			if (!first)
=======
			if (buf.length() > 0)
			{
				buf.append(seperator);
			}
			
			if(each instanceof List)
			{
				buf.append(joinList(seperator, ((List)each).toArray()));
			}
			else
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
				buf.append(", ");

=======
				try 
				{
					buf.append(each.toString());
				}
				catch (Exception e)
				{
					buf.append(each.toString());
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
			first = false;
			buf.append(each);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
	}
=======
	}	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/Entry.java;<<<<<<< MINE
=======
package com.nijiko.permissions;

public class Entry {
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/Group.java;<<<<<<< MINE
=======
package com.nijiko.permissions;

public class Group extends Entry {

    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/User.java;<<<<<<< MINE
=======
package com.nijiko.permissions;

public class User extends Entry {
    
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/PermissionHandler.java;<<<<<<< MINE
=======
package com.nijiko.permissions;

import java.util.Collection;
import java.util.Comparator;
import java.util.Map;
import java.util.Set;

import org.bukkit.entity.Player;

/**
 * Permissions 3.0
 * Copyright (C) 2011  Matt 'The Yeti' Burnett <admin@theyeticave.net>
 * Original Credit & Copyright (C) 2010 Nijikokun <nijikokun@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Permissions Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Permissions Public License for more details.
 *
 * You should have received a copy of the GNU Permissions Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

public abstract class PermissionHandler {
    //World config manipulation methods
    
    /**
     * Sets the default world that is loaded on startup.
     * @param world World to load on startup
     */
    public abstract void setDefaultWorld(String world);
    /**
     * Check if world is loaded.
     * A world is considered as loaded if there exists a user/group storage for it or it mirrors another world.
     * @param world Target world
     * @return Whether the world is loaded.
     */
    public abstract boolean checkWorld(String world);
    
    /**
     * Attempts to load a world. If the world is already loaded, nothing happens.
     * @param world World to load
     * @return Whether world isn't already loaded
     * @throws Exception Any exception that may occur when loading the world.
     */
    public abstract boolean loadWorld(String world) throws Exception;
    /**
     * Forces a load of the world.
     * @param world World to load
     * @throws Exception Any exception that may occur when loading the world.
     */
    public abstract void forceLoadWorld(String world) throws Exception;
    /**
     * Returns a set of the names all loaded worlds. 
     * A world is considered as loaded if there exists a user/group storage for it or it mirrors another world.
     * @return Set of the names all loaded worlds. 
     */
    public abstract Set<String> getWorlds();
    /**
     * Loads the default world and global permissions.
     * @throws Exception  Any exception that may occur when loading the worlds.
     */
    public abstract void load() throws Exception;
    /**
     * Reloads all worlds
     */
    public abstract void reload();
    /**
     * Reloads the specified world
     * @param world Name of target world
     * @return False if world is not loaded, true otherwise
     */
    public abstract boolean reload(String world);
    /**
     * Forces all storages to save,
     */
    public abstract void saveAll();
    /**
     * This method forces a save of the specified world
     * @param world Name of target world
     */
    public abstract void save(String world);
    /**
     * Forces all storages to close.
     */
    public abstract void closeAll();

    //Permission-checking methods
    /**
     * This is an alias for permission(Player, String).
     * @param player Target player
     * @param node Permission node
     * @return True if the player has the specified node, false otherwise
     */
    public abstract boolean has(Player player, String node);
    /**
     * This is an alias for permission(String, String, String).
     * @param worldName Target world (may be different from player's current world)
     * @param playerName Player's name
     * @param node Permission node
     * @return True if the player has the specified node, false otherwise
     */
    public abstract boolean has(String worldName, String playerName, String node);
    /**
     * This method checks if the player has the given permissions in his/her current world.
     * In other words, this calls permissions(player.getWorld().getName(), player.getName(), node).
     * @param player Target player
     * @param node Permission node
     * @return True if the player has the specified node, false otherwise
     */
    public abstract boolean permission(Player player, String node);
    /**
     * This method checks if the player has the given permissions in the given world.
     * @param worldName Target world (may be different from player's current world)
     * @param playerName Player's name
     * @param node Permission node
     * @return True if the player has the specified node, false otherwise
     */
    public abstract boolean permission(String worldName, String playerName, String node);

    //Permission-manipulation methods
    /**
     * Adds the given permission to the targeted player.
     * @param world Target world (may be different from player's current world)
     * @param user Player's name
     * @param node Permission node
     */
    public abstract void addUserPermission(String world, String user, String node);
    /**
     * Removes the given permission from the targeted player.
     * @param world Target world (may be different from player's current world)
     * @param user Player's name
     * @param node Permission node
     */
    public abstract void removeUserPermission(String world, String user, String node);
    /**
     * Adds the given permission to the targeted group.
     * @param world Target world
     * @param user Group's name
     * @param node Permission node
     */
    public abstract void addGroupPermission(String world, String user, String node);
    /**
     * Removes the given permission from the targeted group.
     * @param world Target world
     * @param user Group's name
     * @param node Permission node
     */
    public abstract void removeGroupPermission(String world, String user, String node);

    //Chat, prefix, suffix, build methods
    /**
     * Retrieves the properly-capitalised version of the given group's name.
     * Returns an empty string if group does not exist.
     * @param world Group's world
     * @param group Group's name (any capitalisation)
     * @return Group's properly-capitalised name.
     */
    public abstract String getGroupProperName(String world, String group);
    /**
     * Gets the appropriate prefix for the user.
     * This method is a utility method for chat plugins to get the user's prefix 
     * without having to look at every one of the user's ancestors.
     * Returns an empty string if user has no parent groups.
     * @param world Player's world
     * @param user Player's name
     * @return Player's prefix
     */
    public abstract String getUserPrefix(String world, String user);
    /**
     * Gets the appropriate suffix for the user.
     * This method is a utility method for chat plugins to get the user's suffix 
     * without having to look at every one of the user's ancestors.
     * Returns an empty string if user has no parent groups.
     * @param world Player's world
     * @param user Player's name
     * @return Player's suffix
     */
    public abstract String getUserSuffix(String world, String user);
    /**
     * Gets the primary group of the user.
     * Returns the default group if user has no parent groups,
     * or null if there is no default group for that world.
     * @param world Player's world
     * @param user Player's name
     * @return Player's primary group
     */
    public abstract Group getPrimaryGroupObject(String world, String user);
    /**
     * Gets name of the primary group of the user.
     * Returns the name of the default group if user has no parent groups,
     * or "Default" if there is no default group for that world.
     * @param world Player's world
     * @param user Player's name
     * @return Name of player's primary group
     */
    public abstract String getPrimaryGroup(String world, String user);
    /**
     * Check if user can build.
     * @param world Player's world
     * @param user Player's name
     * @return Whether the user can build
     */
    public abstract boolean canUserBuild(String world, String user);
    
    /**
     * Retrieves group's raw prefix, inheritance not included.
     * Will return an empty string if no prefix is defined for the group.
     * @param world Group's world
     * @param group Group's name
     * @return The prefix defined for the group, empty string if prefix is not defined.
     */
    public abstract String getGroupRawPrefix(String world, String group);
    /**
     * Retrieves group's raw suffix, inheritance not included.
     * Will return an empty string if no suffix is defined for the group.
     * @param world Group's world
     * @param group Group's name
     * @return The suffix defined for the group, empty string if suffix is not defined.
     */
    public abstract String getGroupRawSuffix(String world, String group);
    /**
     * Retrieves group's build setting, inheritance not included.
     * @param world Group's world
     * @param group Group's name
     * @return Returns group's build setting.
     */
    public abstract boolean canGroupRawBuild(String world, String group);

    //Entry methods
    /**
     * Returns the user object defined by the given world and name.
     * This method attempts to create the object if it does not exist.
     * @param world User's world
     * @param name User's name
     * @return User object
     * @throws Exception An exception when creating the user object
     */
    public abstract User safeGetUser(String world, String name) throws Exception;
    /**
     * Returns the group object defined by the given world and name.
     * This method attempts to create the object if it does not exist.
     * @param world Group's world
     * @param name Group's name
     * @return Group object
     * @throws Exception An exception when creating the group object
     */
    public abstract Group safeGetGroup(String world, String name) throws Exception;
    /**
     * Returns the user object defined by the given world and name.
     * This method will return null if the object does not exist.
     * @param world User's world
     * @param name User's name
     * @return User object, or null if it doesn't exist
     */
    public abstract User getUserObject(String world, String name);
    /**
     * Returns the group object defined by the given world and name.
     * This method will return null if the object does not exist.
     * @param world Group's world
     * @param name Group's name
     * @return Group object, or null if it doesn't exist
     */
    public abstract Group getGroupObject(String world, String name);

    /**
     * Returns the group object representing the default group of the given world.
     * This method will return null if the object does not exist or the world has no default group.
     * @param world Target world
     * @return Group object representing default world, or null if it doesn't exist or is not defined.
     */
    public abstract Group getDefaultGroup(String world);
    /**
     * Returns all the user objects in the world.
     * Will return null if world does not exist.
     * @param world Target world
     * @return Collection of all user objects belonging to the world.
     */
    public abstract Collection<User> getUsers(String world);
    /**
     * Returns all the group objects in the world.
     * Will return null if world does not exist.
     * @param world Target world
     * @return Collection of all group objects belonging to the world.
     */
    public abstract Collection<Group> getGroups(String world);

    //Parent-related methods
    public abstract Set<String> getTracks(String world);
    /**
     * Checks if user is in specified group. Includes inherited groups.
     * @param world World of both the user and the group
     * @param user User's name
     * @param group Parent group's name
     * @return Whether user is a child of the specified group
     */
    public abstract boolean inGroup(String world, String user, String group);
    /**
     * Checks if user is in specified group. Includes inherited groups.
     * @param world User's world
     * @param user User's name
     * @param groupWorld Parent group's world
     * @param group Parent group's name
     * @return Whether user is a child of the specified group
     */
    public abstract boolean inGroup(String world, String user, String groupWorld, String group);
    /**
     * Checks if user is in specified group, not counting inherited parents.
     * @param world World of both the user and the group
     * @param user User's name
     * @param group Parent group's name
     * @return Whether user is a child of the specified group
     */
    public abstract boolean inSingleGroup(String world, String user, String group);
    /**
     * Checks if user is in specified group, not counting inherited parents.
     * @param world User's world
     * @param user User's name
     * @param groupWorld Parent group's world
     * @param group Parent group's name
     * @return Whether user is a child of the specified group
     */
    public abstract boolean inSingleGroup(String world, String user, String groupWorld, String group);
    /**
     * Gets a array of the names of all parent groups in the same world. 
     * @param world Target user's world
     * @param name Target user's name
     * @return An array containing the names of all parent groups (including ancestors) that are in the same world
     */
    public abstract String[] getGroups(String world, String name);
    /**
     * Gets a map of world name to all parent groups of the target user in that world. 
     * @param world Target user's world
     * @param name Target user's name
     * @return Map of world name to set of groups that the user inherits from in the world.
     */
    public abstract Map<String, Set<String>> getAllGroups(String world, String name);

    //Weight-related methods
    /**
     * Compare the weights of two users.
     * This method is for plugin devs to compare whether a user can do an action to another user.
     * For example, SlapPlugin can compare the weights of two users when one of them wants to /slap the other.
     * It can decide whether to allow the slap using the result of this function.
     * @param firstWorld First user's world
     * @param first First user's name
     * @param secondWorld Second user's world
     * @param second Second user's name
     * @return -1 if firstWeight < secondWeight, 0 if firstWeight == secondWeight, 1 if firstWeight > secondWeight 
     */
    public abstract int compareWeights(String firstWorld, String first, String secondWorld, String second);
    /**
     * Alias for compareWeights(world, first, world, second).
     * @param world World
     * @param first First user's name
     * @param second Second user's name
     * @return -1 if firstWeight < secondWeight, 0 if firstWeight == secondWeight, 1 if firstWeight > secondWeight 
     */
    public abstract int compareWeights(String world, String first, String second);
    
    //Data-related methods
    public abstract String getRawInfoString(String world, String entryName, String path,boolean isGroup);
    
    public abstract Integer getRawInfoInteger(String world, String entryName, String path, boolean isGroup);
    
    public abstract Double getRawInfoDouble(String world, String entryName, String path, boolean isGroup);
    
    public abstract Boolean getRawInfoBoolean(String world, String entryName, String path, boolean isGroup);


    public abstract String getInfoString(String world, String entryName, String path,boolean isGroup);
    public abstract String getInfoString(String world, String entryName, String path, boolean isGroup, Comparator<String> comparator);
    
    public abstract Integer getInfoInteger(String world, String entryName, String path, boolean isGroup);
    public abstract Integer getInfoInteger(String world, String entryName, String path, boolean isGroup, Comparator<Integer> comparator);
    
    public abstract Double getInfoDouble(String world, String entryName, String path, boolean isGroup);
    public abstract Double getInfoDouble(String world, String entryName, String path, boolean isGroup, Comparator<Double> comparator);
    
    public abstract Boolean getInfoBoolean(String world, String entryName, String path, boolean isGroup);
    public abstract Boolean getInfoBoolean(String world, String entryName, String path, boolean isGroup, Comparator<Boolean> comparator);
    
    
    public abstract void addUserInfo(String world, String name, String path, Object data);
    public abstract void removeUserInfo(String world, String name, String path);
    public abstract void addGroupInfo(String world, String name, String path, Object data);
    public abstract void removeGroupInfo(String world, String name, String path);
    
    //Legacy methods
    @Deprecated
    public abstract String getGroupPermissionString(String world, String group, String path);
    @Deprecated
    public abstract int getGroupPermissionInteger(String world, String group, String path);
    @Deprecated
    public abstract boolean getGroupPermissionBoolean(String world, String group, String path);
    @Deprecated
    public abstract double getGroupPermissionDouble(String world, String group, String path);
    
    @Deprecated
    public abstract String getUserPermissionString(String world, String group, String path);
    @Deprecated
    public abstract int getUserPermissionInteger(String world, String group, String path);
    @Deprecated
    public abstract boolean getUserPermissionBoolean(String world, String group, String path);
    @Deprecated
    public abstract double getUserPermissionDouble(String world, String group, String path);
    
    @Deprecated
    public abstract String getPermissionString(String world, String group, String path);
    @Deprecated
    public abstract int getPermissionInteger(String world, String group, String path);
    @Deprecated
    public abstract boolean getPermissionBoolean(String world, String group, String path);
    @Deprecated
    public abstract double getPermissionDouble(String world, String group, String path);
    

    @Deprecated
    public abstract String getGroup(String world, String group);

    @Deprecated
    public abstract String getGroupPrefix(String world, String group);
    @Deprecated
    public abstract String getGroupSuffix(String world, String group);
    @Deprecated
    public abstract boolean canGroupBuild(String world, String group);
    
    //Cache methods are no longer available
//    @Deprecated
//    public void setCache(String world, Map<String, Boolean> Cache) {
//    }
//    @Deprecated
//    public void setCacheItem(String world, String player, String permission, boolean data){
//    }
//    @Deprecated
//    public Map<String, Boolean> getCache(String world){
//        return null;
//    }
//    @Deprecated
//    public boolean getCacheItem(String world, String player, String permission){
//        return false;
//    }
//    @Deprecated
//    public void removeCachedItem(String world, String player, String permission){
//    }
//    @Deprecated
//    public void clearCache(String world){
//    }
//    @Deprecated
//    public void clearAllCache(){
//    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7cec201_df0d773/rev_7cec201-df0d773/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
		return config.getBoolean("nether.enabled", true);
=======
		return config.getBoolean("nether.enabled", false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7cec201_df0d773/rev_7cec201-df0d773/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
		return config.getDouble("nether.ratio", 16.0);
=======
		return config.getDouble("nether.ratio", 8.0);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	public boolean getNetherPortalsEnabled()
	{
		return isNetherEnabled() && config.getBoolean("nether.portals-enabled", false);
	}

	@Override
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	public String getNetherName()
	{
		return config.getString("nether.folder", "nether");
	}

	@Override
	public boolean isNetherEnabled()
	{
		return config.getBoolean("nether.enabled", false);
	}

	@Override
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	public boolean getGenerateExitPortals()
	{
		return config.getBoolean("nether.generate-exit-portals", true);
	}

	@Override
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	public boolean use1to1RatioInNether()
	{
		return config.getBoolean("nether.use-1to1-ratio", false);
	}

	@Override
	public double getNetherRatio()
	{
		if (config.getBoolean("nether.use-1to1-ratio", false))
		{
			return 1.0;
		}
		return config.getDouble("nether.ratio", 8.0);
	}

	@Override
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
	protected void run(Server server, User user, String commandLabel, String[] args) throws Exception
=======
	protected void run(final Server server, final User user, final String commandLabel, final String[] args) throws Exception
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
		List<World> worlds = server.getWorlds();
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
			World nether = server.getWorld(ess.getSettings().getNetherName());
			if (nether == null) {
				for (World world2 : worlds)
=======
			World nether = null;
			
			final List<World> worlds = server.getWorlds();

			for (World world2 : worlds)
			{
				if (world2.getEnvironment() == World.Environment.NETHER)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
					if (world2.getEnvironment() == World.Environment.NETHER) {
						nether = world2;
						break;
					}
				}
				if (nether == null) {
					return;
=======
					nether = world2;
					break;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
=======
			}
			if (nether == null)
			{
				return;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
			factor = ess.getSettings().getNetherRatio();
=======
			factor = 8.0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
		else if (user.getWorld().getEnvironment() != world.getEnvironment())
=======
		else if (user.getWorld().getEnvironment() == World.Environment.NORMAL && world.getEnvironment() == World.Environment.NETHER)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
			factor = 1.0 / ess.getSettings().getNetherRatio();
=======
			factor = 1.0 / 8.0;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
		else
		{
=======
		else {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
		Location loc = user.getLocation();
		loc = new Location(world, loc.getBlockX() * factor + .5, loc.getBlockY(), loc.getBlockZ() * factor + .5);
=======
		final Location loc = user.getLocation();
		final Location target = new Location(world, loc.getBlockX() * factor + .5, loc.getBlockY(), loc.getBlockZ() * factor + .5);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
		Trade charge = new Trade(this.getName(), ess);
=======
		final Trade charge = new Trade(this.getName(), ess);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;<<<<<<< MINE
		user.getTeleport().teleport(loc, charge);
=======
		user.getTeleport().teleport(target, charge);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Essentials.java;<<<<<<< MINE
		if (settings.isNetherEnabled() && getServer().getWorlds().size() < 2)
		{
			getServer().createWorld(settings.getNetherName(), World.Environment.NETHER);
		}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
		Location afk = user.getAfkPosition();
=======
		final Location afk = user.getAfkPosition();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE

		if (!ess.getSettings().getNetherPortalsEnabled())
		{
			return;
		}

		final Block block = event.getPlayer().getWorld().getBlockAt(event.getTo().getBlockX(), event.getTo().getBlockY(), event.getTo().getBlockZ());
		final List<World> worlds = server.getWorlds();

		if (block.getType() == Material.PORTAL && worlds.size() > 1 && user.isAuthorized("essentials.portal"))
		{
			if (user.getJustPortaled())
			{
				return;
			}

			World nether = server.getWorld(ess.getSettings().getNetherName());
			if (nether == null)
			{
				for (World world : worlds)
				{
					if (world.getEnvironment() == World.Environment.NETHER)
					{
						nether = world;
						break;
					}
				}
				if (nether == null)
				{
					return;
				}
			}
			final World world = user.getWorld() == nether ? worlds.get(0) : nether;

			double factor;
			if (user.getWorld().getEnvironment() == World.Environment.NETHER && world.getEnvironment() == World.Environment.NORMAL)
			{
				factor = ess.getSettings().getNetherRatio();
			}
			else if (user.getWorld().getEnvironment() == World.Environment.NORMAL && world.getEnvironment() == World.Environment.NETHER)
			{
				factor = 1.0 / ess.getSettings().getNetherRatio();
			}
			else
			{
				factor = 1.0;
			}

			Location loc = event.getTo();
			int x = loc.getBlockX();
			int y = loc.getBlockY();
			int z = loc.getBlockZ();

			if (user.getWorld().getBlockAt(x, y, z - 1).getType() == Material.PORTAL)
			{
				z--;
			}
			if (user.getWorld().getBlockAt(x - 1, y, z).getType() == Material.PORTAL)
			{
				x--;
			}

			x = (int)(x * factor);
			z = (int)(z * factor);
			loc = new Location(world, x + .5, y, z + .5);

			Block dest = world.getBlockAt(x, y, z);
			NetherPortal portal = NetherPortal.findPortal(dest);
			if (portal == null)
			{
				if (world.getEnvironment() == World.Environment.NETHER || ess.getSettings().getGenerateExitPortals())
				{
					portal = NetherPortal.createPortal(dest);
					LOGGER.info(Util.format("userCreatedPortal", event.getPlayer().getName()));
					user.sendMessage(Util.i18n("generatingPortal"));
					loc = portal.getSpawn();
				}
			}
			else
			{
				LOGGER.info(Util.format("userUsedPortal", event.getPlayer().getName()));
				user.sendMessage(Util.i18n("usingPortal"));
				loc = portal.getSpawn();
			}

			event.setFrom(loc);
			event.setTo(loc);
			try
			{
				user.getTeleport().now(loc, new Trade("portal", ess));
			}
			catch (Exception ex)
			{
				user.sendMessage(ex.getMessage());
			}
			user.setJustPortaled(true);
			user.sendMessage(Util.i18n("teleportingPortal"));

			event.setCancelled(true);
			return;
		}

		user.setJustPortaled(false);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/signs/EssentialsSign.java;<<<<<<< MINE
				if (signMat.getFacing() == blockFace && isValidSign(new BlockSign(signblock)))
=======
				if (signMat != null && signMat.getFacing() == blockFace && isValidSign(new BlockSign(signblock)))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Teleport.java;<<<<<<< MINE
		back(null);
=======
		now(new Target(user.getLastLocation()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
	boolean getGenerateExitPortals();

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
	String getNetherName();

	boolean getNetherPortalsEnabled();

	double getNetherRatio();

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
	boolean isNetherEnabled();

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
	boolean use1to1RatioInNether();

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		setPlayerListName(name);
=======
		//TODO: Maybe we need to limit nick length, or try use a string trim.
		if (name.length() <= 16) {
			setPlayerListName(name);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_9a172c7_db9df18/rev_9a172c7-db9df18/Essentials/src/com/earth2me/essentials/commands/Commandenchant.java;<<<<<<< MINE
import com.earth2me.essentials.craftbukkit.EnchantmentFix;
import java.util.*;
=======
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_9a172c7_db9df18/rev_9a172c7-db9df18/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
import static com.earth2me.essentials.I18n._;
import com.earth2me.essentials.craftbukkit.EnchantmentFix;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_9a172c7_db9df18/rev_9a172c7-db9df18/Essentials/src/com/earth2me/essentials/EssentialsConf.java;<<<<<<< MINE
import java.util.Collections;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/Essentials.java;<<<<<<< MINE
=======

	@Override
	public I18n getI18n()
	{
		return i18n;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
=======
import com.earth2me.essentials.DescParseTickFormat;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
=======
import java.text.DateFormat;
import java.util.Date;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
=======
import org.bukkit.plugin.Plugin;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
		String worlds, online, unique, playerlist;
=======
		String worlds, online, unique, playerlist, date, time;
		String worldTime12, worldTime24, worldDate, plugins;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
=======
			worldTime12 = DescParseTickFormat.format12(user.getWorld().getTime());
			worldTime24 = DescParseTickFormat.format24(user.getWorld().getTime());
			worldDate = DateFormat.getDateInstance(DateFormat.MEDIUM, ess.getI18n().getCurrentLocale()).format(DescParseTickFormat.ticksToDate(user.getWorld().getTime()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
=======
		final StringBuilder pluginlistBuilder = new StringBuilder();
		for (Plugin p : ess.getServer().getPluginManager().getPlugins())
		{
			if (pluginlistBuilder.length() > 0)
			{
				pluginlistBuilder.append(", ");
			}
			pluginlistBuilder.append(p.getDescription().getName());
		}
		plugins = pluginlistBuilder.toString();

		date = DateFormat.getDateInstance(DateFormat.MEDIUM, ess.getI18n().getCurrentLocale()).format(new Date());
		time = DateFormat.getTimeInstance(DateFormat.MEDIUM, ess.getI18n().getCurrentLocale()).format(new Date());

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
=======
			line = line.replace("{TIME}", time);
			line = line.replace("{DATE}", date);
			line = line.replace("{WORLDTIME12}", worldTime12);
			line = line.replace("{WORLDTIME24}", worldTime24);
			line = line.replace("{WORLDDATE}", worldDate);
			line = line.replace("{PLUGINS}", plugins);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/IEssentials.java;<<<<<<< MINE
=======
	
	I18n getI18n();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/commands/Commandbreak.java;<<<<<<< MINE
		final BlockBreakEvent event = new BlockBreakEvent(block, user);
=======
		final BlockBreakEvent event = new BlockBreakEvent(block, user.getBase());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/storage/AbstractDelayedYamlFileReader.java;<<<<<<< MINE
import java.util.logging.Logger;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/storage/AbstractDelayedYamlFileReader.java;<<<<<<< MINE
import org.yaml.snakeyaml.error.YAMLException;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/storage/AbstractDelayedYamlFileReader.java;<<<<<<< MINE
			Bukkit.getLogger().log(Level.WARNING, "File not found: " + file.toString());
=======
			Bukkit.getLogger().log(Level.INFO, "File not found: " + file.toString());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/Essentials.java;<<<<<<< MINE
		final Matcher versionMatch = Pattern.compile("git-Bukkit-([0-9]+).([0-9]+).([0-9]+)-R[0-9]+-b([0-9]+)jnks.*").matcher(getServer().getVersion());
=======
		final Matcher versionMatch = Pattern.compile("git-Bukkit-([0-9]+).([0-9]+).([0-9]+)-R[0-9]+-(?:[0-9]+-g[0-9a-f]+-)?b([0-9]+)jnks.*").matcher(getServer().getVersion());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsGroupManager/src/org/anjocaido/groupmanager/GroupManager.java;<<<<<<< MINE
		if (worldsHolder == null) {
			// Create the backup folder, if it doesn't exist.
			prepareFileFields();
			// Load the config.yml
			prepareConfig();
			// Load the global groups
			globalGroups = new GlobalGroups(this);
			worldsHolder = new WorldsHolder(this);
		}
=======

		// Create the backup folder, if it doesn't exist.
		prepareFileFields();
		// Load the config.yml
		prepareConfig();
		// Load the global groups
		globalGroups = new GlobalGroups(this);
		worldsHolder = new WorldsHolder(this);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
=======
		if (user.isJailed() && user.getJail() != null && !user.getJail().isEmpty())
		{
			return;
		}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/test/com/earth2me/essentials/FakeServer.java;<<<<<<< MINE
=======
import org.bukkit.event.inventory.InventoryType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/test/com/earth2me/essentials/FakeServer.java;<<<<<<< MINE
=======
import org.bukkit.help.HelpMap;
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryHolder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/test/com/earth2me/essentials/FakeServer.java;<<<<<<< MINE
=======

	@Override
	public HelpMap getHelpMap()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public Inventory createInventory(InventoryHolder ih, InventoryType it)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public Inventory createInventory(InventoryHolder ih, int i)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public Inventory createInventory(InventoryHolder ih, int i, String string)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
import com.earth2me.essentials.textreader.KeywordReplacer;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
import com.earth2me.essentials.textreader.SimpleTextPager;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
			if (kits.isConfigurationSection(name)) 
=======
			if (kits.isConfigurationSection(name))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
			}			
=======
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
	private final static double MINMONEY = -10000000000000.0;

	@Override
	public double getMinMoney()
	{
		double min = config.getDouble("min-money", MINMONEY);
		if (min > 0)
		{
			min = -min;
		}
		if (min < MINMONEY)
		{
			min = MINMONEY;
		}
		return min;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
	
	@Override
	public boolean isEcoLogUpdateEnabled()
	{
		return config.getBoolean("economy-log-update-enabled", false);
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/api/Economy.java;<<<<<<< MINE
=======
		if (balance < ess.getSettings().getMinMoney())
		{
			throw new NoLoanPermittedException();
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;<<<<<<< MINE
=======
import org.bukkit.entity.EntityType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;<<<<<<< MINE
			((CreatureSpawner)target.getBlock().getState()).setCreatureType(mob.getType());
=======
			((CreatureSpawner)target.getBlock().getState()).setSpawnedType(mob.getType());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
	private void changeMobData(final CreatureType type, final Entity spawned, final String data, final User user) throws Exception
=======
	private void changeMobData(final EntityType type, final Entity spawned, final String data, final User user) throws Exception
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		if (type == CreatureType.SLIME || type == CreatureType.MAGMA_CUBE)
=======
		if (type == EntityType.SLIME || type == EntityType.MAGMA_CUBE)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		if ((type == CreatureType.SHEEP
			 || type == CreatureType.COW
			 || type == CreatureType.MUSHROOM_COW
			 || type == CreatureType.CHICKEN
			 || type == CreatureType.PIG
			 || type == CreatureType.WOLF)
=======
		if ((type == EntityType.SHEEP
			 || type == EntityType.COW
			 || type == EntityType.MUSHROOM_COW
			 || type == EntityType.CHICKEN
			 || type == EntityType.PIG
			 || type == EntityType.WOLF)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		if (type == CreatureType.SHEEP)
=======
		if (type == EntityType.SHEEP)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		if (type == CreatureType.WOLF
=======
		if (type == EntityType.WOLF
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		if (type == CreatureType.WOLF
=======
		if (type == EntityType.WOLF
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
		if (type == CreatureType.CREEPER && data.equalsIgnoreCase("powered"))
=======
		if (type == EntityType.CREEPER && data.equalsIgnoreCase("powered"))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;<<<<<<< MINE
						EntityDeathEvent event = new EntityDeathEvent(entity, Collections.EMPTY_LIST);
=======
						EntityDeathEvent event = new EntityDeathEvent((LivingEntity)entity, Collections.EMPTY_LIST);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;<<<<<<< MINE
						EntityDeathEvent event = new EntityDeathEvent(entity, Collections.EMPTY_LIST);
=======
						EntityDeathEvent event = new EntityDeathEvent((LivingEntity)entity, Collections.EMPTY_LIST);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;<<<<<<< MINE
					EntityDeathEvent event = new EntityDeathEvent(entity, Collections.EMPTY_LIST);
=======
					EntityDeathEvent event = new EntityDeathEvent((LivingEntity)entity, Collections.EMPTY_LIST);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;<<<<<<< MINE
					EntityDeathEvent event = new EntityDeathEvent(entity, Collections.EMPTY_LIST);
=======
					EntityDeathEvent event = new EntityDeathEvent((LivingEntity)entity, Collections.EMPTY_LIST);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;<<<<<<< MINE
=======
import static com.earth2me.essentials.I18n._;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;<<<<<<< MINE
=======
					if (!player.canAfford(amount, false))
					{
						throw new Exception(_("notEnoughMoney"));
					}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;<<<<<<< MINE
=======
				if (!player.canAfford(amount, false))
				{
					throw new Exception(_("notEnoughMoney"));
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Essentials.java;<<<<<<< MINE
	public static final int BUKKIT_VERSION = 1938;
=======
	public static final int BUKKIT_VERSION = 1988;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/textreader/HelpInput.java;<<<<<<< MINE
				final HashMap<String, HashMap<String, Object>> cmds = (HashMap<String, HashMap<String, Object>>)desc.getCommands();
=======
				final Map<String, Map<String, Object>> cmds = desc.getCommands();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/textreader/HelpInput.java;<<<<<<< MINE
				for (Map.Entry<String, HashMap<String, Object>> k : cmds.entrySet())
=======
				for (Map.Entry<String, Map<String, Object>> k : cmds.entrySet())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/textreader/HelpInput.java;<<<<<<< MINE
								final HashMap<String, Object> value = k.getValue();
=======
								final Map<String, Object> value = k.getValue();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;<<<<<<< MINE
import com.earth2me.essentials.craftbukkit.OfflineBedLocation;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;<<<<<<< MINE
=======
import org.bukkit.conversations.Conversation;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;<<<<<<< MINE
=======
import org.bukkit.inventory.Inventory;
import org.bukkit.inventory.InventoryView;
import org.bukkit.inventory.InventoryView.Property;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;<<<<<<< MINE
=======
import org.bukkit.metadata.MetadataValue;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;<<<<<<< MINE
	public boolean isPlayer()
	{
		return false;
	}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;<<<<<<< MINE
=======

	@Override
	public <T extends Projectile> T launchProjectile(Class<? extends T> arg0)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public EntityType getType()
	{
		return EntityType.PLAYER;
	}

	@Override
	public <T> void playEffect(Location lctn, Effect effect, T t)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public boolean setWindowProperty(Property prprt, int i)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public InventoryView getOpenInventory()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public InventoryView openInventory(Inventory invntr)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public InventoryView openWorkbench(Location lctn, boolean bln)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public InventoryView openEnchanting(Location lctn, boolean bln)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void openInventory(InventoryView iv)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void closeInventory()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public ItemStack getItemOnCursor()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void setItemOnCursor(ItemStack is)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void setMetadata(String string, MetadataValue mv)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public List<MetadataValue> getMetadata(String string)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public boolean hasMetadata(String string)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void removeMetadata(String string, Plugin plugin)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}


	@Override
	public boolean isConversing()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void acceptConversationInput(String string)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public boolean beginConversation(Conversation c)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void abandonConversation(Conversation c)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void sendMessage(String[] strings)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
			final double mon = user.getMoney();
			if (mon < getMoney() && getMoney() > 0 && !user.isAuthorized("essentials.eco.loan"))
=======
			if (!user.canAfford(getMoney()) && getMoney() > 0)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
			final double mon = user.getMoney();
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
			if (mon < cost && cost > 0 && !user.isAuthorized("essentials.eco.loan"))
=======
			if (!user.canAfford(cost) && cost > 0)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
		if (!ess.getSettings().isEcoLogEnabled())
=======
		if ((loc == null && !ess.getSettings().isEcoLogUpdateEnabled())
			|| (loc != null && !ess.getSettings().isEcoLogEnabled()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
import org.bukkit.entity.CreatureType;
=======
import org.bukkit.entity.EntityType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	CHICKEN("Chicken", Enemies.FRIENDLY, CreatureType.CHICKEN),
	COW("Cow", Enemies.FRIENDLY, CreatureType.COW),
	CREEPER("Creeper", Enemies.ENEMY, CreatureType.CREEPER),
	GHAST("Ghast", Enemies.ENEMY, CreatureType.GHAST),
	GIANT("Giant", Enemies.ENEMY, CreatureType.GIANT),
	PIG("Pig", Enemies.FRIENDLY, CreatureType.PIG),
	PIGZOMB("PigZombie", Enemies.NEUTRAL, CreatureType.PIG_ZOMBIE),
	SHEEP("Sheep", Enemies.FRIENDLY, "", CreatureType.SHEEP),
	SKELETON("Skeleton", Enemies.ENEMY, CreatureType.SKELETON),
	SLIME("Slime", Enemies.ENEMY, CreatureType.SLIME),
	SPIDER("Spider", Enemies.ENEMY, CreatureType.SPIDER),
	SQUID("Squid", Enemies.FRIENDLY, CreatureType.SQUID),
	ZOMBIE("Zombie", Enemies.ENEMY, CreatureType.ZOMBIE),
	WOLF("Wolf", Enemies.NEUTRAL, CreatureType.WOLF),
	CAVESPIDER("CaveSpider", Enemies.ENEMY, CreatureType.CAVE_SPIDER),
	ENDERMAN("Enderman", Enemies.ENEMY, "", CreatureType.ENDERMAN),
	SILVERFISH("Silverfish", Enemies.ENEMY, "", CreatureType.SILVERFISH),
	ENDERDRAGON("EnderDragon", Enemies.ENEMY, CreatureType.ENDER_DRAGON),
	VILLAGER("Villager", Enemies.FRIENDLY, CreatureType.VILLAGER),
	BLAZE("Blaze", Enemies.ENEMY, CreatureType.BLAZE),
	MUSHROOMCOW("MushroomCow", Enemies.FRIENDLY, CreatureType.MUSHROOM_COW),
	MAGMACUBE("MagmaCube", Enemies.ENEMY, CreatureType.MAGMA_CUBE),
	SNOWMAN("Snowman", Enemies.FRIENDLY, "", CreatureType.SNOWMAN);
=======
	CHICKEN("Chicken", Enemies.FRIENDLY, EntityType.CHICKEN),
	COW("Cow", Enemies.FRIENDLY, EntityType.COW),
	CREEPER("Creeper", Enemies.ENEMY, EntityType.CREEPER),
	GHAST("Ghast", Enemies.ENEMY, EntityType.GHAST),
	GIANT("Giant", Enemies.ENEMY, EntityType.GIANT),
	PIG("Pig", Enemies.FRIENDLY, EntityType.PIG),
	PIGZOMB("PigZombie", Enemies.NEUTRAL, EntityType.PIG_ZOMBIE),
	SHEEP("Sheep", Enemies.FRIENDLY, "", EntityType.SHEEP),
	SKELETON("Skeleton", Enemies.ENEMY, EntityType.SKELETON),
	SLIME("Slime", Enemies.ENEMY, EntityType.SLIME),
	SPIDER("Spider", Enemies.ENEMY, EntityType.SPIDER),
	SQUID("Squid", Enemies.FRIENDLY, EntityType.SQUID),
	ZOMBIE("Zombie", Enemies.ENEMY, EntityType.ZOMBIE),
	WOLF("Wolf", Enemies.NEUTRAL, EntityType.WOLF),
	CAVESPIDER("CaveSpider", Enemies.ENEMY, EntityType.CAVE_SPIDER),
	ENDERMAN("Enderman", Enemies.ENEMY, "", EntityType.ENDERMAN),
	SILVERFISH("Silverfish", Enemies.ENEMY, "", EntityType.SILVERFISH),
	ENDERDRAGON("EnderDragon", Enemies.ENEMY, EntityType.ENDER_DRAGON),
	VILLAGER("Villager", Enemies.FRIENDLY, EntityType.VILLAGER),
	BLAZE("Blaze", Enemies.ENEMY, EntityType.BLAZE),
	MUSHROOMCOW("MushroomCow", Enemies.FRIENDLY, EntityType.MUSHROOM_COW),
	MAGMACUBE("MagmaCube", Enemies.ENEMY, EntityType.MAGMA_CUBE),
	SNOWMAN("Snowman", Enemies.FRIENDLY, "", EntityType.SNOWMAN);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	private Mob(String n, Enemies en, String s, CreatureType type)
=======
	private Mob(String n, Enemies en, String s, EntityType type)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	private Mob(String n, Enemies en, CreatureType type)
=======
	private Mob(String n, Enemies en, EntityType type)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	final private CreatureType bukkitType;
=======
	final private EntityType bukkitType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
	public CreatureType getType()
=======
	public EntityType getType()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignFree.java;<<<<<<< MINE
import com.earth2me.essentials.craftbukkit.ShowInventory;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignFree.java;<<<<<<< MINE
=======
import org.bukkit.event.inventory.InventoryType;
import org.bukkit.inventory.Inventory;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignFree.java;<<<<<<< MINE
		ShowInventory.showFilledInventory(player.getBase(), item);
=======
		Inventory i = ess.getServer().createInventory(player, InventoryType.CHEST);
		i.addItem(item);
		player.openInventory(i);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignDisposal.java;<<<<<<< MINE
import com.earth2me.essentials.craftbukkit.ShowInventory;
=======
import org.bukkit.event.inventory.InventoryType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignDisposal.java;<<<<<<< MINE
		ShowInventory.showEmptyInventory(player.getBase());
=======
		player.getBase().openInventory(ess.getServer().createInventory(player, InventoryType.CHEST));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/user/User.java;<<<<<<< MINE
=======

	@Override
	public boolean canAfford(final double cost)
	{
		final double mon = getMoney();
		if (isAuthorized("essentials.eco.loan"))
		{
			return (mon - cost) >= ess.getSettings().getMinMoney();
		}
		return cost <= mon;
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Jails.java;<<<<<<< MINE
		@EventHandler(priority = EventPriority.HIGH)
=======
		@EventHandler(priority = EventPriority.HIGHEST)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Jails.java;<<<<<<< MINE
		@EventHandler(priority = EventPriority.HIGH)
=======
		@EventHandler(priority = EventPriority.HIGHEST)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
=======
	
	double getMinMoney();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
=======
	
	boolean isEcoLogUpdateEnabled();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;<<<<<<< MINE
=======
import java.util.List;
import java.util.ListIterator;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;<<<<<<< MINE
=======
import org.bukkit.entity.HumanEntity;
import org.bukkit.event.inventory.InventoryType;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;<<<<<<< MINE
=======
import org.bukkit.inventory.InventoryHolder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;<<<<<<< MINE
=======

	@Override
	public List<HumanEntity> getViewers()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public String getTitle()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public InventoryType getType()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public InventoryHolder getHolder()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public ListIterator<ItemStack> iterator()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeWorld.java;<<<<<<< MINE
=======
import org.bukkit.metadata.MetadataValue;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeWorld.java;<<<<<<< MINE
=======

	@Override
	public LivingEntity spawnCreature(Location arg0, EntityType arg1)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public <T> void playEffect(Location lctn, Effect effect, T t)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public <T> void playEffect(Location lctn, Effect effect, T t, int i)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void setMetadata(String string, MetadataValue mv)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public List<MetadataValue> getMetadata(String string)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public boolean hasMetadata(String string)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}

	@Override
	public void removeMetadata(String string, Plugin plugin)
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
import org.bukkit.ChatColor;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
			initiator.sendMessage(_("addedToOthersAccount", Util.formatCurrency(value, ess), this.getDisplayName()));
=======
			initiator.sendMessage(_("addedToOthersAccount", Util.formatCurrency(value, ess), this.getDisplayName(), Util.formatCurrency(getMoney(), ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
			initiator.sendMessage(_("takenFromOthersAccount", Util.formatCurrency(value, ess), this.getDisplayName()));
=======
			initiator.sendMessage(_("takenFromOthersAccount", Util.formatCurrency(value, ess), this.getDisplayName(), Util.formatCurrency(getMoney(), ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
=======
		return canAfford(cost, true);
	}

	public boolean canAfford(final double cost, final boolean permcheck)
	{
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		return mon >= cost || isAuthorized("essentials.eco.loan");
=======
		if (!permcheck || isAuthorized("essentials.eco.loan"))
		{
			return (mon - cost) >= ess.getSettings().getMinMoney();
		}
		return cost <= mon;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		}
=======
		}		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
=======
		Trade.log("Update", "Set", "API", getName(), new Trade(value, ess), null, null, null, ess);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		{			
=======
		{
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/IUser.java;<<<<<<< MINE
=======
	
	boolean canAfford(double value);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsUpdate/src/com/earth2me/essentials/update/VersionInfo.java;<<<<<<< MINE
		changelog = updateConfig.getList(path + ".changelog", Collections.<String>emptyList());
=======
		changelog = updateConfig.getStringList(path + ".changelog");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsUpdate/src/com/earth2me/essentials/update/states/InstallationFinishedEvent.java;<<<<<<< MINE
=======
import org.bukkit.event.HandlerList;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsUpdate/src/com/earth2me/essentials/update/states/InstallationFinishedEvent.java;<<<<<<< MINE
=======

	@Override
	public HandlerList getHandlers()
	{
		throw new UnsupportedOperationException("Not supported yet.");
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
=======
import com.earth2me.essentials.*;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
import com.earth2me.essentials.IEssentials;
import com.earth2me.essentials.OfflinePlayer;
import com.earth2me.essentials.User;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
=======
import java.util.List;
import java.util.Locale;
import java.util.Map;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
		final User user = ess.getUser(event.getPlayer());

		if (user.hasPlayedBefore())
=======
		if (event.getPlayer().hasPlayedBefore())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
=======

		final User user = ess.getUser(event.getPlayer());

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
=======
		final String kitName = ess.getSettings().getNewPlayerKit();
		if (!kitName.isEmpty())
		{
			try
			{
				final Map<String, Object> kit = ess.getSettings().getKit(kitName.toLowerCase(Locale.ENGLISH));
				final List<String> items = Kit.getItems(user, kit);
				Kit.expandItems(ess, user, items);
			}
			catch (Exception ex)
			{
				LOGGER.log(Level.WARNING, ex.getMessage());
			}
		}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;<<<<<<< MINE
				Location spawn = spawns.getSpawn(ess.getSettings().getNewbieSpawn());
=======
				final Location spawn = spawns.getSpawn(ess.getSettings().getNewbieSpawn());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsBlockListener.java;<<<<<<< MINE
		boolean unlimitedForUser = user.hasUnlimited(is);
=======
		final boolean unlimitedForUser = user.hasUnlimited(is);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
import org.bukkit.configuration.MemoryConfiguration;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
	private ConfigurationSection kits;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	@Override
	public Map<String, Object> getKit(String name)
=======
	public ConfigurationSection _getKits()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
		name = name.replace('.', '_').replace('/', '_');
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
			final ConfigurationSection kits = getKits();
			if (kits.isConfigurationSection(name))
			{
				return kits.getConfigurationSection(name).getValues(true);
=======
			final ConfigurationSection section = config.getConfigurationSection("kits");
			final ConfigurationSection newSection = new MemoryConfiguration();
			for (String kitItem : section.getKeys(false))
			{
				if (section.isConfigurationSection(kitItem))
				{
					newSection.set(kitItem.toLowerCase(Locale.ENGLISH), section.getConfigurationSection(kitItem));
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
			return newSection;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
		return kits;
	}

	@Override
	public Map<String, Object> getKit(String name)
	{
		name = name.replace('.', '_').replace('/', '_');
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
			return config.getConfigurationSection("kits");
=======
			final ConfigurationSection kits = getKits();
			if (kits.isConfigurationSection(name))
			{
				return kits.getConfigurationSection(name).getValues(true);
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
=======
	public String getNewPlayerKit()
	{
		return config.getString("newbies.kit", "");
	}

	@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
		enabledSigns = getEnabledSigns();
		itemSpawnBl = getItemSpawnBlacklist();
=======
		enabledSigns = _getEnabledSigns();
		itemSpawnBl = _getItemSpawnBlacklist();
		kits = _getKits();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	private List<Integer> getItemSpawnBlacklist()
=======
	private List<Integer> _getItemSpawnBlacklist()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	private List<EssentialsSign> getEnabledSigns()
=======
	private List<EssentialsSign> _getEnabledSigns()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/api/Economy.java;<<<<<<< MINE
		return Util.formatCurrency(amount, ess);
=======
		return Util.displayCurrency(amount, ess);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalancetop.java;<<<<<<< MINE
					cache.getLines().add(_("serverTotal", Util.formatCurrency(totalMoney, ess)));
=======
					cache.getLines().add(_("serverTotal", Util.displayCurrency(totalMoney, ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalancetop.java;<<<<<<< MINE
						cache.getLines().add(pos + ". " + entry.getKey() + ", " + Util.formatCurrency(entry.getValue(), ess));
=======
						cache.getLines().add(pos + ". " + entry.getKey() + ", " + Util.displayCurrency(entry.getValue(), ess));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandlist.java;<<<<<<< MINE
=======
import com.earth2me.essentials.Util;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandlist.java;<<<<<<< MINE
				groupString.append(group).append(": ");
=======
				groupString.append(_("listGroupTag",Util.replaceColor(group)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;<<<<<<< MINE
=======
import org.bukkit.command.ConsoleCommandSender;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;<<<<<<< MINE
=======
		else if (args[0].equalsIgnoreCase("moo"))
		{
			run_moo(server, sender, commandLabel, args);
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;<<<<<<< MINE
					loc.getBlock().setType(Material.NOTE_BLOCK);
=======
					player.sendBlockChange(loc, Material.NOTE_BLOCK, (byte)0);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;<<<<<<< MINE
			return;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;<<<<<<< MINE
=======
	
	private void run_moo(final Server server, final CommandSender sender, final String command, final String args[])
	{
		if(sender instanceof ConsoleCommandSender)
			sender.sendMessage(new String[]{"         (__)", "         (oo)", "   /------\\/", "  / |    ||", " *  /\\---/\\", "    ~~   ~~", "....\"Have you mooed today?\"..." } );
		else
			sender.sendMessage(new String[]{"            (__)", "            (oo)", "   /------\\/", "  /  |      | |", " *  /\\---/\\", "    ~~    ~~", "....\"Have you mooed today?\"..." } );
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandsell.java;<<<<<<< MINE
		user.sendMessage(_("itemSold", Util.formatCurrency(worth * amount, ess), amount, is.getType().toString().toLowerCase(Locale.ENGLISH), Util.formatCurrency(worth, ess)));
		logger.log(Level.INFO, _("itemSoldConsole", user.getDisplayName(), is.getType().toString().toLowerCase(Locale.ENGLISH), Util.formatCurrency(worth * amount, ess), amount, Util.formatCurrency(worth, ess)));
=======
		user.sendMessage(_("itemSold", Util.displayCurrency(worth * amount, ess), amount, is.getType().toString().toLowerCase(Locale.ENGLISH), Util.displayCurrency(worth, ess)));
		logger.log(Level.INFO, _("itemSoldConsole", user.getDisplayName(), is.getType().toString().toLowerCase(Locale.ENGLISH), Util.displayCurrency(worth * amount, ess), amount, Util.displayCurrency(worth, ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							 Util.formatCurrency(worth * amount, ess),
=======
							 Util.displayCurrency(worth * amount, ess),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							 Util.formatCurrency(worth, ess))
=======
							 Util.displayCurrency(worth, ess))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							 Util.formatCurrency(worth * amount, ess),
=======
							 Util.displayCurrency(worth * amount, ess),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							 Util.formatCurrency(worth, ess)));
=======
							 Util.displayCurrency(worth, ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							   Util.formatCurrency(worth * amount, ess),
=======
							   Util.displayCurrency(worth * amount, ess),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							   Util.formatCurrency(worth, ess))
=======
							   Util.displayCurrency(worth, ess))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							   Util.formatCurrency(worth * amount, ess),
=======
							   Util.displayCurrency(worth * amount, ess),
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;<<<<<<< MINE
							   Util.formatCurrency(worth, ess)));
=======
							   Util.displayCurrency(worth, ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandantioch.java;<<<<<<< MINE
		ess.broadcastMessage(user, "...lobbest thou thy Holy Hand Grenade of Antioch towards thy foe,");
		ess.broadcastMessage(user, "who being naughty in My sight, shall snuff it.");
=======
		if (args.length > 0)
		{
			ess.broadcastMessage(user, "...lobbest thou thy Holy Hand Grenade of Antioch towards thy foe,");
			ess.broadcastMessage(user, "who being naughty in My sight, shall snuff it.");
		}		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
import java.util.Locale;
import java.util.Random;
import java.util.Set;
=======
import java.util.*;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
			Set<String> availableList = Mob.getMobList();
			for (String mob : availableList)
=======
			final Set<String> mobList = Mob.getMobList();
			final Set<String> availableList = new HashSet<String>();
			for (String mob : mobList)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
				if (!user.isAuthorized("essentials.spawnmob." + mob.toLowerCase()))
=======
				if (user.isAuthorized("essentials.spawnmob." + mob.toLowerCase()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
					availableList.remove(mob);
=======
					availableList.add(mob);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;<<<<<<< MINE
				user.sendMessage(args[1] + " " + mob.name.toLowerCase(Locale.ENGLISH) + mob.suffix + " " + _("spawned"));
=======
				user.sendMessage(mobCount + " " + mob.name.toLowerCase(Locale.ENGLISH) + mob.suffix + " " + _("spawned"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalance.java;<<<<<<< MINE
		sender.sendMessage(_("balance", Util.formatCurrency(getPlayer(server, args, 0, true).getMoney(), ess)));
=======
		sender.sendMessage(_("balance", Util.displayCurrency(getPlayer(server, args, 0, true).getMoney(), ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalance.java;<<<<<<< MINE
		user.sendMessage(_("balance", Util.formatCurrency(bal, ess)));
=======
		user.sendMessage(_("balance", Util.displayCurrency(bal, ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandwhois.java;<<<<<<< MINE
				sender.sendMessage(_("whoisMoney", Util.formatCurrency(user.getMoney(), ess)));
=======
				sender.sendMessage(_("whoisMoney", Util.displayCurrency(user.getMoney(), ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;<<<<<<< MINE
		if (args[1].contentEquals("*"))
=======
		if (args[1].contentEquals("**"))
		{
			for (String sUser : ess.getUserMap().getAllUniqueUsers())
			{
				final User player = ess.getUser(sUser);
				switch (cmd)
				{
				case GIVE:
					player.giveMoney(amount);
					break;

				case TAKE:
					if (player.canAfford(amount, false))
					{
						player.takeMoney(amount);
					}					
					break;

				case RESET:
					player.setMoney(amount == 0 ? ess.getSettings().getStartingBalance() : amount);
					break;
				}
			}
		}
		else if (args[1].contentEquals("*"))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
		if (event.getResult() != Result.ALLOWED && event.getResult() != Result.KICK_FULL && event.getResult() != Result.KICK_BANNED)
=======
		switch (event.getResult())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
=======
		case ALLOWED:
		case KICK_FULL:
		case KICK_BANNED:
			break;
		default:
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
		if (banExpired == false && (user.isBanned() || event.getResult() == Result.KICK_BANNED))
=======
		if (!banExpired && (user.isBanned() || event.getResult() == Result.KICK_BANNED))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
		final User user = ess.getUser(event.getPlayer());
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
=======
			final User user = ess.getUser(event.getPlayer());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
		if (ess.getSettings().changeDisplayName())
		{
			user.setDisplayNick();
		}
		updateCompass(user);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
	@EventHandler(priority = EventPriority.NORMAL)
	public void onPlayerAnimation(final PlayerAnimationEvent event)
	{
		final User user = ess.getUser(event.getPlayer());
		user.updateActivity(true);
	}

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
				User spyer = ess.getUser(player);
=======
				final User spyer = ess.getUser(player);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
=======
		final User user = ess.getUser(event.getPlayer());
		if (ess.getSettings().changeDisplayName())
		{
			user.setDisplayNick();
		}
		updateCompass(user);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
			User user = ess.getUser(event.getPlayer());
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
	@EventHandler(priority = EventPriority.MONITOR)
=======
	@EventHandler(priority = EventPriority.NORMAL)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
=======
		final User user = ess.getUser(event.getPlayer());
		user.updateActivity(true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
			final User user = ess.getUser(event.getPlayer());
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
	public void onPlayerPickupItem(PlayerPickupItemEvent event)
=======
	public void onPlayerPickupItem(final PlayerPickupItemEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;<<<<<<< MINE
=======
import static com.earth2me.essentials.I18n.capitalCase;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;<<<<<<< MINE
					list.append(" ").append(kiteItem);
=======
					list.append(" ").append(capitalCase(kiteItem));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;<<<<<<< MINE
	public static List<String> getItems(final User user, final Map<String, Object> els) throws Exception
=======
	public static List<String> getItems(final User user, final Map<String, Object> kit) throws Exception
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;<<<<<<< MINE
=======
		if (kit == null)
		{
			throw new Exception(_("kitError2"));
		}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;<<<<<<< MINE
			return (List<String>)els.get("items");
=======
			return (List<String>)kit.get("items");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
=======
import java.util.Collections;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Mob.java;<<<<<<< MINE
		return hashMap.keySet();
=======
		return Collections.unmodifiableSet(hashMap.keySet());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/EssentialsSign.java;<<<<<<< MINE
			sign.setLine(index, Util.formatCurrency(money, ess));
=======
			sign.setLine(index, Util.shortCurrency(money, ess));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;<<<<<<< MINE
				if (Util.formatCurrency(money, ess).length() * 2 > 15)
=======
				if (Util.shortCurrency(money, ess).length() * 2 > 15)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;<<<<<<< MINE
				sign.setLine(index, Util.formatCurrency(money, ess) + ":0");
=======
				sign.setLine(index, Util.shortCurrency(money, ess) + ":0");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;<<<<<<< MINE
				sign.setLine(index, Util.formatCurrency(money, ess) + ":" + Util.formatCurrency(amount, ess).substring(1));
=======
				sign.setLine(index, Util.shortCurrency(money, ess) + ":" + Util.shortCurrency(amount, ess).substring(1));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;<<<<<<< MINE
				final String newline = Util.formatCurrency(money, ess) + ":" + Util.formatCurrency(amount + value, ess).substring(1);
=======
				final String newline = Util.shortCurrency(money, ess) + ":" + Util.shortCurrency(amount + value, ess).substring(1);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
	private static DecimalFormat df = new DecimalFormat("#0.00", DecimalFormatSymbols.getInstance(Locale.US));
=======
	private static DecimalFormat dFormat = new DecimalFormat("#0.00", DecimalFormatSymbols.getInstance(Locale.US));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
	public static String formatCurrency(final double value, final IEssentials ess)
=======
	public static String formatAsCurrency(final double value)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
		String str = ess.getSettings().getCurrencySymbol() + df.format(value);
=======
		String str = dFormat.format(value);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;<<<<<<< MINE
=======
	public static String displayCurrency(final double value, final IEssentials ess)
	{
		return _("currency", ess.getSettings().getCurrencySymbol(), formatAsCurrency(value));
	}

	public static String shortCurrency(final double value, final IEssentials ess)
	{
		return ess.getSettings().getCurrencySymbol() + formatAsCurrency(value);
	}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
		godmode = getGodModeEnabled();
=======
		godmode = _getGodModeEnabled();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
=======
		nickname = _getNickname();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
=======
	private String nickname;
	
	public String _getNickname()
	{
		return config.getString("nickname");
	}
	
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
		return config.getString("nickname");
=======
		return nickname;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
=======
		nickname = nick;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
	private boolean getGodModeEnabled()
=======
	private boolean _getGodModeEnabled()
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
		
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;<<<<<<< MINE
		return new HashMap<String, Object>();		
=======
		return new HashMap<String, Object>();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
=======
	String getNewPlayerKit();

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/ISettings.java;<<<<<<< MINE
	
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		sendMessage(_("addedToAccount", Util.formatCurrency(value, ess)));
=======
		sendMessage(_("addedToAccount", Util.displayCurrency(value, ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
			initiator.sendMessage(_("addedToOthersAccount", Util.formatCurrency(value, ess), this.getDisplayName(), Util.formatCurrency(getMoney(), ess)));
=======
			initiator.sendMessage(_("addedToOthersAccount", Util.displayCurrency(value, ess), this.getDisplayName(), Util.displayCurrency(getMoney(), ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
			sendMessage(_("moneySentTo", Util.formatCurrency(value, ess), reciever.getDisplayName()));
			reciever.sendMessage(_("moneyRecievedFrom", Util.formatCurrency(value, ess), getDisplayName()));
=======
			sendMessage(_("moneySentTo", Util.displayCurrency(value, ess), reciever.getDisplayName()));
			reciever.sendMessage(_("moneyRecievedFrom", Util.displayCurrency(value, ess), getDisplayName()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		sendMessage(_("takenFromAccount", Util.formatCurrency(value, ess)));
=======
		sendMessage(_("takenFromAccount", Util.displayCurrency(value, ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
			initiator.sendMessage(_("takenFromOthersAccount", Util.formatCurrency(value, ess), this.getDisplayName(), Util.formatCurrency(getMoney(), ess)));
=======
			initiator.sendMessage(_("takenFromOthersAccount", Util.displayCurrency(value, ess), this.getDisplayName(), Util.displayCurrency(getMoney(), ess)));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
	public String getNick(boolean addprefixsuffix)
=======
	public String getNick(final boolean addprefixsuffix)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		if (isOp())
=======

		if (addprefixsuffix && isOp())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
				nickname.insert(0, ess.getSettings().getOperatorColor().toString());
				nickname.append("f");
=======
				final String opPrefix = ess.getSettings().getOperatorColor().toString();
				if (opPrefix.length() > 0) {
					nickname.insert(0, opPrefix);
					nickname.append("f");
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
				final String prefix = ess.getPermissionsHandler().getPrefix(base).replace('&', '').replace("{WORLDNAME}", this.getWorld().getName());
=======
				final String prefix = ess.getPermissionsHandler().getPrefix(base).replace('&', '');
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
				final String suffix = ess.getPermissionsHandler().getSuffix(base).replace('&', '').replace("{WORLDNAME}", this.getWorld().getName());
=======
				final String suffix = ess.getPermissionsHandler().getSuffix(base).replace('&', '');
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
=======
	@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;<<<<<<< MINE
		}		
=======
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
	public void onEntityDamage(EntityDamageEvent event)
=======
	public void onEntityDamage(final EntityDamageByEntityEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
		if (event instanceof EntityDamageByEntityEvent)
		{
			EntityDamageByEntityEvent edEvent = (EntityDamageByEntityEvent)event;
			Entity eAttack = edEvent.getDamager();
			Entity eDefend = edEvent.getEntity();
			if (eDefend instanceof Player && eAttack instanceof Player)
=======
		final Entity eAttack = event.getDamager();
		final Entity eDefend = event.getEntity();
		if (eDefend instanceof Player && eAttack instanceof Player)
		{
			final User defender = ess.getUser(eDefend);
			final User attacker = ess.getUser(eAttack);
			attacker.updateActivity(true);
			final List<String> commandList = attacker.getPowertool(attacker.getItemInHand());
			if (commandList != null && !commandList.isEmpty())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
				User defender = ess.getUser(eDefend);
				User attacker = ess.getUser(eAttack);
				attacker.updateActivity(true);
				ItemStack is = attacker.getItemInHand();
				List<String> commandList = attacker.getPowertool(is);
				if (commandList != null && !commandList.isEmpty())
=======
				for (String command : commandList)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
					for (String command : commandList)
=======
					if (command != null && !command.isEmpty())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE

						if (command != null && !command.isEmpty())
						{
							attacker.getServer().dispatchCommand(attacker, command.replaceAll("\\{player\\}", defender.getName()));
							event.setCancelled(true);
							return;
						}
=======
						attacker.getServer().dispatchCommand(attacker, command.replaceAll("\\{player\\}", defender.getName()));
						event.setCancelled(true);
						return;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
			if (eDefend instanceof Animals && eAttack instanceof Player)
=======
		}
		else if (eDefend instanceof Animals && eAttack instanceof Player)
		{
			final User player = ess.getUser(eAttack);
			final ItemStack hand = player.getItemInHand();
			if (hand != null && hand.getType() == Material.MILK_BUCKET)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
				User player = ess.getUser(eAttack);
				ItemStack hand = player.getItemInHand();
				if (hand != null && hand.getType() == Material.MILK_BUCKET)
				{
					((Animals)eDefend).setAge(-24000);
					hand.setType(Material.BUCKET);
					player.setItemInHand(hand);
					player.updateInventory();
					event.setCancelled(true);
				}
=======
				((Animals)eDefend).setAge(-24000);
				hand.setType(Material.BUCKET);
				player.setItemInHand(hand);
				player.updateInventory();
				event.setCancelled(true);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
=======
	}

	@EventHandler(priority = EventPriority.LOWEST)
	public void onEntityDamage(final EntityDamageEvent event)
	{
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
	public void onEntityCombust(EntityCombustEvent event)
=======
	public void onEntityCombust(final EntityCombustEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
	public void onEntityDeath(final EntityDeathEvent event)
=======
	public void onPlayerDeathEvent(final PlayerDeathEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
		if (event instanceof PlayerDeathEvent)
=======
		final User user = ess.getUser(event.getEntity());
		if (user.isAuthorized("essentials.back.ondeath") && !ess.getSettings().isCommandDisabled("back"))
		{
			user.setLastLocation();
			user.sendMessage(_("backAfterDeath"));
		}
		if (!ess.getSettings().areDeathMessagesEnabled())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
			final PlayerDeathEvent pdevent = (PlayerDeathEvent)event;
			final User user = ess.getUser(pdevent.getEntity());
			if (user.isAuthorized("essentials.back.ondeath") && !ess.getSettings().isCommandDisabled("back"))
			{
				user.setLastLocation();
				user.sendMessage(_("backAfterDeath"));
			}
			if (!ess.getSettings().areDeathMessagesEnabled())
			{
				pdevent.setDeathMessage("");
			}
=======
			event.setDeathMessage("");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
	public void onFoodLevelChange(FoodLevelChangeEvent event)
=======
	public void onFoodLevelChange(final FoodLevelChangeEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
	public void onEntityRegainHealth(EntityRegainHealthEvent event)
=======
	public void onEntityRegainHealth(final EntityRegainHealthEvent event)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ce1e923_0da3bc3/rev_ce1e923-0da3bc3/EssentialsGroupManager/src/org/anjocaido/groupmanager/permissions/BukkitPermissions.java;<<<<<<< MINE
		/*
		 * Trigger at highest so we tidy up last.
		 */
		@EventHandler(priority = EventPriority.HIGHEST)
=======
		@EventHandler(priority = EventPriority.HIGHEST)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_136d60e_f3a2b27/rev_136d60e-f3a2b27/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;<<<<<<< MINE
=======
			event.setDroppedExp(0);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_eed0edd_b37b165/rev_eed0edd-b37b165/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;<<<<<<< MINE
=======
		throw new NoChargeException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_eed0edd_b37b165/rev_eed0edd-b37b165/Essentials/src/com/earth2me/essentials/signs/SignKit.java;<<<<<<< MINE
			|| (group.isEmpty() && (player.isAuthorized("essentials.kit." + kitName))))
=======
			|| (group.isEmpty() && (player.isAuthorized("essentials.kits." + kitName))))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_eed0edd_b37b165/rev_eed0edd-b37b165/Essentials/src/com/earth2me/essentials/signs/SignWarp.java;<<<<<<< MINE
			|| (group.isEmpty() && (!ess.getSettings().getPerWarpPermission() || player.isAuthorized("essentials.warp." + warpName))))
=======
			|| (group.isEmpty() && (!ess.getSettings().getPerWarpPermission() || player.isAuthorized("essentials.warps." + warpName))))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_c9ef36a_8143b25/rev_c9ef36a-8143b25/Essentials/src/com/earth2me/essentials/commands/Commandmail.java;<<<<<<< MINE
import org.bukkit.entity.Player;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_c9ef36a_8143b25/rev_c9ef36a-8143b25/Essentials/src/com/earth2me/essentials/commands/Commandmail.java;<<<<<<< MINE
			User u = ess.getUser(args[0]);
=======
			User u = ess.getUser(args[1]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_c9ef36a_8143b25/rev_c9ef36a-8143b25/Essentials/src/com/earth2me/essentials/commands/Commandmail.java;<<<<<<< MINE
			User u = ess.getUser(args[0]);
=======
			User u = ess.getUser(args[1]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandsell.java;<<<<<<< MINE
		InventoryWorkaround.removeItem(user.getInventory(), true, true, ris);
=======
		user.getInventory().removeItem(ris);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandgive.java;<<<<<<< MINE
			InventoryWorkaround.addItem(giveTo.getInventory(), true, ess.getSettings().getOversizedStackSize(), stack);
=======
			InventoryWorkaround.addOversizedItems(giveTo.getInventory(), ess.getSettings().getOversizedStackSize(), stack);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandgive.java;<<<<<<< MINE
			InventoryWorkaround.addItem(giveTo.getInventory(), true, stack);
=======
			InventoryWorkaround.addItems(giveTo.getInventory(), stack);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commanditem.java;<<<<<<< MINE
			InventoryWorkaround.addItem(user.getInventory(), true, ess.getSettings().getOversizedStackSize(), stack);
=======
			InventoryWorkaround.addOversizedItems(user.getInventory(), ess.getSettings().getOversizedStackSize(), stack);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commanditem.java;<<<<<<< MINE
			InventoryWorkaround.addItem(user.getInventory(), true, stack);
=======
			InventoryWorkaround.addItems(user.getInventory(), stack);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandhat.java;<<<<<<< MINE
				InventoryWorkaround.addItem(user.getInventory(), true, head);
=======
				InventoryWorkaround.addItems(user.getInventory(), head);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandunlimited.java;<<<<<<< MINE
			if (!InventoryWorkaround.containsItem(target.getInventory(), true, true, stack))
=======
			if (!target.getInventory().containsAtLeast(stack, stack.getAmount()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;<<<<<<< MINE
import org.bukkit.plugin.java.JavaPluginLoader;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;<<<<<<< MINE
=======
import org.yaml.snakeyaml.constructor.CustomClassLoaderConstructor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;<<<<<<< MINE
public class BukkitConstructor extends Constructor
=======
public class BukkitConstructor extends CustomClassLoaderConstructor
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;<<<<<<< MINE
		super(clazz);
=======
		super(clazz, plugin.getClass().getClassLoader());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;<<<<<<< MINE
=======
		@Override
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;<<<<<<< MINE
				if (typeDefinitions == null) {
=======
				if (typeDefinitions == null)
				{
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;<<<<<<< MINE

	@Override
	protected Class<?> getClassForNode(final Node node)
	{
		Class<?> clazz;
		final String name = node.getTag().getClassName();
		if (plugin == null)
		{
			clazz = super.getClassForNode(node);
		}
		else
		{
			final JavaPluginLoader jpl = (JavaPluginLoader)plugin.getPluginLoader();
			clazz = jpl.getClassByName(name);
		}

		if (clazz == null)
		{
			throw new YAMLException("Class not found: " + name);
		}
		else
		{
			return clazz;
		}
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Essentials.java;<<<<<<< MINE
	public static final int BUKKIT_VERSION = 2455;
=======
	public static final int BUKKIT_VERSION = 2543;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
=======
import com.earth2me.essentials.Util;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;<<<<<<< MINE
			balance = Double.toString(user.getMoney());
=======
			balance = Util.displayCurrency(user.getMoney(), ess);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
			&& !InventoryWorkaround.containsItem(user.getInventory(), true, true, itemStack))
=======
			&& !user.getInventory().containsAtLeast(itemStack, itemStack.getAmount()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
				final Map<Integer, ItemStack> leftOver = InventoryWorkaround.addItem(user.getInventory(), true, getItemStack());
=======
				final Map<Integer, ItemStack> leftOver = InventoryWorkaround.addItems(user.getInventory(), getItemStack());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
				success = InventoryWorkaround.addAllItems(user.getInventory(), true, getItemStack());
=======
				success = InventoryWorkaround.addAllItems(user.getInventory(), getItemStack());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
			if (!InventoryWorkaround.containsItem(user.getInventory(), true, true, itemStack))
=======
			if (!user.getInventory().containsAtLeast(itemStack, itemStack.getAmount()))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;<<<<<<< MINE
			InventoryWorkaround.removeItem(user.getInventory(), true, true, getItemStack());
=======
			user.getInventory().removeItem(getItemStack());
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Kit.java;<<<<<<< MINE
					overfilled = InventoryWorkaround.addItem(user.getInventory(), true, ess.getSettings().getOversizedStackSize(), stack);
=======
					overfilled = InventoryWorkaround.addOversizedItems(user.getInventory(), ess.getSettings().getOversizedStackSize(), stack);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Kit.java;<<<<<<< MINE
					overfilled = InventoryWorkaround.addItem(user.getInventory(), true, 0, stack);
=======
					overfilled = InventoryWorkaround.addItems(user.getInventory(), stack);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
=======
import org.bukkit.Bukkit;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
	public static int first(final Inventory inventory, final ItemStack item, final boolean enforceDurability, final boolean enforceAmount, final boolean enforceEnchantments)
	{
		return next(inventory, item, 0, enforceDurability, enforceAmount, enforceEnchantments);
	}

	public static int next(final Inventory cinventory, final ItemStack item, final int start, final boolean enforceDurability, final boolean enforceAmount, final boolean enforceEnchantments)
	{
		final ItemStack[] inventory = cinventory.getContents();
		for (int i = start; i < inventory.length; i++)
		{
			final ItemStack cItem = inventory[i];
			if (cItem == null)
			{
				continue;
			}
			if (item.getTypeId() == cItem.getTypeId() && (!enforceAmount || item.getAmount() == cItem.getAmount()) && (!enforceDurability || cItem.getDurability() == item.getDurability()) && (!enforceEnchantments || cItem.getEnchantments().equals(item.getEnchantments())))
			{
				return i;
			}
		}
		return -1;
	}

	public static int firstPartial(final Inventory cinventory, final ItemStack item, final boolean enforceDurability)
	{
		return firstPartial(cinventory, item, enforceDurability, item.getType().getMaxStackSize());
	}

	public static int firstPartial(final Inventory cinventory, final ItemStack item, final boolean enforceDurability, final int maxAmount)
=======
	private static int firstPartial(final Inventory inventory, final ItemStack item, final int maxAmount)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
		final ItemStack[] inventory = cinventory.getContents();
		for (int i = 0; i < inventory.length; i++)
=======
		final ItemStack[] stacks = inventory.getContents();
		for (int i = 0; i < stacks.length; i++)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
			final ItemStack cItem = inventory[i];
			if (cItem == null)
			{
				continue;
			}
			if (item.getTypeId() == cItem.getTypeId() && cItem.getAmount() < maxAmount && (!enforceDurability || cItem.getDurability() == item.getDurability()) && cItem.getEnchantments().equals(item.getEnchantments()))
=======
			final ItemStack cItem = stacks[i];
			if (cItem != null && cItem.getAmount() < maxAmount && cItem.isSimilar(item))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
	public static boolean addAllItems(final Inventory cinventory, final boolean enforceDurability, final ItemStack... items)
=======
	public static boolean addAllItems(final Inventory inventory, final ItemStack... items)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
		final Inventory fake = new FakeInventory(cinventory.getContents());
		if (addItem(fake, enforceDurability, items).isEmpty())
=======
		final Inventory fakeInventory = Bukkit.getServer().createInventory(null, inventory.getType());
		fakeInventory.setContents(inventory.getContents());
		if (addItems(fakeInventory, items).isEmpty())
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
			addItem(cinventory, enforceDurability, items);
=======
			addItems(inventory, items);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
		else
		{
			return false;
		}
=======
		return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
	public static Map<Integer, ItemStack> addItem(final Inventory cinventory, final boolean forceDurability, final ItemStack... items)
=======
	public static Map<Integer, ItemStack> addItems(final Inventory inventory, final ItemStack... items)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
		return addItem(cinventory, forceDurability, 0, items);
=======
		return addOversizedItems(inventory, 0, items);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
	public static Map<Integer, ItemStack> addItem(final Inventory cinventory, final boolean enforceDurability, final int oversizedStacks, final ItemStack... items)
=======
	public static Map<Integer, ItemStack> addOversizedItems(final Inventory inventory, final int oversizedStacks, final ItemStack... items)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
		ItemStack[] combined = new ItemStack[items.length];
=======
		final ItemStack[] combined = new ItemStack[items.length];
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
				if (combined[j].getTypeId() == items[i].getTypeId() && (!enforceDurability || combined[j].getDurability() == items[i].getDurability()) && combined[j].getEnchantments().equals(items[i].getEnchantments()))
=======
				if (combined[j].isSimilar(items[i]))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
				final int firstPartial = firstPartial(cinventory, item, enforceDurability, maxAmount);
=======
				final int firstPartial = firstPartial(inventory, item, maxAmount);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
					final int firstFree = cinventory.firstEmpty();
=======
					final int firstFree = inventory.firstEmpty();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
							cinventory.setItem(firstFree, stack);
=======
							inventory.setItem(firstFree, stack);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
							cinventory.setItem(firstFree, item);
=======
							inventory.setItem(firstFree, item);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE
					final ItemStack partialItem = cinventory.getItem(firstPartial);
=======
					final ItemStack partialItem = inventory.getItem(firstPartial);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;<<<<<<< MINE

	public static Map<Integer, ItemStack> removeItem(final Inventory cinventory, final boolean enforceDurability, final boolean enforceEnchantments, final ItemStack... items)
	{
		final Map<Integer, ItemStack> leftover = new HashMap<Integer, ItemStack>();

		// TODO: optimization

		for (int i = 0; i < items.length; i++)
		{
			final ItemStack item = items[i];
			if (item == null)
			{
				continue;
			}
			int toDelete = item.getAmount();

			while (true)
			{

				// Bail when done
				if (toDelete <= 0)
				{
					break;
				}

				// get first Item, ignore the amount
				final int first = first(cinventory, item, enforceDurability, false, enforceEnchantments);

				// Drat! we don't have this type in the inventory
				if (first == -1)
				{
					item.setAmount(toDelete);
					leftover.put(i, item);
					break;
				}
				else
				{
					final ItemStack itemStack = cinventory.getItem(first);
					final int amount = itemStack.getAmount();

					if (amount <= toDelete)
					{
						toDelete -= amount;
						// clear the slot, all used up
						cinventory.clear(first);
					}
					else
					{
						// split the stack and store
						itemStack.setAmount(amount - toDelete);
						cinventory.setItem(first, itemStack);
						toDelete = 0;
					}
				}
			}
		}
		return leftover;
	}

	public static boolean containsItem(final Inventory cinventory, final boolean enforceDurability, final boolean enforceEnchantments, final ItemStack... items)
	{
		final Map<Integer, ItemStack> leftover = new HashMap<Integer, ItemStack>();

		// TODO: optimization

		// combine items

		ItemStack[] combined = new ItemStack[items.length];
		for (int i = 0; i < items.length; i++)
		{
			if (items[i] == null)
			{
				continue;
			}
			for (int j = 0; j < combined.length; j++)
			{
				if (combined[j] == null)
				{
					combined[j] = items[i].clone();
					break;
				}
				if (combined[j].getTypeId() == items[i].getTypeId() && (!enforceDurability || combined[j].getDurability() == items[i].getDurability()) && (!enforceEnchantments || combined[j].getEnchantments().equals(items[i].getEnchantments())))
				{
					combined[j].setAmount(combined[j].getAmount() + items[i].getAmount());
					break;
				}
			}
		}

		for (int i = 0; i < combined.length; i++)
		{
			final ItemStack item = combined[i];
			if (item == null)
			{
				continue;
			}
			int mustHave = item.getAmount();
			int position = 0;

			while (true)
			{
				// Bail when done
				if (mustHave <= 0)
				{
					break;
				}

				final int slot = next(cinventory, item, position, enforceDurability, false, enforceEnchantments);

				// Drat! we don't have this type in the inventory
				if (slot == -1)
				{
					leftover.put(i, item);
					break;
				}
				else
				{
					final ItemStack itemStack = cinventory.getItem(slot);
					final int amount = itemStack.getAmount();

					if (amount <= mustHave)
					{
						mustHave -= amount;
					}
					else
					{
						mustHave = 0;
					}
					position = slot + 1;
				}
			}
		}
		return leftover.isEmpty();
	}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;<<<<<<< MINE
=======
import com.earth2me.essentials.ChargeException;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;<<<<<<< MINE
		if (user.isTpRequestHere())
		{
			charge.isAffordableFor(user);
		}
		else
		{
			charge.isAffordableFor(target);
		}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;<<<<<<< MINE
		if (user.isTpRequestHere())
=======
		try
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;<<<<<<< MINE
			target.getTeleport().teleportToMe(user, charge, TeleportCause.COMMAND);
=======
			if (user.isTpRequestHere())
			{
				target.getTeleport().teleportToMe(user, charge, TeleportCause.COMMAND);
			}
			else
			{
				target.getTeleport().teleport(user, charge, TeleportCause.COMMAND);
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;<<<<<<< MINE
		else
=======
		catch (ChargeException ex)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;<<<<<<< MINE
			target.getTeleport().teleport(user, charge, TeleportCause.COMMAND);
=======
			user.sendMessage(_("pendingTeleportCancelled"));
			ess.showError(target, ex, commandLabel);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
=======
import static com.earth2me.essentials.I18n._;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
=======
import org.bukkit.inventory.meta.BookMeta;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
	
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
=======
		String player = user.getName();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
			ItemStack newItem = new ItemStack(Material.BOOK_AND_QUILL, item.getAmount());
			newItem.setItemMeta(meta);
			user.setItemInHand(newItem);
			user.sendMessage("You can now edit the contents of this book.");
=======
			BookMeta bmeta = (BookMeta)meta;
			if (args[0].equalsIgnoreCase("author"))
			{
				if (user.isAuthorized("essentals.book.author"))
				{
					ItemStack newbook = new ItemStack(Material.WRITTEN_BOOK, 1);
					bmeta.setAuthor(args[1]);
					newbook.setItemMeta(bmeta);
					user.setItemInHand(newbook);
					user.sendMessage(_("bookAuthorSet", args[1]));
				}
				else
				{
					user.sendMessage(_("denyChangeAuthor"));
				}
			}
			else if (args[0].equalsIgnoreCase("title"))
			{
				if (user.isAuthorized("essentials.book.title"))
				{

					if (isAuthor(bmeta, player) || user.isAuthorized("essentials.book.title.others"))
					{
						ItemStack newbook = new ItemStack(Material.WRITTEN_BOOK, 1);
						bmeta.setTitle(args[1]);
						newbook.setItemMeta(bmeta);
						user.setItemInHand(newbook);
						user.sendMessage(_("bookTitleSet", args[1]));
					}
					else
					{
						user.sendMessage(_("denyChangeTitle"));
					}
				}
				else
				{
					user.sendMessage(_("denyChangeTitle"));
				}
			}
			else
			{
				if (isAuthor(bmeta, player) || user.isAuthorized("essentials.book.others"))
				{
					ItemStack newItem = new ItemStack(Material.BOOK_AND_QUILL, item.getAmount());
					newItem.setItemMeta(meta);
					user.setItemInHand(newItem);
					user.sendMessage(_("editBookContents"));
				}
				else
				{
					user.sendMessage(_("denyBookEdit"));
				}
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
=======
			BookMeta bmeta = (BookMeta)meta;
			bmeta.setAuthor(player);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
			newItem.setItemMeta(meta);
=======
			newItem.setItemMeta(bmeta);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
			user.sendMessage("This book is now locked and signed.");
=======
			user.sendMessage(_("bookLocked"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
			throw new Exception(_("holdBook"));
=======
			throw new Exception(_("holdBook"));
		}
	}

	private boolean isAuthor(BookMeta bmeta, String player)
	{
		if (bmeta.getAuthor().equalsIgnoreCase(player))
		{
			return true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
=======
import com.earth2me.essentials.Util;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
=======
import org.bukkit.inventory.ItemStack;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
			if (args[0].length() >= 3)
=======
			if (args[0].contentEquals("*") && user.isAuthorized("essentials.clearinventory.all"))
			{
				if (args.length > 1)
				{
					for (Player onlinePlayer : server.getOnlinePlayers())
					{
						clearInventory(onlinePlayer, args[1]);
					}
					user.sendMessage("Cleared everyone's inventory");
				}
				else
				{
					throw new NotEnoughArgumentsException();
				}
			}
			else if (args[0].length() >= 3)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
						p.getInventory().clear();
=======
						if (args.length > 1)
						{
							clearInventory(p, args[1]);
						}
						else
						{
							p.getInventory().clear();
						}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
					return;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
				throw new Exception(_("playerNotFound"));
=======
				else
				{
					clearInventory(user, args[0]);
					user.sendMessage(_("inventoryCleared"));
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
					p.getInventory().clear();
=======
					clearInventory(p, args[1]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
					throw new Exception(_("playerNotFound"));
=======
					clearInventory(user, args[0]);
					user.sendMessage(_("inventoryCleared"));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
			user.getInventory().clear();
=======
			if (args.length > 0)
			{
				clearInventory(user, args[0]);
			}
			else
			{
				user.getInventory().clear();
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
		if (args[0].length() >= 3)
=======
		if (args[0].contentEquals("*"))
		{
			if (args.length > 1)
			{
				for (Player onlinePlayer : server.getOnlinePlayers())
				{
					clearInventory(onlinePlayer, args[1]);
				}
				sender.sendMessage("Cleared everyone's inventory");
			}
			else
			{
				throw new NotEnoughArgumentsException();
			}
		}
		else if (args[0].length() >= 3)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
					p.getInventory().clear();
=======
					if (args.length > 1)
					{
						clearInventory(p, args[1]);
					}
					else
					{
						p.getInventory().clear();
					}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
				return;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
			throw new Exception(_("playerNotFound"));
=======
			else
			{
				throw new Exception(_("playerNotFound"));
			}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
				u.getInventory().clear();
=======
				clearInventory(u, args[0]);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;<<<<<<< MINE
=======

	public void clearInventory(Player player, String arg) throws Exception
	{
		final String[] split = arg.split(":");
		if (arg.contentEquals("*"))
		{
			player.getInventory().clear();
		}
		else
		{
			final ItemStack item = ess.getItemDb().get(split[0]);
			final int type = item.getTypeId();

			if (split.length > 1 && Util.isInt(arg.replace(":", "")))
			{
				player.getInventory().clear(type, Integer.parseInt(split[1]));
			}
			else
			{
				if (Util.isInt(split[0]))
				{
					player.getInventory().clear(type, -1);
				}
				else
				{
					player.getInventory().clear(type, item.getDurability());
				}
			}
		}
	}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/commands/Commandpotion.java;<<<<<<< MINE
=======
		
		if (args.length < 3)
		{
			throw new NotEnoughArgumentsException();
		}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/MetaItemStack.java;<<<<<<< MINE
					throw new Exception(_("invalidPotionEffect", split[1]));
=======
					throw new Exception(_("invalidPotionMeta", split[1]));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/MetaItemStack.java;<<<<<<< MINE
=======
					if (power > 0 && power < 4)
					{
						power -= 1;
					}
				}
				else
				{
					throw new Exception(_("invalidPotionMeta", split[1]));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/MetaItemStack.java;<<<<<<< MINE
=======
				else
				{
					throw new Exception(_("invalidPotionMeta", split[1]));
				}
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;<<<<<<< MINE
=======
import com.earth2me.essentials.utils.FormatUtil;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;<<<<<<< MINE
		final String ipAddress;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;<<<<<<< MINE
		final User player = ess.getUser(args[0]);
		if (player == null)
=======
		String ipAddress;
		if (FormatUtil.validIP(args[0]))
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;<<<<<<< MINE
			ipAddress = player.getLastLoginAddress();
			if (ipAddress.length() == 0)
=======
			try
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;<<<<<<< MINE
				throw new Exception(_("playerNotFound"));
=======
				User player = getPlayer(server, args, 0, true, true);
				ipAddress = player.getLastLoginAddress();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;<<<<<<< MINE
=======
			catch (PlayerNotFoundException ex)
			{
				ipAddress = args[0];
			}
		}

		if (ipAddress.isEmpty())
		{
			throw new PlayerNotFoundException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;<<<<<<< MINE
		
		ess.broadcastMessage(sender, "essentials.ban.notify", _("playerBanIpAddress", senderName, ipAddress));		
=======

		ess.broadcastMessage(sender, "essentials.ban.notify", _("playerBanIpAddress", senderName, ipAddress));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;<<<<<<< MINE
import com.earth2me.essentials.utils.StringUtil;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;<<<<<<< MINE
=======
		
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;<<<<<<< MINE
			final User user = getPlayer(server, args, 0, true, true);
			ipAddress = user.getLastLoginAddress();
			if (ipAddress.isEmpty())
=======
			try
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;<<<<<<< MINE
				throw new PlayerNotFoundException();
=======
				User player = getPlayer(server, args, 0, true, true);
				ipAddress = player.getLastLoginAddress();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;<<<<<<< MINE
=======
			catch (PlayerNotFoundException ex)
			{
				ipAddress = args[0];
			}
		}

		if (ipAddress.isEmpty())
		{
			throw new PlayerNotFoundException();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/perm/PermissionsHandler.java;<<<<<<< MINE
import com.earth2me.essentials.utils.NumberUtil;
import com.earth2me.essentials.utils.StringUtil;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/perm/PermissionsHandler.java;<<<<<<< MINE
			final String bVer = bPermPlugin.getDescription().getVersion().replace(".", "");
			if (NumberUtil.isInt(bVer) && Integer.parseInt(bVer) < 284)
			{
				if (!(handler instanceof BPermissionsHandler))
				{
					LOGGER.log(Level.INFO, "Essentials: Using bPermissions based permissions.");
					handler = new BPermissionsHandler();
				}
				return;
			}
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/perm/PermissionsHandler.java;<<<<<<< MINE

		}
		final Plugin permPlugin = pluginManager.getPlugin("Permissions");
		if (permPlugin != null && permPlugin.isEnabled())
		{
			if (permPlugin.getDescription().getVersion().charAt(0) == '3')
			{
				if (!(handler instanceof Permissions3Handler))
				{
					LOGGER.log(Level.INFO, "Essentials: Using Permissions 3 based permissions.");
					handler = new Permissions3Handler(permPlugin);
				}
			}
			else
			{
				if (!(handler instanceof Permissions2Handler))
				{
					LOGGER.log(Level.INFO, "Essentials: Using Permissions 2 based permissions.");
					handler = new Permissions2Handler(permPlugin);
				}
			}
			return;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_46ab4d0_baa9f0a/rev_46ab4d0-baa9f0a/Essentials/src/com/earth2me/essentials/utils/FormatUtil.java;<<<<<<< MINE
	static final transient Pattern REPLACE_COLOR_PATTERN = Pattern.compile("&([0-9a-f])");
=======
	static final transient Pattern REPLACE_COLOR_PATTERN = Pattern.compile("&([0-9a-fA-F])");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_46ab4d0_baa9f0a/rev_46ab4d0-baa9f0a/Essentials/src/com/earth2me/essentials/utils/FormatUtil.java;<<<<<<< MINE
	static final transient Pattern REPLACE_FORMAT_PATTERN = Pattern.compile("&([l-or])");
	static final transient Pattern REPLACE_MAGIC_PATTERN = Pattern.compile("&(k)");
	static final transient Pattern REPLACE_PATTERN = Pattern.compile("&([0-9a-fk-or])");
=======
	static final transient Pattern REPLACE_FORMAT_PATTERN = Pattern.compile("&([l-orL-OR])");
	static final transient Pattern REPLACE_MAGIC_PATTERN = Pattern.compile("&([Kk])");
	static final transient Pattern REPLACE_PATTERN = Pattern.compile("&([0-9a-fk-orA-FK-OR])");
>>>>>>> YOURS
