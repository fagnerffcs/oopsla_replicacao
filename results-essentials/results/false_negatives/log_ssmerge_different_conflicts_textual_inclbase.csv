file;linedbasedConf
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_1faaddf_7d50288/rev_1faaddf-7d50288/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE

    private static AmazonAutoScaling getAmazonAutoScalingClient() {
        String aWSAccessId = eurekaConfig.getAWSAccessId();
        String aWSSecretKey = eurekaConfig.getAWSSecretKey();
        ClientConfiguration clientConfiguration = new ClientConfiguration()
                .withConnectionTimeout(eurekaConfig.getASGQueryTimeoutMs());

        if (null != aWSAccessId && !"".equals(aWSAccessId) &&
                null != aWSSecretKey && !"".equals(aWSSecretKey)) {
            return new AmazonAutoScalingClient(
                    new BasicAWSCredentials(aWSAccessId, aWSSecretKey),
                    clientConfiguration);
        }
        else
        {
            return new AmazonAutoScalingClient(
                    new InstanceProfileCredentialsProvider(),
                    clientConfiguration);
        }
    }
   
||||||| BASE
    
=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_0dadaea_ddcda44/rev_0dadaea-ddcda44/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
    .getInstance().getConfiguration();
    private static final AmazonAutoScaling client = getAmazonAutoScalingClient();
||||||| BASE
    .getInstance().getConfiguration();
    private static final AmazonAutoScaling client = new AmazonAutoScalingClient(
            new BasicAWSCredentials(eurekaConfig.getAWSAccessId(),
                    eurekaConfig.getAWSSecretKey()),
                    new ClientConfiguration().withConnectionTimeout(eurekaConfig
                            .getASGQueryTimeoutMs()));
=======
            .getInstance().getConfiguration();
    private static final AmazonAutoScaling client = new AmazonAutoScalingClient(
            new BasicAWSCredentials(eurekaConfig.getAWSAccessId(),
                    eurekaConfig.getAWSSecretKey()),
            new ClientConfiguration().withConnectionTimeout(eurekaConfig
                    .getASGQueryTimeoutMs()));
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_4727485_42d73d3/rev_4727485-42d73d3/eureka-core/src/main/java/com/netflix/eureka/resources/ResponseCache.java;<<<<<<< MINE
import java.util.Arrays;
||||||| BASE
=======
import java.util.Date;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = { instanceInfo.getId(),
                                  instanceInfo.getStatus().name(),
                                  instanceInfo.getActionType().name() };
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
||||||| BASE
=======
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = { instanceInfo.getId(),
                                  instanceInfo.getStatus().name(),
                                  instanceInfo.getActionType().name() };
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/util/EurekaMonitors.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/resources/ResponseCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/test/java/com/netflix/eureka/TestDefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-core/src/test/java/com/netflix/eureka/InstanceRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/InstanceRegionChecker.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a84be6a_08e0412/rev_a84be6a-08e0412/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
            this.eventBus = eventBus;
||||||| BASE
=======
            scheduler = Executors.newScheduledThreadPool(4);

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
    
||||||| BASE
    private final int localRandomEurekaPort = 7799;

=======

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b7e1825_f0dec22/rev_b7e1825-f0dec22/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
import java.rmi.dgc.Lease;
import java.util.Arrays;
import java.util.List;
||||||| BASE
=======
import java.util.Arrays;
import java.util.List;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE

    public static final String ALL_REGIONS_VIP1_ADDR = "myvip1";
    public static final String REMOTE_REGION_APP1_INSTANCE1_HOSTNAME = "blah1-1";
    public static final String REMOTE_REGION_APP1_INSTANCE2_HOSTNAME = "blah1-2";
    public static final String LOCAL_REGION_APP1_NAME = "MYAPP1_LOC";
    public static final String LOCAL_REGION_APP1_INSTANCE1_HOSTNAME = "blahloc1-1";
    public static final String LOCAL_REGION_APP1_INSTANCE2_HOSTNAME = "blahloc1-2";
    public static final String REMOTE_REGION_APP1_NAME = "MYAPP1";

    public static final String ALL_REGIONS_VIP2_ADDR = "myvip2";
    public static final String REMOTE_REGION_APP2_INSTANCE1_HOSTNAME = "blah2-1";
    public static final String REMOTE_REGION_APP2_INSTANCE2_HOSTNAME = "blah2-2";
    public static final String REMOTE_REGION_APP2_INSTANCE3_HOSTNAME = "blah2-3";
    public static final String LOCAL_REGION_APP2_NAME = "MYAPP2_LOC";
    public static final String LOCAL_REGION_APP2_INSTANCE1_HOSTNAME = "blahloc2-1";
    public static final String LOCAL_REGION_APP2_INSTANCE2_HOSTNAME = "blahloc2-2";
    public static final String LOCAL_REGION_APP2_INSTANCE3_HOSTNAME = "blahloc2-3";
    public static final String REMOTE_REGION_APP2_NAME = "MYAPP2";

||||||| BASE
=======

    public static final String ALL_REGIONS_VIP1_ADDR = "myvip1";
    public static final String REMOTE_REGION_APP1_INSTANCE1_HOSTNAME = "blah1-1";
    public static final String REMOTE_REGION_APP1_INSTANCE2_HOSTNAME = "blah1-2";
    public static final String LOCAL_REGION_APP1_NAME = "MYAPP1_LOC";
    public static final String LOCAL_REGION_APP1_INSTANCE1_HOSTNAME = "blahloc1-1";
    public static final String LOCAL_REGION_APP1_INSTANCE2_HOSTNAME = "blahloc1-2";
    public static final String REMOTE_REGION_APP1_NAME = "MYAPP1";

    public static final String ALL_REGIONS_VIP2_ADDR = "myvip2";
    public static final String REMOTE_REGION_APP2_INSTANCE1_HOSTNAME = "blah2-1";
    public static final String REMOTE_REGION_APP2_INSTANCE2_HOSTNAME = "blah2-2";
    public static final String LOCAL_REGION_APP2_NAME = "MYAPP2_LOC";
    public static final String LOCAL_REGION_APP2_INSTANCE1_HOSTNAME = "blahloc2-1";
    public static final String LOCAL_REGION_APP2_INSTANCE2_HOSTNAME = "blahloc2-2";
    public static final String REMOTE_REGION_APP2_NAME = "MYAPP2";

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
        for (Application app : createRemoteApps()) {
            mockLocalEurekaServer.addRemoteRegionApps(app.getName(), app);
        }

        for (Application appDelta : createRemoteAppsDelta()) {
            mockLocalEurekaServer.addRemoteRegionAppsDelta(appDelta.getName(), appDelta);
        }
    }
||||||| BASE
        Application myapp = createRemoteApps();
        Application myappDelta = createRemoteAppsDelta();
=======
        for (Application app : createRemoteApps()) {
            mockLocalEurekaServer.addRemoteRegionApps(app.getName(), app);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static List<Application> createRemoteApps() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(REMOTE_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, REMOTE_REGION_APP1_INSTANCE1_HOSTNAME, null);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(REMOTE_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, REMOTE_REGION_APP2_INSTANCE1_HOSTNAME, null);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
    }

    private static List<Application> createRemoteAppsDelta() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(REMOTE_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, REMOTE_REGION_APP1_INSTANCE2_HOSTNAME, null);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(REMOTE_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, REMOTE_REGION_APP2_INSTANCE2_HOSTNAME, null);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
||||||| BASE
        mockLocalEurekaServer.addRemoteRegionApps(REMOTE_REGION_APP_NAME, myapp);
        mockLocalEurekaServer.addRemoteRegionAppsDelta(REMOTE_REGION_APP_NAME, myappDelta);
=======
        for (Application appDelta : createRemoteAppsDelta()) {
            mockLocalEurekaServer.addRemoteRegionAppsDelta(appDelta.getName(), appDelta);
        }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private void populateLocalRegistryAtStartup() {
        for (Application app : createLocalApps()) {
            mockLocalEurekaServer.addLocalRegionApps(app.getName(), app);
        }

        for (Application appDelta : createLocalAppsDelta()) {
            mockLocalEurekaServer.addLocalRegionAppsDelta(appDelta.getName(), appDelta);
        }
||||||| BASE
    private static Application createRemoteApps() {
        Application myapp = new Application(REMOTE_REGION_APP_NAME);
        InstanceInfo instanceInfo = createRemoteInstance(REMOTE_REGION_INSTANCE_1_HOSTNAME);
        myapp.addInstance(instanceInfo);
        return myapp;
=======
    private static List<Application> createRemoteApps() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createRemoteInstanceForApp1(REMOTE_REGION_APP1_INSTANCE1_HOSTNAME);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createRemoteInstanceForApp2(REMOTE_REGION_APP2_INSTANCE1_HOSTNAME);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    protected void addLocalAppDelta() {
        Application myappDelta = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo = createInstance(LOCAL_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, LOCAL_REGION_APP2_INSTANCE3_HOSTNAME, null);
        instanceInfo.setActionType(InstanceInfo.ActionType.ADDED);
        myappDelta.addInstance(instanceInfo);
        mockLocalEurekaServer.addLocalRegionAppsDelta(LOCAL_REGION_APP2_NAME, myappDelta);
||||||| BASE
    private static Application createRemoteAppsDelta() {
        Application myapp = new Application(REMOTE_REGION_APP_NAME);
        InstanceInfo instanceInfo = createRemoteInstance(REMOTE_REGION_INSTANCE_2_HOSTNAME);
        instanceInfo.setActionType(InstanceInfo.ActionType.ADDED);
        myapp.addInstance(instanceInfo);
        return myapp;
=======
    private static List<Application> createRemoteAppsDelta() {
        Application myapp1 = new Application(REMOTE_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createRemoteInstanceForApp1(REMOTE_REGION_APP1_INSTANCE2_HOSTNAME);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(REMOTE_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createRemoteInstanceForApp2(REMOTE_REGION_APP2_INSTANCE2_HOSTNAME);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static List<Application> createLocalApps() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(LOCAL_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, LOCAL_REGION_APP1_INSTANCE1_HOSTNAME, null);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(LOCAL_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, LOCAL_REGION_APP2_INSTANCE1_HOSTNAME, null);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
||||||| BASE
    private static InstanceInfo createRemoteInstance(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = InstanceInfo.Builder.newBuilder();
        instanceBuilder.setAppName(REMOTE_REGION_APP_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP_ADDR);
        instanceBuilder.setHostName(instanceHostName);
        instanceBuilder.setIPAddr("10.10.101.1");
        AmazonInfo amazonInfo = getAmazonInfo(REMOTE_ZONE, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        instanceBuilder.setLeaseInfo(LeaseInfo.Builder.newBuilder().build());
        return instanceBuilder.build();
=======
    private static InstanceInfo createRemoteInstanceForApp1(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(REMOTE_REGION_APP1_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP1_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(REMOTE_ZONE, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
    }

    private static InstanceInfo createRemoteInstanceForApp2(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(REMOTE_REGION_APP2_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP2_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(REMOTE_ZONE, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static List<Application> createLocalAppsDelta() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createInstance(LOCAL_REGION_APP1_NAME, ALL_REGIONS_VIP1_ADDR, LOCAL_REGION_APP1_INSTANCE2_HOSTNAME, null);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createInstance(LOCAL_REGION_APP2_NAME, ALL_REGIONS_VIP2_ADDR, LOCAL_REGION_APP2_INSTANCE2_HOSTNAME, null);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
||||||| BASE
    private void populateLocalRegistryAtStartup() {
        Application myapp = createLocalApps();
        Application myappDelta = createLocalAppsDelta();
        mockLocalEurekaServer.addLocalRegionApps(LOCAL_REGION_APP_NAME, myapp);
        mockLocalEurekaServer.addLocalRegionAppsDelta(LOCAL_REGION_APP_NAME, myappDelta);
    }

    private static Application createLocalApps() {
        Application myapp = new Application(LOCAL_REGION_APP_NAME);
        InstanceInfo instanceInfo = createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME);
        myapp.addInstance(instanceInfo);
        return myapp;
    }

    private static Application createLocalAppsDelta() {
        Application myapp = new Application(LOCAL_REGION_APP_NAME);
        InstanceInfo instanceInfo = createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME);
        instanceInfo.setActionType(InstanceInfo.ActionType.ADDED);
        myapp.addInstance(instanceInfo);
        return myapp;
=======
    private void populateLocalRegistryAtStartup() {
        for (Application app : createLocalApps()) {
            mockLocalEurekaServer.addLocalRegionApps(app.getName(), app);
        }

        for (Application appDelta : createLocalAppsDelta()) {
            mockLocalEurekaServer.addLocalRegionAppsDelta(appDelta.getName(), appDelta);
        }
    }

    private static List<Application> createLocalApps() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createLocalInstanceForApp1(LOCAL_REGION_APP1_INSTANCE1_HOSTNAME);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createLocalInstanceForApp2(LOCAL_REGION_APP2_INSTANCE1_HOSTNAME);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
    }

    private static List<Application> createLocalAppsDelta() {
        Application myapp1 = new Application(LOCAL_REGION_APP1_NAME);
        InstanceInfo instanceInfo1 = createLocalInstanceForApp1(LOCAL_REGION_APP1_INSTANCE2_HOSTNAME);
        instanceInfo1.setActionType(InstanceInfo.ActionType.ADDED);
        myapp1.addInstance(instanceInfo1);

        Application myapp2 = new Application(LOCAL_REGION_APP2_NAME);
        InstanceInfo instanceInfo2 = createLocalInstanceForApp2(LOCAL_REGION_APP2_INSTANCE2_HOSTNAME);
        instanceInfo2.setActionType(InstanceInfo.ActionType.ADDED);
        myapp2.addInstance(instanceInfo2);

        return Arrays.asList(myapp1, myapp2);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
    private static InstanceInfo createInstance(String appName, String vipAddress, String instanceHostName, String zone) {
||||||| BASE
    private static InstanceInfo createLocalInstance(String instanceHostName) {
=======
    private static InstanceInfo.Builder createBaseInstance(String instanceHostName) {
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
        instanceBuilder.setAppName(appName);
        instanceBuilder.setVIPAddress(vipAddress);
||||||| BASE
        instanceBuilder.setAppName(LOCAL_REGION_APP_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP_ADDR);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;<<<<<<< MINE
        instanceBuilder.setLeaseInfo(LeaseInfo.Builder.newBuilder().build());
        AmazonInfo amazonInfo = getAmazonInfo(zone, instanceHostName);
||||||| BASE
        AmazonInfo amazonInfo = getAmazonInfo(null, instanceHostName);
=======
        instanceBuilder.setLeaseInfo(LeaseInfo.Builder.newBuilder().build());
        return instanceBuilder;
    }

    private static InstanceInfo createLocalInstanceForApp1(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(LOCAL_REGION_APP1_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP1_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(null, instanceHostName);
        instanceBuilder.setDataCenterInfo(amazonInfo);
        instanceBuilder.setMetadata(amazonInfo.getMetadata());
        return instanceBuilder.build();
    }

    private static InstanceInfo createLocalInstanceForApp2(String instanceHostName) {
        InstanceInfo.Builder instanceBuilder = createBaseInstance(instanceHostName);
        instanceBuilder.setAppName(LOCAL_REGION_APP2_NAME);
        instanceBuilder.setVIPAddress(ALL_REGIONS_VIP2_ADDR);
        AmazonInfo amazonInfo = getAmazonInfo(null, instanceHostName);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;<<<<<<< MINE
        checkInstancesFromARegion("local", LOCAL_REGION_APP1_INSTANCE1_HOSTNAME,
                LOCAL_REGION_APP1_INSTANCE2_HOSTNAME);
        checkInstancesFromARegion(REMOTE_REGION, REMOTE_REGION_APP1_INSTANCE1_HOSTNAME,
                REMOTE_REGION_APP1_INSTANCE2_HOSTNAME);
    }

    @Test
    public void testAppsHashCodeAfterRefresh() throws Exception {
        Assert.assertEquals("UP_2_", client.getApplications().getAppsHashCode());

        addLocalAppDelta();
        mockLocalEurekaServer.waitForDeltaToBeRetrieved(CLIENT_REFRESH_RATE);

        Assert.assertEquals("UP_3_", client.getApplications().getAppsHashCode());
||||||| BASE
        checkInstancesFromARegion("local", LOCAL_REGION_INSTANCE_1_HOSTNAME,
                                  LOCAL_REGION_INSTANCE_2_HOSTNAME);
        checkInstancesFromARegion(REMOTE_REGION, REMOTE_REGION_INSTANCE_1_HOSTNAME,
                                  REMOTE_REGION_INSTANCE_2_HOSTNAME);
=======
        checkInstancesFromARegion("local", LOCAL_REGION_APP1_INSTANCE1_HOSTNAME,
                LOCAL_REGION_APP1_INSTANCE2_HOSTNAME);
        checkInstancesFromARegion(REMOTE_REGION, REMOTE_REGION_APP1_INSTANCE1_HOSTNAME,
                REMOTE_REGION_APP1_INSTANCE2_HOSTNAME);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_526d3b1_6333a71/rev_526d3b1-6333a71/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/DefaultEurekaServerConfigTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/util/RateLimiterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AmazonInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/providers/EurekaConfigBasedInstanceInfoProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/AbstractInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/CloudInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/appinfo/PropertiesInstanceConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Application.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/Applications.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/NamedConnectionPool.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/InstanceRegionChecker.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/InstanceRegionChecker.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaUpStatusResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/EntityBodyConverter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/converters/Converters.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/DiscoveryJerseyProvider.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/ISerializer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/main/java/com/netflix/discovery/provider/ISerializer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/appinfo/AmazonInfoTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/appinfo/AmazonInfoTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/shared/ApplicationsTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockBackupRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockBackupRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientCloseJerseyThreadTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientCloseJerseyThreadTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientDisableRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/AbstractDiscoveryClientTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryClientRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/DiscoveryStatusCheckerTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/BackUpRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7afa7b0_9711533/rev_7afa7b0-9711533/eureka-client/src/test/java/com/netflix/discovery/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b276656_00a016c/rev_b276656-00a016c/eureka-client/src/test/java/com/netflix/discovery/converters/InstanceInfoGenerator.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7ac504a_578f4c0/rev_7ac504a-578f4c0/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
public interface InstanceRegistry extends LeaseManager<InstanceInfo>, LookupService<String> {
||||||| BASE
public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,
        LookupService<String> {

    private static final Logger logger = LoggerFactory
            .getLogger(InstanceRegistry.class);
    private static final EurekaServerConfig EUREKA_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final String[] EMPTY_STR_ARRAY = new String[0];
    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();
    private Timer evictionTimer = new Timer("Eureka-EvictionTimer", true);
    private volatile MeasuredRate renewsLastMin;
    protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
            .newBuilder().initialCapacity(500)
            .expireAfterAccess(1, TimeUnit.HOURS)
            .<String, InstanceStatus>build().asMap();

    // CircularQueues here for debugging/statistics purposes only
    private final CircularQueue<Pair<Long, String>> recentRegisteredQueue;
    private final CircularQueue<Pair<Long, String>> recentCanceledQueue;
    private Timer deltaRetentionTimer = new Timer("Eureka-DeltaRetentionTimer",
            true);
    private ConcurrentLinkedQueue<RecentlyChangedItem> recentlyChangedQueue = new ConcurrentLinkedQueue<RecentlyChangedItem>();
    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock read = readWriteLock.readLock();
    private final Lock write = readWriteLock.writeLock();
    protected Map<String, RemoteRegionRegistry> regionNameVSRemoteRegistry = new HashMap<String, RemoteRegionRegistry>();
    protected String[] allKnownRemoteRegions = EMPTY_STR_ARRAY;
    protected final Object lock = new Object();
    protected volatile int numberOfRenewsPerMinThreshold;
    protected volatile int expectedNumberOfRenewsPerMin;
    protected static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();

    private static final AtomicReference<EvictionTask> EVICTION_TASK = new AtomicReference<EvictionTask>();


    /**
     * Create a new, empty instance registry.
     */
    protected InstanceRegistry() {
        recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);
        recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);
        deltaRetentionTimer.schedule(getDeltaRetentionTask(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs());
    }

    /**
     * Completely clear the registry.
     */
    public void clearRegistry() {
        overriddenInstanceStatusMap.clear();
        recentCanceledQueue.clear();
        recentRegisteredQueue.clear();
        recentlyChangedQueue.clear();
        registry.clear();

    }

    /**
     * Registers a new instance with a given duration.
     *
     * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object,
     * int, boolean)
     */
    public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
        try {
            read.lock();
            Map<String, Lease<InstanceInfo>> gMap = registry.get(r
                    .getAppName());
            REGISTER.increment(isReplication);
            if (gMap == null) {
                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap =
                        new ConcurrentHashMap<String, Lease<InstanceInfo>>();
                gMap = registry.putIfAbsent(r.getAppName(), gNewMap);
                if (gMap == null) {
                    gMap = gNewMap;
                }
            }
            Lease<InstanceInfo> existingLease = gMap.get(r.getId());
            // Retain the last dirty timestamp without overwriting it, if there
            // is already a lease
            if (existingLease != null && (existingLease.getHolder() != null)) {
                Long existingLastDirtyTimestamp = existingLease.getHolder()
                        .getLastDirtyTimestamp();
                Long registrationLastDirtyTimestamp = r.getLastDirtyTimestamp();
                if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                    logger.warn(
                            "There is an existing lease and the existing lease's dirty timestamp {} is greater than "
                                    + "the one that is being registered {}", existingLastDirtyTimestamp,
                            registrationLastDirtyTimestamp);
                    r.setLastDirtyTimestamp(existingLastDirtyTimestamp);
                }
            } else {
                // The lease does not exist and hence it is a new registration
                synchronized (lock) {
                    if (this.expectedNumberOfRenewsPerMin > 0) {
                        // Since the client wants to cancel it, reduce the threshold
                        // (1
                        // for 30 seconds, 2 for a minute)
                        this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;
                        this.numberOfRenewsPerMinThreshold =
                                (int) (this.expectedNumberOfRenewsPerMin
                                        * EUREKA_SERVER_CONFIG.getRenewalPercentThreshold());
                    }
                }
            }
            Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                    leaseDuration);
            if (existingLease != null) {
                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
            }
            gMap.put(r.getId(), lease);
            synchronized (recentRegisteredQueue) {
                recentRegisteredQueue.add(new Pair<Long, String>(System.currentTimeMillis(), r.getAppName()
                        + "(" + r.getId() + ")"));
            }
            // This is where the initial state transfer of overridden status
            // happens
            if (!InstanceStatus.UNKNOWN.equals(r.getOverriddenStatus())) {
                logger.debug(
                        "Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                                + "overrides", r.getOverriddenStatus(), r.getId());
                if (!overriddenInstanceStatusMap.containsKey(r.getId())) {
                    logger.info(
                            "Not found overridden id {} and hence adding it",
                            r.getId());
                    overriddenInstanceStatusMap.put(r.getId(),
                            r.getOverriddenStatus());
                }
            }
            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(r.getId());
            if (overriddenStatusFromMap != null) {
                logger.info(
                        "Storing overridden status {} from map", overriddenStatusFromMap);
                r.setOverriddenStatus(overriddenStatusFromMap);
            }

            // Set the status based on the overridden status rules
            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(
                    r, existingLease, isReplication);
            r.setStatusWithoutDirty(overriddenInstanceStatus);

            // If the lease is registered with UP status, set lease service up timestamp
            if (InstanceStatus.UP.equals(r.getStatus())) {
                lease.serviceUp();
            }
            r.setActionType(ActionType.ADDED);
            recentlyChangedQueue.add(new RecentlyChangedItem(lease));
            r.setLastUpdatedTimestamp();
            invalidateCache(r.getAppName(), r.getVIPAddress(), r.getSecureVipAddress());
            logger.info("Registered instance id {} with status {}", r.getId(),
                    r.getStatus().toString());
            logger.debug("DS: Registry: registered " + r.getAppName() + " - "
                    + r.getId());
        } finally {
            read.unlock();
        }
    }

    /**
     * Cancels the registration of an instance.
     *
     * <p>
     * This is normally invoked by a client when it shuts down informing the
     * server to remove the instance from traffic.
     * </p>
     *
     * @param appName
     *            the application name of the application.
     * @param id
     *            the unique identifier of the instance.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the instance was removed from the
     *         {@link InstanceRegistry} successfully, false otherwise.
     */
    public boolean cancel(String appName, String id, boolean isReplication) {
        try {
            read.lock();
            CANCEL.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> leaseToCancel = null;
            if (gMap != null) {
                leaseToCancel = gMap.remove(id);
            }
            synchronized (recentCanceledQueue) {
                recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
            }
            InstanceStatus instanceStatus = overriddenInstanceStatusMap
                    .remove(id);
            if (instanceStatus != null) {
                logger.debug(
                        "Removed instance id {} from the overridden map which has value {}",
                        id, instanceStatus.name());
            }
            if (leaseToCancel == null) {
                CANCEL_NOT_FOUND.increment(isReplication);
                logger.warn("DS: Registry: cancel failed because Lease is not registered for: "
                        + appName + ":" + id);
                return false;
            } else {
                leaseToCancel.cancel();
                InstanceInfo instanceInfo = leaseToCancel.getHolder();
                String vip = null;
                String svip = null;
                if (instanceInfo != null) {
                    instanceInfo.setActionType(ActionType.DELETED);
                    recentlyChangedQueue.add(new RecentlyChangedItem(
                            leaseToCancel));
                    instanceInfo.setLastUpdatedTimestamp();
                    vip = instanceInfo.getVIPAddress();
                    svip = instanceInfo.getSecureVipAddress();
                }
                invalidateCache(appName, vip, svip);
                logger.debug("DS: Registry: canceled lease: " + appName + " - "
                        + id);
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Marks the given instance of the given app name as renewed, and also marks whether it originated from
     * replication.
     *
     * @see com.netflix.eureka.lease.LeaseManager#renew(java.lang.String,
     * java.lang.String, boolean)
     */
    public boolean renew(String appName, String id, boolean isReplication) {
        RENEW.increment(isReplication);
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        Lease<InstanceInfo> leaseToRenew = null;
        if (gMap != null) {
            leaseToRenew = gMap.get(id);
        }
        if (leaseToRenew == null) {
            RENEW_NOT_FOUND.increment(isReplication);
            logger.warn("DS: Registry: lease doesn't exist, registering resource: "
                    + appName + " - " + id);
            return false;
        } else {
            InstanceInfo instanceInfo = leaseToRenew.getHolder();
            if (instanceInfo != null) {
                // touchASGCache(instanceInfo.getASGName());
                InstanceStatus overriddenInstanceStatus = this
                        .getOverriddenInstanceStatus(instanceInfo,
                                leaseToRenew, isReplication);
                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
                    logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                            + "; re-register required", instanceInfo.getId());
                    RENEW_NOT_FOUND.increment(isReplication);
                    return false;
                }
                if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
                    Object[] args = {instanceInfo.getStatus().name(),
                            instanceInfo.getOverriddenStatus().name(),
                            instanceInfo.getId()};
                    logger.info(
                            "The instance status {} is different from overridden instance status {} for instance {}. "
                                    + "Hence setting the status to overridden status", args);
                    instanceInfo.setStatus(overriddenInstanceStatus);
                }
            }
            renewsLastMin.increment();
            leaseToRenew.renew();
            return true;
        }
    }

    /**
     * Stores overridden status if it is not already there. This happens during
     * a reconciliation process during renewal requests.
     *
     * @param id
     *            the unique identifier of the instance.
     * @param overriddenStatus
     *            Overridden status if any.
     */
    public void storeOverriddenStatusIfRequired(String id,
                                                InstanceStatus overriddenStatus) {
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.get(id);
        if ((instanceStatus == null)
                || (!overriddenStatus.equals(instanceStatus))) {
            // We might not have the overridden status if the server got
            // restarted -this will help us maintain the overridden state
            // from the replica
            logger.info(
                    "Adding overridden status for instance id {} and the value is {}",
                    id, overriddenStatus.name());
            overriddenInstanceStatusMap.put(id, overriddenStatus);
            List<InstanceInfo> instanceInfo = this.getInstancesById(id, false);
            if ((instanceInfo != null) && (!instanceInfo.isEmpty())) {
                instanceInfo.iterator().next().setOverriddenStatus(overriddenStatus);
                logger.info(
                        "Setting the overridden status for instance id {} and the value is {} ",
                        id, overriddenStatus.name());

            }
        }
    }

    /**
     * Updates the status of an instance. Normally happens to put an instance
     * between {@link InstanceStatus#OUT_OF_SERVICE} and
     * {@link InstanceStatus#UP} to put the instance in and out of traffic.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean statusUpdate(String appName, String id,
                                InstanceStatus newStatus, String lastDirtyTimestamp,
                                boolean isReplication) {
        try {
            read.lock();
            STATUS_UPDATE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                if ((info != null) && !(info.getStatus().equals(newStatus))) {
                    // Mark service as UP if needed
                    if (InstanceStatus.UP.equals(newStatus)) {
                        lease.serviceUp();
                    }
                    // This is NAC overriden status
                    overriddenInstanceStatusMap.put(id, newStatus);
                    // Set it for transfer of overridden status to replica on
                    // replica start up
                    info.setOverriddenStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                        info.setStatusWithoutDirty(newStatus);
                    } else {
                        info.setStatus(newStatus);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Removes status override for a give instance.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        try {
            read.lock();
            STATUS_OVERRIDE_DELETE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
                if (currentOverride != null && info != null) {
                    info.setOverriddenStatus(InstanceStatus.UNKNOWN);
                    info.setStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Evicts everything in the instance registry that has expired, if expiry is enabled.
     *
     * @see com.netflix.eureka.lease.LeaseManager#evict()
     */
    public void evict() {
        if (!isLeaseExpirationEnabled()) {
            logger.debug("DS: lease expiration is currently disabled.");
            return;
        }
        logger.debug("Running the evict task");
        for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
            Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
            if (leaseMap != null) {
                for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
                    Lease<InstanceInfo> lease = leaseEntry.getValue();
                    if (lease.isExpired() && lease.getHolder() != null) {
                        String appName = lease.getHolder().getAppName();
                        String id = lease.getHolder().getId();
                        EXPIRED.increment();
                        logger.warn("DS: Registry: expired lease for "
                                + appName + " - " + id);
                        cancel(appName, id, false);
                    }
                }
            }
        }
    }

    /**
     * Returns the given app that is in this instance only, falling back to other regions transparently only
     * if specified in this client configuration.
     *
     * @param appName
     *      - the application name of the application
     * @return the application
     *
     * @see
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
     */
    public Application getApplication(String appName) {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        return this.getApplication(appName, !disableTransparentFallback);
    }

    /**
     * Get application information.
     *
     * @param appName
     *            - The name of the application
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the application
     */
    public Application getApplication(String appName, boolean includeRemoteRegion) {
        Application app = null;

        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);

        if (leaseMap != null && leaseMap.size() > 0) {
            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {
                if (app == null) {
                    app = new Application(appName);
                }
                app.addInstance(decorateInstanceInfo(entry.getValue()));
            }
        } else if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application;
                }
            }
        }
        return app;
    }

    /**
     * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.
     *
     * @return the list of all known applications
     *
     * @see com.netflix.discovery.shared.LookupService#getApplications()
     */
    public Applications getApplications() {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        if (disableTransparentFallback) {
            return getApplicationsFromLocalRegionOnly();
        } else {
            return this.getApplications(true); // Behavior of falling back to remote region can be disabled.
        }
    }

    /**
     * Returns applications including instances from all remote regions. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with a <code>null</code> argument.
     */
    public Applications getApplicationsFromAllRemoteRegions() {
        return getApplicationsFromMultipleRegions(allKnownRemoteRegions);
    }

    /**
     * Returns applications including instances from local region only. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with an empty array.
     */
    public Applications getApplicationsFromLocalRegionOnly() {
        return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);
    }

    /**
     * This method will return applications with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     * The application instances for which this union will be done can be restricted to the names returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for every region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     * If you are not selectively requesting for a remote region, use {@link #getApplicationsFromAllRemoteRegions()}
     * or {@link #getApplicationsFromLocalRegionOnly()}
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> or empty no remote regions are
     *                      included.
     *
     * @return The applications with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be only for certain whitelisted apps as explained above.
     */
    public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {

        boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;

        logger.info("Fetching applications registry with remote regions: {}, Regions argument {}", includeRemoteRegion,
                Arrays.toString(remoteRegions));

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
        } else {
            GET_ALL_CACHE_MISS.increment();
        }
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }
                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                if (null != remoteRegistry) {
                    Applications remoteApps = remoteRegistry.getApplications();
                    for (Application application : remoteApps.getRegisteredApplications()) {
                        if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                            Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                            if (appInstanceTillNow == null) {
                                appInstanceTillNow = new Application(application.getName());
                                apps.addApplication(appInstanceTillNow);
                            }
                            for (InstanceInfo instanceInfo : application.getInstances()) {
                                appInstanceTillNow.addInstance(instanceInfo);
                            }
                        } else {
                            logger.info("Application {} not fetched from the remote region {} as there exists a "
                                            + "whitelist and this app is not in the whitelist.", application.getName(),
                                    remoteRegion);
                        }
                    }
                } else {
                    logger.warn("No remote registry available for the remote region {}", remoteRegion);
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {
        Set<String> whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(remoteRegion);
        if (null == whiteList) {
            whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(null); // see global whitelist.
        }
        return null == whiteList || whiteList.contains(appName);
    }

    /**
     * Get the registry information about all {@link Applications}.
     *
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return applications
     * @deprecated Use {@link #getApplicationsFromMultipleRegions(String[])} instead. This method has a flawed behavior
     * of transparently falling back to a remote region if no instances for an app is available locally. The new
     * behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplications(boolean includeRemoteRegion) {
        GET_ALL_CACHE_MISS.increment();
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {

                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();

                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }

                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Applications applications = remoteRegistry.getApplications();
                for (Application application : applications
                        .getRegisteredApplications()) {
                    Application appInLocalRegistry = apps
                            .getRegisteredApplications(application.getName());
                    if (appInLocalRegistry == null) {
                        apps.addApplication(application);
                    }
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    /**
     * Get the registry information about the delta changes. The deltas are
     * cached for a window specified by
     * {@link EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()}. Subsequent
     * requests for delta information may return the same information and client
     * must make sure this does not adversely affect them.
     *
     * @return all application deltas.
     * @deprecated use {@link #getApplicationDeltasFromMultipleRegions(String[])} instead. This method has a
     * flawed behavior of transparently falling back to a remote region if no instances for an app is available locally.
     * The new behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplicationDeltas() {
        GET_ALL_CACHE_MISS_DELTA.increment();
        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :"
                    + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();

            if (!disableTransparentFallback) {
                Applications allAppsInLocalRegion = getApplications(false);

                for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                    Applications applications = remoteRegistry.getApplicationDeltas();
                    for (Application application : applications.getRegisteredApplications()) {
                        Application appInLocalRegistry =
                                allAppsInLocalRegion.getRegisteredApplications(application.getName());
                        if (appInLocalRegistry == null) {
                            apps.addApplication(application);
                        }
                    }
                }
            }

            Applications allApps = getApplications(!disableTransparentFallback);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow =
                                            apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id) {
        return this.getInstanceByAppAndId(appName, id, true);
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id,
                                              boolean includeRemoteRegions) {
        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (leaseMap != null) {
            lease = leaseMap.get(id);
        }
        if (lease != null
                && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
            return decorateInstanceInfo(lease);
        } else if (includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application.getByInstanceId(id);
                }
            }
        }
        return null;
    }

    /**
     * Get all instances by ID, including automatically asking other regions if the ID is unknown.
     *
     * @see com.netflix.discovery.shared.LookupService#getInstancesById(String)
     */
    public List<InstanceInfo> getInstancesById(String id) {
        return this.getInstancesById(id, true);
    }

    /**
     * Get the list of instances by its unique id.
     *
     * @param id
     *            - the unique id of the instance
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return list of InstanceInfo objects.
     */
    public List<InstanceInfo> getInstancesById(String id,
                                               boolean includeRemoteRegions) {
        List<InstanceInfo> list = new ArrayList<InstanceInfo>();

        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = registry
                .entrySet().iterator(); iter.hasNext(); ) {

            Map<String, Lease<InstanceInfo>> leaseMap = iter.next().getValue();
            if (leaseMap != null) {
                Lease<InstanceInfo> lease = leaseMap.get(id);

                if (lease == null
                        || (isLeaseExpirationEnabled() && lease.isExpired())) {
                    continue;
                }

                if (list == Collections.EMPTY_LIST) {
                    list = new ArrayList<InstanceInfo>();
                }
                list.add(decorateInstanceInfo(lease));
            }
        }
        if (list.isEmpty() && includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                for (Application application : remoteRegistry.getApplications()
                        .getRegisteredApplications()) {
                    InstanceInfo instanceInfo = application.getByInstanceId(id);
                    if (instanceInfo != null) {
                        list.add(instanceInfo);
                        return list;
                    }
                }
            }
        }
        return list;
    }

    /**
     * Checks whether lease expiration is enabled.
     *
     * @return true if enabled
     */
    public abstract boolean isLeaseExpirationEnabled();

    private InstanceInfo decorateInstanceInfo(Lease<InstanceInfo> lease) {
        InstanceInfo info = lease.getHolder();

        // client app settings
        int renewalInterval = LeaseInfo.DEFAULT_LEASE_RENEWAL_INTERVAL;
        int leaseDuration = LeaseInfo.DEFAULT_LEASE_DURATION;

        // TODO: clean this up
        if (info.getLeaseInfo() != null) {
            renewalInterval = info.getLeaseInfo().getRenewalIntervalInSecs();
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }

        info.setLeaseInfo(LeaseInfo.Builder.newBuilder()
                .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                .setRenewalIntervalInSecs(renewalInterval)
                .setDurationInSecs(leaseDuration)
                .setEvictionTimestamp(lease.getEvictionTimestamp()).build());

        info.setIsCoordinatingDiscoveryServer();
        return info;
    }

    /**
     * Servo route; do not call.
     *
     * @return servo data
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsInLastMin",
            description = "Number of total heartbeats received in the last minute", type = DataSourceType.GAUGE)
    public long getNumOfRenewsInLastMin() {
        if (renewsLastMin != null) {
            return renewsLastMin.getCount();
        } else {
            return 0;
        }
    }

    /**
     * Get the N instances that are most recently registered.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNRegisteredInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();

        synchronized (recentRegisteredQueue) {
            for (Pair<Long, String> aRecentRegisteredQueue : recentRegisteredQueue) {
                list.add(aRecentRegisteredQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    /**
     * Get the N instances that have most recently canceled.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNCanceledInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();
        synchronized (recentCanceledQueue) {
            for (Pair<Long, String> aRecentCanceledQueue : recentCanceledQueue) {
                list.add(aRecentCanceledQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    private void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
        // invalidate cache
        ResponseCache.getInstance().invalidate(appName, vipAddress, secureVipAddress);
    }

    private static final class RecentlyChangedItem {
        private long lastUpdateTime;
        private Lease<InstanceInfo> leaseInfo;

        public RecentlyChangedItem(Lease<InstanceInfo> lease) {
            this.leaseInfo = lease;
            lastUpdateTime = System.currentTimeMillis();
        }

        public long getLastUpdateTime() {
            return this.lastUpdateTime;
        }

        public Lease<InstanceInfo> getLeaseInfo() {
            return this.leaseInfo;
        }
    }

    protected void postInit() {
        renewsLastMin = new MeasuredRate(1000 * 60 * 1);
        if (EVICTION_TASK.get() != null) {
            EVICTION_TASK.get().cancel();
        }
        EVICTION_TASK.set(new EvictionTask());
        evictionTimer.schedule(EVICTION_TASK.get(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs());
    }

    @com.netflix.servo.annotations.Monitor(name = "numOfElementsinInstanceCache", description = "Number of elements in the instance Cache", type = DataSourceType.GAUGE)
    public long getNumberofElementsininstanceCache() {
        return overriddenInstanceStatusMap.size();
    }

    private final class EvictionTask extends TimerTask {

        @Override
        public void run() {
            try {
                evict();
            } catch (Throwable e) {
                logger.error("Could not run the evict task", e);
            }
        }

    }


    private class CircularQueue<E> extends ConcurrentLinkedQueue<E> {
        private int size = 0;

        public CircularQueue(int size) {
            this.size = size;
        }

        @Override
        public boolean add(E e) {
            this.makeSpaceIfNotAvailable();
            return super.add(e);

        }

        private void makeSpaceIfNotAvailable() {
            if (this.size() == size) {
                this.remove();
            }
        }

        public boolean offer(E e) {
            this.makeSpaceIfNotAvailable();
            return super.offer(e);
        }
    }


    private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                       Lease<InstanceInfo> existingLease, boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance
        // says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat
        // failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed
        // as well since the service may be
        // currently in SERVICE
        if ((!InstanceStatus.UP.equals(r.getStatus()))
                && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug(
                    "Trusting the instance status {} from replica or instance for instance",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise
        // the ASG status
        if (overridden != null) {
            logger.debug(
                    "The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }
        // If the ASGName is present- check for its status
        boolean isASGDisabled = false;
        if (r.getASGName() != null) {
            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(
                    r.getASGName());
            logger.debug("The ASG name is specified {} and the value is {}",
                    r.getASGName(), isASGDisabled);
            if (isASGDisabled) {
                return InstanceStatus.OUT_OF_SERVICE;
            } else {
                return InstanceStatus.UP;
            }
        }
        // This is for backward compatibility until all applications have ASG
        // names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or
            // OUT_OF_SERVICE
            if ((existingStatus != null)
                    && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                    || InstanceStatus.UP.equals(existingStatus))) {
                logger.debug(
                        "There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug(
                "Returning the default instance status {} for instance {},",
                r.getStatus(), r.getId());
        return r.getStatus();
    }

    private TimerTask getDeltaRetentionTask() {
        return new TimerTask() {

            @Override
            public void run() {
                Iterator<RecentlyChangedItem> it = recentlyChangedQueue.iterator();
                while (it.hasNext()) {
                    if (it.next().getLastUpdateTime() <
                            System.currentTimeMillis() - EUREKA_CONFIG.getRetentionTimeInMSInDeltaQueue()) {
                        it.remove();
                    } else {
                        break;
                    }
                }
            }

        };
    }
=======
public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,
        LookupService<String> {

    private static final Logger logger = LoggerFactory
            .getLogger(InstanceRegistry.class);
    private static final EurekaServerConfig EUREKA_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final String[] EMPTY_STR_ARRAY = new String[0];
    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();
    private Timer evictionTimer = new Timer("Eureka-EvictionTimer", true);
    private volatile MeasuredRate renewsLastMin;
    protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
            .newBuilder().initialCapacity(500)
            .expireAfterAccess(1, TimeUnit.HOURS)
            .<String, InstanceStatus>build().asMap();

    // CircularQueues here for debugging/statistics purposes only
    private final CircularQueue<Pair<Long, String>> recentRegisteredQueue;
    private final CircularQueue<Pair<Long, String>> recentCanceledQueue;
    private Timer deltaRetentionTimer = new Timer("Eureka-DeltaRetentionTimer",
            true);
    private ConcurrentLinkedQueue<RecentlyChangedItem> recentlyChangedQueue = new ConcurrentLinkedQueue<RecentlyChangedItem>();
    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock read = readWriteLock.readLock();
    private final Lock write = readWriteLock.writeLock();
    protected Map<String, RemoteRegionRegistry> regionNameVSRemoteRegistry = new HashMap<String, RemoteRegionRegistry>();
    protected String[] allKnownRemoteRegions = EMPTY_STR_ARRAY;
    protected final Object lock = new Object();
    protected volatile int numberOfRenewsPerMinThreshold;
    protected volatile int expectedNumberOfRenewsPerMin;
    protected static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();

    private static final AtomicReference<EvictionTask> EVICTION_TASK = new AtomicReference<EvictionTask>();


    /**
     * Create a new, empty instance registry.
     */
    protected InstanceRegistry() {
        recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);
        recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);
        deltaRetentionTimer.schedule(getDeltaRetentionTask(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs());
    }

    /**
     * Completely clear the registry.
     */
    public void clearRegistry() {
        overriddenInstanceStatusMap.clear();
        recentCanceledQueue.clear();
        recentRegisteredQueue.clear();
        recentlyChangedQueue.clear();
        registry.clear();

    }

    /**
     * Registers a new instance with a given duration.
     *
     * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object,
     * int, boolean)
     */
    public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
        try {
            read.lock();
            Map<String, Lease<InstanceInfo>> gMap = registry.get(r
                    .getAppName());
            REGISTER.increment(isReplication);
            if (gMap == null) {
                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap =
                        new ConcurrentHashMap<String, Lease<InstanceInfo>>();
                gMap = registry.putIfAbsent(r.getAppName(), gNewMap);
                if (gMap == null) {
                    gMap = gNewMap;
                }
            }
            Lease<InstanceInfo> existingLease = gMap.get(r.getId());
            // Retain the last dirty timestamp without overwriting it, if there
            // is already a lease
            if (existingLease != null && (existingLease.getHolder() != null)) {
                Long existingLastDirtyTimestamp = existingLease.getHolder()
                        .getLastDirtyTimestamp();
                Long registrationLastDirtyTimestamp = r.getLastDirtyTimestamp();
                if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                    logger.warn(
                            "There is an existing lease and the existing lease's dirty timestamp {} is greater than "
                                    + "the one that is being registered {}", existingLastDirtyTimestamp,
                            registrationLastDirtyTimestamp);
                    r.setLastDirtyTimestamp(existingLastDirtyTimestamp);
                }
            } else {
                // The lease does not exist and hence it is a new registration
                synchronized (lock) {
                    if (this.expectedNumberOfRenewsPerMin > 0) {
                        // Since the client wants to cancel it, reduce the threshold
                        // (1
                        // for 30 seconds, 2 for a minute)
                        this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;
                        this.numberOfRenewsPerMinThreshold =
                                (int) (this.expectedNumberOfRenewsPerMin
                                        * EUREKA_SERVER_CONFIG.getRenewalPercentThreshold());
                    }
                }
            }
            Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                    leaseDuration);
            if (existingLease != null) {
                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
            }
            gMap.put(r.getId(), lease);
            synchronized (recentRegisteredQueue) {
                recentRegisteredQueue.add(new Pair<Long, String>(System.currentTimeMillis(), r.getAppName()
                        + "(" + r.getId() + ")"));
            }
            // This is where the initial state transfer of overridden status
            // happens
            if (!InstanceStatus.UNKNOWN.equals(r.getOverriddenStatus())) {
                logger.debug(
                        "Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                                + "overrides", r.getOverriddenStatus(), r.getId());
                if (!overriddenInstanceStatusMap.containsKey(r.getId())) {
                    logger.info(
                            "Not found overridden id {} and hence adding it",
                            r.getId());
                    overriddenInstanceStatusMap.put(r.getId(),
                            r.getOverriddenStatus());
                }
            }
            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(r.getId());
            if (overriddenStatusFromMap != null) {
                logger.info(
                        "Storing overridden status {} from map", overriddenStatusFromMap);
                r.setOverriddenStatus(overriddenStatusFromMap);
            }

            // Set the status based on the overridden status rules
            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(
                    r, existingLease, isReplication);
            r.setStatusWithoutDirty(overriddenInstanceStatus);

            // If the lease is registered with UP status, set lease service up timestamp
            if (InstanceStatus.UP.equals(r.getStatus())) {
                lease.serviceUp();
            }
            r.setActionType(ActionType.ADDED);
            recentlyChangedQueue.add(new RecentlyChangedItem(lease));
            r.setLastUpdatedTimestamp();
            invalidateCache(r.getAppName(), r.getVIPAddress(), r.getSecureVipAddress());
            logger.info("Registered instance id {} with status {}", r.getId(),
                    r.getStatus().toString());
            logger.debug("DS: Registry: registered " + r.getAppName() + " - "
                    + r.getId());
        } finally {
            read.unlock();
        }
    }

    /**
     * Cancels the registration of an instance.
     *
     * <p>
     * This is normally invoked by a client when it shuts down informing the
     * server to remove the instance from traffic.
     * </p>
     *
     * @param appName
     *            the application name of the application.
     * @param id
     *            the unique identifier of the instance.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the instance was removed from the
     *         {@link InstanceRegistry} successfully, false otherwise.
     */
    public boolean cancel(String appName, String id, boolean isReplication) {
        try {
            read.lock();
            CANCEL.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> leaseToCancel = null;
            if (gMap != null) {
                leaseToCancel = gMap.remove(id);
            }
            synchronized (recentCanceledQueue) {
                recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
            }
            InstanceStatus instanceStatus = overriddenInstanceStatusMap
                    .remove(id);
            if (instanceStatus != null) {
                logger.debug(
                        "Removed instance id {} from the overridden map which has value {}",
                        id, instanceStatus.name());
            }
            if (leaseToCancel == null) {
                CANCEL_NOT_FOUND.increment(isReplication);
                logger.warn("DS: Registry: cancel failed because Lease is not registered for: "
                        + appName + ":" + id);
                return false;
            } else {
                leaseToCancel.cancel();
                InstanceInfo instanceInfo = leaseToCancel.getHolder();
                String vip = null;
                String svip = null;
                if (instanceInfo != null) {
                    instanceInfo.setActionType(ActionType.DELETED);
                    recentlyChangedQueue.add(new RecentlyChangedItem(
                            leaseToCancel));
                    instanceInfo.setLastUpdatedTimestamp();
                    vip = instanceInfo.getVIPAddress();
                    svip = instanceInfo.getSecureVipAddress();
                }
                invalidateCache(appName, vip, svip);
                logger.debug("DS: Registry: canceled lease: " + appName + " - "
                        + id);
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Marks the given instance of the given app name as renewed, and also marks whether it originated from
     * replication.
     *
     * @see com.netflix.eureka.lease.LeaseManager#renew(java.lang.String,
     * java.lang.String, boolean)
     */
    public boolean renew(String appName, String id, boolean isReplication) {
        RENEW.increment(isReplication);
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        Lease<InstanceInfo> leaseToRenew = null;
        if (gMap != null) {
            leaseToRenew = gMap.get(id);
        }
        if (leaseToRenew == null) {
            RENEW_NOT_FOUND.increment(isReplication);
            logger.warn("DS: Registry: lease doesn't exist, registering resource: "
                    + appName + " - " + id);
            return false;
        } else {
            InstanceInfo instanceInfo = leaseToRenew.getHolder();
            if (instanceInfo != null) {
                // touchASGCache(instanceInfo.getASGName());
                InstanceStatus overriddenInstanceStatus = this
                        .getOverriddenInstanceStatus(instanceInfo,
                                leaseToRenew, isReplication);
                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
                    logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                            + "; re-register required", instanceInfo.getId());
                    RENEW_NOT_FOUND.increment(isReplication);
                    return false;
                }
                if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
                    Object[] args = {instanceInfo.getStatus().name(),
                            instanceInfo.getOverriddenStatus().name(),
                            instanceInfo.getId()};
                    logger.info(
                            "The instance status {} is different from overridden instance status {} for instance {}. "
                                    + "Hence setting the status to overridden status", args);
                    instanceInfo.setStatus(overriddenInstanceStatus);
                }
            }
            renewsLastMin.increment();
            leaseToRenew.renew();
            return true;
        }
    }

    /**
     * Stores overridden status if it is not already there. This happens during
     * a reconciliation process during renewal requests.
     *
     * @param id
     *            the unique identifier of the instance.
     * @param overriddenStatus
     *            Overridden status if any.
     */
    public void storeOverriddenStatusIfRequired(String id,
                                                InstanceStatus overriddenStatus) {
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.get(id);
        if ((instanceStatus == null)
                || (!overriddenStatus.equals(instanceStatus))) {
            // We might not have the overridden status if the server got
            // restarted -this will help us maintain the overridden state
            // from the replica
            logger.info(
                    "Adding overridden status for instance id {} and the value is {}",
                    id, overriddenStatus.name());
            overriddenInstanceStatusMap.put(id, overriddenStatus);
            List<InstanceInfo> instanceInfo = this.getInstancesById(id, false);
            if ((instanceInfo != null) && (!instanceInfo.isEmpty())) {
                instanceInfo.iterator().next().setOverriddenStatus(overriddenStatus);
                logger.info(
                        "Setting the overridden status for instance id {} and the value is {} ",
                        id, overriddenStatus.name());

            }
        }
    }

    /**
     * Updates the status of an instance. Normally happens to put an instance
     * between {@link InstanceStatus#OUT_OF_SERVICE} and
     * {@link InstanceStatus#UP} to put the instance in and out of traffic.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean statusUpdate(String appName, String id,
                                InstanceStatus newStatus, String lastDirtyTimestamp,
                                boolean isReplication) {
        try {
            read.lock();
            STATUS_UPDATE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                if ((info != null) && !(info.getStatus().equals(newStatus))) {
                    // Mark service as UP if needed
                    if (InstanceStatus.UP.equals(newStatus)) {
                        lease.serviceUp();
                    }
                    // This is NAC overriden status
                    overriddenInstanceStatusMap.put(id, newStatus);
                    // Set it for transfer of overridden status to replica on
                    // replica start up
                    info.setOverriddenStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                        info.setStatusWithoutDirty(newStatus);
                    } else {
                        info.setStatus(newStatus);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Removes status override for a give instance.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        try {
            read.lock();
            STATUS_OVERRIDE_DELETE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
                if (currentOverride != null && info != null) {
                    info.setOverriddenStatus(InstanceStatus.UNKNOWN);
                    info.setStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Evicts everything in the instance registry that has expired, if expiry is enabled.
     *
     * @see com.netflix.eureka.lease.LeaseManager#evict()
     */
    public void evict() {
        if (!isLeaseExpirationEnabled()) {
            logger.debug("DS: lease expiration is currently disabled.");
            return;
        }
        logger.debug("Running the evict task");
        for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
            Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
            if (leaseMap != null) {
                for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
                    Lease<InstanceInfo> lease = leaseEntry.getValue();
                    if (lease.isExpired() && lease.getHolder() != null) {
                        String appName = lease.getHolder().getAppName();
                        String id = lease.getHolder().getId();
                        EXPIRED.increment();
                        logger.warn("DS: Registry: expired lease for "
                                + appName + " - " + id);
                        cancel(appName, id, false);
                    }
                }
            }
        }
    }

    /**
     * Returns the given app that is in this instance only, falling back to other regions transparently only
     * if specified in this client configuration.
     *
     * @param appName
     *      - the application name of the application
     * @return the application
     *
     * @see
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
     */
    public Application getApplication(String appName) {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        return this.getApplication(appName, !disableTransparentFallback);
    }

    /**
     * Get application information.
     *
     * @param appName
     *            - The name of the application
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the application
     */
    public Application getApplication(String appName, boolean includeRemoteRegion) {
        Application app = null;

        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);

        if (leaseMap != null && leaseMap.size() > 0) {
            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {
                if (app == null) {
                    app = new Application(appName);
                }
                app.addInstance(decorateInstanceInfo(entry.getValue()));
            }
        } else if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application;
                }
            }
        }
        return app;
    }

    /**
     * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.
     *
     * @return the list of all known applications
     *
     * @see com.netflix.discovery.shared.LookupService#getApplications()
     */
    public Applications getApplications() {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        if (disableTransparentFallback) {
            return getApplicationsFromLocalRegionOnly();
        } else {
            return this.getApplications(true); // Behavior of falling back to remote region can be disabled.
        }
    }

    /**
     * Returns applications including instances from all remote regions. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with a <code>null</code> argument.
     */
    public Applications getApplicationsFromAllRemoteRegions() {
        return getApplicationsFromMultipleRegions(allKnownRemoteRegions);
    }

    /**
     * Returns applications including instances from local region only. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with an empty array.
     */
    public Applications getApplicationsFromLocalRegionOnly() {
        return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);
    }

    /**
     * This method will return applications with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     * The application instances for which this union will be done can be restricted to the names returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for every region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     * If you are not selectively requesting for a remote region, use {@link #getApplicationsFromAllRemoteRegions()}
     * or {@link #getApplicationsFromLocalRegionOnly()}
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> or empty no remote regions are
     *                      included.
     *
     * @return The applications with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be only for certain whitelisted apps as explained above.
     */
    public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {

        boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;

        logger.info("Fetching applications registry with remote regions: {}, Regions argument {}", includeRemoteRegion,
                Arrays.toString(remoteRegions));

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
        } else {
            GET_ALL_CACHE_MISS.increment();
        }
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }
                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                if (null != remoteRegistry) {
                    Applications remoteApps = remoteRegistry.getApplications();
                    for (Application application : remoteApps.getRegisteredApplications()) {
                        if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                            logger.info("Application {}  fetched from the remote region {}",
                                    application.getName(), remoteRegion);

                            Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                            if (appInstanceTillNow == null) {
                                appInstanceTillNow = new Application(application.getName());
                                apps.addApplication(appInstanceTillNow);
                            }
                            for (InstanceInfo instanceInfo : application.getInstances()) {
                                appInstanceTillNow.addInstance(instanceInfo);
                            }
                        } else {
                            logger.debug("Application {} not fetched from the remote region {} as there exists a "
                                            + "whitelist and this app is not in the whitelist.",
                                    application.getName(), remoteRegion);
                        }
                    }
                } else {
                    logger.warn("No remote registry available for the remote region {}", remoteRegion);
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {
        Set<String> whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(remoteRegion);
        if (null == whiteList) {
            whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(null); // see global whitelist.
        }
        return null == whiteList || whiteList.contains(appName);
    }

    /**
     * Get the registry information about all {@link Applications}.
     *
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return applications
     * @deprecated Use {@link #getApplicationsFromMultipleRegions(String[])} instead. This method has a flawed behavior
     * of transparently falling back to a remote region if no instances for an app is available locally. The new
     * behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplications(boolean includeRemoteRegion) {
        GET_ALL_CACHE_MISS.increment();
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {

                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();

                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }

                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Applications applications = remoteRegistry.getApplications();
                for (Application application : applications
                        .getRegisteredApplications()) {
                    Application appInLocalRegistry = apps
                            .getRegisteredApplications(application.getName());
                    if (appInLocalRegistry == null) {
                        apps.addApplication(application);
                    }
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    /**
     * Get the registry information about the delta changes. The deltas are
     * cached for a window specified by
     * {@link EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()}. Subsequent
     * requests for delta information may return the same information and client
     * must make sure this does not adversely affect them.
     *
     * @return all application deltas.
     * @deprecated use {@link #getApplicationDeltasFromMultipleRegions(String[])} instead. This method has a
     * flawed behavior of transparently falling back to a remote region if no instances for an app is available locally.
     * The new behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplicationDeltas() {
        GET_ALL_CACHE_MISS_DELTA.increment();
        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :"
                    + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();

            if (!disableTransparentFallback) {
                Applications allAppsInLocalRegion = getApplications(false);

                for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                    Applications applications = remoteRegistry.getApplicationDeltas();
                    for (Application application : applications.getRegisteredApplications()) {
                        Application appInLocalRegistry =
                                allAppsInLocalRegion.getRegisteredApplications(application.getName());
                        if (appInLocalRegistry == null) {
                            apps.addApplication(application);
                        }
                    }
                }
            }

            Applications allApps = getApplications(!disableTransparentFallback);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow =
                                            apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id) {
        return this.getInstanceByAppAndId(appName, id, true);
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id,
                                              boolean includeRemoteRegions) {
        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (leaseMap != null) {
            lease = leaseMap.get(id);
        }
        if (lease != null
                && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
            return decorateInstanceInfo(lease);
        } else if (includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application.getByInstanceId(id);
                }
            }
        }
        return null;
    }

    /**
     * Get all instances by ID, including automatically asking other regions if the ID is unknown.
     *
     * @see com.netflix.discovery.shared.LookupService#getInstancesById(String)
     */
    public List<InstanceInfo> getInstancesById(String id) {
        return this.getInstancesById(id, true);
    }

    /**
     * Get the list of instances by its unique id.
     *
     * @param id
     *            - the unique id of the instance
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return list of InstanceInfo objects.
     */
    public List<InstanceInfo> getInstancesById(String id,
                                               boolean includeRemoteRegions) {
        List<InstanceInfo> list = new ArrayList<InstanceInfo>();

        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = registry
                .entrySet().iterator(); iter.hasNext(); ) {

            Map<String, Lease<InstanceInfo>> leaseMap = iter.next().getValue();
            if (leaseMap != null) {
                Lease<InstanceInfo> lease = leaseMap.get(id);

                if (lease == null
                        || (isLeaseExpirationEnabled() && lease.isExpired())) {
                    continue;
                }

                if (list == Collections.EMPTY_LIST) {
                    list = new ArrayList<InstanceInfo>();
                }
                list.add(decorateInstanceInfo(lease));
            }
        }
        if (list.isEmpty() && includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                for (Application application : remoteRegistry.getApplications()
                        .getRegisteredApplications()) {
                    InstanceInfo instanceInfo = application.getByInstanceId(id);
                    if (instanceInfo != null) {
                        list.add(instanceInfo);
                        return list;
                    }
                }
            }
        }
        return list;
    }

    /**
     * Checks whether lease expiration is enabled.
     *
     * @return true if enabled
     */
    public abstract boolean isLeaseExpirationEnabled();

    private InstanceInfo decorateInstanceInfo(Lease<InstanceInfo> lease) {
        InstanceInfo info = lease.getHolder();

        // client app settings
        int renewalInterval = LeaseInfo.DEFAULT_LEASE_RENEWAL_INTERVAL;
        int leaseDuration = LeaseInfo.DEFAULT_LEASE_DURATION;

        // TODO: clean this up
        if (info.getLeaseInfo() != null) {
            renewalInterval = info.getLeaseInfo().getRenewalIntervalInSecs();
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }

        info.setLeaseInfo(LeaseInfo.Builder.newBuilder()
                .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                .setRenewalIntervalInSecs(renewalInterval)
                .setDurationInSecs(leaseDuration)
                .setEvictionTimestamp(lease.getEvictionTimestamp()).build());

        info.setIsCoordinatingDiscoveryServer();
        return info;
    }

    /**
     * Servo route; do not call.
     *
     * @return servo data
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsInLastMin",
            description = "Number of total heartbeats received in the last minute", type = DataSourceType.GAUGE)
    public long getNumOfRenewsInLastMin() {
        if (renewsLastMin != null) {
            return renewsLastMin.getCount();
        } else {
            return 0;
        }
    }

    /**
     * Get the N instances that are most recently registered.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNRegisteredInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();

        synchronized (recentRegisteredQueue) {
            for (Pair<Long, String> aRecentRegisteredQueue : recentRegisteredQueue) {
                list.add(aRecentRegisteredQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    /**
     * Get the N instances that have most recently canceled.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNCanceledInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();
        synchronized (recentCanceledQueue) {
            for (Pair<Long, String> aRecentCanceledQueue : recentCanceledQueue) {
                list.add(aRecentCanceledQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    private void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
        // invalidate cache
        ResponseCache.getInstance().invalidate(appName, vipAddress, secureVipAddress);
    }

    private static final class RecentlyChangedItem {
        private long lastUpdateTime;
        private Lease<InstanceInfo> leaseInfo;

        public RecentlyChangedItem(Lease<InstanceInfo> lease) {
            this.leaseInfo = lease;
            lastUpdateTime = System.currentTimeMillis();
        }

        public long getLastUpdateTime() {
            return this.lastUpdateTime;
        }

        public Lease<InstanceInfo> getLeaseInfo() {
            return this.leaseInfo;
        }
    }

    protected void postInit() {
        renewsLastMin = new MeasuredRate(1000 * 60 * 1);
        if (EVICTION_TASK.get() != null) {
            EVICTION_TASK.get().cancel();
        }
        EVICTION_TASK.set(new EvictionTask());
        evictionTimer.schedule(EVICTION_TASK.get(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs());
    }

    @com.netflix.servo.annotations.Monitor(name = "numOfElementsinInstanceCache", description = "Number of elements in the instance Cache", type = DataSourceType.GAUGE)
    public long getNumberofElementsininstanceCache() {
        return overriddenInstanceStatusMap.size();
    }

    private final class EvictionTask extends TimerTask {

        @Override
        public void run() {
            try {
                evict();
            } catch (Throwable e) {
                logger.error("Could not run the evict task", e);
            }
        }

    }


    private class CircularQueue<E> extends ConcurrentLinkedQueue<E> {
        private int size = 0;

        public CircularQueue(int size) {
            this.size = size;
        }

        @Override
        public boolean add(E e) {
            this.makeSpaceIfNotAvailable();
            return super.add(e);

        }

        private void makeSpaceIfNotAvailable() {
            if (this.size() == size) {
                this.remove();
            }
        }

        public boolean offer(E e) {
            this.makeSpaceIfNotAvailable();
            return super.offer(e);
        }
    }


    private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                       Lease<InstanceInfo> existingLease, boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance
        // says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat
        // failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed
        // as well since the service may be
        // currently in SERVICE
        if ((!InstanceStatus.UP.equals(r.getStatus()))
                && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug(
                    "Trusting the instance status {} from replica or instance for instance",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise
        // the ASG status
        if (overridden != null) {
            logger.debug(
                    "The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }
        // If the ASGName is present- check for its status
        boolean isASGDisabled = false;
        if (r.getASGName() != null) {
            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(
                    r.getASGName());
            logger.debug("The ASG name is specified {} and the value is {}",
                    r.getASGName(), isASGDisabled);
            if (isASGDisabled) {
                return InstanceStatus.OUT_OF_SERVICE;
            } else {
                return InstanceStatus.UP;
            }
        }
        // This is for backward compatibility until all applications have ASG
        // names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or
            // OUT_OF_SERVICE
            if ((existingStatus != null)
                    && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                    || InstanceStatus.UP.equals(existingStatus))) {
                logger.debug(
                        "There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug(
                "Returning the default instance status {} for instance {},",
                r.getStatus(), r.getId());
        return r.getStatus();
    }

    private TimerTask getDeltaRetentionTask() {
        return new TimerTask() {

            @Override
            public void run() {
                Iterator<RecentlyChangedItem> it = recentlyChangedQueue.iterator();
                while (it.hasNext()) {
                    if (it.next().getLastUpdateTime() <
                            System.currentTimeMillis() - EUREKA_CONFIG.getRetentionTimeInMSInDeltaQueue()) {
                        it.remove();
                    } else {
                        break;
                    }
                }
            }

        };
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_81aaebd_756bcd9/rev_81aaebd-756bcd9/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistry.java;<<<<<<< MINE
public interface PeerAwareInstanceRegistry extends InstanceRegistry {
    void register(InstanceInfo info, boolean isReplication);
||||||| BASE
public class PeerAwareInstanceRegistry extends InstanceRegistry {
    private static final String US_EAST_1 = "us-east-1";

    private static final int PRIME_PEER_NODES_RETRY_MS = 30000;

    private static final int REGISTRY_SYNC_RETRY_MS = 30000;

    private static final Logger logger = LoggerFactory
            .getLogger(PeerAwareInstanceRegistry.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final EurekaClientConfig EUREKA_CLIENT_CONFIG = DiscoveryManager
            .getInstance().getEurekaClientConfig();

    private long startupTime = 0;
    private boolean peerInstancesTransferEmptyOnStartup = true;
    private static final Timer timerReplicaNodes = new Timer(
            "Eureka-PeerNodesUpdater", true);

    public enum Action {
        Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;

        private com.netflix.servo.monitor.Timer timer = Monitors.newTimer(this
                .name());

        public com.netflix.servo.monitor.Timer getTimer() {
            return this.timer;
        }

    }

    private static final Comparator<Application> APP_COMPARATOR = new Comparator<Application>() {
        public int compare(Application l, Application r) {
            return l.getName().compareTo(r.getName());
        }
    };

    private final MeasuredRate numberOfReplicationsLastMin = new MeasuredRate(
            1000 * 60 * 1);


    private AtomicReference<List<PeerEurekaNode>> peerEurekaNodes;

    private Timer timer = new Timer(
            "ReplicaAwareInstanceRegistry - RenewalThresholdUpdater", true);

    private static final PeerAwareInstanceRegistry instance = new PeerAwareInstanceRegistry();

    PeerAwareInstanceRegistry() {
        // Make it an atomic reference since this could be updated in the
        // background.
        peerEurekaNodes = new AtomicReference<List<PeerEurekaNode>>();
        peerEurekaNodes.set(new ArrayList<PeerEurekaNode>());
        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn(
                    "Cannot register the JMX monitor for the InstanceRegistry :",
                    e);
        }
        init();
    }

    public static PeerAwareInstanceRegistry getInstance() {
        return instance;
    }

    /**
     * Set up replica nodes and the task that updates the threshold
     * periodically.
     */
    private void init() {
        setupPeerEurekaNodes();
        scheduleRenewalThresholdUpdateTask();
    }

    /**
     * Schedule the task that updates <em>renewal threshold</em> periodically.
     * The renewal threshold would be used to determine if the renewals drop
     * dramatically because of network partition and to protect expiring too
     * many instances at a time.
     *
     */
    private void scheduleRenewalThresholdUpdateTask() {
        timer.schedule(new TimerTask() {

                           @Override
                           public void run() {
                               updateRenewalThreshold();

                           }

                       }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
                EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs());
    }

    /**
     * Set up a schedule task to update peer eureka node information
     * periodically to determine if a node has been removed or added to the
     * list.
     */
    private void setupPeerEurekaNodes() {
        try {
            updatePeerEurekaNodes();
            timerReplicaNodes.schedule(new TimerTask() {

                                           @Override
                                           public void run() {
                                               try {
                                                   updatePeerEurekaNodes();
                                               } catch (Throwable e) {
                                                   logger.error("Cannot update the replica Nodes", e);
                                               }

                                           }
                                       }, EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs(),
                    EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs());

        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    /**
     * Update information about peer eureka nodes.
     */
    private void updatePeerEurekaNodes() {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();

        EurekaClientConfig clientConfig = DiscoveryManager.getInstance().getEurekaClientConfig();
        String zone = InstanceInfo.getZone(
                clientConfig.getAvailabilityZones(clientConfig.getRegion()),
                myInfo);

        List<String> replicaUrls = DiscoveryManager.getInstance().getEurekaClient().getDiscoveryServiceUrls(zone);

        List<PeerEurekaNode> replicaNodes = new ArrayList<PeerEurekaNode>();
        for (String replicaUrl : replicaUrls) {
            if (!isThisMe(replicaUrl)) {
                logger.info("Adding replica node: " + replicaUrl);
                replicaNodes.add(new PeerEurekaNode(replicaUrl));
            }
        }
        if (replicaNodes.isEmpty()) {
            logger.warn("The replica size seems to be empty. Check the route 53 DNS Registry");
            return;
        }
        List<PeerEurekaNode> existingReplicaNodes = peerEurekaNodes.get();
        if (!replicaNodes.equals(existingReplicaNodes)) {
            List<String> previousServiceUrls = new ArrayList<String>();
            for (PeerEurekaNode node : existingReplicaNodes) {
                previousServiceUrls.add(node.getServiceUrl());
            }
            List<String> currentServiceUrls = new ArrayList<String>();
            for (PeerEurekaNode node : replicaNodes) {
                currentServiceUrls.add(node.getServiceUrl());
            }
            logger.info(
                    "Updating the replica nodes as they seem to have changed from {} to {} ",
                    previousServiceUrls, currentServiceUrls);
            peerEurekaNodes.set(replicaNodes);
            for (PeerEurekaNode existingReplicaNode : existingReplicaNodes) {
                existingReplicaNode.destroyResources();
            }
        } else {
            for (PeerEurekaNode replicaNode : replicaNodes) {
                replicaNode.destroyResources();
            }
        }
    }

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        LookupService lookupService = DiscoveryManager.getInstance()
                .getLookupService();
        int count = 0;

        for (int i = 0; ((i < EUREKA_SERVER_CONFIG.getRegistrySyncRetries()) && (count == 0)); i++) {
            Applications apps = lookupService.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {

                            register(instance, instance.getLeaseInfo()
                                    .getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
            if (count == 0) {
                try {
                    Thread.sleep(REGISTRY_SYNC_RETRY_MS);
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
        }
        return count;
    }

    public void openForTraffic(int count) {
        // Renewals happen every 30 seconds and for a minute it should be a
        // factor of 2.
        this.expectedNumberOfRenewsPerMin = count * 2;
        this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                .getRenewalPercentThreshold());
        logger.info("Got " + count + " instances from neighboring DS node");
        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
        this.startupTime = System.currentTimeMillis();
        if (count > 0) {
            this.peerInstancesTransferEmptyOnStartup = false;
        }
        boolean isAws = (Name.Amazon.equals(ApplicationInfoManager
                .getInstance().getInfo().getDataCenterInfo().getName()));
        if (isAws && EUREKA_SERVER_CONFIG.shouldPrimeAwsReplicaConnections()) {
            logger.info("Priming AWS connections for all replicas..");
            primeAwsReplicas();
        }
        logger.info("Changing status to UP");
        ApplicationInfoManager.getInstance().setInstanceStatus(
                InstanceStatus.UP);
        super.postInit();
    }

    /**
     * Prime connections for Aws replicas.
     * <p>
     * Sometimes when the eureka servers comes up, AWS firewall may not allow
     * the network connections immediately. This will cause the outbound
     * connections to fail, but the inbound connections continue to work. What
     * this means is the clients would have switched to this node (after EIP
     * binding) and so the other eureka nodes will expire all instances that
     * have been switched because of the lack of outgoing heartbeats from this
     * instance.
     * </p>
     * <p>
     * The best protection in this scenario is to block and wait until we are
     * able to ping all eureka nodes successfully atleast once. Until then we
     * won't open up the traffic.
     * </p>
     */
    private void primeAwsReplicas() {
        boolean areAllPeerNodesPrimed = false;
        while (!areAllPeerNodesPrimed) {
            String peerHostName = null;
            try {
                Application eurekaApps = this.getApplication(
                        ApplicationInfoManager.getInstance().getInfo()
                                .getAppName(), false);
                if (eurekaApps == null) {
                    areAllPeerNodesPrimed = true;
                }
                for (PeerEurekaNode node : peerEurekaNodes.get()) {
                    for (InstanceInfo peerInstanceInfo : eurekaApps
                            .getInstances()) {
                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();
                        // If the lease is expired - do not worry about priming
                        if (System.currentTimeMillis() > (leaseInfo
                                .getRenewalTimestamp() + (leaseInfo
                                .getDurationInSecs() * 1000))
                                + (2 * 60 * 1000)) {
                            continue;
                        }
                        peerHostName = peerInstanceInfo.getHostName();
                        logger.info(
                                "Trying to send heartbeat for the eureka server at {} to make sure the network "
                                        + "channels are open", peerHostName);
                        // Only try to contact the eureka nodes that are in this
                        // instance's registry - because
                        // the other instances may be legitimately down
                        if (peerHostName.equalsIgnoreCase(new URI(node
                                .getServiceUrl()).getHost())) {
                            node.heartbeat(peerInstanceInfo.getAppName(),
                                    peerInstanceInfo.getId(), peerInstanceInfo,
                                    null, true);
                        }
                    }
                }
                areAllPeerNodesPrimed = true;
            } catch (Throwable e) {
                logger.error("Could not contact " + peerHostName, e);
                try {
                    Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                } catch (InterruptedException e1) {
                    logger.warn("Interrupted while priming : ", e1);
                    areAllPeerNodesPrimed = true;
                }
            }
        }
    }

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, o otherwise returns
     *         true
     */
    public boolean shouldAllowAccess(boolean remoteRegionRequired) {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (!(System.currentTimeMillis() > this.startupTime
                    + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
                return false;
            }
        }
        if (remoteRegionRequired) {
            for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
                if (!remoteRegionRegistry.isReadyForServingData()) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean shouldAllowAccess() {
        return shouldAllowAccess(true);
    }

    /**
     * Gets the list of peer eureka nodes which is the list to replicate
     * information to.
     *
     * @return the list of replica nodes.
     */
    public List<PeerEurekaNode> getReplicaNodes() {
        return Collections.unmodifiableList(peerEurekaNodes.get());
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#cancel(java.lang.String,
     * java.lang.String, long, boolean)
     */
    @Override
    public boolean cancel(final String appName, final String id,
                          final boolean isReplication) {
        if (super.cancel(appName, id, isReplication)) {
            replicateToPeers(Action.Cancel, appName, id, null, null,
                    isReplication);
            synchronized (lock) {
                if (this.expectedNumberOfRenewsPerMin > 0) {
                    // Since the client wants to cancel it, reduce the threshold
                    // (1
                    // for 30 seconds, 2 for a minute)
                    this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2;
                    this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Registers the information about the {@link InstanceInfo} and replicates
     * this information to all peer eureka nodes. If this is replication event
     * from other replica nodes then it is not replicated.
     *
     * @param info
     *            the {@link InstanceInfo} to be registered and replicated.
     * @param isReplication
     *            true if this is a replication event from other replica nodes,
     *            false otherwise.
     */
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null
                && info.getLeaseInfo().getDurationInSecs() > 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(),
                info, null, isReplication);
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#renew(java.lang.String,
     * java.lang.String, long, boolean)
     */
    public boolean renew(final String appName, final String id,
                         final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null,
                    isReplication);
            return true;
        }
        return false;
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String,
     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,
     * java.lang.String, boolean)
     */
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp,
                isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus,
                    isReplication);
            return true;
        }
        return false;
    }

    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /**
     * Replicate the <em>ASG status</em> updates to peer eureka nodes. If this
     * event is a replication from other nodes, then it is not replicated to
     * other nodes.
     *
     * @param asgName
     *            the asg name for which the status needs to be replicated.
     * @param newStatus
     *            the {@link ASGStatus} information that needs to be replicated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     */
    public void statusUpdate(final String asgName, final ASGStatus newStatus,
                             final boolean isReplication) {
        // If this is replicated from an other node, do not try to replicate
        // again.
        if (isReplication) {
            return;
        }
        for (final PeerEurekaNode node : peerEurekaNodes.get()) {
            replicateASGInfoToReplicaNodes(asgName, newStatus, node);

        }

    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#isLeaseExpirationEnabled()
     */
    @Override
    public boolean isLeaseExpirationEnabled() {
        boolean leaseExpirationEnabled = (numberOfRenewsPerMinThreshold > 0)
                && (getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold);
        boolean isSelfPreservationModeEnabled = isSelfPreservationModeEnabled();
        if ((!leaseExpirationEnabled)) {
            if (!isSelfPreservationModeEnabled) {
                logger.warn("The self preservation mode is disabled!. Hence allowing the instances to expire.");
                leaseExpirationEnabled = true;
            }
        }
        return leaseExpirationEnabled;
    }

    /**
     * Checks to see if the self-preservation mode is enabled.
     *
     * <p>
     * The self-preservation mode is enabled if the expected number of renewals
     * per minute {@link #getNumOfRenewsInLastMin()} is lesser than the expected
     * threshold which is determined by {@link #getNumOfRenewsPerMinThreshold()}
     * . Eureka perceives this as a danger and stops expiring instances as this
     * is most likely because of a network event. The mode is disabled only when
     * the renewals get back to above the threshold or if the flag
     * {@link EurekaServerConfig#shouldEnableSelfPreservation()} is set to
     * false.
     * </p>
     *
     * @return true if the self-preservation mode is enabled, false otherwise.
     */
    public boolean isSelfPreservationModeEnabled() {
        return EUREKA_SERVER_CONFIG.shouldEnableSelfPreservation();
    }

    /**
     * Perform all cleanup and shutdown operations.
     */
    void shutdown() {
        try {
            DefaultMonitorRegistry.getInstance().unregister(
                    Monitors.newObjectMonitor(this));
        } catch (Throwable t) {
            logger.error("Cannot shutdown monitor registry", t);
        }
        try {
            for (PeerEurekaNode node : this.peerEurekaNodes.get()) {
                node.shutDown();
            }
        } catch (Throwable t) {
            logger.error("Cannot shutdown ReplicaAwareInstanceRegistry", t);
        }
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String virtualHostname,
                                                boolean secure) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Updates the <em>renewal threshold</em> based on the current number of
     * renewals. The threshold is a percentage as specified in
     * {@link EurekaServerConfig#getRenewalPercentThreshold()} of renewals
     * received per minute {@link #getNumOfRenewsInLastMin()}.
     */
    private void updateRenewalThreshold() {
        try {
            LookupService lookupService = DiscoveryManager.getInstance()
                    .getLookupService();
            Applications apps = lookupService.getApplications();
            int count = 0;
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    if (this.isRegisterable(instance)) {
                        ++count;
                    }
                }
            }
            synchronized (lock) {
                // Update threshold only if the threshold is greater than the
                // current expected threshold of if the self preservation is disabled.
                if ((count * 2) > (EUREKA_SERVER_CONFIG
                        .getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
                        || (!this.isSelfPreservationModeEnabled())) {
                    this.expectedNumberOfRenewsPerMin = count * 2;
                    this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            logger.info("Current renewal threshold is : {}",
                    numberOfRenewsPerMinThreshold);
        } catch (Throwable e) {
            logger.error("Cannot update renewal threshold", e);
        }
    }

    /**
     * Gets the list of all {@link Applications} from the registry in sorted
     * lexical order of {@link Application#getName()}.
     *
     * @return the list of {@link Applications} in lexical order.
     */
    public List<Application> getSortedApplications() {
        List<Application> apps = new ArrayList<Application>(getApplications()
                .getRegisteredApplications());
        Collections.sort(apps, APP_COMPARATOR);
        return apps;
    }

    /**
     * Gets the number of <em>renewals</em> in the last minute.
     *
     * @return a long value representing the number of <em>renewals</em> in the
     *         last minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfReplicationsInLastMin",
            description = "Number of total replications received in the last minute",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public long getNumOfReplicationsInLastMin() {
        return numberOfReplicationsLastMin.getCount();
    }

    /**
     * Checks if the number of renewals is lesser than threshold.
     *
     * @return 0 if the renewals are greater than threshold, 1 otherwise.
     */
    @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public int isBelowRenewThresold() {
        if ((getNumOfRenewsInLastMin() < numberOfRenewsPerMinThreshold)
                && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Gets the threshold for the renewals per minute.
     *
     * @return the integer representing the threshold for the renewals per
     *         minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsPerMinThreshold", type = DataSourceType.GAUGE)
    public int getNumOfRenewsPerMinThreshold() {
        return numberOfRenewsPerMinThreshold;
    }


    /**
     * Checks if an instance is registerable in this region. Instances from
     * other regions are rejected.
     *
     * @param instanceInfo
     *            - the instance info information of the instance
     * @return - true, if it can be registered in this server, false otherwise.
     */
    public boolean isRegisterable(InstanceInfo instanceInfo) {
        DataCenterInfo datacenterInfo = instanceInfo.getDataCenterInfo();
        String serverRegion = EUREKA_CLIENT_CONFIG.getRegion();
        if (AmazonInfo.class.isInstance(datacenterInfo)) {
            AmazonInfo info = AmazonInfo.class.cast(instanceInfo
                    .getDataCenterInfo());
            String availabilityZone = info.get(MetaDataKey.availabilityZone);
            // Can be null for dev environments in non-AWS data center
            if (availabilityZone == null
                    && US_EAST_1.equalsIgnoreCase(serverRegion)) {
                return true;
            } else if ((availabilityZone != null)
                    && (availabilityZone.contains(serverRegion))) {
                // If in the same region as server, then consider it
                // registerable
                return true;
            }
        }
        return true; // Everything non-amazon is registrable.
    }

    /**
     * Checks if the given service url contains the current host which is trying
     * to replicate. Only after the EIP binding is done the host has a chance to
     * identify itself in the list of replica nodes and needs to take itself out
     * of replication traffic.
     *
     * @param url
     *            the service url of the replica node that the check is made.
     * @return true, if the url represents the current node which is trying to
     *         replicate, false otherwise.
     */
    private boolean isThisMe(String url) {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();
        try {
            URI uri = new URI(url);
            return (uri.getHost().equals(myInfo.getHostName()));
        } catch (URISyntaxException e) {
            logger.error("Error in syntax", e);
            return false;
        }
    }

    /**
     * Replicates all eureka actions to peer eureka nodes except for replication
     * traffic to this node.
     *
     */
    private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {

            if (isReplication) {
                numberOfReplicationsLastMin.increment();
            }
            // If it is a replication already, do not replicate again as this
            // will create a poison replication
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.get()) {
                // If the url represents this host, do not replicate
                // to yourself.
                if (isThisMe(node.getServiceUrl())) {
                    continue;
                }
                replicateInstanceActionsToPeers(action, appName, id, info,
                        newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }

    /**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                            .get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                            false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error(
                    "Cannot replicate information to " + node.getServiceUrl()
                            + " for action " + action.name(), t);
        }
    }

    /**
     * Replicates all ASG status changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateASGInfoToReplicaNodes(final String asgName,
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
        CurrentRequestVersion.set(Version.V2);
        try {
            node.statusUpdate(asgName, newStatus);

        } catch (Throwable e) {
            logger.error(
                    "Cannot replicate ASG status information to "
                            + node.getServiceUrl(), e);
        }

    }

=======
public class PeerAwareInstanceRegistry extends InstanceRegistry {
    private static final String US_EAST_1 = "us-east-1";

    private static final int PRIME_PEER_NODES_RETRY_MS = 30000;

    private static final int REGISTRY_SYNC_RETRY_MS = 30000;

    private static final Logger logger = LoggerFactory
            .getLogger(PeerAwareInstanceRegistry.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final EurekaClientConfig EUREKA_CLIENT_CONFIG = DiscoveryManager
            .getInstance().getEurekaClientConfig();

    private long startupTime = 0;
    private boolean peerInstancesTransferEmptyOnStartup = true;
    private static final Timer timerReplicaNodes = new Timer(
            "Eureka-PeerNodesUpdater", true);

    public enum Action {
        Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;

        private com.netflix.servo.monitor.Timer timer = Monitors.newTimer(this
                .name());

        public com.netflix.servo.monitor.Timer getTimer() {
            return this.timer;
        }

    }

    private static final Comparator<Application> APP_COMPARATOR = new Comparator<Application>() {
        public int compare(Application l, Application r) {
            return l.getName().compareTo(r.getName());
        }
    };

    private final MeasuredRate numberOfReplicationsLastMin = new MeasuredRate(
            1000 * 60 * 1);


    private AtomicReference<List<PeerEurekaNode>> peerEurekaNodes;

    private Timer timer = new Timer(
            "ReplicaAwareInstanceRegistry - RenewalThresholdUpdater", true);

    private static final PeerAwareInstanceRegistry instance = new PeerAwareInstanceRegistry();

    PeerAwareInstanceRegistry() {
        // Make it an atomic reference since this could be updated in the
        // background.
        peerEurekaNodes = new AtomicReference<List<PeerEurekaNode>>();
        peerEurekaNodes.set(new ArrayList<PeerEurekaNode>());
        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn(
                    "Cannot register the JMX monitor for the InstanceRegistry :",
                    e);
        }
        init();
    }

    public static PeerAwareInstanceRegistry getInstance() {
        return instance;
    }

    /**
     * Set up replica nodes and the task that updates the threshold
     * periodically.
     */
    private void init() {
        setupPeerEurekaNodes();
        scheduleRenewalThresholdUpdateTask();
    }

    /**
     * Schedule the task that updates <em>renewal threshold</em> periodically.
     * The renewal threshold would be used to determine if the renewals drop
     * dramatically because of network partition and to protect expiring too
     * many instances at a time.
     *
     */
    private void scheduleRenewalThresholdUpdateTask() {
        timer.schedule(new TimerTask() {

                           @Override
                           public void run() {
                               updateRenewalThreshold();

                           }

                       }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
                EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs());
    }

    /**
     * Set up a schedule task to update peer eureka node information
     * periodically to determine if a node has been removed or added to the
     * list.
     */
    private void setupPeerEurekaNodes() {
        try {
            updatePeerEurekaNodes();
            timerReplicaNodes.schedule(new TimerTask() {

                                           @Override
                                           public void run() {
                                               try {
                                                   updatePeerEurekaNodes();
                                               } catch (Throwable e) {
                                                   logger.error("Cannot update the replica Nodes", e);
                                               }

                                           }
                                       }, EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs(),
                    EUREKA_SERVER_CONFIG.getPeerEurekaNodesUpdateIntervalMs());

        } catch (Exception e) {
            throw new IllegalStateException(e);
        }
    }

    /**
     * Update information about peer eureka nodes.
     */
    private void updatePeerEurekaNodes() {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();

        EurekaClientConfig clientConfig = DiscoveryManager.getInstance().getEurekaClientConfig();
        String zone = InstanceInfo.getZone(
                clientConfig.getAvailabilityZones(clientConfig.getRegion()),
                myInfo);

        List<String> replicaUrls = DiscoveryManager.getInstance().getEurekaClient().getDiscoveryServiceUrls(zone);

        List<PeerEurekaNode> replicaNodes = new ArrayList<PeerEurekaNode>();
        for (String replicaUrl : replicaUrls) {
            if (!isThisMe(replicaUrl)) {
                logger.info("Adding replica node: " + replicaUrl);
                replicaNodes.add(new PeerEurekaNode(replicaUrl));
            }
        }
        if (replicaNodes.isEmpty()) {
            logger.warn("The replica size seems to be empty. Check the route 53 DNS Registry");
            return;
        }
        List<PeerEurekaNode> existingReplicaNodes = peerEurekaNodes.get();
        if (!replicaNodes.equals(existingReplicaNodes)) {
            List<String> previousServiceUrls = new ArrayList<String>();
            for (PeerEurekaNode node : existingReplicaNodes) {
                previousServiceUrls.add(node.getServiceUrl());
            }
            List<String> currentServiceUrls = new ArrayList<String>();
            for (PeerEurekaNode node : replicaNodes) {
                currentServiceUrls.add(node.getServiceUrl());
            }
            logger.info(
                    "Updating the replica nodes as they seem to have changed from {} to {} ",
                    previousServiceUrls, currentServiceUrls);
            peerEurekaNodes.set(replicaNodes);
            for (PeerEurekaNode existingReplicaNode : existingReplicaNodes) {
                existingReplicaNode.destroyResources();
            }
        } else {
            for (PeerEurekaNode replicaNode : replicaNodes) {
                replicaNode.destroyResources();
            }
        }
    }

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        LookupService lookupService = DiscoveryManager.getInstance()
                .getLookupService();
        int count = 0;

        for (int i = 0; ((i < EUREKA_SERVER_CONFIG.getRegistrySyncRetries()) && (count == 0)); i++) {
            Applications apps = lookupService.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {

                            register(instance, instance.getLeaseInfo()
                                    .getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
            if (count == 0) {
                try {
                    Thread.sleep(REGISTRY_SYNC_RETRY_MS);
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
        }
        return count;
    }

    public void openForTraffic(int count) {
        // Renewals happen every 30 seconds and for a minute it should be a
        // factor of 2.
        this.expectedNumberOfRenewsPerMin = count * 2;
        this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                .getRenewalPercentThreshold());
        logger.info("Got " + count + " instances from neighboring DS node");
        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
        this.startupTime = System.currentTimeMillis();
        if (count > 0) {
            this.peerInstancesTransferEmptyOnStartup = false;
        }
        boolean isAws = (Name.Amazon.equals(ApplicationInfoManager
                .getInstance().getInfo().getDataCenterInfo().getName()));
        if (isAws && EUREKA_SERVER_CONFIG.shouldPrimeAwsReplicaConnections()) {
            logger.info("Priming AWS connections for all replicas..");
            primeAwsReplicas();
        }
        logger.info("Changing status to UP");
        ApplicationInfoManager.getInstance().setInstanceStatus(
                InstanceStatus.UP);
        super.postInit();
    }

    /**
     * Prime connections for Aws replicas.
     * <p>
     * Sometimes when the eureka servers comes up, AWS firewall may not allow
     * the network connections immediately. This will cause the outbound
     * connections to fail, but the inbound connections continue to work. What
     * this means is the clients would have switched to this node (after EIP
     * binding) and so the other eureka nodes will expire all instances that
     * have been switched because of the lack of outgoing heartbeats from this
     * instance.
     * </p>
     * <p>
     * The best protection in this scenario is to block and wait until we are
     * able to ping all eureka nodes successfully atleast once. Until then we
     * won't open up the traffic.
     * </p>
     */
    private void primeAwsReplicas() {
        boolean areAllPeerNodesPrimed = false;
        while (!areAllPeerNodesPrimed) {
            String peerHostName = null;
            try {
                Application eurekaApps = this.getApplication(
                        ApplicationInfoManager.getInstance().getInfo()
                                .getAppName(), false);
                if (eurekaApps == null) {
                    areAllPeerNodesPrimed = true;
                }
                for (PeerEurekaNode node : peerEurekaNodes.get()) {
                    for (InstanceInfo peerInstanceInfo : eurekaApps
                            .getInstances()) {
                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();
                        // If the lease is expired - do not worry about priming
                        if (System.currentTimeMillis() > (leaseInfo
                                .getRenewalTimestamp() + (leaseInfo
                                .getDurationInSecs() * 1000))
                                + (2 * 60 * 1000)) {
                            continue;
                        }
                        peerHostName = peerInstanceInfo.getHostName();
                        logger.info(
                                "Trying to send heartbeat for the eureka server at {} to make sure the network "
                                        + "channels are open", peerHostName);
                        // Only try to contact the eureka nodes that are in this
                        // instance's registry - because
                        // the other instances may be legitimately down
                        if (peerHostName.equalsIgnoreCase(new URI(node
                                .getServiceUrl()).getHost())) {
                            node.heartbeat(peerInstanceInfo.getAppName(),
                                    peerInstanceInfo.getId(), peerInstanceInfo,
                                    null, true);
                        }
                    }
                }
                areAllPeerNodesPrimed = true;
            } catch (Throwable e) {
                logger.error("Could not contact " + peerHostName, e);
                try {
                    Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                } catch (InterruptedException e1) {
                    logger.warn("Interrupted while priming : ", e1);
                    areAllPeerNodesPrimed = true;
                }
            }
        }
    }

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, o otherwise returns
     *         true
     */
    public boolean shouldAllowAccess(boolean remoteRegionRequired) {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (!(System.currentTimeMillis() > this.startupTime
                    + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
                return false;
            }
        }
        if (remoteRegionRequired) {
            for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
                if (!remoteRegionRegistry.isReadyForServingData()) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean shouldAllowAccess() {
        return shouldAllowAccess(true);
    }

    /**
     * Gets the list of peer eureka nodes which is the list to replicate
     * information to.
     *
     * @return the list of replica nodes.
     */
    public List<PeerEurekaNode> getReplicaNodes() {
        return Collections.unmodifiableList(peerEurekaNodes.get());
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#cancel(java.lang.String,
     * java.lang.String, long, boolean)
     */
    @Override
    public boolean cancel(final String appName, final String id,
                          final boolean isReplication) {
        if (super.cancel(appName, id, isReplication)) {
            replicateToPeers(Action.Cancel, appName, id, null, null,
                    isReplication);
            synchronized (lock) {
                if (this.expectedNumberOfRenewsPerMin > 0) {
                    // Since the client wants to cancel it, reduce the threshold
                    // (1
                    // for 30 seconds, 2 for a minute)
                    this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2;
                    this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Registers the information about the {@link InstanceInfo} and replicates
     * this information to all peer eureka nodes. If this is replication event
     * from other replica nodes then it is not replicated.
     *
     * @param info
     *            the {@link InstanceInfo} to be registered and replicated.
     * @param isReplication
     *            true if this is a replication event from other replica nodes,
     *            false otherwise.
     */
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null
                && info.getLeaseInfo().getDurationInSecs() > 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(),
                info, null, isReplication);
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#renew(java.lang.String,
     * java.lang.String, long, boolean)
     */
    public boolean renew(final String appName, final String id,
                         final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null,
                    isReplication);
            return true;
        }
        return false;
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String,
     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,
     * java.lang.String, boolean)
     */
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp,
                isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus,
                    isReplication);
            return true;
        }
        return false;
    }

    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /**
     * Replicate the <em>ASG status</em> updates to peer eureka nodes. If this
     * event is a replication from other nodes, then it is not replicated to
     * other nodes.
     *
     * @param asgName
     *            the asg name for which the status needs to be replicated.
     * @param newStatus
     *            the {@link ASGStatus} information that needs to be replicated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     */
    public void statusUpdate(final String asgName, final ASGStatus newStatus,
                             final boolean isReplication) {
        // If this is replicated from an other node, do not try to replicate
        // again.
        if (isReplication) {
            return;
        }
        for (final PeerEurekaNode node : peerEurekaNodes.get()) {
            replicateASGInfoToReplicaNodes(asgName, newStatus, node);

        }

    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#isLeaseExpirationEnabled()
     */
    @Override
    public boolean isLeaseExpirationEnabled() {
        boolean leaseExpirationEnabled = (numberOfRenewsPerMinThreshold > 0)
                && (getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold);
        boolean isSelfPreservationModeEnabled = isSelfPreservationModeEnabled();
        if ((!leaseExpirationEnabled)) {
            if (!isSelfPreservationModeEnabled) {
                logger.warn("The self preservation mode is disabled!. Hence allowing the instances to expire.");
                leaseExpirationEnabled = true;
            }
        }
        return leaseExpirationEnabled;
    }

    /**
     * Checks to see if the self-preservation mode is enabled.
     *
     * <p>
     * The self-preservation mode is enabled if the expected number of renewals
     * per minute {@link #getNumOfRenewsInLastMin()} is lesser than the expected
     * threshold which is determined by {@link #getNumOfRenewsPerMinThreshold()}
     * . Eureka perceives this as a danger and stops expiring instances as this
     * is most likely because of a network event. The mode is disabled only when
     * the renewals get back to above the threshold or if the flag
     * {@link EurekaServerConfig#shouldEnableSelfPreservation()} is set to
     * false.
     * </p>
     *
     * @return true if the self-preservation mode is enabled, false otherwise.
     */
    public boolean isSelfPreservationModeEnabled() {
        return EUREKA_SERVER_CONFIG.shouldEnableSelfPreservation();
    }

    /**
     * Perform all cleanup and shutdown operations.
     */
    void shutdown() {
        try {
            DefaultMonitorRegistry.getInstance().unregister(
                    Monitors.newObjectMonitor(this));
        } catch (Throwable t) {
            logger.error("Cannot shutdown monitor registry", t);
        }
        try {
            for (PeerEurekaNode node : this.peerEurekaNodes.get()) {
                node.shutDown();
            }
        } catch (Throwable t) {
            logger.error("Cannot shutdown ReplicaAwareInstanceRegistry", t);
        }
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String virtualHostname,
                                                boolean secure) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Updates the <em>renewal threshold</em> based on the current number of
     * renewals. The threshold is a percentage as specified in
     * {@link EurekaServerConfig#getRenewalPercentThreshold()} of renewals
     * received per minute {@link #getNumOfRenewsInLastMin()}.
     */
    private void updateRenewalThreshold() {
        try {
            LookupService lookupService = DiscoveryManager.getInstance()
                    .getLookupService();
            Applications apps = lookupService.getApplications();
            int count = 0;
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    if (this.isRegisterable(instance)) {
                        ++count;
                    }
                }
            }
            synchronized (lock) {
                // Update threshold only if the threshold is greater than the
                // current expected threshold of if the self preservation is disabled.
                if ((count * 2) > (EUREKA_SERVER_CONFIG
                        .getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
                        || (!this.isSelfPreservationModeEnabled())) {
                    this.expectedNumberOfRenewsPerMin = count * 2;
                    this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            logger.info("Current renewal threshold is : {}",
                    numberOfRenewsPerMinThreshold);
        } catch (Throwable e) {
            logger.error("Cannot update renewal threshold", e);
        }
    }

    /**
     * Gets the list of all {@link Applications} from the registry in sorted
     * lexical order of {@link Application#getName()}.
     *
     * @return the list of {@link Applications} in lexical order.
     */
    public List<Application> getSortedApplications() {
        List<Application> apps = new ArrayList<Application>(getApplications()
                .getRegisteredApplications());
        Collections.sort(apps, APP_COMPARATOR);
        return apps;
    }

    /**
     * Gets the number of <em>renewals</em> in the last minute.
     *
     * @return a long value representing the number of <em>renewals</em> in the
     *         last minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfReplicationsInLastMin",
            description = "Number of total replications received in the last minute",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public long getNumOfReplicationsInLastMin() {
        return numberOfReplicationsLastMin.getCount();
    }

    /**
     * Checks if the number of renewals is lesser than threshold. This method is for servo metrics only.
     *
     * @return 0 if the renewals are greater than threshold, 1 otherwise.
     */
    @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public int isBelowRenewThresold() {
        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Gets the threshold for the renewals per minute.
     *
     * @return the integer representing the threshold for the renewals per
     *         minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsPerMinThreshold", type = DataSourceType.GAUGE)
    public int getNumOfRenewsPerMinThreshold() {
        return numberOfRenewsPerMinThreshold;
    }


    /**
     * Checks if an instance is registerable in this region. Instances from
     * other regions are rejected.
     *
     * @param instanceInfo
     *            - the instance info information of the instance
     * @return - true, if it can be registered in this server, false otherwise.
     */
    public boolean isRegisterable(InstanceInfo instanceInfo) {
        DataCenterInfo datacenterInfo = instanceInfo.getDataCenterInfo();
        String serverRegion = EUREKA_CLIENT_CONFIG.getRegion();
        if (AmazonInfo.class.isInstance(datacenterInfo)) {
            AmazonInfo info = AmazonInfo.class.cast(instanceInfo
                    .getDataCenterInfo());
            String availabilityZone = info.get(MetaDataKey.availabilityZone);
            // Can be null for dev environments in non-AWS data center
            if (availabilityZone == null
                    && US_EAST_1.equalsIgnoreCase(serverRegion)) {
                return true;
            } else if ((availabilityZone != null)
                    && (availabilityZone.contains(serverRegion))) {
                // If in the same region as server, then consider it
                // registerable
                return true;
            }
        }
        return true; // Everything non-amazon is registrable.
    }

    /**
     * Checks if the given service url contains the current host which is trying
     * to replicate. Only after the EIP binding is done the host has a chance to
     * identify itself in the list of replica nodes and needs to take itself out
     * of replication traffic.
     *
     * @param url
     *            the service url of the replica node that the check is made.
     * @return true, if the url represents the current node which is trying to
     *         replicate, false otherwise.
     */
    private boolean isThisMe(String url) {
        InstanceInfo myInfo = ApplicationInfoManager.getInstance().getInfo();
        try {
            URI uri = new URI(url);
            return (uri.getHost().equals(myInfo.getHostName()));
        } catch (URISyntaxException e) {
            logger.error("Error in syntax", e);
            return false;
        }
    }

    /**
     * Replicates all eureka actions to peer eureka nodes except for replication
     * traffic to this node.
     *
     */
    private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {

            if (isReplication) {
                numberOfReplicationsLastMin.increment();
            }
            // If it is a replication already, do not replicate again as this
            // will create a poison replication
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.get()) {
                // If the url represents this host, do not replicate
                // to yourself.
                if (isThisMe(node.getServiceUrl())) {
                    continue;
                }
                replicateInstanceActionsToPeers(action, appName, id, info,
                        newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }

    /**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                            .get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                            false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error(
                    "Cannot replicate information to " + node.getServiceUrl()
                            + " for action " + action.name(), t);
        }
    }

    /**
     * Replicates all ASG status changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateASGInfoToReplicaNodes(final String asgName,
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
        CurrentRequestVersion.set(Version.V2);
        try {
            node.statusUpdate(asgName, newStatus);

        } catch (Throwable e) {
            logger.error(
                    "Cannot replicate ASG status information to "
                            + node.getServiceUrl(), e);
        }

    }

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_491cca0_3f69679/rev_491cca0-3f69679/eureka-core/src/main/java/com/netflix/eureka/InstanceRegistry.java;<<<<<<< MINE
public interface InstanceRegistry extends LeaseManager<InstanceInfo>, LookupService<String> {
||||||| BASE
public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,
        LookupService<String> {

    private static final Logger logger = LoggerFactory
            .getLogger(InstanceRegistry.class);
    private static final EurekaServerConfig EUREKA_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final String[] EMPTY_STR_ARRAY = new String[0];
    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();
    private Timer evictionTimer = new Timer("Eureka-EvictionTimer", true);
    private volatile MeasuredRate renewsLastMin;
    protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
            .newBuilder().initialCapacity(500)
            .expireAfterAccess(1, TimeUnit.HOURS)
            .<String, InstanceStatus>build().asMap();

    // CircularQueues here for debugging/statistics purposes only
    private final CircularQueue<Pair<Long, String>> recentRegisteredQueue;
    private final CircularQueue<Pair<Long, String>> recentCanceledQueue;
    private Timer deltaRetentionTimer = new Timer("Eureka-DeltaRetentionTimer",
            true);
    private ConcurrentLinkedQueue<RecentlyChangedItem> recentlyChangedQueue = new ConcurrentLinkedQueue<RecentlyChangedItem>();
    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock read = readWriteLock.readLock();
    private final Lock write = readWriteLock.writeLock();
    protected Map<String, RemoteRegionRegistry> regionNameVSRemoteRegistry = new HashMap<String, RemoteRegionRegistry>();
    protected String[] allKnownRemoteRegions = EMPTY_STR_ARRAY;
    protected final Object lock = new Object();
    protected volatile int numberOfRenewsPerMinThreshold;
    protected volatile int expectedNumberOfRenewsPerMin;
    protected static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();

    private static final AtomicReference<EvictionTask> EVICTION_TASK = new AtomicReference<EvictionTask>();


    /**
     * Create a new, empty instance registry.
     */
    protected InstanceRegistry() {
        recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);
        recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);
        deltaRetentionTimer.schedule(getDeltaRetentionTask(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs());
    }

    /**
     * Completely clear the registry.
     */
    public void clearRegistry() {
        overriddenInstanceStatusMap.clear();
        recentCanceledQueue.clear();
        recentRegisteredQueue.clear();
        recentlyChangedQueue.clear();
        registry.clear();

    }

    /**
     * Registers a new instance with a given duration.
     *
     * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object,
     * int, boolean)
     */
    public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
        try {
            read.lock();
            Map<String, Lease<InstanceInfo>> gMap = registry.get(r
                    .getAppName());
            REGISTER.increment(isReplication);
            if (gMap == null) {
                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap =
                        new ConcurrentHashMap<String, Lease<InstanceInfo>>();
                gMap = registry.putIfAbsent(r.getAppName(), gNewMap);
                if (gMap == null) {
                    gMap = gNewMap;
                }
            }
            Lease<InstanceInfo> existingLease = gMap.get(r.getId());
            // Retain the last dirty timestamp without overwriting it, if there
            // is already a lease
            if (existingLease != null && (existingLease.getHolder() != null)) {
                Long existingLastDirtyTimestamp = existingLease.getHolder()
                        .getLastDirtyTimestamp();
                Long registrationLastDirtyTimestamp = r.getLastDirtyTimestamp();
                if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                    logger.warn(
                            "There is an existing lease and the existing lease's dirty timestamp {} is greater than "
                                    + "the one that is being registered {}", existingLastDirtyTimestamp,
                            registrationLastDirtyTimestamp);
                    r.setLastDirtyTimestamp(existingLastDirtyTimestamp);
                }
            } else {
                // The lease does not exist and hence it is a new registration
                synchronized (lock) {
                    if (this.expectedNumberOfRenewsPerMin > 0) {
                        // Since the client wants to cancel it, reduce the threshold
                        // (1
                        // for 30 seconds, 2 for a minute)
                        this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;
                        this.numberOfRenewsPerMinThreshold =
                                (int) (this.expectedNumberOfRenewsPerMin
                                        * EUREKA_SERVER_CONFIG.getRenewalPercentThreshold());
                    }
                }
            }
            Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                    leaseDuration);
            if (existingLease != null) {
                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
            }
            gMap.put(r.getId(), lease);
            synchronized (recentRegisteredQueue) {
                recentRegisteredQueue.add(new Pair<Long, String>(System.currentTimeMillis(), r.getAppName()
                        + "(" + r.getId() + ")"));
            }
            // This is where the initial state transfer of overridden status
            // happens
            if (!InstanceStatus.UNKNOWN.equals(r.getOverriddenStatus())) {
                logger.debug(
                        "Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                                + "overrides", r.getOverriddenStatus(), r.getId());
                if (!overriddenInstanceStatusMap.containsKey(r.getId())) {
                    logger.info(
                            "Not found overridden id {} and hence adding it",
                            r.getId());
                    overriddenInstanceStatusMap.put(r.getId(),
                            r.getOverriddenStatus());
                }
            }
            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(r.getId());
            if (overriddenStatusFromMap != null) {
                logger.info(
                        "Storing overridden status {} from map", overriddenStatusFromMap);
                r.setOverriddenStatus(overriddenStatusFromMap);
            }

            // Set the status based on the overridden status rules
            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(
                    r, existingLease, isReplication);
            r.setStatusWithoutDirty(overriddenInstanceStatus);

            // If the lease is registered with UP status, set lease service up timestamp
            if (InstanceStatus.UP.equals(r.getStatus())) {
                lease.serviceUp();
            }
            r.setActionType(ActionType.ADDED);
            recentlyChangedQueue.add(new RecentlyChangedItem(lease));
            r.setLastUpdatedTimestamp();
            invalidateCache(r.getAppName(), r.getVIPAddress(), r.getSecureVipAddress());
            logger.info("Registered instance id {} with status {}", r.getId(),
                    r.getStatus().toString());
            logger.debug("DS: Registry: registered " + r.getAppName() + " - "
                    + r.getId());
        } finally {
            read.unlock();
        }
    }

    /**
     * Cancels the registration of an instance.
     *
     * <p>
     * This is normally invoked by a client when it shuts down informing the
     * server to remove the instance from traffic.
     * </p>
     *
     * @param appName
     *            the application name of the application.
     * @param id
     *            the unique identifier of the instance.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the instance was removed from the
     *         {@link InstanceRegistry} successfully, false otherwise.
     */
    public boolean cancel(String appName, String id, boolean isReplication) {
        try {
            read.lock();
            CANCEL.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> leaseToCancel = null;
            if (gMap != null) {
                leaseToCancel = gMap.remove(id);
            }
            synchronized (recentCanceledQueue) {
                recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
            }
            InstanceStatus instanceStatus = overriddenInstanceStatusMap
                    .remove(id);
            if (instanceStatus != null) {
                logger.debug(
                        "Removed instance id {} from the overridden map which has value {}",
                        id, instanceStatus.name());
            }
            if (leaseToCancel == null) {
                CANCEL_NOT_FOUND.increment(isReplication);
                logger.warn("DS: Registry: cancel failed because Lease is not registered for: "
                        + appName + ":" + id);
                return false;
            } else {
                leaseToCancel.cancel();
                InstanceInfo instanceInfo = leaseToCancel.getHolder();
                String vip = null;
                String svip = null;
                if (instanceInfo != null) {
                    instanceInfo.setActionType(ActionType.DELETED);
                    recentlyChangedQueue.add(new RecentlyChangedItem(
                            leaseToCancel));
                    instanceInfo.setLastUpdatedTimestamp();
                    vip = instanceInfo.getVIPAddress();
                    svip = instanceInfo.getSecureVipAddress();
                }
                invalidateCache(appName, vip, svip);
                logger.debug("DS: Registry: canceled lease: " + appName + " - "
                        + id);
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Marks the given instance of the given app name as renewed, and also marks whether it originated from
     * replication.
     *
     * @see com.netflix.eureka.lease.LeaseManager#renew(java.lang.String,
     * java.lang.String, boolean)
     */
    public boolean renew(String appName, String id, boolean isReplication) {
        RENEW.increment(isReplication);
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        Lease<InstanceInfo> leaseToRenew = null;
        if (gMap != null) {
            leaseToRenew = gMap.get(id);
        }
        if (leaseToRenew == null) {
            RENEW_NOT_FOUND.increment(isReplication);
            logger.warn("DS: Registry: lease doesn't exist, registering resource: "
                    + appName + " - " + id);
            return false;
        } else {
            InstanceInfo instanceInfo = leaseToRenew.getHolder();
            if (instanceInfo != null) {
                // touchASGCache(instanceInfo.getASGName());
                InstanceStatus overriddenInstanceStatus = this
                        .getOverriddenInstanceStatus(instanceInfo,
                                leaseToRenew, isReplication);
                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
                    logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                            + "; re-register required", instanceInfo.getId());
                    RENEW_NOT_FOUND.increment(isReplication);
                    return false;
                }
                if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
                    Object[] args = {instanceInfo.getStatus().name(),
                            instanceInfo.getOverriddenStatus().name(),
                            instanceInfo.getId()};
                    logger.info(
                            "The instance status {} is different from overridden instance status {} for instance {}. "
                                    + "Hence setting the status to overridden status", args);
                    instanceInfo.setStatus(overriddenInstanceStatus);
                }
            }
            renewsLastMin.increment();
            leaseToRenew.renew();
            return true;
        }
    }

    /**
     * Stores overridden status if it is not already there. This happens during
     * a reconciliation process during renewal requests.
     *
     * @param id
     *            the unique identifier of the instance.
     * @param overriddenStatus
     *            Overridden status if any.
     */
    public void storeOverriddenStatusIfRequired(String id,
                                                InstanceStatus overriddenStatus) {
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.get(id);
        if ((instanceStatus == null)
                || (!overriddenStatus.equals(instanceStatus))) {
            // We might not have the overridden status if the server got
            // restarted -this will help us maintain the overridden state
            // from the replica
            logger.info(
                    "Adding overridden status for instance id {} and the value is {}",
                    id, overriddenStatus.name());
            overriddenInstanceStatusMap.put(id, overriddenStatus);
            List<InstanceInfo> instanceInfo = this.getInstancesById(id, false);
            if ((instanceInfo != null) && (!instanceInfo.isEmpty())) {
                instanceInfo.iterator().next().setOverriddenStatus(overriddenStatus);
                logger.info(
                        "Setting the overridden status for instance id {} and the value is {} ",
                        id, overriddenStatus.name());

            }
        }
    }

    /**
     * Updates the status of an instance. Normally happens to put an instance
     * between {@link InstanceStatus#OUT_OF_SERVICE} and
     * {@link InstanceStatus#UP} to put the instance in and out of traffic.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean statusUpdate(String appName, String id,
                                InstanceStatus newStatus, String lastDirtyTimestamp,
                                boolean isReplication) {
        try {
            read.lock();
            STATUS_UPDATE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                if ((info != null) && !(info.getStatus().equals(newStatus))) {
                    // Mark service as UP if needed
                    if (InstanceStatus.UP.equals(newStatus)) {
                        lease.serviceUp();
                    }
                    // This is NAC overriden status
                    overriddenInstanceStatusMap.put(id, newStatus);
                    // Set it for transfer of overridden status to replica on
                    // replica start up
                    info.setOverriddenStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                        info.setStatusWithoutDirty(newStatus);
                    } else {
                        info.setStatus(newStatus);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Removes status override for a give instance.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        try {
            read.lock();
            STATUS_OVERRIDE_DELETE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
                if (currentOverride != null && info != null) {
                    info.setOverriddenStatus(InstanceStatus.UNKNOWN);
                    info.setStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Evicts everything in the instance registry that has expired, if expiry is enabled.
     *
     * @see com.netflix.eureka.lease.LeaseManager#evict()
     */
    public void evict() {
        if (!isLeaseExpirationEnabled()) {
            logger.debug("DS: lease expiration is currently disabled.");
            return;
        }
        logger.debug("Running the evict task");
        for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
            Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
            if (leaseMap != null) {
                for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
                    Lease<InstanceInfo> lease = leaseEntry.getValue();
                    if (lease.isExpired() && lease.getHolder() != null) {
                        String appName = lease.getHolder().getAppName();
                        String id = lease.getHolder().getId();
                        EXPIRED.increment();
                        logger.warn("DS: Registry: expired lease for "
                                + appName + " - " + id);
                        cancel(appName, id, false);
                    }
                }
            }
        }
    }

    /**
     * Returns the given app that is in this instance only, falling back to other regions transparently only
     * if specified in this client configuration.
     *
     * @param appName
     *      - the application name of the application
     * @return the application
     *
     * @see
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
     */
    public Application getApplication(String appName) {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        return this.getApplication(appName, !disableTransparentFallback);
    }

    /**
     * Get application information.
     *
     * @param appName
     *            - The name of the application
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the application
     */
    public Application getApplication(String appName, boolean includeRemoteRegion) {
        Application app = null;

        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);

        if (leaseMap != null && leaseMap.size() > 0) {
            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {
                if (app == null) {
                    app = new Application(appName);
                }
                app.addInstance(decorateInstanceInfo(entry.getValue()));
            }
        } else if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application;
                }
            }
        }
        return app;
    }

    /**
     * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.
     *
     * @return the list of all known applications
     *
     * @see com.netflix.discovery.shared.LookupService#getApplications()
     */
    public Applications getApplications() {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        if (disableTransparentFallback) {
            return getApplicationsFromLocalRegionOnly();
        } else {
            return this.getApplications(true); // Behavior of falling back to remote region can be disabled.
        }
    }

    /**
     * Returns applications including instances from all remote regions. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with a <code>null</code> argument.
     */
    public Applications getApplicationsFromAllRemoteRegions() {
        return getApplicationsFromMultipleRegions(allKnownRemoteRegions);
    }

    /**
     * Returns applications including instances from local region only. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with an empty array.
     */
    public Applications getApplicationsFromLocalRegionOnly() {
        return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);
    }

    /**
     * This method will return applications with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     * The application instances for which this union will be done can be restricted to the names returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for every region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     * If you are not selectively requesting for a remote region, use {@link #getApplicationsFromAllRemoteRegions()}
     * or {@link #getApplicationsFromLocalRegionOnly()}
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> or empty no remote regions are
     *                      included.
     *
     * @return The applications with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be only for certain whitelisted apps as explained above.
     */
    public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {

        boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;

        logger.info("Fetching applications registry with remote regions: {}, Regions argument {}", includeRemoteRegion,
                Arrays.toString(remoteRegions));

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
        } else {
            GET_ALL_CACHE_MISS.increment();
        }
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }
                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                if (null != remoteRegistry) {
                    Applications remoteApps = remoteRegistry.getApplications();
                    for (Application application : remoteApps.getRegisteredApplications()) {
                        if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                            logger.info("Application {}  fetched from the remote region {}",
                                    application.getName(), remoteRegion);

                            Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                            if (appInstanceTillNow == null) {
                                appInstanceTillNow = new Application(application.getName());
                                apps.addApplication(appInstanceTillNow);
                            }
                            for (InstanceInfo instanceInfo : application.getInstances()) {
                                appInstanceTillNow.addInstance(instanceInfo);
                            }
                        } else {
                            logger.debug("Application {} not fetched from the remote region {} as there exists a "
                                            + "whitelist and this app is not in the whitelist.",
                                    application.getName(), remoteRegion);
                        }
                    }
                } else {
                    logger.warn("No remote registry available for the remote region {}", remoteRegion);
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {
        Set<String> whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(remoteRegion);
        if (null == whiteList) {
            whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(null); // see global whitelist.
        }
        return null == whiteList || whiteList.contains(appName);
    }

    /**
     * Get the registry information about all {@link Applications}.
     *
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return applications
     * @deprecated Use {@link #getApplicationsFromMultipleRegions(String[])} instead. This method has a flawed behavior
     * of transparently falling back to a remote region if no instances for an app is available locally. The new
     * behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplications(boolean includeRemoteRegion) {
        GET_ALL_CACHE_MISS.increment();
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {

                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();

                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }

                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Applications applications = remoteRegistry.getApplications();
                for (Application application : applications
                        .getRegisteredApplications()) {
                    Application appInLocalRegistry = apps
                            .getRegisteredApplications(application.getName());
                    if (appInLocalRegistry == null) {
                        apps.addApplication(application);
                    }
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    /**
     * Get the registry information about the delta changes. The deltas are
     * cached for a window specified by
     * {@link EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()}. Subsequent
     * requests for delta information may return the same information and client
     * must make sure this does not adversely affect them.
     *
     * @return all application deltas.
     * @deprecated use {@link #getApplicationDeltasFromMultipleRegions(String[])} instead. This method has a
     * flawed behavior of transparently falling back to a remote region if no instances for an app is available locally.
     * The new behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplicationDeltas() {
        GET_ALL_CACHE_MISS_DELTA.increment();
        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :"
                    + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();

            if (!disableTransparentFallback) {
                Applications allAppsInLocalRegion = getApplications(false);

                for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                    Applications applications = remoteRegistry.getApplicationDeltas();
                    for (Application application : applications.getRegisteredApplications()) {
                        Application appInLocalRegistry =
                                allAppsInLocalRegion.getRegisteredApplications(application.getName());
                        if (appInLocalRegistry == null) {
                            apps.addApplication(application);
                        }
                    }
                }
            }

            Applications allApps = getApplications(!disableTransparentFallback);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow =
                                            apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id) {
        return this.getInstanceByAppAndId(appName, id, true);
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id,
                                              boolean includeRemoteRegions) {
        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (leaseMap != null) {
            lease = leaseMap.get(id);
        }
        if (lease != null
                && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
            return decorateInstanceInfo(lease);
        } else if (includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application.getByInstanceId(id);
                }
            }
        }
        return null;
    }

    /**
     * Get all instances by ID, including automatically asking other regions if the ID is unknown.
     *
     * @see com.netflix.discovery.shared.LookupService#getInstancesById(String)
     */
    public List<InstanceInfo> getInstancesById(String id) {
        return this.getInstancesById(id, true);
    }

    /**
     * Get the list of instances by its unique id.
     *
     * @param id
     *            - the unique id of the instance
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return list of InstanceInfo objects.
     */
    public List<InstanceInfo> getInstancesById(String id,
                                               boolean includeRemoteRegions) {
        List<InstanceInfo> list = new ArrayList<InstanceInfo>();

        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = registry
                .entrySet().iterator(); iter.hasNext(); ) {

            Map<String, Lease<InstanceInfo>> leaseMap = iter.next().getValue();
            if (leaseMap != null) {
                Lease<InstanceInfo> lease = leaseMap.get(id);

                if (lease == null
                        || (isLeaseExpirationEnabled() && lease.isExpired())) {
                    continue;
                }

                if (list == Collections.EMPTY_LIST) {
                    list = new ArrayList<InstanceInfo>();
                }
                list.add(decorateInstanceInfo(lease));
            }
        }
        if (list.isEmpty() && includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                for (Application application : remoteRegistry.getApplications()
                        .getRegisteredApplications()) {
                    InstanceInfo instanceInfo = application.getByInstanceId(id);
                    if (instanceInfo != null) {
                        list.add(instanceInfo);
                        return list;
                    }
                }
            }
        }
        return list;
    }

    /**
     * Checks whether lease expiration is enabled.
     *
     * @return true if enabled
     */
    public abstract boolean isLeaseExpirationEnabled();

    private InstanceInfo decorateInstanceInfo(Lease<InstanceInfo> lease) {
        InstanceInfo info = lease.getHolder();

        // client app settings
        int renewalInterval = LeaseInfo.DEFAULT_LEASE_RENEWAL_INTERVAL;
        int leaseDuration = LeaseInfo.DEFAULT_LEASE_DURATION;

        // TODO: clean this up
        if (info.getLeaseInfo() != null) {
            renewalInterval = info.getLeaseInfo().getRenewalIntervalInSecs();
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }

        info.setLeaseInfo(LeaseInfo.Builder.newBuilder()
                .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                .setRenewalIntervalInSecs(renewalInterval)
                .setDurationInSecs(leaseDuration)
                .setEvictionTimestamp(lease.getEvictionTimestamp()).build());

        info.setIsCoordinatingDiscoveryServer();
        return info;
    }

    /**
     * Servo route; do not call.
     *
     * @return servo data
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsInLastMin",
            description = "Number of total heartbeats received in the last minute", type = DataSourceType.GAUGE)
    public long getNumOfRenewsInLastMin() {
        if (renewsLastMin != null) {
            return renewsLastMin.getCount();
        } else {
            return 0;
        }
    }

    /**
     * Get the N instances that are most recently registered.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNRegisteredInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();

        synchronized (recentRegisteredQueue) {
            for (Pair<Long, String> aRecentRegisteredQueue : recentRegisteredQueue) {
                list.add(aRecentRegisteredQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    /**
     * Get the N instances that have most recently canceled.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNCanceledInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();
        synchronized (recentCanceledQueue) {
            for (Pair<Long, String> aRecentCanceledQueue : recentCanceledQueue) {
                list.add(aRecentCanceledQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    private void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
        // invalidate cache
        ResponseCache.getInstance().invalidate(appName, vipAddress, secureVipAddress);
    }

    private static final class RecentlyChangedItem {
        private long lastUpdateTime;
        private Lease<InstanceInfo> leaseInfo;

        public RecentlyChangedItem(Lease<InstanceInfo> lease) {
            this.leaseInfo = lease;
            lastUpdateTime = System.currentTimeMillis();
        }

        public long getLastUpdateTime() {
            return this.lastUpdateTime;
        }

        public Lease<InstanceInfo> getLeaseInfo() {
            return this.leaseInfo;
        }
    }

    protected void postInit() {
        renewsLastMin = new MeasuredRate(1000 * 60 * 1);
        if (EVICTION_TASK.get() != null) {
            EVICTION_TASK.get().cancel();
        }
        EVICTION_TASK.set(new EvictionTask());
        evictionTimer.schedule(EVICTION_TASK.get(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs());
    }

    @com.netflix.servo.annotations.Monitor(name = "numOfElementsinInstanceCache", description = "Number of elements in the instance Cache", type = DataSourceType.GAUGE)
    public long getNumberofElementsininstanceCache() {
        return overriddenInstanceStatusMap.size();
    }

    private final class EvictionTask extends TimerTask {

        @Override
        public void run() {
            try {
                evict();
            } catch (Throwable e) {
                logger.error("Could not run the evict task", e);
            }
        }

    }


    private class CircularQueue<E> extends ConcurrentLinkedQueue<E> {
        private int size = 0;

        public CircularQueue(int size) {
            this.size = size;
        }

        @Override
        public boolean add(E e) {
            this.makeSpaceIfNotAvailable();
            return super.add(e);

        }

        private void makeSpaceIfNotAvailable() {
            if (this.size() == size) {
                this.remove();
            }
        }

        public boolean offer(E e) {
            this.makeSpaceIfNotAvailable();
            return super.offer(e);
        }
    }


    private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                       Lease<InstanceInfo> existingLease, boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance
        // says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat
        // failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed
        // as well since the service may be
        // currently in SERVICE
        if ((!InstanceStatus.UP.equals(r.getStatus()))
                && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug(
                    "Trusting the instance status {} from replica or instance for instance",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise
        // the ASG status
        if (overridden != null) {
            logger.debug(
                    "The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }
        // If the ASGName is present- check for its status
        boolean isASGDisabled = false;
        if (r.getASGName() != null) {
            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(
                    r.getASGName());
            logger.debug("The ASG name is specified {} and the value is {}",
                    r.getASGName(), isASGDisabled);
            if (isASGDisabled) {
                return InstanceStatus.OUT_OF_SERVICE;
            } else {
                return InstanceStatus.UP;
            }
        }
        // This is for backward compatibility until all applications have ASG
        // names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or
            // OUT_OF_SERVICE
            if ((existingStatus != null)
                    && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                    || InstanceStatus.UP.equals(existingStatus))) {
                logger.debug(
                        "There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug(
                "Returning the default instance status {} for instance {},",
                r.getStatus(), r.getId());
        return r.getStatus();
    }

    private TimerTask getDeltaRetentionTask() {
        return new TimerTask() {

            @Override
            public void run() {
                Iterator<RecentlyChangedItem> it = recentlyChangedQueue.iterator();
                while (it.hasNext()) {
                    if (it.next().getLastUpdateTime() <
                            System.currentTimeMillis() - EUREKA_CONFIG.getRetentionTimeInMSInDeltaQueue()) {
                        it.remove();
                    } else {
                        break;
                    }
                }
            }

        };
    }
=======
public abstract class InstanceRegistry implements LeaseManager<InstanceInfo>,
        LookupService<String> {

    private static final Logger logger = LoggerFactory
            .getLogger(InstanceRegistry.class);
    private static final EurekaServerConfig EUREKA_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final String[] EMPTY_STR_ARRAY = new String[0];
    private final ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>> registry = new ConcurrentHashMap<String, Map<String, Lease<InstanceInfo>>>();
    private Timer evictionTimer = new Timer("Eureka-EvictionTimer", true);
    private volatile MeasuredRate renewsLastMin;
    protected ConcurrentMap<String, InstanceStatus> overriddenInstanceStatusMap = CacheBuilder
            .newBuilder().initialCapacity(500)
            .expireAfterAccess(1, TimeUnit.HOURS)
            .<String, InstanceStatus>build().asMap();

    // CircularQueues here for debugging/statistics purposes only
    private final CircularQueue<Pair<Long, String>> recentRegisteredQueue;
    private final CircularQueue<Pair<Long, String>> recentCanceledQueue;
    private Timer deltaRetentionTimer = new Timer("Eureka-DeltaRetentionTimer",
            true);
    private ConcurrentLinkedQueue<RecentlyChangedItem> recentlyChangedQueue = new ConcurrentLinkedQueue<RecentlyChangedItem>();
    private final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private final Lock read = readWriteLock.readLock();
    private final Lock write = readWriteLock.writeLock();
    protected Map<String, RemoteRegionRegistry> regionNameVSRemoteRegistry = new HashMap<String, RemoteRegionRegistry>();
    protected String[] allKnownRemoteRegions = EMPTY_STR_ARRAY;
    protected final Object lock = new Object();
    protected volatile int numberOfRenewsPerMinThreshold;
    protected volatile int expectedNumberOfRenewsPerMin;
    protected static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();

    private static final AtomicReference<EvictionTask> EVICTION_TASK = new AtomicReference<EvictionTask>();


    /**
     * Create a new, empty instance registry.
     */
    protected InstanceRegistry() {
        recentCanceledQueue = new CircularQueue<Pair<Long, String>>(1000);
        recentRegisteredQueue = new CircularQueue<Pair<Long, String>>(1000);
        deltaRetentionTimer.schedule(getDeltaRetentionTask(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs(),
                EUREKA_CONFIG.getDeltaRetentionTimerIntervalInMs());
    }

    /**
     * Completely clear the registry.
     */
    public void clearRegistry() {
        overriddenInstanceStatusMap.clear();
        recentCanceledQueue.clear();
        recentRegisteredQueue.clear();
        recentlyChangedQueue.clear();
        registry.clear();

    }

    /**
     * Registers a new instance with a given duration.
     *
     * @see com.netflix.eureka.lease.LeaseManager#register(java.lang.Object,
     * int, boolean)
     */
    public void register(InstanceInfo r, int leaseDuration, boolean isReplication) {
        try {
            read.lock();
            Map<String, Lease<InstanceInfo>> gMap = registry.get(r
                    .getAppName());
            REGISTER.increment(isReplication);
            if (gMap == null) {
                final ConcurrentHashMap<String, Lease<InstanceInfo>> gNewMap =
                        new ConcurrentHashMap<String, Lease<InstanceInfo>>();
                gMap = registry.putIfAbsent(r.getAppName(), gNewMap);
                if (gMap == null) {
                    gMap = gNewMap;
                }
            }
            Lease<InstanceInfo> existingLease = gMap.get(r.getId());
            // Retain the last dirty timestamp without overwriting it, if there
            // is already a lease
            if (existingLease != null && (existingLease.getHolder() != null)) {
                Long existingLastDirtyTimestamp = existingLease.getHolder()
                        .getLastDirtyTimestamp();
                Long registrationLastDirtyTimestamp = r.getLastDirtyTimestamp();
                if (existingLastDirtyTimestamp > registrationLastDirtyTimestamp) {
                    logger.warn(
                            "There is an existing lease and the existing lease's dirty timestamp {} is greater than "
                                    + "the one that is being registered {}", existingLastDirtyTimestamp,
                            registrationLastDirtyTimestamp);
                    r.setLastDirtyTimestamp(existingLastDirtyTimestamp);
                }
            } else {
                // The lease does not exist and hence it is a new registration
                synchronized (lock) {
                    if (this.expectedNumberOfRenewsPerMin > 0) {
                        // Since the client wants to cancel it, reduce the threshold
                        // (1
                        // for 30 seconds, 2 for a minute)
                        this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;
                        this.numberOfRenewsPerMinThreshold =
                                (int) (this.expectedNumberOfRenewsPerMin
                                        * EUREKA_SERVER_CONFIG.getRenewalPercentThreshold());
                    }
                }
            }
            Lease<InstanceInfo> lease = new Lease<InstanceInfo>(r,
                    leaseDuration);
            if (existingLease != null) {
                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());
            }
            gMap.put(r.getId(), lease);
            synchronized (recentRegisteredQueue) {
                recentRegisteredQueue.add(new Pair<Long, String>(System.currentTimeMillis(), r.getAppName()
                        + "(" + r.getId() + ")"));
            }
            // This is where the initial state transfer of overridden status
            // happens
            if (!InstanceStatus.UNKNOWN.equals(r.getOverriddenStatus())) {
                logger.debug(
                        "Found overridden status {} for instance {}. Checking to see if needs to be add to the "
                                + "overrides", r.getOverriddenStatus(), r.getId());
                if (!overriddenInstanceStatusMap.containsKey(r.getId())) {
                    logger.info(
                            "Not found overridden id {} and hence adding it",
                            r.getId());
                    overriddenInstanceStatusMap.put(r.getId(),
                            r.getOverriddenStatus());
                }
            }
            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(r.getId());
            if (overriddenStatusFromMap != null) {
                logger.info(
                        "Storing overridden status {} from map", overriddenStatusFromMap);
                r.setOverriddenStatus(overriddenStatusFromMap);
            }

            // Set the status based on the overridden status rules
            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(
                    r, existingLease, isReplication);
            r.setStatusWithoutDirty(overriddenInstanceStatus);

            // If the lease is registered with UP status, set lease service up timestamp
            if (InstanceStatus.UP.equals(r.getStatus())) {
                lease.serviceUp();
            }
            r.setActionType(ActionType.ADDED);
            recentlyChangedQueue.add(new RecentlyChangedItem(lease));
            r.setLastUpdatedTimestamp();
            invalidateCache(r.getAppName(), r.getVIPAddress(), r.getSecureVipAddress());
            logger.info("Registered instance id {} with status {}", r.getId(),
                    r.getStatus().toString());
            logger.debug("DS: Registry: registered " + r.getAppName() + " - "
                    + r.getId());
        } finally {
            read.unlock();
        }
    }

    /**
     * Cancels the registration of an instance.
     *
     * <p>
     * This is normally invoked by a client when it shuts down informing the
     * server to remove the instance from traffic.
     * </p>
     *
     * @param appName
     *            the application name of the application.
     * @param id
     *            the unique identifier of the instance.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the instance was removed from the
     *         {@link InstanceRegistry} successfully, false otherwise.
     */
    public boolean cancel(String appName, String id, boolean isReplication) {
        try {
            read.lock();
            CANCEL.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> leaseToCancel = null;
            if (gMap != null) {
                leaseToCancel = gMap.remove(id);
            }
            synchronized (recentCanceledQueue) {
                recentCanceledQueue.add(new Pair<Long, String>(System.currentTimeMillis(), appName + "(" + id + ")"));
            }
            InstanceStatus instanceStatus = overriddenInstanceStatusMap
                    .remove(id);
            if (instanceStatus != null) {
                logger.debug(
                        "Removed instance id {} from the overridden map which has value {}",
                        id, instanceStatus.name());
            }
            if (leaseToCancel == null) {
                CANCEL_NOT_FOUND.increment(isReplication);
                logger.warn("DS: Registry: cancel failed because Lease is not registered for: "
                        + appName + ":" + id);
                return false;
            } else {
                leaseToCancel.cancel();
                InstanceInfo instanceInfo = leaseToCancel.getHolder();
                String vip = null;
                String svip = null;
                if (instanceInfo != null) {
                    instanceInfo.setActionType(ActionType.DELETED);
                    recentlyChangedQueue.add(new RecentlyChangedItem(
                            leaseToCancel));
                    instanceInfo.setLastUpdatedTimestamp();
                    vip = instanceInfo.getVIPAddress();
                    svip = instanceInfo.getSecureVipAddress();
                }
                invalidateCache(appName, vip, svip);
                logger.debug("DS: Registry: canceled lease: " + appName + " - "
                        + id);
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Marks the given instance of the given app name as renewed, and also marks whether it originated from
     * replication.
     *
     * @see com.netflix.eureka.lease.LeaseManager#renew(java.lang.String,
     * java.lang.String, boolean)
     */
    public boolean renew(String appName, String id, boolean isReplication) {
        RENEW.increment(isReplication);
        Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
        Lease<InstanceInfo> leaseToRenew = null;
        if (gMap != null) {
            leaseToRenew = gMap.get(id);
        }
        if (leaseToRenew == null) {
            RENEW_NOT_FOUND.increment(isReplication);
            logger.warn("DS: Registry: lease doesn't exist, registering resource: "
                    + appName + " - " + id);
            return false;
        } else {
            InstanceInfo instanceInfo = leaseToRenew.getHolder();
            if (instanceInfo != null) {
                // touchASGCache(instanceInfo.getASGName());
                InstanceStatus overriddenInstanceStatus = this
                        .getOverriddenInstanceStatus(instanceInfo,
                                leaseToRenew, isReplication);
                if (overriddenInstanceStatus == InstanceStatus.UNKNOWN) {
                    logger.info("Instance status UNKNOWN possibly due to deleted override for instance {}"
                            + "; re-register required", instanceInfo.getId());
                    RENEW_NOT_FOUND.increment(isReplication);
                    return false;
                }
                if (!instanceInfo.getStatus().equals(overriddenInstanceStatus)) {
                    Object[] args = {instanceInfo.getStatus().name(),
                            instanceInfo.getOverriddenStatus().name(),
                            instanceInfo.getId()};
                    logger.info(
                            "The instance status {} is different from overridden instance status {} for instance {}. "
                                    + "Hence setting the status to overridden status", args);
                    instanceInfo.setStatus(overriddenInstanceStatus);
                }
            }
            renewsLastMin.increment();
            leaseToRenew.renew();
            return true;
        }
    }

    /**
     * Stores overridden status if it is not already there. This happens during
     * a reconciliation process during renewal requests.
     *
     * @param id
     *            the unique identifier of the instance.
     * @param overriddenStatus
     *            Overridden status if any.
     */
    public void storeOverriddenStatusIfRequired(String id,
                                                InstanceStatus overriddenStatus) {
        InstanceStatus instanceStatus = overriddenInstanceStatusMap.get(id);
        if ((instanceStatus == null)
                || (!overriddenStatus.equals(instanceStatus))) {
            // We might not have the overridden status if the server got
            // restarted -this will help us maintain the overridden state
            // from the replica
            logger.info(
                    "Adding overridden status for instance id {} and the value is {}",
                    id, overriddenStatus.name());
            overriddenInstanceStatusMap.put(id, overriddenStatus);
            List<InstanceInfo> instanceInfo = this.getInstancesById(id, false);
            if ((instanceInfo != null) && (!instanceInfo.isEmpty())) {
                instanceInfo.iterator().next().setOverriddenStatus(overriddenStatus);
                logger.info(
                        "Setting the overridden status for instance id {} and the value is {} ",
                        id, overriddenStatus.name());

            }
        }
    }

    /**
     * Updates the status of an instance. Normally happens to put an instance
     * between {@link InstanceStatus#OUT_OF_SERVICE} and
     * {@link InstanceStatus#UP} to put the instance in and out of traffic.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean statusUpdate(String appName, String id,
                                InstanceStatus newStatus, String lastDirtyTimestamp,
                                boolean isReplication) {
        try {
            read.lock();
            STATUS_UPDATE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                if ((info != null) && !(info.getStatus().equals(newStatus))) {
                    // Mark service as UP if needed
                    if (InstanceStatus.UP.equals(newStatus)) {
                        lease.serviceUp();
                    }
                    // This is NAC overriden status
                    overriddenInstanceStatusMap.put(id, newStatus);
                    // Set it for transfer of overridden status to replica on
                    // replica start up
                    info.setOverriddenStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                        info.setStatusWithoutDirty(newStatus);
                    } else {
                        info.setStatus(newStatus);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Removes status override for a give instance.
     *
     * @param appName
     *            the application name of the instance.
     * @param id
     *            the unique identifier of the instance.
     * @param newStatus
     *            the new {@link InstanceStatus}.
     * @param lastDirtyTimestamp
     *            last timestamp when this instance information was updated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     * @return true if the status was successfully updated, false otherwise.
     */
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        try {
            read.lock();
            STATUS_OVERRIDE_DELETE.increment(isReplication);
            Map<String, Lease<InstanceInfo>> gMap = registry.get(appName);
            Lease<InstanceInfo> lease = null;
            if (gMap != null) {
                lease = gMap.get(id);
            }
            if (lease == null) {
                return false;
            } else {
                lease.renew();
                InstanceInfo info = lease.getHolder();
                InstanceStatus currentOverride = overriddenInstanceStatusMap.remove(id);
                if (currentOverride != null && info != null) {
                    info.setOverriddenStatus(InstanceStatus.UNKNOWN);
                    info.setStatus(newStatus);
                    long replicaDirtyTimestamp = 0;
                    if (lastDirtyTimestamp != null) {
                        replicaDirtyTimestamp = Long
                                .valueOf(lastDirtyTimestamp);
                    }
                    // If the replication's dirty timestamp is more than the
                    // existing one, just update
                    // it to the replica's.
                    if (replicaDirtyTimestamp > info.getLastDirtyTimestamp()) {
                        info.setLastDirtyTimestamp(replicaDirtyTimestamp);
                    }
                    info.setActionType(ActionType.MODIFIED);
                    recentlyChangedQueue
                            .add(new RecentlyChangedItem(lease));
                    info.setLastUpdatedTimestamp();
                    invalidateCache(appName, info.getVIPAddress(), info.getSecureVipAddress());
                }
                return true;
            }
        } finally {
            read.unlock();
        }
    }

    /**
     * Evicts everything in the instance registry that has expired, if expiry is enabled.
     *
     * @see com.netflix.eureka.lease.LeaseManager#evict()
     */
    public void evict() {
        if (!isLeaseExpirationEnabled()) {
            logger.debug("DS: lease expiration is currently disabled.");
            return;
        }
        logger.debug("Running the evict task");
        for (Entry<String, Map<String, Lease<InstanceInfo>>> groupEntry : registry.entrySet()) {
            Map<String, Lease<InstanceInfo>> leaseMap = groupEntry.getValue();
            if (leaseMap != null) {
                for (Entry<String, Lease<InstanceInfo>> leaseEntry : leaseMap.entrySet()) {
                    Lease<InstanceInfo> lease = leaseEntry.getValue();
                    if (lease.isExpired() && lease.getHolder() != null) {
                        String appName = lease.getHolder().getAppName();
                        String id = lease.getHolder().getId();
                        EXPIRED.increment();
                        logger.warn("DS: Registry: expired lease for "
                                + appName + " - " + id);
                        cancel(appName, id, false);
                    }
                }
            }
        }
    }

    /**
     * Returns the given app that is in this instance only, falling back to other regions transparently only
     * if specified in this client configuration.
     *
     * @param appName
     *      - the application name of the application
     * @return the application
     *
     * @see
     * com.netflix.discovery.shared.LookupService#getApplication(java.lang.String)
     */
    public Application getApplication(String appName) {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        return this.getApplication(appName, !disableTransparentFallback);
    }

    /**
     * Get application information.
     *
     * @param appName
     *            - The name of the application
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the application
     */
    public Application getApplication(String appName, boolean includeRemoteRegion) {
        Application app = null;

        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);

        if (leaseMap != null && leaseMap.size() > 0) {
            for (Entry<String, Lease<InstanceInfo>> entry : leaseMap.entrySet()) {
                if (app == null) {
                    app = new Application(appName);
                }
                app.addInstance(decorateInstanceInfo(entry.getValue()));
            }
        } else if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application;
                }
            }
        }
        return app;
    }

    /**
     * Get all applications in this instance registry, falling back to other regions if allowed in the Eureka config.
     *
     * @return the list of all known applications
     *
     * @see com.netflix.discovery.shared.LookupService#getApplications()
     */
    public Applications getApplications() {
        boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();
        if (disableTransparentFallback) {
            return getApplicationsFromLocalRegionOnly();
        } else {
            return this.getApplications(true); // Behavior of falling back to remote region can be disabled.
        }
    }

    /**
     * Returns applications including instances from all remote regions. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with a <code>null</code> argument.
     */
    public Applications getApplicationsFromAllRemoteRegions() {
        return getApplicationsFromMultipleRegions(allKnownRemoteRegions);
    }

    /**
     * Returns applications including instances from local region only. <br/>
     * Same as calling {@link #getApplicationsFromMultipleRegions(String[])} with an empty array.
     */
    public Applications getApplicationsFromLocalRegionOnly() {
        return getApplicationsFromMultipleRegions(EMPTY_STR_ARRAY);
    }

    /**
     * This method will return applications with instances from all passed remote regions as well as the current region.
     * Thus, this gives a union view of instances from multiple regions. <br/>
     * The application instances for which this union will be done can be restricted to the names returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for every region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     * If you are not selectively requesting for a remote region, use {@link #getApplicationsFromAllRemoteRegions()}
     * or {@link #getApplicationsFromLocalRegionOnly()}
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> or empty no remote regions are
     *                      included.
     *
     * @return The applications with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be only for certain whitelisted apps as explained above.
     */
    public Applications getApplicationsFromMultipleRegions(String[] remoteRegions) {

        boolean includeRemoteRegion = null != remoteRegions && remoteRegions.length != 0;

        logger.info("Fetching applications registry with remote regions: {}, Regions argument {}", includeRemoteRegion,
                Arrays.toString(remoteRegions));

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS.increment();
        } else {
            GET_ALL_CACHE_MISS.increment();
        }
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {
                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();
                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }
                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (String remoteRegion : remoteRegions) {
                RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                if (null != remoteRegistry) {
                    Applications remoteApps = remoteRegistry.getApplications();
                    for (Application application : remoteApps.getRegisteredApplications()) {
                        if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                            logger.info("Application {}  fetched from the remote region {}",
                                    application.getName(), remoteRegion);

                            Application appInstanceTillNow = apps.getRegisteredApplications(application.getName());
                            if (appInstanceTillNow == null) {
                                appInstanceTillNow = new Application(application.getName());
                                apps.addApplication(appInstanceTillNow);
                            }
                            for (InstanceInfo instanceInfo : application.getInstances()) {
                                appInstanceTillNow.addInstance(instanceInfo);
                            }
                        } else {
                            logger.debug("Application {} not fetched from the remote region {} as there exists a "
                                            + "whitelist and this app is not in the whitelist.",
                                    application.getName(), remoteRegion);
                        }
                    }
                } else {
                    logger.warn("No remote registry available for the remote region {}", remoteRegion);
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    private boolean shouldFetchFromRemoteRegistry(String appName, String remoteRegion) {
        Set<String> whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(remoteRegion);
        if (null == whiteList) {
            whiteList = EUREKA_CONFIG.getRemoteRegionAppWhitelist(null); // see global whitelist.
        }
        return null == whiteList || whiteList.contains(appName);
    }

    /**
     * Get the registry information about all {@link Applications}.
     *
     * @param includeRemoteRegion
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return applications
     * @deprecated Use {@link #getApplicationsFromMultipleRegions(String[])} instead. This method has a flawed behavior
     * of transparently falling back to a remote region if no instances for an app is available locally. The new
     * behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplications(boolean includeRemoteRegion) {
        GET_ALL_CACHE_MISS.increment();
        Applications apps = new Applications();
        apps.setVersion(1L);
        for (Entry<String, Map<String, Lease<InstanceInfo>>> entry : registry.entrySet()) {
            Application app = null;

            if (entry.getValue() != null) {
                for (Entry<String, Lease<InstanceInfo>> stringLeaseEntry : entry.getValue().entrySet()) {

                    Lease<InstanceInfo> lease = stringLeaseEntry.getValue();

                    if (app == null) {
                        app = new Application(lease.getHolder().getAppName());
                    }

                    app.addInstance(decorateInstanceInfo(lease));
                }
            }
            if (app != null) {
                apps.addApplication(app);
            }
        }
        if (includeRemoteRegion) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Applications applications = remoteRegistry.getApplications();
                for (Application application : applications
                        .getRegisteredApplications()) {
                    Application appInLocalRegistry = apps
                            .getRegisteredApplications(application.getName());
                    if (appInLocalRegistry == null) {
                        apps.addApplication(application);
                    }
                }
            }
        }
        apps.setAppsHashCode(apps.getReconcileHashCode());
        return apps;
    }

    /**
     * Get the registry information about the delta changes. The deltas are
     * cached for a window specified by
     * {@link EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()}. Subsequent
     * requests for delta information may return the same information and client
     * must make sure this does not adversely affect them.
     *
     * @return all application deltas.
     * @deprecated use {@link #getApplicationDeltasFromMultipleRegions(String[])} instead. This method has a
     * flawed behavior of transparently falling back to a remote region if no instances for an app is available locally.
     * The new behavior is to explicitly specify if you need a remote region.
     */
    @Deprecated
    public Applications getApplicationDeltas() {
        GET_ALL_CACHE_MISS_DELTA.increment();
        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDelta().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :"
                    + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            boolean disableTransparentFallback = EUREKA_CONFIG.disableTransparentFallbackToOtherRegion();

            if (!disableTransparentFallback) {
                Applications allAppsInLocalRegion = getApplications(false);

                for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                    Applications applications = remoteRegistry.getApplicationDeltas();
                    for (Application application : applications.getRegisteredApplications()) {
                        Application appInLocalRegistry =
                                allAppsInLocalRegion.getRegisteredApplications(application.getName());
                        if (appInLocalRegistry == null) {
                            apps.addApplication(application);
                        }
                    }
                }
            }

            Applications allApps = getApplications(!disableTransparentFallback);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the application delta also including instances from the passed remote regions, with the instances from the
     * local region. <br/>
     *
     * The remote regions from where the instances will be chosen can further be restricted if this application does not
     * appear in the whitelist specified for the region as returned by
     * {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} for a region. In case, there is no whitelist
     * defined for a region, this method will also look for a global whitelist by passing <code>null</code> to the
     * method {@link EurekaServerConfig#getRemoteRegionAppWhitelist(String)} <br/>
     *
     * @param remoteRegions The remote regions for which the instances are to be queried. The instances may be limited
     *                      by a whitelist as explained above. If <code>null</code> all remote regions are included.
     *                      If empty list then no remote region is included.
     *
     * @return The delta with instances from the passed remote regions as well as local region. The instances
     * from remote regions can be further be restricted as explained above. <code>null</code> if the application does
     * not exist locally or in remote regions.
     */
    public Applications getApplicationDeltasFromMultipleRegions(String[] remoteRegions) {
        if (null == remoteRegions) {
            remoteRegions = allKnownRemoteRegions; // null means all remote regions.
        }

        boolean includeRemoteRegion = remoteRegions.length != 0;

        if (includeRemoteRegion) {
            GET_ALL_WITH_REMOTE_REGIONS_CACHE_MISS_DELTA.increment();
        } else {
            GET_ALL_CACHE_MISS_DELTA.increment();
        }

        Applications apps = new Applications();
        apps.setVersion(ResponseCache.getVersionDeltaWithRegions().get());
        Map<String, Application> applicationInstancesMap = new HashMap<String, Application>();
        try {
            write.lock();
            Iterator<RecentlyChangedItem> iter = this.recentlyChangedQueue.iterator();
            logger.debug("The number of elements in the delta queue is :" + this.recentlyChangedQueue.size());
            while (iter.hasNext()) {
                Lease<InstanceInfo> lease = iter.next().getLeaseInfo();
                InstanceInfo instanceInfo = lease.getHolder();
                Object[] args = {instanceInfo.getId(),
                        instanceInfo.getStatus().name(),
                        instanceInfo.getActionType().name()};
                logger.debug(
                        "The instance id %s is found with status %s and actiontype %s",
                        args);
                Application app = applicationInstancesMap.get(instanceInfo
                        .getAppName());
                if (app == null) {
                    app = new Application(instanceInfo.getAppName());
                    applicationInstancesMap.put(instanceInfo.getAppName(), app);
                    apps.addApplication(app);
                }
                app.addInstance(decorateInstanceInfo(lease));
            }

            if (includeRemoteRegion) {
                for (String remoteRegion : remoteRegions) {
                    RemoteRegionRegistry remoteRegistry = regionNameVSRemoteRegistry.get(remoteRegion);
                    if (null != remoteRegistry) {
                        Applications remoteAppsDelta = remoteRegistry.getApplicationDeltas();
                        if (null != remoteAppsDelta) {
                            for (Application application : remoteAppsDelta.getRegisteredApplications()) {
                                if (shouldFetchFromRemoteRegistry(application.getName(), remoteRegion)) {
                                    Application appInstanceTillNow =
                                            apps.getRegisteredApplications(application.getName());
                                    if (appInstanceTillNow == null) {
                                        appInstanceTillNow = new Application(application.getName());
                                        apps.addApplication(appInstanceTillNow);
                                    }
                                    for (InstanceInfo instanceInfo : application.getInstances()) {
                                        appInstanceTillNow.addInstance(instanceInfo);
                                    }
                                }
                            }
                        }
                    }
                }
            }

            Applications allApps = getApplicationsFromMultipleRegions(remoteRegions);
            apps.setAppsHashCode(allApps.getReconcileHashCode());
            return apps;
        } finally {
            write.unlock();
        }
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id) {
        return this.getInstanceByAppAndId(appName, id, true);
    }

    /**
     * Gets the {@link InstanceInfo} information.
     *
     * @param appName
     *            the application name for which the information is requested.
     * @param id
     *            the unique identifier of the instance.
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return the information about the instance.
     */
    public InstanceInfo getInstanceByAppAndId(String appName, String id,
                                              boolean includeRemoteRegions) {
        Map<String, Lease<InstanceInfo>> leaseMap = registry.get(appName);
        Lease<InstanceInfo> lease = null;
        if (leaseMap != null) {
            lease = leaseMap.get(id);
        }
        if (lease != null
                && (!isLeaseExpirationEnabled() || !lease.isExpired())) {
            return decorateInstanceInfo(lease);
        } else if (includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                Application application = remoteRegistry.getApplication(appName);
                if (application != null) {
                    return application.getByInstanceId(id);
                }
            }
        }
        return null;
    }

    /**
     * Get all instances by ID, including automatically asking other regions if the ID is unknown.
     *
     * @see com.netflix.discovery.shared.LookupService#getInstancesById(String)
     */
    public List<InstanceInfo> getInstancesById(String id) {
        return this.getInstancesById(id, true);
    }

    /**
     * Get the list of instances by its unique id.
     *
     * @param id
     *            - the unique id of the instance
     * @param includeRemoteRegions
     *            - true, if we need to include applications from remote regions
     *            as indicated by the region {@link URL} by this property
     *            {@link EurekaServerConfig#getRemoteRegionUrls()}, false
     *            otherwise
     * @return list of InstanceInfo objects.
     */
    public List<InstanceInfo> getInstancesById(String id,
                                               boolean includeRemoteRegions) {
        List<InstanceInfo> list = new ArrayList<InstanceInfo>();

        for (Iterator<Entry<String, Map<String, Lease<InstanceInfo>>>> iter = registry
                .entrySet().iterator(); iter.hasNext(); ) {

            Map<String, Lease<InstanceInfo>> leaseMap = iter.next().getValue();
            if (leaseMap != null) {
                Lease<InstanceInfo> lease = leaseMap.get(id);

                if (lease == null
                        || (isLeaseExpirationEnabled() && lease.isExpired())) {
                    continue;
                }

                if (list == Collections.EMPTY_LIST) {
                    list = new ArrayList<InstanceInfo>();
                }
                list.add(decorateInstanceInfo(lease));
            }
        }
        if (list.isEmpty() && includeRemoteRegions) {
            for (RemoteRegionRegistry remoteRegistry : this.regionNameVSRemoteRegistry.values()) {
                for (Application application : remoteRegistry.getApplications()
                        .getRegisteredApplications()) {
                    InstanceInfo instanceInfo = application.getByInstanceId(id);
                    if (instanceInfo != null) {
                        list.add(instanceInfo);
                        return list;
                    }
                }
            }
        }
        return list;
    }

    /**
     * Checks whether lease expiration is enabled.
     *
     * @return true if enabled
     */
    public abstract boolean isLeaseExpirationEnabled();

    private InstanceInfo decorateInstanceInfo(Lease<InstanceInfo> lease) {
        InstanceInfo info = lease.getHolder();

        // client app settings
        int renewalInterval = LeaseInfo.DEFAULT_LEASE_RENEWAL_INTERVAL;
        int leaseDuration = LeaseInfo.DEFAULT_LEASE_DURATION;

        // TODO: clean this up
        if (info.getLeaseInfo() != null) {
            renewalInterval = info.getLeaseInfo().getRenewalIntervalInSecs();
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }

        info.setLeaseInfo(LeaseInfo.Builder.newBuilder()
                .setRegistrationTimestamp(lease.getRegistrationTimestamp())
                .setRenewalTimestamp(lease.getLastRenewalTimestamp())
                .setServiceUpTimestamp(lease.getServiceUpTimestamp())
                .setRenewalIntervalInSecs(renewalInterval)
                .setDurationInSecs(leaseDuration)
                .setEvictionTimestamp(lease.getEvictionTimestamp()).build());

        info.setIsCoordinatingDiscoveryServer();
        return info;
    }

    /**
     * Servo route; do not call.
     *
     * @return servo data
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsInLastMin",
            description = "Number of total heartbeats received in the last minute", type = DataSourceType.GAUGE)
    public long getNumOfRenewsInLastMin() {
        if (renewsLastMin != null) {
            return renewsLastMin.getCount();
        } else {
            return 0;
        }
    }

    /**
     * Get the N instances that are most recently registered.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNRegisteredInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();

        synchronized (recentRegisteredQueue) {
            for (Pair<Long, String> aRecentRegisteredQueue : recentRegisteredQueue) {
                list.add(aRecentRegisteredQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    /**
     * Get the N instances that have most recently canceled.
     *
     * @return
     */
    public List<Pair<Long, String>> getLastNCanceledInstances() {
        List<Pair<Long, String>> list = new ArrayList<Pair<Long, String>>();
        synchronized (recentCanceledQueue) {
            for (Pair<Long, String> aRecentCanceledQueue : recentCanceledQueue) {
                list.add(aRecentCanceledQueue);
            }
        }
        Collections.reverse(list);
        return list;
    }

    private void invalidateCache(String appName, @Nullable String vipAddress, @Nullable String secureVipAddress) {
        // invalidate cache
        ResponseCache.getInstance().invalidate(appName, vipAddress, secureVipAddress);
    }

    private static final class RecentlyChangedItem {
        private long lastUpdateTime;
        private Lease<InstanceInfo> leaseInfo;

        public RecentlyChangedItem(Lease<InstanceInfo> lease) {
            this.leaseInfo = lease;
            lastUpdateTime = System.currentTimeMillis();
        }

        public long getLastUpdateTime() {
            return this.lastUpdateTime;
        }

        public Lease<InstanceInfo> getLeaseInfo() {
            return this.leaseInfo;
        }
    }

    protected void postInit() {
        renewsLastMin = new MeasuredRate(1000 * 60 * 1);
        if (EVICTION_TASK.get() != null) {
            EVICTION_TASK.get().cancel();
        }
        EVICTION_TASK.set(new EvictionTask());
        evictionTimer.schedule(EVICTION_TASK.get(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs(),
                EUREKA_CONFIG.getEvictionIntervalTimerInMs());
    }

    @com.netflix.servo.annotations.Monitor(name = "numOfElementsinInstanceCache", description = "Number of elements in the instance Cache", type = DataSourceType.GAUGE)
    public long getNumberofElementsininstanceCache() {
        return overriddenInstanceStatusMap.size();
    }

    private final class EvictionTask extends TimerTask {

        @Override
        public void run() {
            try {
                evict();
            } catch (Throwable e) {
                logger.error("Could not run the evict task", e);
            }
        }

    }


    private class CircularQueue<E> extends ConcurrentLinkedQueue<E> {
        private int size = 0;

        public CircularQueue(int size) {
            this.size = size;
        }

        @Override
        public boolean add(E e) {
            this.makeSpaceIfNotAvailable();
            return super.add(e);

        }

        private void makeSpaceIfNotAvailable() {
            if (this.size() == size) {
                this.remove();
            }
        }

        public boolean offer(E e) {
            this.makeSpaceIfNotAvailable();
            return super.offer(e);
        }
    }


    private InstanceStatus getOverriddenInstanceStatus(InstanceInfo r,
                                                       Lease<InstanceInfo> existingLease, boolean isReplication) {
        // ReplicationInstance is DOWN or STARTING - believe that, but when the instance
        // says UP, question that
        // The client instance sends STARTING or DOWN (because of heartbeat
        // failures), then we accept what
        // the client says. The same is the case with replica as well.
        // The OUT_OF_SERVICE from the client or replica needs to be confirmed
        // as well since the service may be
        // currently in SERVICE
        if ((!InstanceStatus.UP.equals(r.getStatus()))
                && (!InstanceStatus.OUT_OF_SERVICE.equals(r.getStatus()))) {
            logger.debug(
                    "Trusting the instance status {} from replica or instance for instance",
                    r.getStatus(), r.getId());
            return r.getStatus();
        }
        // Overrides are the status like OUT_OF_SERVICE and UP set by NAC
        InstanceStatus overridden = overriddenInstanceStatusMap.get(r.getId());
        // If there are instance specific overrides, then they win - otherwise
        // the ASG status
        if (overridden != null) {
            logger.debug(
                    "The instance specific override for instance {} and the value is {}",
                    r.getId(), overridden.name());
            return overridden;
        }
        // If the ASGName is present- check for its status
        boolean isASGDisabled = false;
        if (r.getASGName() != null) {
            isASGDisabled = !AwsAsgUtil.getInstance().isASGEnabled(r);
            logger.debug("The ASG name is specified {} and the value is {}",
                    r.getASGName(), isASGDisabled);
            if (isASGDisabled) {
                return InstanceStatus.OUT_OF_SERVICE;
            } else {
                return InstanceStatus.UP;
            }
        }
        // This is for backward compatibility until all applications have ASG
        // names, otherwise while starting up
        // the client status may override status replicated from other servers
        if (!isReplication) {
            InstanceStatus existingStatus = null;
            if (existingLease != null) {
                existingStatus = existingLease.getHolder().getStatus();
            }
            // Allow server to have its way when the status is UP or
            // OUT_OF_SERVICE
            if ((existingStatus != null)
                    && (InstanceStatus.OUT_OF_SERVICE.equals(existingStatus)
                    || InstanceStatus.UP.equals(existingStatus))) {
                logger.debug(
                        "There is already an existing lease with status {}  for instance {}",
                        existingLease.getHolder().getStatus().name(),
                        existingLease.getHolder().getId());
                return existingLease.getHolder().getStatus();
            }
        }
        logger.debug(
                "Returning the default instance status {} for instance {},",
                r.getStatus(), r.getId());
        return r.getStatus();
    }

    private TimerTask getDeltaRetentionTask() {
        return new TimerTask() {

            @Override
            public void run() {
                Iterator<RecentlyChangedItem> it = recentlyChangedQueue.iterator();
                while (it.hasNext()) {
                    if (it.next().getLastUpdateTime() <
                            System.currentTimeMillis() - EUREKA_CONFIG.getRetentionTimeInMSInDeltaQueue()) {
                        it.remove();
                    } else {
                        break;
                    }
                }
            }

        };
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_491cca0_3f69679/rev_491cca0-3f69679/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
    private Set<String> getASGNames() {
        Set<String> asgNames = new HashSet<String>();
        Applications apps = PeerAwareInstanceRegistryImpl.getInstance().getApplications(false);
||||||| BASE
    private Set<String> getASGNames() {
        Set<String> asgNames = new HashSet<String>();
        Applications apps = PeerAwareInstanceRegistry.getInstance()
        .getApplications(false);
=======
    private Set<CacheKey> getCacheKeys() {
        Set<CacheKey> cacheKeys = new HashSet<CacheKey>();
        Applications apps = PeerAwareInstanceRegistry.getInstance().getApplications(false);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_6ad0339_bac3649/rev_6ad0339-bac3649/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
import com.netflix.eureka.PeerAwareInstanceRegistryImpl;
||||||| BASE
=======
import com.netflix.appinfo.DataCenterInfo;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c9f6ea_0d7c1b1/rev_7c9f6ea-0d7c1b1/eureka-core/src/main/java/com/netflix/eureka/util/AwsAsgUtil.java;<<<<<<< MINE
            .expireAfterAccess(10, TimeUnit.MINUTES)
||||||| BASE
            .expireAfterAccess(5, TimeUnit.MINUTES)
=======
            .expireAfterAccess(eurekaConfig.getASGCacheExpiryTimeoutMs(), TimeUnit.MILLISECONDS)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import com.netflix.config.DynamicPropertyFactory;
import com.netflix.discovery.converters.CodecWrapper;
import com.netflix.discovery.converters.CodecWrapper.CodecType;
import com.netflix.discovery.provider.DiscoveryJerseyProvider;
||||||| BASE
import com.netflix.config.DynamicPropertyFactory;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_9b180dc_1c2989d/rev_9b180dc-1c2989d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
||||||| BASE
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.JerseyClient;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
||||||| BASE
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.JerseyClient;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
||||||| BASE
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.JerseyClient;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClient.java;<<<<<<< MINE
||||||| BASE
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.discovery.shared;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.google.common.base.Preconditions;
import com.netflix.discovery.provider.DiscoveryJerseyProvider;
import com.netflix.servo.monitor.BasicCounter;
import com.netflix.servo.monitor.BasicTimer;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.MonitorConfig;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A wrapper for Jersey Apache Client to set the necessary configurations.
 *
 * @author Karthik Ranganathan
 *
 */
public final class EurekaJerseyClient {

    private EurekaJerseyClient() {
    }

    /**
     * Creates a Jersey client with the given configuration parameters.
     *
     *
     * @param clientName
     * @param connectionTimeout
     *            - The connection timeout of the connection in milliseconds
     * @param readTimeout
     *            - The read timeout of the connection in milliseconds
     * @param maxConnectionsPerHost
     *            - The maximum number of connections to a particular host
     * @param maxTotalConnections
     *            - The maximum number of total connections across all hosts
     * @param connectionIdleTimeout
     *            - The idle timeout after which the connections will be cleaned
     *            up in seconds
     * @return - The jersey client object encapsulating the connection
     */
    public static JerseyClient createJerseyClient(String clientName, int connectionTimeout,
                                                  int readTimeout, int maxConnectionsPerHost,
                                                  int maxTotalConnections, int connectionIdleTimeout) {
        Preconditions.checkNotNull(clientName, "Client name can not be null.");
        try {
            ClientConfig jerseyClientConfig = new CustomApacheHttpClientConfig(clientName, maxConnectionsPerHost,
                    maxTotalConnections);

            return new JerseyClient(connectionTimeout, readTimeout,
                    connectionIdleTimeout, jerseyClientConfig);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client ", e);
        }
    }

    /**
     * Creates a Jersey client with the given configuration parameters.
     *
     *
     * @param clientName
     * @param connectionTimeout
     *            - The connection timeout of the connection in milliseconds
     * @param readTimeout
     *            - The read timeout of the connection in milliseconds
     * @param maxConnectionsPerHost
     *            - The maximum number of connections to a particular host
     * @param maxTotalConnections
     *            - The maximum number of total connections across all hosts
     * @param connectionIdleTimeout
     *            - The idle timeout after which the connections will be cleaned
     *            up in seconds
     * @param proxyHost
     *            - The hostname of the proxy
     * @param proxyPort
     *            - The port number the proxy is listening on
     * @param proxyUserName
     *            - The username to use to authenticate to the proxy
     * @param proxyPassword
     *            - The password to use to authenticate to the proxy
     * @return - The jersey client object encapsulating the connection
     */
    public static JerseyClient createProxyJerseyClient(String clientName, int connectionTimeout,
                                                       int readTimeout, int maxConnectionsPerHost, int maxTotalConnections, int connectionIdleTimeout,
                                                       String proxyHost, String proxyPort, String proxyUserName, String proxyPassword) {
        Preconditions.checkNotNull(clientName, "Client name can not be null.");
        try {
            ClientConfig jerseyClientConfig = new ProxyCustomApacheHttpClientConfig(clientName, maxConnectionsPerHost,
                    maxTotalConnections, proxyHost, proxyPort, proxyUserName, proxyPassword);

            return new JerseyClient(connectionTimeout, readTimeout,
                    connectionIdleTimeout, jerseyClientConfig);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client ", e);
        }
    }

    /**
     * Creates the SSL based Jersey client with the given configuration
     * parameters.
     *
     *
     *
     * @param clientName
     * @param connectionTimeout
     *            - The connection timeout of the connection in milliseconds
     * @param readTimeout
     *            - The read timeout of the connection in milliseconds
     * @param maxConnectionsPerHost
     *            - The maximum number of connections to a particular host
     * @param maxTotalConnections
     *            - The maximum number of total connections across all hosts
     * @param connectionIdleTimeout
     *            - The idle timeout after which the connections will be cleaned
     *            up in seconds
     * @param trustStoreFileName
     *            - The full path to the trust store file
     * @param trustStorePassword
     *            - The password of the trust store file
     * @return - The jersey client object encapsulating the connection
     */

    public static JerseyClient createSSLJerseyClient(String clientName, int connectionTimeout,
                                                     int readTimeout, int maxConnectionsPerHost,
                                                     int maxTotalConnections, int connectionIdleTimeout,
                                                     String trustStoreFileName, String trustStorePassword) {
        Preconditions.checkNotNull(clientName, "Client name can not be null.");
        try {
            ClientConfig jerseyClientConfig = new SSLCustomApacheHttpClientConfig(
                    clientName, maxConnectionsPerHost, maxTotalConnections,
                    trustStoreFileName, trustStorePassword);

            return new JerseyClient(connectionTimeout, readTimeout,
                    connectionIdleTimeout, jerseyClientConfig);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create SSL Jersey client ", e);
        }
    }

    /**
     * Creates the SSL based Jersey client with the given configuration
     * parameters and using a SystemSocketFactory to support standard keystore/truststore 
     * system properties.
     *
     * @param clientName
     * @param connectionTimeout
     *            - The connection timeout of the connection in milliseconds
     * @param readTimeout
     *            - The read timeout of the connection in milliseconds
     * @param maxConnectionsPerHost
     *            - The maximum number of connections to a particular host
     * @param maxTotalConnections
     *            - The maximum number of total connections across all hosts
     * @param connectionIdleTimeout
     *            - The idle timeout after which the connections will be cleaned
     *            up in seconds
     * @return - The jersey client object encapsulating the connection
     */

    public static JerseyClient createSystemSSLJerseyClient(String clientName, int connectionTimeout,
                                                           int readTimeout, int maxConnectionsPerHost,
                                                           int maxTotalConnections, int connectionIdleTimeout) {
        Preconditions.checkNotNull(clientName, "Client name can not be null.");
        try {
            ClientConfig jerseyClientConfig = new SystemSSLCustomApacheHttpClientConfig(
                    clientName, maxConnectionsPerHost, maxTotalConnections);

            return new JerseyClient(connectionTimeout, readTimeout,
                    connectionIdleTimeout, jerseyClientConfig);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create System SSL Jersey client ", e);
        }
    }

    private static class CustomApacheHttpClientConfig extends DefaultApacheHttpClient4Config {

        public CustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost, int maxTotalConnections)
                throws Throwable {
            MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName);
            cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
            cm.setMaxTotal(maxTotalConnections);
            getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
            // To pin a client to specific server in case redirect happens, we handle redirects directly
            // (see DiscoveryClient.makeRemoteCall methods).
            getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
            getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);
        }
    }

    private static class ProxyCustomApacheHttpClientConfig extends DefaultApacheHttpClient4Config {

        public ProxyCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost, int maxTotalConnections,
                                                 String proxyHost, String proxyPort, String proxyUserName, String proxyPassword)
                throws Throwable {
            MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName);
            cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
            cm.setMaxTotal(maxTotalConnections);
            getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
            // To pin a client to specific server in case redirect happens, we handle redirects directly
            // (see DiscoveryClient.makeRemoteCall methods).
            getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
            getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);

            if (proxyUserName != null && proxyPassword != null) {
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
            } else {
                // Due to bug in apache client, user name/password must always be set.
                // Otherwise proxy configuration is ignored.
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
                getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
            }
            getProperties().put(
                    DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI,
                    "http://" + proxyHost + ":" + proxyPort);
        }
    }

    private static class SSLCustomApacheHttpClientConfig extends DefaultApacheHttpClient4Config {
        private static final String PROTOCOL_SCHEME = "SSL";
        private static final int HTTPS_PORT = 443;
        private static final String PROTOCOL = "https";
        private static final String KEYSTORE_TYPE = "JKS";

        public SSLCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost,
                                               int maxTotalConnections, String trustStoreFileName,
                                               String trustStorePassword) throws Throwable {

            SSLContext sslContext = SSLContext.getInstance(PROTOCOL_SCHEME);
            TrustManagerFactory tmf = TrustManagerFactory
                    .getInstance(TrustManagerFactory.getDefaultAlgorithm());
            KeyStore sslKeyStore = KeyStore.getInstance(KEYSTORE_TYPE);
            FileInputStream fin = null;
            try {
                fin = new FileInputStream(trustStoreFileName);
                sslKeyStore.load(fin, trustStorePassword.toCharArray());
                tmf.init(sslKeyStore);
                sslContext.init(null, createTrustManagers(sslKeyStore), null);
                SSLSocketFactory sslSocketFactory = new SSLSocketFactory(
                        sslContext);
                sslSocketFactory
                        .setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
                SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

                MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
                cm.setMaxTotal(maxTotalConnections);
                // To pin a client to specific server in case redirect happens, we handle redirects directly
                // (see DiscoveryClient.makeRemoteCall methods).
                getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
                getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
                getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);
            } finally {
                if (fin != null) {
                    fin.close();
                }
            }

        }

        private static TrustManager[] createTrustManagers(KeyStore trustStore) {
            TrustManagerFactory factory;
            try {
                factory = TrustManagerFactory.getInstance(TrustManagerFactory
                        .getDefaultAlgorithm());
                factory.init(trustStore);
            } catch (Throwable e) {
                throw new RuntimeException(e);
            }

            final TrustManager[] managers = factory.getTrustManagers();

            return managers;

        }
    }

    private static class SystemSSLCustomApacheHttpClientConfig extends DefaultApacheHttpClient4Config {
        private static final int HTTPS_PORT = 443;
        private static final String PROTOCOL = "https";

        public SystemSSLCustomApacheHttpClientConfig(String clientName, int maxConnectionsPerHost,
                                                     int maxTotalConnections) throws Throwable {

            SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
            SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
            sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

            MonitoredConnectionManager cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
            cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
            cm.setMaxTotal(maxTotalConnections);
            getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);
            // To pin a client to specific server in case redirect happens, we handle redirects directly
            // (see DiscoveryClient.makeRemoteCall methods).
            getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
            getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);
        }
    }

    public static class JerseyClient {

        private static final int HTTP_CONNECTION_CLEANER_INTERVAL_MS = 30 * 1000;

        private ApacheHttpClient4 apacheHttpClient;

        ClientConfig jerseyClientConfig;

        private ScheduledExecutorService eurekaConnCleaner =
                Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {

                    private final AtomicInteger threadNumber = new AtomicInteger(1);

                    @Override
                    public Thread newThread(Runnable r) {
                        Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                        thread.setDaemon(true);
                        return thread;
                    }
                });

        private static final Logger s_logger = LoggerFactory.getLogger(JerseyClient.class);

        public ApacheHttpClient4 getClient() {
            return apacheHttpClient;
        }

        public ClientConfig getClientconfig() {
            return jerseyClientConfig;
        }

        public JerseyClient(int connectionTimeout, int readTimeout, final int connectionIdleTimeout,
                            ClientConfig clientConfig) {
            try {
                jerseyClientConfig = clientConfig;
                jerseyClientConfig.getClasses().add(DiscoveryJerseyProvider.class);
                apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);
                HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();

                HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);
                HttpConnectionParams.setSoTimeout(params, readTimeout);

                eurekaConnCleaner.scheduleWithFixedDelay(
                        new ConnectionCleanerTask(connectionIdleTimeout), HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                        HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                        TimeUnit.MILLISECONDS);
            } catch (Throwable e) {
                throw new RuntimeException("Cannot create Jersey client", e);
            }

        }

        /**
         * Clean up resources.
         */
        public void destroyResources() {
            if (eurekaConnCleaner != null) {
                eurekaConnCleaner.shutdown();
            }
            if (apacheHttpClient != null) {
                apacheHttpClient.destroy();
            }
        }

        private class ConnectionCleanerTask implements Runnable {

            private final int connectionIdleTimeout;
            private final BasicTimer executionTimeStats;
            private final Counter cleanupFailed;

            public ConnectionCleanerTask(int connectionIdleTimeout) {
                this.connectionIdleTimeout = connectionIdleTimeout;
                MonitorConfig.Builder monitorConfigBuilder = MonitorConfig.builder("Eureka-Connection-Cleaner-Time");
                executionTimeStats = new BasicTimer(monitorConfigBuilder.build());
                cleanupFailed = new BasicCounter(MonitorConfig.builder("Eureka-Connection-Cleaner-Failure").build());
                try {
                    Monitors.registerObject(this);
                } catch (Exception e) {
                    s_logger.error("Unable to register with servo.", e);
                }
            }

            @Override
            public void run() {
                Stopwatch start = executionTimeStats.start();
                try {
                    apacheHttpClient
                            .getClientHandler()
                            .getHttpClient()
                            .getConnectionManager()
                            .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
                } catch (Throwable e) {
                    s_logger.error("Cannot clean connections", e);
                    cleanupFailed.increment();
                } finally {
                    if (null != start) {
                        start.stop();
                    }
                }

            }

        }
    }

}=======
package com.netflix.discovery.shared;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.netflix.discovery.provider.DiscoveryJerseyProvider;
import com.netflix.servo.monitor.BasicCounter;
import com.netflix.servo.monitor.BasicTimer;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.MonitorConfig;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.discovery.util.DiscoveryBuildInfo.buildVersion;

/**
 * @author Tomasz Bak
 */
public class EurekaJerseyClient {

    private static final Logger s_logger = LoggerFactory.getLogger(EurekaJerseyClient.class);

    private static final int HTTP_CONNECTION_CLEANER_INTERVAL_MS = 30 * 1000;

    private static final String PROTOCOL = "https";
    private static final String PROTOCOL_SCHEME = "SSL";
    private static final int HTTPS_PORT = 443;
    private static final String KEYSTORE_TYPE = "JKS";

    private final ApacheHttpClient4 apacheHttpClient;

    ClientConfig jerseyClientConfig;

    private final ScheduledExecutorService eurekaConnCleaner =
            Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {

                private final AtomicInteger threadNumber = new AtomicInteger(1);

                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
                }
            });

    public EurekaJerseyClient(int connectionTimeout, int readTimeout, final int connectionIdleTimeout,
                              ClientConfig clientConfig) {
        try {
            jerseyClientConfig = clientConfig;
            jerseyClientConfig.getClasses().add(DiscoveryJerseyProvider.class);
            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);
            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();

            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);
            HttpConnectionParams.setSoTimeout(params, readTimeout);

            eurekaConnCleaner.scheduleWithFixedDelay(
                    new ConnectionCleanerTask(connectionIdleTimeout), HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    TimeUnit.MILLISECONDS);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client", e);
        }
    }

    public ApacheHttpClient4 getClient() {
        return apacheHttpClient;
    }

    /**
     * Clean up resources.
     */
    public void destroyResources() {
        if (eurekaConnCleaner != null) {
            eurekaConnCleaner.shutdown();
        }
        if (apacheHttpClient != null) {
            apacheHttpClient.destroy();
        }
    }

    public static class EurekaJerseyClientBuilder {

        private boolean systemSSL;
        private String clientName;
        private int maxConnectionsPerHost;
        private int maxTotalConnections;
        private String trustStoreFileName;
        private String trustStorePassword;
        private String userAgent;
        private String proxyUserName;
        private String proxyPassword;
        private String proxyHost;
        private String proxyPort;
        private int connectionTimeout;
        private int readTimeout;
        private int connectionIdleTimeout;

        public EurekaJerseyClientBuilder withClientName(String clientName) {
            this.clientName = clientName;
            return this;
        }

        public EurekaJerseyClientBuilder withUserAgent(String userAgent) {
            this.userAgent = userAgent;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionTimeout(int connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withReadTimeout(int readTimeout) {
            this.readTimeout = readTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionIdleTimeout(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxConnectionsPerHost(int maxConnectionsPerHost) {
            this.maxConnectionsPerHost = maxConnectionsPerHost;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxTotalConnections(int maxTotalConnections) {
            this.maxTotalConnections = maxTotalConnections;
            return this;
        }

        public EurekaJerseyClientBuilder withProxy(String proxyHost, String proxyPort, String user, String password) {
            this.proxyHost = proxyHost;
            this.proxyPort = proxyPort;
            this.proxyUserName = user;
            this.proxyPassword = password;
            return this;
        }

        public EurekaJerseyClientBuilder withSystemSSLConfiguration() {
            this.systemSSL = true;
            return this;
        }

        public EurekaJerseyClientBuilder withTrustStoreFile(String trustStoreFileName, String trustStorePassword) {
            this.trustStoreFileName = trustStoreFileName;
            this.trustStorePassword = trustStorePassword;
            return this;
        }

        public EurekaJerseyClient build() {
            MyDefaultApacheHttpClient4Config config = new MyDefaultApacheHttpClient4Config();
            try {
                return new EurekaJerseyClient(connectionTimeout, readTimeout, connectionIdleTimeout, config);
            } catch (Throwable e) {
                throw new RuntimeException("Cannot create Jersey client ", e);
            }
        }

        class MyDefaultApacheHttpClient4Config extends DefaultApacheHttpClient4Config {
            MyDefaultApacheHttpClient4Config() {
                MonitoredConnectionManager cm;

                if (systemSSL) {
                    cm = createSystemSslCM();
                } else if (trustStoreFileName != null) {
                    cm = createCustomSslCM();
                } else {
                    cm = new MonitoredConnectionManager(clientName);
                }

                if (proxyHost != null) {
                    addProxyConfiguration(cm);
                }

                // Common properties to all clients
                cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
                cm.setMaxTotal(maxTotalConnections);
                getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);

                String fullUserAgentName = (userAgent == null ? clientName : userAgent) + "/v" + buildVersion();
                getProperties().put(CoreProtocolPNames.USER_AGENT, fullUserAgentName);

                // To pin a client to specific server in case redirect happens, we handle redirects directly
                // (see DiscoveryClient.makeRemoteCall methods).
                getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
                getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);

            }

            private void addProxyConfiguration(MonitoredConnectionManager cm) {
                if (proxyUserName != null && proxyPassword != null) {
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
                } else {
                    // Due to bug in apache client, user name/password must always be set.
                    // Otherwise proxy configuration is ignored.
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
                }
                getProperties().put(DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI, "http://" + proxyHost + ":" + proxyPort);
            }

            private MonitoredConnectionManager createSystemSslCM() {
                MonitoredConnectionManager cm;
                SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
                SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));
                cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                return cm;
            }

            private MonitoredConnectionManager createCustomSslCM() {
                FileInputStream fin = null;
                try {
                    SSLContext sslContext = SSLContext.getInstance(PROTOCOL_SCHEME);
                    KeyStore sslKeyStore = KeyStore.getInstance(KEYSTORE_TYPE);

                    fin = new FileInputStream(trustStoreFileName);
                    sslKeyStore.load(fin, trustStorePassword.toCharArray());

                    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    factory.init(sslKeyStore);

                    TrustManager[] trustManagers = factory.getTrustManagers();

                    sslContext.init(null, trustManagers, null);
                    SSLSocketFactory sslSocketFactory = new SSLSocketFactory(sslContext);
                    sslSocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
                    SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                    sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

                    return new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                } catch (Exception ex) {
                    throw new IllegalStateException("SSL configuration issue", ex);
                } finally {
                    if (fin != null) {
                        try {
                            fin.close();
                        } catch (IOException ignore) {
                        }
                    }
                }
            }
        }
    }

    private class ConnectionCleanerTask implements Runnable {

        private final int connectionIdleTimeout;
        private final BasicTimer executionTimeStats;
        private final Counter cleanupFailed;

        private ConnectionCleanerTask(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            MonitorConfig.Builder monitorConfigBuilder = MonitorConfig.builder("Eureka-Connection-Cleaner-Time");
            executionTimeStats = new BasicTimer(monitorConfigBuilder.build());
            cleanupFailed = new BasicCounter(MonitorConfig.builder("Eureka-Connection-Cleaner-Failure").build());
            try {
                Monitors.registerObject(this);
            } catch (Exception e) {
                s_logger.error("Unable to register with servo.", e);
            }
        }

        @Override
        public void run() {
            Stopwatch start = executionTimeStats.start();
            try {
                apacheHttpClient
                        .getClientHandler()
                        .getHttpClient()
                        .getConnectionManager()
                        .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
            } catch (Throwable e) {
                s_logger.error("Cannot clean connections", e);
                cleanupFailed.increment();
            } finally {
                if (null != start) {
                    start.stop();
                }
            }

        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
import com.netflix.discovery.shared.JerseyClient;
import com.netflix.discovery.shared.JerseyClientConfigBuilder;
||||||| BASE
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.JerseyClient;
=======
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClient.EurekaJerseyClientBuilder;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private final EurekaAccept clientAccept;
    private final JerseyClient discoveryJerseyClient;
||||||| BASE
    private String appPathIdentifier;
    private boolean isRegisteredWithDiscovery = false;
    private JerseyClient discoveryJerseyClient;
    private AtomicReference<String> lastQueryRedirect = new AtomicReference<String>();
    private AtomicReference<String> lastRegisterRedirect = new AtomicReference<String>();
    private ApacheHttpClient4 discoveryApacheClient;
    protected static EurekaClientConfig clientConfig;
=======
    private String appPathIdentifier;
    private boolean isRegisteredWithDiscovery = false;
    private EurekaJerseyClient discoveryJerseyClient;
    private AtomicReference<String> lastQueryRedirect = new AtomicReference<String>();
    private AtomicReference<String> lastRegisterRedirect = new AtomicReference<String>();
    private ApacheHttpClient4 discoveryApacheClient;
    protected static EurekaClientConfig clientConfig;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b694d77_fcffccb/rev_b694d77-fcffccb/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private InstanceInfoReplicator instanceInfoReplicator;

||||||| BASE
=======
    private volatile long lastSuccessfulRegistryFetchTimestamp = -1;
    private volatile long lastSuccessfulHeartbeatTimestamp = -1;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_6e0b19f_9415eda/rev_6e0b19f-9415eda/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;<<<<<<< MINE
    private InstanceInfoReplicator instanceInfoReplicator;
||||||| BASE
=======
    private final ThresholdLevelsMetric heartbeatStalenessMonitor;
    private final ThresholdLevelsMetric registryStalenessMonitor;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a6b86ea_e879aa1/rev_a6b86ea-e879aa1/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
import com.netflix.eureka.resources.ServerCodecs;
||||||| BASE
=======
import com.sun.jersey.api.client.Client;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-core/src/main/java/com/netflix/eureka/RemoteRegionRegistry.java;<<<<<<< MINE
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.netflix.eureka;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;
import java.net.InetAddress;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.ActionType;
import com.netflix.discovery.EurekaIdentityHeaderFilter;
import com.netflix.discovery.TimedSupervisorTask;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.transport.jersey.EurekaJerseyClient;
import com.netflix.discovery.shared.transport.jersey.EurekaJerseyClientImpl.EurekaJerseyClientBuilder;
import com.netflix.discovery.shared.LookupService;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.filter.GZIPContentEncodingFilter;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Handles all registry operations that needs to be done on a eureka service running in an other region.
 *
 * The primary operations include fetching registry information from remote region and fetching delta information
 * on a periodic basis.
 *
 * @author Karthik Ranganathan
 *
 */
public class RemoteRegionRegistry implements LookupService<String> {
    private static final Logger logger = LoggerFactory.getLogger(RemoteRegionRegistry.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG =
            EurekaServerConfigurationManager.getInstance().getConfiguration();

    private final ApacheHttpClient4 discoveryApacheClient;
    private final EurekaJerseyClient discoveryJerseyClient;
    private final com.netflix.servo.monitor.Timer fetchRegistryTimer;
    private final URL remoteRegionURL;

    private final ScheduledExecutorService scheduler;
    // monotonically increasing generation counter to ensure stale threads do not reset registry to an older version
    private final AtomicLong fullRegistryGeneration = new AtomicLong(0);
    private final AtomicLong deltaGeneration = new AtomicLong(0);

    private final AtomicReference<Applications> applications = new AtomicReference<Applications>();
    private final AtomicReference<Applications> applicationsDelta = new AtomicReference<Applications>();
    private volatile boolean readyForServingData;

    public RemoteRegionRegistry(String regionName, URL remoteRegionURL) {
        this.remoteRegionURL = remoteRegionURL;
        this.fetchRegistryTimer = Monitors.newTimer(this.remoteRegionURL.toString() + "_FetchRegistry");

        EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                .withUserAgent("Java-EurekaClient-RemoteRegion")
                .withConnectionTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionConnectTimeoutMs())
                .withReadTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionReadTimeoutMs())
                .withMaxConnectionsPerHost(EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnectionsPerHost())
                .withMaxTotalConnections(EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnections())
                .withConnectionIdleTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionConnectionIdleTimeoutSeconds());

        if (remoteRegionURL.getProtocol().equals("http")) {
            clientBuilder.withClientName("Discovery-RemoteRegionClient-" + regionName);
        } else if ("true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
            clientBuilder.withClientName("Discovery-RemoteRegionSystemSecureClient-" + regionName)
                    .withSystemSSLConfiguration();
        } else {
            clientBuilder.withClientName("Discovery-RemoteRegionSecureClient-" + regionName)
                    .withTrustStoreFile(
                            EUREKA_SERVER_CONFIG.getRemoteRegionTrustStore(),
                            EUREKA_SERVER_CONFIG.getRemoteRegionTrustStorePassword()
                    );
        }
        discoveryJerseyClient = clientBuilder.build();
        discoveryApacheClient = discoveryJerseyClient.getClient();

        // should we enable GZip decoding of responses based on Response
        // Headers?
        if (EUREKA_SERVER_CONFIG.shouldGZipContentFromRemoteRegion()) {
            // compressed only if there exists a 'Content-Encoding' header
            // whose value is "gzip"
            discoveryApacheClient
                    .addFilter(new GZIPContentEncodingFilter(false));
        }

        String ip = null;
        try {
            ip = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn("Cannot find localhost ip", e);
        }
        EurekaServerIdentity identity = new EurekaServerIdentity(ip);
        discoveryApacheClient.addFilter(new EurekaIdentityHeaderFilter(identity));

        applications.set(new Applications());
        try {
            if (fetchRegistry()) {
                this.readyForServingData = true;
            } else {
                logger.warn("Failed to fetch remote registry. This means this eureka server is not ready for serving "
                        + "traffic.");
            }
        } catch (Throwable e) {
            logger.error("Problem fetching registry information :", e);
        }

        // remote region fetch
        Runnable remoteRegionFetchTask = new Runnable() {
            @Override
            public void run() {
                try {
                    if (fetchRegistry()) {
                        readyForServingData = true;
                    } else {
                        logger.warn("Failed to fetch remote registry. This means this eureka server is not "
                                + "ready for serving traffic.");
                    }
                } catch (Throwable e) {
                    logger.error(
                            "Error getting from remote registry :", e);
                }
            }
        };

        ThreadPoolExecutor remoteRegionFetchExecutor = new ThreadPoolExecutor(
                1, EUREKA_SERVER_CONFIG.getRemoteRegionFetchThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());  // use direct handoff

        scheduler = Executors.newScheduledThreadPool(1,
                new ThreadFactoryBuilder()
                        .setNameFormat("Eureka-RemoteRegionCacheRefresher_" + regionName + "-%d")
                        .setDaemon(true)
                        .build());

        scheduler.schedule(
                new TimedSupervisorTask(
                        "RemoteRegionFetch_" + regionName,
                        scheduler,
                        remoteRegionFetchExecutor,
                        EUREKA_SERVER_CONFIG.getRemoteRegionRegistryFetchInterval(),
                        TimeUnit.SECONDS,
                        5,  // exponential backoff bound
                        remoteRegionFetchTask
                ),
                EUREKA_SERVER_CONFIG.getRemoteRegionRegistryFetchInterval(), TimeUnit.SECONDS);
    }

    /**
     * Check if this registry is ready for serving data.
     * @return true if ready, false otherwise.
     */
    public boolean isReadyForServingData() {
        return readyForServingData;
    }

    /**
     * Fetch the registry information from the remote region.
     * @return true, if the fetch was successful, false otherwise.
     */
    private boolean fetchRegistry() {
        ClientResponse response = null;
        Stopwatch tracer = fetchRegistryTimer.start();

        try {
            // If the delta is disabled or if it is the first time, get all
            // applications
            if (EUREKA_SERVER_CONFIG.shouldDisableDeltaForRemoteRegions()
                    || (getApplications() == null)
                    || (getApplications().getRegisteredApplications().size() == 0)) {
                logger.info("Disable delta property : {}", EUREKA_SERVER_CONFIG
                        .shouldDisableDeltaForRemoteRegions());
                logger.info("Application is null : {}",
                        (getApplications() == null));
                logger.info(
                        "Registered Applications size is zero : {}",
                        (getApplications().getRegisteredApplications().size() == 0));
                response = storeFullRegistry();
            } else {
                long currDeltaGeneration = deltaGeneration.get();
                Applications delta = null;
                response = fetchRemoteRegistry(true);
                if (null != response) {
                    if (response.getStatus() == Status.OK.getStatusCode()) {
                        delta = response.getEntity(Applications.class);
                        if (delta == null) {
                            logger.error("The delta is null for some reason. Not storing this information");
                        } else if (deltaGeneration.compareAndSet(currDeltaGeneration, currDeltaGeneration + 1)) {
                            this.applicationsDelta.set(delta);
                        } else {
                            delta = null;  // set the delta to null so we don't use it
                            logger.warn("Not updating delta as another thread is updating it already");
                        }
                    }
                    if (delta == null) {
                        logger.warn("The server does not allow the delta revision to be applied because it is not "
                                + "safe. Hence got the full registry.");
                        this.closeResponse(response);
                        response = fetchRemoteRegistry(true);
                    } else {
                        updateDelta(delta);
                        String reconcileHashCode = getApplications()
                                .getReconcileHashCode();
                        // There is a diff in number of instances for some reason
                        if ((!reconcileHashCode.equals(delta.getAppsHashCode()))) {
                            response = reconcileAndLogDifference(response, delta, reconcileHashCode);

                        }
                    }
                }
            }
            logTotalInstances();

            logger.debug("Remote Registry Fetch Status : {}", null == response ? null : response.getStatus());
        } catch (Throwable e) {
            logger.error(
                    "Unable to fetch registry information from the remote registry "
                            + this.remoteRegionURL.toString(), e);
            return false;

        } finally {
            if (tracer != null) {
                tracer.stop();
            }
            closeResponse(response);
        }
        return null != response;
    }

    /**
     * Updates the delta information fetches from the eureka server into the
     * local cache.
     *
     * @param delta
     *            the delta information received from eureka server in the last
     *            poll cycle.
     */
    private void updateDelta(Applications delta) {
        int deltaCount = 0;
        for (Application app : delta.getRegisteredApplications()) {
            for (InstanceInfo instance : app.getInstances()) {
                ++deltaCount;
                if (ActionType.ADDED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Added instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);
                } else if (ActionType.MODIFIED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Modified instance {} to the existing apps ",
                            instance.getId());

                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);

                } else if (ActionType.DELETED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Deleted instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).removeInstance(instance);
                }
            }
        }
        logger.debug(
                "The total number of instances fetched by the delta processor : {}",
                deltaCount);

    }

    /**
     * Close HTTP response object and its respective resources.
     *
     * @param response
     *            the HttpResponse object.
     */
    private void closeResponse(ClientResponse response) {
        if (response != null) {
            try {
                response.close();
            } catch (Throwable th) {
                logger.error("Cannot release response resource :", th);
            }
        }
    }

    /**
     * Gets the full registry information from the eureka server and stores it
     * locally.
     *
     * @return the full registry information.
     */
    public ClientResponse storeFullRegistry() {
        long currentUpdateGeneration = fullRegistryGeneration.get();
        ClientResponse response = fetchRemoteRegistry(false);
        if (response == null) {
            logger.error("The response is null.");
            return null;
        }
        Applications apps = response.getEntity(Applications.class);
        if (apps == null) {
            logger.error("The application is null for some reason. Not storing this information");
        } else if (fullRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {
            applications.set(apps);
        } else {
            logger.warn("Not updating applications as another thread is updating it already");
        }
        logger.info("The response status is {}", response.getStatus());
        return response;
    }

    /**
     * Fetch registry information from the remote region.
     * @param delta - true, if the fetch needs to get deltas, false otherwise
     * @return - response which has information about the data.
     */
    private ClientResponse fetchRemoteRegistry(boolean delta) {
        logger.info(
                "Getting instance registry info from the eureka server : {} , delta : {}",
                this.remoteRegionURL, delta);
        ClientResponse response = null;
        try {

            String urlPath = delta ? "apps/delta" : "apps/";

            response = discoveryApacheClient
                    .resource(this.remoteRegionURL.toString() + urlPath)
                    .accept(MediaType.APPLICATION_JSON_TYPE)
                    .get(ClientResponse.class);
            int httpStatus = response.getStatus();
            if (httpStatus >= 200 && httpStatus < 300) {
                logger.debug("Got the data successfully : {}", httpStatus);
            } else {
                logger.warn("Cannot get the data from {} : {}", this.remoteRegionURL.toString(), httpStatus);
                return null; // To short circuit entity evaluation.
            }

        } catch (Throwable t) {
            logger.error("Can't get a response from " + this.remoteRegionURL, t);

        }
        return response;
    }

    /**
     * Reconciles the delta information fetched to see if the hashcodes match.
     *
     * @param response - the response of the delta fetch.
     * @param delta - the delta information fetched previously for reconcililation.
     * @param reconcileHashCode - the hashcode for comparison.
     * @return - response
     * @throws Throwable
     */
    private ClientResponse reconcileAndLogDifference(ClientResponse response,
                                                     Applications delta, String reconcileHashCode) throws Throwable {
        logger.warn(
                "The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry",
                reconcileHashCode, delta.getAppsHashCode());

        this.closeResponse(response);
        response = this.fetchRemoteRegistry(false);
        if (null == response) {
            logger.warn("Response is null while fetching remote registry during reconcile difference.");
            return null;
        }
        Applications serverApps = response.getEntity(Applications.class);
        Map<String, List<String>> reconcileDiffMap = getApplications()
                .getReconcileMapDiff(serverApps);
        String reconcileString = "";
        for (Map.Entry<String, List<String>> mapEntry : reconcileDiffMap
                .entrySet()) {
            reconcileString = reconcileString + mapEntry.getKey() + ": ";
            for (String displayString : mapEntry.getValue()) {
                reconcileString = reconcileString + displayString;
            }
            reconcileString = reconcileString + "\n";
        }
        logger.warn("The reconcile string is {}", reconcileString);
        applications.set(serverApps);
        applicationsDelta.set(serverApps);
        logger.warn(
                "The Reconcile hashcodes after complete sync up, client : {}, server : {}.",
                getApplications().getReconcileHashCode(),
                delta.getAppsHashCode());
        return response;
    }

    /**
     * Logs the total number of non-filtered instances stored locally.
     */
    private void logTotalInstances() {
        int totInstances = 0;
        for (Application application : getApplications().getRegisteredApplications()) {
            totInstances += application.getInstancesAsIsFromEureka().size();
        }
        logger.debug("The total number of all instances in the client now is {}", totInstances);
    }

    @Override
    public Applications getApplications() {
        return applications.get();
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String arg0, boolean arg1) {
        return null;
    }

    @Override
    public Application getApplication(String appName) {
        return this.applications.get().getRegisteredApplications(appName);
    }

    @Override
    public List<InstanceInfo> getInstancesById(String id) {
        List<InstanceInfo> list = Collections.emptyList();

        for (Application app : applications.get().getRegisteredApplications()) {
            InstanceInfo info = app.getByInstanceId(id);
            if (info != null) {
                list.add(info);
                return list;
            }
        }
        return list;
    }

    public Applications getApplicationDeltas() {
        return this.applicationsDelta.get();
    }

}||||||| BASE
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package com.netflix.eureka;

import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response.Status;
import java.net.InetAddress;
import java.net.URL;
import java.net.UnknownHostException;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;

import com.google.common.util.concurrent.ThreadFactoryBuilder;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.ActionType;
import com.netflix.discovery.EurekaIdentityHeaderFilter;
import com.netflix.discovery.TimedSupervisorTask;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.EurekaJerseyClient;
import com.netflix.discovery.shared.EurekaJerseyClientImpl.EurekaJerseyClientBuilder;
import com.netflix.discovery.shared.LookupService;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.ClientResponse;
import com.sun.jersey.api.client.filter.GZIPContentEncodingFilter;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Handles all registry operations that needs to be done on a eureka service running in an other region.
 *
 * The primary operations include fetching registry information from remote region and fetching delta information
 * on a periodic basis.
 *
 * @author Karthik Ranganathan
 *
 */
public class RemoteRegionRegistry implements LookupService<String> {
    private static final Logger logger = LoggerFactory.getLogger(RemoteRegionRegistry.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG =
            EurekaServerConfigurationManager.getInstance().getConfiguration();

    private final ApacheHttpClient4 discoveryApacheClient;
    private final EurekaJerseyClient discoveryJerseyClient;
    private final com.netflix.servo.monitor.Timer fetchRegistryTimer;
    private final URL remoteRegionURL;

    private final ScheduledExecutorService scheduler;
    // monotonically increasing generation counter to ensure stale threads do not reset registry to an older version
    private final AtomicLong fullRegistryGeneration = new AtomicLong(0);
    private final AtomicLong deltaGeneration = new AtomicLong(0);

    private final AtomicReference<Applications> applications = new AtomicReference<Applications>();
    private final AtomicReference<Applications> applicationsDelta = new AtomicReference<Applications>();
    private volatile boolean readyForServingData;

    public RemoteRegionRegistry(String regionName, URL remoteRegionURL) {
        this.remoteRegionURL = remoteRegionURL;
        this.fetchRegistryTimer = Monitors.newTimer(this.remoteRegionURL.toString() + "_FetchRegistry");

        EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                .withUserAgent("Java-EurekaClient-RemoteRegion")
                .withConnectionTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionConnectTimeoutMs())
                .withReadTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionReadTimeoutMs())
                .withMaxConnectionsPerHost(EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnectionsPerHost())
                .withMaxTotalConnections(EUREKA_SERVER_CONFIG.getRemoteRegionTotalConnections())
                .withConnectionIdleTimeout(EUREKA_SERVER_CONFIG.getRemoteRegionConnectionIdleTimeoutSeconds());

        if (remoteRegionURL.getProtocol().equals("http")) {
            clientBuilder.withClientName("Discovery-RemoteRegionClient-" + regionName);
        } else if ("true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
            clientBuilder.withClientName("Discovery-RemoteRegionSystemSecureClient-" + regionName)
                    .withSystemSSLConfiguration();
        } else {
            clientBuilder.withClientName("Discovery-RemoteRegionSecureClient-" + regionName)
                    .withTrustStoreFile(
                            EUREKA_SERVER_CONFIG.getRemoteRegionTrustStore(),
                            EUREKA_SERVER_CONFIG.getRemoteRegionTrustStorePassword()
                    );
        }
        discoveryJerseyClient = clientBuilder.build();
        discoveryApacheClient = discoveryJerseyClient.getClient();

        // should we enable GZip decoding of responses based on Response
        // Headers?
        if (EUREKA_SERVER_CONFIG.shouldGZipContentFromRemoteRegion()) {
            // compressed only if there exists a 'Content-Encoding' header
            // whose value is "gzip"
            discoveryApacheClient
                    .addFilter(new GZIPContentEncodingFilter(false));
        }

        String ip = null;
        try {
            ip = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn("Cannot find localhost ip", e);
        }
        EurekaServerIdentity identity = new EurekaServerIdentity(ip);
        discoveryApacheClient.addFilter(new EurekaIdentityHeaderFilter(identity));

        applications.set(new Applications());
        try {
            if (fetchRegistry()) {
                this.readyForServingData = true;
            } else {
                logger.warn("Failed to fetch remote registry. This means this eureka server is not ready for serving "
                        + "traffic.");
            }
        } catch (Throwable e) {
            logger.error("Problem fetching registry information :", e);
        }

        // remote region fetch
        Runnable remoteRegionFetchTask = new Runnable() {
            @Override
            public void run() {
                try {
                    if (fetchRegistry()) {
                        readyForServingData = true;
                    } else {
                        logger.warn("Failed to fetch remote registry. This means this eureka server is not "
                                + "ready for serving traffic.");
                    }
                } catch (Throwable e) {
                    logger.error(
                            "Error getting from remote registry :", e);
                }
            }
        };

        ThreadPoolExecutor remoteRegionFetchExecutor = new ThreadPoolExecutor(
                1, EUREKA_SERVER_CONFIG.getRemoteRegionFetchThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());  // use direct handoff

        scheduler = Executors.newScheduledThreadPool(1,
                new ThreadFactoryBuilder()
                        .setNameFormat("Eureka-RemoteRegionCacheRefresher_" + regionName + "-%d")
                        .setDaemon(true)
                        .build());

        scheduler.schedule(
                new TimedSupervisorTask(
                        "RemoteRegionFetch_" + regionName,
                        scheduler,
                        remoteRegionFetchExecutor,
                        EUREKA_SERVER_CONFIG.getRemoteRegionRegistryFetchInterval(),
                        TimeUnit.SECONDS,
                        5,  // exponential backoff bound
                        remoteRegionFetchTask
                ),
                EUREKA_SERVER_CONFIG.getRemoteRegionRegistryFetchInterval(), TimeUnit.SECONDS);
    }

    /**
     * Check if this registry is ready for serving data.
     * @return true if ready, false otherwise.
     */
    public boolean isReadyForServingData() {
        return readyForServingData;
    }

    /**
     * Fetch the registry information from the remote region.
     * @return true, if the fetch was successful, false otherwise.
     */
    private boolean fetchRegistry() {
        ClientResponse response = null;
        Stopwatch tracer = fetchRegistryTimer.start();

        try {
            // If the delta is disabled or if it is the first time, get all
            // applications
            if (EUREKA_SERVER_CONFIG.shouldDisableDeltaForRemoteRegions()
                    || (getApplications() == null)
                    || (getApplications().getRegisteredApplications().size() == 0)) {
                logger.info("Disable delta property : {}", EUREKA_SERVER_CONFIG
                        .shouldDisableDeltaForRemoteRegions());
                logger.info("Application is null : {}",
                        (getApplications() == null));
                logger.info(
                        "Registered Applications size is zero : {}",
                        (getApplications().getRegisteredApplications().size() == 0));
                response = storeFullRegistry();
            } else {
                long currDeltaGeneration = deltaGeneration.get();
                Applications delta = null;
                response = fetchRemoteRegistry(true);
                if (null != response) {
                    if (response.getStatus() == Status.OK.getStatusCode()) {
                        delta = response.getEntity(Applications.class);
                        if (delta == null) {
                            logger.error("The delta is null for some reason. Not storing this information");
                        } else if (deltaGeneration.compareAndSet(currDeltaGeneration, currDeltaGeneration + 1)) {
                            this.applicationsDelta.set(delta);
                        } else {
                            delta = null;  // set the delta to null so we don't use it
                            logger.warn("Not updating delta as another thread is updating it already");
                        }
                    }
                    if (delta == null) {
                        logger.warn("The server does not allow the delta revision to be applied because it is not "
                                + "safe. Hence got the full registry.");
                        this.closeResponse(response);
                        response = fetchRemoteRegistry(true);
                    } else {
                        updateDelta(delta);
                        String reconcileHashCode = getApplications()
                                .getReconcileHashCode();
                        // There is a diff in number of instances for some reason
                        if ((!reconcileHashCode.equals(delta.getAppsHashCode()))) {
                            response = reconcileAndLogDifference(response, delta, reconcileHashCode);

                        }
                    }
                }
            }
            logTotalInstances();

            logger.debug("Remote Registry Fetch Status : {}", null == response ? null : response.getStatus());
        } catch (Throwable e) {
            logger.error(
                    "Unable to fetch registry information from the remote registry "
                            + this.remoteRegionURL.toString(), e);
            return false;

        } finally {
            if (tracer != null) {
                tracer.stop();
            }
            closeResponse(response);
        }
        return null != response;
    }

    /**
     * Updates the delta information fetches from the eureka server into the
     * local cache.
     *
     * @param delta
     *            the delta information received from eureka server in the last
     *            poll cycle.
     */
    private void updateDelta(Applications delta) {
        int deltaCount = 0;
        for (Application app : delta.getRegisteredApplications()) {
            for (InstanceInfo instance : app.getInstances()) {
                ++deltaCount;
                if (ActionType.ADDED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Added instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);
                } else if (ActionType.MODIFIED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Modified instance {} to the existing apps ",
                            instance.getId());

                    getApplications().getRegisteredApplications(
                            instance.getAppName()).addInstance(instance);

                } else if (ActionType.DELETED.equals(instance.getActionType())) {
                    Application existingApp = getApplications()
                            .getRegisteredApplications(instance.getAppName());
                    if (existingApp == null) {
                        getApplications().addApplication(app);
                    }
                    logger.debug("Deleted instance {} to the existing apps ",
                            instance.getId());
                    getApplications().getRegisteredApplications(
                            instance.getAppName()).removeInstance(instance);
                }
            }
        }
        logger.debug(
                "The total number of instances fetched by the delta processor : {}",
                deltaCount);

    }

    /**
     * Close HTTP response object and its respective resources.
     *
     * @param response
     *            the HttpResponse object.
     */
    private void closeResponse(ClientResponse response) {
        if (response != null) {
            try {
                response.close();
            } catch (Throwable th) {
                logger.error("Cannot release response resource :", th);
            }
        }
    }

    /**
     * Gets the full registry information from the eureka server and stores it
     * locally.
     *
     * @return the full registry information.
     */
    public ClientResponse storeFullRegistry() {
        long currentUpdateGeneration = fullRegistryGeneration.get();
        ClientResponse response = fetchRemoteRegistry(false);
        if (response == null) {
            logger.error("The response is null.");
            return null;
        }
        Applications apps = response.getEntity(Applications.class);
        if (apps == null) {
            logger.error("The application is null for some reason. Not storing this information");
        } else if (fullRegistryGeneration.compareAndSet(currentUpdateGeneration, currentUpdateGeneration + 1)) {
            applications.set(apps);
        } else {
            logger.warn("Not updating applications as another thread is updating it already");
        }
        logger.info("The response status is {}", response.getStatus());
        return response;
    }

    /**
     * Fetch registry information from the remote region.
     * @param delta - true, if the fetch needs to get deltas, false otherwise
     * @return - response which has information about the data.
     */
    private ClientResponse fetchRemoteRegistry(boolean delta) {
        logger.info(
                "Getting instance registry info from the eureka server : {} , delta : {}",
                this.remoteRegionURL, delta);
        ClientResponse response = null;
        try {

            String urlPath = delta ? "apps/delta" : "apps/";

            response = discoveryApacheClient
                    .resource(this.remoteRegionURL.toString() + urlPath)
                    .accept(MediaType.APPLICATION_JSON_TYPE)
                    .get(ClientResponse.class);
            int httpStatus = response.getStatus();
            if (httpStatus >= 200 && httpStatus < 300) {
                logger.debug("Got the data successfully : {}", httpStatus);
            } else {
                logger.warn("Cannot get the data from {} : {}", this.remoteRegionURL.toString(), httpStatus);
                return null; // To short circuit entity evaluation.
            }

        } catch (Throwable t) {
            logger.error("Can't get a response from " + this.remoteRegionURL, t);

        }
        return response;
    }

    /**
     * Reconciles the delta information fetched to see if the hashcodes match.
     *
     * @param response - the response of the delta fetch.
     * @param delta - the delta information fetched previously for reconcililation.
     * @param reconcileHashCode - the hashcode for comparison.
     * @return - response
     * @throws Throwable
     */
    private ClientResponse reconcileAndLogDifference(ClientResponse response,
                                                     Applications delta, String reconcileHashCode) throws Throwable {
        logger.warn(
                "The Reconcile hashcodes do not match, client : {}, server : {}. Getting the full registry",
                reconcileHashCode, delta.getAppsHashCode());

        this.closeResponse(response);
        response = this.fetchRemoteRegistry(false);
        if (null == response) {
            logger.warn("Response is null while fetching remote registry during reconcile difference.");
            return null;
        }
        Applications serverApps = response.getEntity(Applications.class);
        Map<String, List<String>> reconcileDiffMap = getApplications()
                .getReconcileMapDiff(serverApps);
        String reconcileString = "";
        for (Map.Entry<String, List<String>> mapEntry : reconcileDiffMap
                .entrySet()) {
            reconcileString = reconcileString + mapEntry.getKey() + ": ";
            for (String displayString : mapEntry.getValue()) {
                reconcileString = reconcileString + displayString;
            }
            reconcileString = reconcileString + "\n";
        }
        logger.warn("The reconcile string is {}", reconcileString);
        applications.set(serverApps);
        applicationsDelta.set(serverApps);
        logger.warn(
                "The Reconcile hashcodes after complete sync up, client : {}, server : {}.",
                getApplications().getReconcileHashCode(),
                delta.getAppsHashCode());
        return response;
    }

    /**
     * Logs the total number of non-filtered instances stored locally.
     */
    private void logTotalInstances() {
        int totInstances = 0;
        for (Application application : getApplications().getRegisteredApplications()) {
            totInstances += application.getInstancesAsIsFromEureka().size();
        }
        logger.debug("The total number of all instances in the client now is {}", totInstances);
    }

    @Override
    public Applications getApplications() {
        return applications.get();
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String arg0, boolean arg1) {
        return null;
    }

    @Override
    public Application getApplication(String appName) {
        return this.applications.get().getRegisteredApplications(appName);
    }

    @Override
    public List<InstanceInfo> getInstancesById(String id) {
        List<InstanceInfo> list = Collections.emptyList();

        for (Application app : applications.get().getRegisteredApplications()) {
            InstanceInfo info = app.getByInstanceId(id);
            if (info != null) {
                list.add(info);
                return list;
            }
        }
        return list;
    }

    public Applications getApplicationDeltas() {
        return this.applicationsDelta.get();
    }

}=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
||||||| BASE
import com.sun.jersey.api.client.Client;
=======
import com.netflix.eureka.resources.ServerCodecs;
import com.sun.jersey.api.client.Client;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;<<<<<<< MINE
    public JerseyReplicationClient(EurekaJerseyClient jerseyClient, String serviceUrl) {
        super(jerseyClient, serviceUrl);
        this.jerseyClient = jerseyClient;
        this.jerseyApacheClient = jerseyClient.getClient();
||||||| BASE
    public JerseyReplicationClient(EurekaServerConfig config, String serviceUrl) {
        super(serviceUrl);
        String name = getClass().getSimpleName() + ": " + serviceUrl + "apps/: ";

        try {
            String hostname;
            try {
                hostname = new URL(serviceUrl).getHost();
            } catch (MalformedURLException e) {
                hostname = serviceUrl;
            }

            String jerseyClientName = "Discovery-PeerNodeClient-" + hostname;
            EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                    .withClientName(jerseyClientName)
                    .withUserAgent("Java-EurekaClient-Replication")
                    .withConnectionTimeout(config.getPeerNodeConnectTimeoutMs())
                    .withReadTimeout(config.getPeerNodeReadTimeoutMs())
                    .withMaxConnectionsPerHost(config.getPeerNodeTotalConnectionsPerHost())
                    .withMaxTotalConnections(config.getPeerNodeTotalConnections())
                    .withConnectionIdleTimeout(config.getPeerNodeConnectionIdleTimeoutSeconds());

            if (serviceUrl.startsWith("https://") &&
                    "true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
                clientBuilder.withSystemSSLConfiguration();
            }
            jerseyClient = clientBuilder.build();
            jerseyApacheClient = jerseyClient.getClient();
            jerseyApacheClient.addFilter(new DynamicGZIPContentEncodingFilter(config));
        } catch (Throwable e) {
            throw new RuntimeException("Cannot Create new Replica Node :" + name, e);
        }

        String ip = null;
        try {
            ip = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn("Cannot find localhost ip", e);
        }
        EurekaServerIdentity identity = new EurekaServerIdentity(ip);
        jerseyApacheClient.addFilter(new EurekaIdentityHeaderFilter(identity));
    }

    @Override
    protected Client getJerseyClient() {
        return jerseyApacheClient;
=======
    public JerseyReplicationClient(EurekaServerConfig config, ServerCodecs serverCodecs, String serviceUrl) {
        super(serviceUrl);
        String name = getClass().getSimpleName() + ": " + serviceUrl + "apps/: ";

        try {
            String hostname;
            try {
                hostname = new URL(serviceUrl).getHost();
            } catch (MalformedURLException e) {
                hostname = serviceUrl;
            }

            String jerseyClientName = "Discovery-PeerNodeClient-" + hostname;
            EurekaJerseyClientBuilder clientBuilder = new EurekaJerseyClientBuilder()
                    .withClientName(jerseyClientName)
                    .withUserAgent("Java-EurekaClient-Replication")
                    .withEncoderWrapper(serverCodecs.getFullJsonCodec())
                    .withDecoderWrapper(serverCodecs.getFullJsonCodec())
                    .withConnectionTimeout(config.getPeerNodeConnectTimeoutMs())
                    .withReadTimeout(config.getPeerNodeReadTimeoutMs())
                    .withMaxConnectionsPerHost(config.getPeerNodeTotalConnectionsPerHost())
                    .withMaxTotalConnections(config.getPeerNodeTotalConnections())
                    .withConnectionIdleTimeout(config.getPeerNodeConnectionIdleTimeoutSeconds());

            if (serviceUrl.startsWith("https://") &&
                    "true".equals(System.getProperty("com.netflix.eureka.shouldSSLConnectionsUseSystemSocketFactory"))) {
                clientBuilder.withSystemSSLConfiguration();
            }
            jerseyClient = clientBuilder.build();
            jerseyApacheClient = jerseyClient.getClient();
            jerseyApacheClient.addFilter(new DynamicGZIPContentEncodingFilter(config));
        } catch (Throwable e) {
            throw new RuntimeException("Cannot Create new Replica Node :" + name, e);
        }

        String ip = null;
        try {
            ip = InetAddress.getLocalHost().getHostAddress();
        } catch (UnknownHostException e) {
            logger.warn("Cannot find localhost ip", e);
        }
        EurekaServerIdentity identity = new EurekaServerIdentity(ip);
        jerseyApacheClient.addFilter(new EurekaIdentityHeaderFilter(identity));
    }

    @Override
    protected Client getJerseyClient() {
        return jerseyApacheClient;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;<<<<<<< MINE
||||||| BASE
package com.netflix.discovery.shared;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.netflix.discovery.converters.wrappers.CodecWrappers;
import com.netflix.discovery.converters.wrappers.DecoderWrapper;
import com.netflix.discovery.converters.wrappers.EncoderWrapper;
import com.netflix.discovery.provider.DiscoveryJerseyProvider;
import com.netflix.servo.monitor.BasicCounter;
import com.netflix.servo.monitor.BasicTimer;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.MonitorConfig;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.discovery.util.DiscoveryBuildInfo.buildVersion;

/**
 * @author Tomasz Bak
 */
public class EurekaJerseyClientImpl implements EurekaJerseyClient {

    private static final Logger s_logger = LoggerFactory.getLogger(EurekaJerseyClientImpl.class);

    private static final int HTTP_CONNECTION_CLEANER_INTERVAL_MS = 30 * 1000;

    private static final String PROTOCOL = "https";
    private static final String PROTOCOL_SCHEME = "SSL";
    private static final int HTTPS_PORT = 443;
    private static final String KEYSTORE_TYPE = "JKS";

    private final ApacheHttpClient4 apacheHttpClient;

    ClientConfig jerseyClientConfig;

    private final ScheduledExecutorService eurekaConnCleaner =
            Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {

                private final AtomicInteger threadNumber = new AtomicInteger(1);

                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
                }
            });

    public EurekaJerseyClientImpl(int connectionTimeout, int readTimeout, final int connectionIdleTimeout,
                              ClientConfig clientConfig) {
        try {
            jerseyClientConfig = clientConfig;
            jerseyClientConfig.getClasses().add(DiscoveryJerseyProvider.class);
            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);
            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();

            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);
            HttpConnectionParams.setSoTimeout(params, readTimeout);

            eurekaConnCleaner.scheduleWithFixedDelay(
                    new ConnectionCleanerTask(connectionIdleTimeout), HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    TimeUnit.MILLISECONDS);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client", e);
        }
    }

    @Override
    public ApacheHttpClient4 getClient() {
        return apacheHttpClient;
    }

    /**
     * Clean up resources.
     */
    @Override
    public void destroyResources() {
        if (eurekaConnCleaner != null) {
            eurekaConnCleaner.shutdown();
        }
        if (apacheHttpClient != null) {
            apacheHttpClient.destroy();
        }
    }

    public static class EurekaJerseyClientBuilder {

        private boolean systemSSL;
        private String clientName;
        private int maxConnectionsPerHost;
        private int maxTotalConnections;
        private String trustStoreFileName;
        private String trustStorePassword;
        private String userAgent;
        private String proxyUserName;
        private String proxyPassword;
        private String proxyHost;
        private String proxyPort;
        private int connectionTimeout;
        private int readTimeout;
        private int connectionIdleTimeout;
        private EncoderWrapper encoderWrapper;
        private DecoderWrapper decoderWrapper;

        public EurekaJerseyClientBuilder withClientName(String clientName) {
            this.clientName = clientName;
            return this;
        }

        public EurekaJerseyClientBuilder withUserAgent(String userAgent) {
            this.userAgent = userAgent;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionTimeout(int connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withReadTimeout(int readTimeout) {
            this.readTimeout = readTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionIdleTimeout(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxConnectionsPerHost(int maxConnectionsPerHost) {
            this.maxConnectionsPerHost = maxConnectionsPerHost;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxTotalConnections(int maxTotalConnections) {
            this.maxTotalConnections = maxTotalConnections;
            return this;
        }

        public EurekaJerseyClientBuilder withProxy(String proxyHost, String proxyPort, String user, String password) {
            this.proxyHost = proxyHost;
            this.proxyPort = proxyPort;
            this.proxyUserName = user;
            this.proxyPassword = password;
            return this;
        }

        public EurekaJerseyClientBuilder withSystemSSLConfiguration() {
            this.systemSSL = true;
            return this;
        }

        public EurekaJerseyClientBuilder withTrustStoreFile(String trustStoreFileName, String trustStorePassword) {
            this.trustStoreFileName = trustStoreFileName;
            this.trustStorePassword = trustStorePassword;
            return this;
        }

        public EurekaJerseyClientBuilder withEncoder(String encoderName) {
            return this.withEncoderWrapper(CodecWrappers.getEncoder(encoderName));
        }

        public EurekaJerseyClientBuilder withEncoderWrapper(EncoderWrapper encoderWrapper) {
            this.encoderWrapper = encoderWrapper;
            return this;
        }

        public EurekaJerseyClientBuilder withDecoder(String decoderName, String clientDataAccept) {
            return this.withDecoderWrapper(CodecWrappers.resolveDecoder(decoderName, clientDataAccept));
        }

        public EurekaJerseyClientBuilder withDecoderWrapper(DecoderWrapper decoderWrapper) {
            this.decoderWrapper = decoderWrapper;
            return this;
        }

        public EurekaJerseyClient build() {
            MyDefaultApacheHttpClient4Config config = new MyDefaultApacheHttpClient4Config();
            try {
                return new EurekaJerseyClientImpl(connectionTimeout, readTimeout, connectionIdleTimeout, config);
            } catch (Throwable e) {
                throw new RuntimeException("Cannot create Jersey client ", e);
            }
        }

        class MyDefaultApacheHttpClient4Config extends DefaultApacheHttpClient4Config {
            MyDefaultApacheHttpClient4Config() {
                MonitoredConnectionManager cm;

                if (systemSSL) {
                    cm = createSystemSslCM();
                } else if (trustStoreFileName != null) {
                    cm = createCustomSslCM();
                } else {
                    cm = new MonitoredConnectionManager(clientName);
                }

                if (proxyHost != null) {
                    addProxyConfiguration(cm);
                }

                DiscoveryJerseyProvider discoveryJerseyProvider = new DiscoveryJerseyProvider(encoderWrapper, decoderWrapper);
                getSingletons().add(discoveryJerseyProvider);

                // Common properties to all clients
                cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
                cm.setMaxTotal(maxTotalConnections);
                getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);

                String fullUserAgentName = (userAgent == null ? clientName : userAgent) + "/v" + buildVersion();
                getProperties().put(CoreProtocolPNames.USER_AGENT, fullUserAgentName);

                // To pin a client to specific server in case redirect happens, we handle redirects directly
                // (see DiscoveryClient.makeRemoteCall methods).
                getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
                getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);

            }

            private void addProxyConfiguration(MonitoredConnectionManager cm) {
                if (proxyUserName != null && proxyPassword != null) {
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
                } else {
                    // Due to bug in apache client, user name/password must always be set.
                    // Otherwise proxy configuration is ignored.
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
                }
                getProperties().put(DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI, "http://" + proxyHost + ":" + proxyPort);
            }

            private MonitoredConnectionManager createSystemSslCM() {
                MonitoredConnectionManager cm;
                SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
                SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));
                cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                return cm;
            }

            private MonitoredConnectionManager createCustomSslCM() {
                FileInputStream fin = null;
                try {
                    SSLContext sslContext = SSLContext.getInstance(PROTOCOL_SCHEME);
                    KeyStore sslKeyStore = KeyStore.getInstance(KEYSTORE_TYPE);

                    fin = new FileInputStream(trustStoreFileName);
                    sslKeyStore.load(fin, trustStorePassword.toCharArray());

                    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    factory.init(sslKeyStore);

                    TrustManager[] trustManagers = factory.getTrustManagers();

                    sslContext.init(null, trustManagers, null);
                    SSLSocketFactory sslSocketFactory = new SSLSocketFactory(sslContext);
                    sslSocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
                    SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                    sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

                    return new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                } catch (Exception ex) {
                    throw new IllegalStateException("SSL configuration issue", ex);
                } finally {
                    if (fin != null) {
                        try {
                            fin.close();
                        } catch (IOException ignore) {
                        }
                    }
                }
            }
        }
    }

    private class ConnectionCleanerTask implements Runnable {

        private final int connectionIdleTimeout;
        private final BasicTimer executionTimeStats;
        private final Counter cleanupFailed;

        private ConnectionCleanerTask(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            MonitorConfig.Builder monitorConfigBuilder = MonitorConfig.builder("Eureka-Connection-Cleaner-Time");
            executionTimeStats = new BasicTimer(monitorConfigBuilder.build());
            cleanupFailed = new BasicCounter(MonitorConfig.builder("Eureka-Connection-Cleaner-Failure").build());
            try {
                Monitors.registerObject(this);
            } catch (Exception e) {
                s_logger.error("Unable to register with servo.", e);
            }
        }

        @Override
        public void run() {
            Stopwatch start = executionTimeStats.start();
            try {
                apacheHttpClient
                        .getClientHandler()
                        .getHttpClient()
                        .getConnectionManager()
                        .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
            } catch (Throwable e) {
                s_logger.error("Cannot clean connections", e);
                cleanupFailed.increment();
            } finally {
                if (null != start) {
                    start.stop();
                }
            }

        }
    }
}=======
package com.netflix.discovery.shared;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.TrustManagerFactory;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.KeyStore;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.netflix.discovery.converters.wrappers.CodecWrappers;
import com.netflix.discovery.converters.wrappers.DecoderWrapper;
import com.netflix.discovery.converters.wrappers.EncoderWrapper;
import com.netflix.discovery.provider.DiscoveryJerseyProvider;
import com.netflix.servo.monitor.BasicCounter;
import com.netflix.servo.monitor.BasicTimer;
import com.netflix.servo.monitor.Counter;
import com.netflix.servo.monitor.MonitorConfig;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import com.sun.jersey.api.client.config.ClientConfig;
import com.sun.jersey.client.apache4.ApacheHttpClient4;
import com.sun.jersey.client.apache4.config.ApacheHttpClient4Config;
import com.sun.jersey.client.apache4.config.DefaultApacheHttpClient4Config;
import org.apache.http.client.params.ClientPNames;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.params.CoreProtocolPNames;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.discovery.util.DiscoveryBuildInfo.buildVersion;

/**
 * @author Tomasz Bak
 */
public class EurekaJerseyClientImpl implements EurekaJerseyClient {

    private static final Logger s_logger = LoggerFactory.getLogger(EurekaJerseyClientImpl.class);

    private static final int HTTP_CONNECTION_CLEANER_INTERVAL_MS = 30 * 1000;

    private static final String PROTOCOL = "https";
    private static final String PROTOCOL_SCHEME = "SSL";
    private static final int HTTPS_PORT = 443;
    private static final String KEYSTORE_TYPE = "JKS";

    private final ApacheHttpClient4 apacheHttpClient;

    ClientConfig jerseyClientConfig;

    private final ScheduledExecutorService eurekaConnCleaner =
            Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {

                private final AtomicInteger threadNumber = new AtomicInteger(1);

                @Override
                public Thread newThread(Runnable r) {
                    Thread thread = new Thread(r, "Eureka-JerseyClient-Conn-Cleaner" + threadNumber.incrementAndGet());
                    thread.setDaemon(true);
                    return thread;
                }
            });

    public EurekaJerseyClientImpl(int connectionTimeout, int readTimeout, final int connectionIdleTimeout,
                              ClientConfig clientConfig) {
        try {
            jerseyClientConfig = clientConfig;
            apacheHttpClient = ApacheHttpClient4.create(jerseyClientConfig);
            HttpParams params = apacheHttpClient.getClientHandler().getHttpClient().getParams();

            HttpConnectionParams.setConnectionTimeout(params, connectionTimeout);
            HttpConnectionParams.setSoTimeout(params, readTimeout);

            eurekaConnCleaner.scheduleWithFixedDelay(
                    new ConnectionCleanerTask(connectionIdleTimeout), HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    HTTP_CONNECTION_CLEANER_INTERVAL_MS,
                    TimeUnit.MILLISECONDS);
        } catch (Throwable e) {
            throw new RuntimeException("Cannot create Jersey client", e);
        }
    }

    @Override
    public ApacheHttpClient4 getClient() {
        return apacheHttpClient;
    }

    /**
     * Clean up resources.
     */
    @Override
    public void destroyResources() {
        if (eurekaConnCleaner != null) {
            eurekaConnCleaner.shutdown();
        }
        if (apacheHttpClient != null) {
            apacheHttpClient.destroy();
        }
    }

    public static class EurekaJerseyClientBuilder {

        private boolean systemSSL;
        private String clientName;
        private int maxConnectionsPerHost;
        private int maxTotalConnections;
        private String trustStoreFileName;
        private String trustStorePassword;
        private String userAgent;
        private String proxyUserName;
        private String proxyPassword;
        private String proxyHost;
        private String proxyPort;
        private int connectionTimeout;
        private int readTimeout;
        private int connectionIdleTimeout;
        private EncoderWrapper encoderWrapper;
        private DecoderWrapper decoderWrapper;

        public EurekaJerseyClientBuilder withClientName(String clientName) {
            this.clientName = clientName;
            return this;
        }

        public EurekaJerseyClientBuilder withUserAgent(String userAgent) {
            this.userAgent = userAgent;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionTimeout(int connectionTimeout) {
            this.connectionTimeout = connectionTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withReadTimeout(int readTimeout) {
            this.readTimeout = readTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withConnectionIdleTimeout(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxConnectionsPerHost(int maxConnectionsPerHost) {
            this.maxConnectionsPerHost = maxConnectionsPerHost;
            return this;
        }

        public EurekaJerseyClientBuilder withMaxTotalConnections(int maxTotalConnections) {
            this.maxTotalConnections = maxTotalConnections;
            return this;
        }

        public EurekaJerseyClientBuilder withProxy(String proxyHost, String proxyPort, String user, String password) {
            this.proxyHost = proxyHost;
            this.proxyPort = proxyPort;
            this.proxyUserName = user;
            this.proxyPassword = password;
            return this;
        }

        public EurekaJerseyClientBuilder withSystemSSLConfiguration() {
            this.systemSSL = true;
            return this;
        }

        public EurekaJerseyClientBuilder withTrustStoreFile(String trustStoreFileName, String trustStorePassword) {
            this.trustStoreFileName = trustStoreFileName;
            this.trustStorePassword = trustStorePassword;
            return this;
        }

        public EurekaJerseyClientBuilder withEncoder(String encoderName) {
            return this.withEncoderWrapper(CodecWrappers.getEncoder(encoderName));
        }

        public EurekaJerseyClientBuilder withEncoderWrapper(EncoderWrapper encoderWrapper) {
            this.encoderWrapper = encoderWrapper;
            return this;
        }

        public EurekaJerseyClientBuilder withDecoder(String decoderName, String clientDataAccept) {
            return this.withDecoderWrapper(CodecWrappers.resolveDecoder(decoderName, clientDataAccept));
        }

        public EurekaJerseyClientBuilder withDecoderWrapper(DecoderWrapper decoderWrapper) {
            this.decoderWrapper = decoderWrapper;
            return this;
        }

        public EurekaJerseyClient build() {
            MyDefaultApacheHttpClient4Config config = new MyDefaultApacheHttpClient4Config();
            try {
                return new EurekaJerseyClientImpl(connectionTimeout, readTimeout, connectionIdleTimeout, config);
            } catch (Throwable e) {
                throw new RuntimeException("Cannot create Jersey client ", e);
            }
        }

        class MyDefaultApacheHttpClient4Config extends DefaultApacheHttpClient4Config {
            MyDefaultApacheHttpClient4Config() {
                MonitoredConnectionManager cm;

                if (systemSSL) {
                    cm = createSystemSslCM();
                } else if (trustStoreFileName != null) {
                    cm = createCustomSslCM();
                } else {
                    cm = new MonitoredConnectionManager(clientName);
                }

                if (proxyHost != null) {
                    addProxyConfiguration(cm);
                }

                DiscoveryJerseyProvider discoveryJerseyProvider = new DiscoveryJerseyProvider(encoderWrapper, decoderWrapper);
                getSingletons().add(discoveryJerseyProvider);

                // Common properties to all clients
                cm.setDefaultMaxPerRoute(maxConnectionsPerHost);
                cm.setMaxTotal(maxTotalConnections);
                getProperties().put(ApacheHttpClient4Config.PROPERTY_CONNECTION_MANAGER, cm);

                String fullUserAgentName = (userAgent == null ? clientName : userAgent) + "/v" + buildVersion();
                getProperties().put(CoreProtocolPNames.USER_AGENT, fullUserAgentName);

                // To pin a client to specific server in case redirect happens, we handle redirects directly
                // (see DiscoveryClient.makeRemoteCall methods).
                getProperties().put(PROPERTY_FOLLOW_REDIRECTS, Boolean.FALSE);
                getProperties().put(ClientPNames.HANDLE_REDIRECTS, Boolean.FALSE);
            }

            private void addProxyConfiguration(MonitoredConnectionManager cm) {
                if (proxyUserName != null && proxyPassword != null) {
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, proxyUserName);
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, proxyPassword);
                } else {
                    // Due to bug in apache client, user name/password must always be set.
                    // Otherwise proxy configuration is ignored.
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_USERNAME, "guest");
                    getProperties().put(ApacheHttpClient4Config.PROPERTY_PROXY_PASSWORD, "guest");
                }
                getProperties().put(DefaultApacheHttpClient4Config.PROPERTY_PROXY_URI, "http://" + proxyHost + ":" + proxyPort);
            }

            private MonitoredConnectionManager createSystemSslCM() {
                MonitoredConnectionManager cm;
                SSLSocketFactory sslSocketFactory = SSLSocketFactory.getSystemSocketFactory();
                SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));
                cm = new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                return cm;
            }

            private MonitoredConnectionManager createCustomSslCM() {
                FileInputStream fin = null;
                try {
                    SSLContext sslContext = SSLContext.getInstance(PROTOCOL_SCHEME);
                    KeyStore sslKeyStore = KeyStore.getInstance(KEYSTORE_TYPE);

                    fin = new FileInputStream(trustStoreFileName);
                    sslKeyStore.load(fin, trustStorePassword.toCharArray());

                    TrustManagerFactory factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
                    factory.init(sslKeyStore);

                    TrustManager[] trustManagers = factory.getTrustManagers();

                    sslContext.init(null, trustManagers, null);
                    SSLSocketFactory sslSocketFactory = new SSLSocketFactory(sslContext);
                    sslSocketFactory.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);
                    SchemeRegistry sslSchemeRegistry = new SchemeRegistry();
                    sslSchemeRegistry.register(new Scheme(PROTOCOL, HTTPS_PORT, sslSocketFactory));

                    return new MonitoredConnectionManager(clientName, sslSchemeRegistry);
                } catch (Exception ex) {
                    throw new IllegalStateException("SSL configuration issue", ex);
                } finally {
                    if (fin != null) {
                        try {
                            fin.close();
                        } catch (IOException ignore) {
                        }
                    }
                }
            }
        }
    }

    private class ConnectionCleanerTask implements Runnable {

        private final int connectionIdleTimeout;
        private final BasicTimer executionTimeStats;
        private final Counter cleanupFailed;

        private ConnectionCleanerTask(int connectionIdleTimeout) {
            this.connectionIdleTimeout = connectionIdleTimeout;
            MonitorConfig.Builder monitorConfigBuilder = MonitorConfig.builder("Eureka-Connection-Cleaner-Time");
            executionTimeStats = new BasicTimer(monitorConfigBuilder.build());
            cleanupFailed = new BasicCounter(MonitorConfig.builder("Eureka-Connection-Cleaner-Failure").build());
            try {
                Monitors.registerObject(this);
            } catch (Exception e) {
                s_logger.error("Unable to register with servo.", e);
            }
        }

        @Override
        public void run() {
            Stopwatch start = executionTimeStats.start();
            try {
                apacheHttpClient
                        .getClientHandler()
                        .getHttpClient()
                        .getConnectionManager()
                        .closeIdleConnections(connectionIdleTimeout, TimeUnit.SECONDS);
            } catch (Throwable e) {
                s_logger.error("Cannot clean connections", e);
                cleanupFailed.increment();
            } finally {
                if (null != start) {
                    start.stop();
                }
            }

        }
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-client/src/test/java/com/netflix/discovery/converters/EurekaJacksonCodecTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_a995b04_c1c4cbe/rev_a995b04-c1c4cbe/eureka-client/src/test/java/com/netflix/discovery/converters/EurekaJsonAndXmlJacksonCodecTest.java;<<<<<<< MINE
    public void testInstanceInfoWithNoMetaEncodeDecodeWithJson() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaJsonJacksonCodec().getObjectMapper());
    }

    @Test
    public void testInstanceInfoWithNoMetaEncodeDecodeWithXml() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaXmlJacksonCodec().getObjectMapper());
    }

    private void doInstanceInfoWithNoMetaEncodeDecode(ObjectMapper mapper) throws Exception {
        InstanceInfo noMetaDataInfo = new InstanceInfo.Builder(infoIterator.next()).setMetadata(null).build();

        String encodedString = mapper.writeValueAsString(noMetaDataInfo);
        InstanceInfo decodedValue = mapper.readValue(encodedString, InstanceInfo.class);

        assertThat(decodedValue.getId(), is(equalTo(noMetaDataInfo.getId())));
    }

    @Test
||||||| BASE
=======
    public void testInstanceInfoWithNoMetaEncodeDecodeWithJson() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaJsonJacksonCodec().getObjectMapper(), true);
    }

    @Test
    public void testInstanceInfoWithNoMetaEncodeDecodeWithXml() throws Exception {
        doInstanceInfoWithNoMetaEncodeDecode(new EurekaXmlJacksonCodec().getObjectMapper(), false);
    }

    private void doInstanceInfoWithNoMetaEncodeDecode(ObjectMapper mapper, boolean json) throws Exception {
        InstanceInfo noMetaDataInfo = new InstanceInfo.Builder(infoIterator.next()).setMetadata(null).build();

        String encodedString = mapper.writeValueAsString(noMetaDataInfo);

        // Backward compatibility with old codec
        if (json) {
            assertThat(encodedString.contains("\"@class\":\"java.util.Collections$EmptyMap\""), is(true));
        }

        InstanceInfo decodedValue = mapper.readValue(encodedString, InstanceInfo.class);
        assertThat(decodedValue.getId(), is(equalTo(noMetaDataInfo.getId())));
        assertThat(decodedValue.getMetadata().isEmpty(), is(true));
    }

    @Test
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_90eea3b_1837e04/rev_90eea3b-1837e04/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server/src/test/java/com/netflix/eureka/resources/EurekaClientServerRestIntegrationTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-test-utils/src/main/java/com/netflix/discovery/util/DiagnosticClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/RemoteRegionRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/ResponseCacheImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/Key.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/ResponseCache.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/AwsInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/InstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/registry/PeerAwareInstanceRegistryImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/lease/LeaseManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/lease/Lease.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/ServerRequestAuthFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaBootStrap.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerContext.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/RateLimitingFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerContext.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/V1AwareInstanceInfoConverter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/EurekaServerContextHolder.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/AsgReplicationTask.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/protocol/ReplicationInstance.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/InstanceReplicationTask.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/cluster/JerseyReplicationClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/aws/AwsAsgUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/StatusFilter.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerCodecs.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/AbstractVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstanceResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ASGResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/CurrentRequestVersion.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/InstancesResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/DefaultServerCodecs.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ApplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerInfoResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerInfoResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/ServerInfoResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/VIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/PeerReplicationResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/resources/SecureVIPResource.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/registry/ResponseCacheTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/registry/InstanceRegistryTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RateLimitingFilterTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/mock/MockRemoteEurekaServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/JerseyReplicationClientTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/ReplicationTaskProcessorTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/PeerEurekaNodeTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/cluster/ClusterSampleData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/util/AwsAsgUtilTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/AbstractTester.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RemoteRegionSoftDependencyTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RemoteRegionSoftDependencyTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/RemoteRegionSoftDependencyTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationsResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationsResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/AbstractVIPResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/InstanceResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/ApplicationResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/PeerReplicationResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-core/src/test/java/com/netflix/eureka/resources/PeerReplicationResourceTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/guice/EurekaServerModule.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/guice/LocalEurekaServerModule.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/EurekaInjectorCreator.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-server-karyon3/src/main/java/com/netflix/eureka/EurekaContextListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/appinfo/ApplicationInfoManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/shared/EurekaJerseyClientImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/endpoint/DnsResolver.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/endpoint/EndpointUtils.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/PropertyBasedAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/PropertyBasedAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/AbstractAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DNSBasedAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DNSBasedAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DNSBasedAzToRegionMapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/EurekaClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/converters/wrappers/CodecWrapper.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/DiscoveryClient.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/main/java/com/netflix/discovery/NotImplementedRegistryImpl.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_c1c4cbe_dd8d47d/rev_c1c4cbe-dd8d47d/eureka-client/src/test/java/com/netflix/discovery/converters/wrappers/CodecWrappersTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE


    /**
     * Get the configured binding strategy EIP or Route53.
     * @return the configured binding strategy
     */
    AwsBindingStrategy getBindingStrategy();

    /**
     *
     * @return the ttl used to set up the route53 domain if new
     */
    long getRoute53DomainTTL();

    /**
     * Gets the number of times the server should try to bind to the candidate
     * Route53 domain.
     *
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the number of times the server should try to bind to the
     *         candidate Route53 domain.
     */
    int getRoute53BindRebindRetries();

    /**
     * Gets the interval with which the server should check if the Route53 domain is bound
     * and should try to bind in the case if it is already not bound.
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the time in milliseconds.
     */
    int getRoute53BindingRetryIntervalMs();
||||||| BASE
=======

    /**
     * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
     * the corresponding configuration can be put into experimental configuration section.
     *
     * @return a property of experimental feature
     */
    String getExperimental(String name);
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/main/java/com/netflix/eureka/PeerAwareInstanceRegistryImpl.java;<<<<<<< MINE
||||||| BASE
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka;

import java.net.URI;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.DataCenterInfo;
import com.netflix.appinfo.DataCenterInfo.Name;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.appinfo.LeaseInfo;
import com.netflix.discovery.DiscoveryManager;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.LookupService;
import com.netflix.eureka.cluster.PeerEurekaNode;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.lease.Lease;
import com.netflix.eureka.resources.ASGResource.ASGStatus;
import com.netflix.eureka.util.MeasuredRate;
import com.netflix.servo.DefaultMonitorRegistry;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.eureka.cluster.PeerEurekaNodes.isThisMe;

/**
 * Handles replication of all operations to {@link AbstractInstanceRegistry} to peer
 * <em>Eureka</em> nodes to keep them all in sync.
 *
 * <p>
 * Primary operations that are replicated are the
 * <em>Registers,Renewals,Cancels,Expirations and Status Changes</em>
 * </p>
 *
 * <p>
 * When the eureka server starts up it tries to fetch all the registry
 * information from the peer eureka nodes.If for some reason this operation
 * fails, the server does not allow the user to get the registry information for
 * a period specified in
 * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}.
 * </p>
 *
 * <p>
 * One important thing to note about <em>renewals</em>.If the renewal drops more
 * than the specified threshold as specified in
 * {@link EurekaServerConfig#getRenewalPercentThreshold()} within a period of
 * {@link EurekaServerConfig#getRenewalThresholdUpdateIntervalMs()}, eureka
 * perceives this as a danger and stops expiring instances.
 * </p>
 *
 * @author Karthik Ranganathan, Greg Kim
 *
 */
public class PeerAwareInstanceRegistryImpl extends AbstractInstanceRegistry implements PeerAwareInstanceRegistry {
    private static final String US_EAST_1 = "us-east-1";

    private static final int PRIME_PEER_NODES_RETRY_MS = 30000;

    private static final int REGISTRY_SYNC_RETRY_MS = 30000;

    private static final Logger logger = LoggerFactory.getLogger(PeerAwareInstanceRegistryImpl.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final EurekaClientConfig EUREKA_CLIENT_CONFIG = DiscoveryManager
            .getInstance().getEurekaClientConfig();

    private long startupTime = 0;
    private boolean peerInstancesTransferEmptyOnStartup = true;

    public enum Action {
        Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;

        private com.netflix.servo.monitor.Timer timer = Monitors.newTimer(this.name());

        public com.netflix.servo.monitor.Timer getTimer() {
            return this.timer;
        }

    }

    private static final Comparator<Application> APP_COMPARATOR = new Comparator<Application>() {
        public int compare(Application l, Application r) {
            return l.getName().compareTo(r.getName());
        }
    };

    private final MeasuredRate numberOfReplicationsLastMin = new MeasuredRate(1000 * 60 * 1);


    private final PeerEurekaNodes peerEurekaNodes;

    private Timer timer = new Timer(
            "ReplicaAwareInstanceRegistry - RenewalThresholdUpdater", true);

    private static final PeerAwareInstanceRegistryImpl instance = new PeerAwareInstanceRegistryImpl();

    PeerAwareInstanceRegistryImpl() {
        this.peerEurekaNodes = new PeerEurekaNodes(this, EUREKA_SERVER_CONFIG);

        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn(
                    "Cannot register the JMX monitor for the InstanceRegistry :",
                    e);
        }
        init();
    }

    public static PeerAwareInstanceRegistryImpl getInstance() {
        return instance;
    }

    /**
     * Set up replica nodes and the task that updates the threshold
     * periodically.
     */
    private void init() {
        peerEurekaNodes.start();
        scheduleRenewalThresholdUpdateTask();
    }

    /**
     * Schedule the task that updates <em>renewal threshold</em> periodically.
     * The renewal threshold would be used to determine if the renewals drop
     * dramatically because of network partition and to protect expiring too
     * many instances at a time.
     *
     */
    private void scheduleRenewalThresholdUpdateTask() {
        timer.schedule(new TimerTask() {

                           @Override
                           public void run() {
                               updateRenewalThreshold();

                           }

                       }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
                EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs());
    }

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        LookupService lookupService = DiscoveryManager.getInstance()
                .getLookupService();
        int count = 0;

        for (int i = 0; ((i < EUREKA_SERVER_CONFIG.getRegistrySyncRetries()) && (count == 0)); i++) {
            Applications apps = lookupService.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {

                            register(instance, instance.getLeaseInfo()
                                    .getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
            if (count == 0) {
                try {
                    Thread.sleep(REGISTRY_SYNC_RETRY_MS);
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
        }
        return count;
    }

    public void openForTraffic(int count) {
        // Renewals happen every 30 seconds and for a minute it should be a
        // factor of 2.
        this.expectedNumberOfRenewsPerMin = count * 2;
        this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                .getRenewalPercentThreshold());
        logger.info("Got " + count + " instances from neighboring DS node");
        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
        this.startupTime = System.currentTimeMillis();
        if (count > 0) {
            this.peerInstancesTransferEmptyOnStartup = false;
        }
        boolean isAws = (Name.Amazon.equals(ApplicationInfoManager
                .getInstance().getInfo().getDataCenterInfo().getName()));
        if (isAws && EUREKA_SERVER_CONFIG.shouldPrimeAwsReplicaConnections()) {
            logger.info("Priming AWS connections for all replicas..");
            primeAwsReplicas();
        }
        logger.info("Changing status to UP");
        ApplicationInfoManager.getInstance().setInstanceStatus(
                InstanceStatus.UP);
        super.postInit();
    }

    /**
     * Prime connections for Aws replicas.
     * <p>
     * Sometimes when the eureka servers comes up, AWS firewall may not allow
     * the network connections immediately. This will cause the outbound
     * connections to fail, but the inbound connections continue to work. What
     * this means is the clients would have switched to this node (after EIP
     * binding) and so the other eureka nodes will expire all instances that
     * have been switched because of the lack of outgoing heartbeats from this
     * instance.
     * </p>
     * <p>
     * The best protection in this scenario is to block and wait until we are
     * able to ping all eureka nodes successfully atleast once. Until then we
     * won't open up the traffic.
     * </p>
     */
    private void primeAwsReplicas() {
        boolean areAllPeerNodesPrimed = false;
        while (!areAllPeerNodesPrimed) {
            String peerHostName = null;
            try {
                Application eurekaApps = this.getApplication(
                        ApplicationInfoManager.getInstance().getInfo()
                                .getAppName(), false);
                if (eurekaApps == null) {
                    areAllPeerNodesPrimed = true;
                }
                for (PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                    for (InstanceInfo peerInstanceInfo : eurekaApps
                            .getInstances()) {
                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();
                        // If the lease is expired - do not worry about priming
                        if (System.currentTimeMillis() > (leaseInfo
                                .getRenewalTimestamp() + (leaseInfo
                                .getDurationInSecs() * 1000))
                                + (2 * 60 * 1000)) {
                            continue;
                        }
                        peerHostName = peerInstanceInfo.getHostName();
                        logger.info(
                                "Trying to send heartbeat for the eureka server at {} to make sure the network "
                                        + "channels are open", peerHostName);
                        // Only try to contact the eureka nodes that are in this
                        // instance's registry - because
                        // the other instances may be legitimately down
                        if (peerHostName.equalsIgnoreCase(new URI(node
                                .getServiceUrl()).getHost())) {
                            node.heartbeat(peerInstanceInfo.getAppName(),
                                    peerInstanceInfo.getId(), peerInstanceInfo,
                                    null, true);
                        }
                    }
                }
                areAllPeerNodesPrimed = true;
            } catch (Throwable e) {
                logger.error("Could not contact " + peerHostName, e);
                try {
                    Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                } catch (InterruptedException e1) {
                    logger.warn("Interrupted while priming : ", e1);
                    areAllPeerNodesPrimed = true;
                }
            }
        }
    }

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, o otherwise returns
     *         true
     */
    public boolean shouldAllowAccess(boolean remoteRegionRequired) {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (!(System.currentTimeMillis() > this.startupTime
                    + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
                return false;
            }
        }
        if (remoteRegionRequired) {
            for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
                if (!remoteRegionRegistry.isReadyForServingData()) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean shouldAllowAccess() {
        return shouldAllowAccess(true);
    }

    /**
     * Gets the list of peer eureka nodes which is the list to replicate
     * information to.
     *
     * @return the list of replica nodes.
     */
    public List<PeerEurekaNode> getReplicaNodes() {
        return Collections.unmodifiableList(peerEurekaNodes.getPeerEurekaNodes());
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#cancel(java.lang.String,
     * java.lang.String, long, boolean)
     */
    @Override
    public boolean cancel(final String appName, final String id,
                          final boolean isReplication) {
        if (super.cancel(appName, id, isReplication)) {
            replicateToPeers(Action.Cancel, appName, id, null, null,
                    isReplication);
            synchronized (lock) {
                if (this.expectedNumberOfRenewsPerMin > 0) {
                    // Since the client wants to cancel it, reduce the threshold
                    // (1
                    // for 30 seconds, 2 for a minute)
                    this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2;
                    this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Registers the information about the {@link InstanceInfo} and replicates
     * this information to all peer eureka nodes. If this is replication event
     * from other replica nodes then it is not replicated.
     *
     * @param info
     *            the {@link InstanceInfo} to be registered and replicated.
     * @param isReplication
     *            true if this is a replication event from other replica nodes,
     *            false otherwise.
     */
    @Override
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null
                && info.getLeaseInfo().getDurationInSecs() > 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(),
                info, null, isReplication);
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#renew(java.lang.String,
     * java.lang.String, long, boolean)
     */
    public boolean renew(final String appName, final String id,
                         final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null,
                    isReplication);
            return true;
        }
        return false;
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String,
     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,
     * java.lang.String, boolean)
     */
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp,
                isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus,
                    isReplication);
            return true;
        }
        return false;
    }

    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /**
     * Replicate the <em>ASG status</em> updates to peer eureka nodes. If this
     * event is a replication from other nodes, then it is not replicated to
     * other nodes.
     *
     * @param asgName
     *            the asg name for which the status needs to be replicated.
     * @param newStatus
     *            the {@link ASGStatus} information that needs to be replicated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     */
    public void statusUpdate(final String asgName, final ASGStatus newStatus,
                             final boolean isReplication) {
        // If this is replicated from an other node, do not try to replicate
        // again.
        if (isReplication) {
            return;
        }
        for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
            replicateASGInfoToReplicaNodes(asgName, newStatus, node);

        }

    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#isLeaseExpirationEnabled()
     */
    @Override
    public boolean isLeaseExpirationEnabled() {
        boolean leaseExpirationEnabled = (numberOfRenewsPerMinThreshold > 0)
                && (getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold);
        boolean isSelfPreservationModeEnabled = isSelfPreservationModeEnabled();
        if ((!leaseExpirationEnabled)) {
            if (!isSelfPreservationModeEnabled) {
                logger.warn("The self preservation mode is disabled!. Hence allowing the instances to expire.");
                leaseExpirationEnabled = true;
            }
        }
        return leaseExpirationEnabled;
    }

    /**
     * Checks to see if the self-preservation mode is enabled.
     *
     * <p>
     * The self-preservation mode is enabled if the expected number of renewals
     * per minute {@link #getNumOfRenewsInLastMin()} is lesser than the expected
     * threshold which is determined by {@link #getNumOfRenewsPerMinThreshold()}
     * . Eureka perceives this as a danger and stops expiring instances as this
     * is most likely because of a network event. The mode is disabled only when
     * the renewals get back to above the threshold or if the flag
     * {@link EurekaServerConfig#shouldEnableSelfPreservation()} is set to
     * false.
     * </p>
     *
     * @return true if the self-preservation mode is enabled, false otherwise.
     */
    public boolean isSelfPreservationModeEnabled() {
        return EUREKA_SERVER_CONFIG.shouldEnableSelfPreservation();
    }

    /**
     * Perform all cleanup and shutdown operations.
     */
    void shutdown() {
        try {
            DefaultMonitorRegistry.getInstance().unregister(
                    Monitors.newObjectMonitor(this));
        } catch (Throwable t) {
            logger.error("Cannot shutdown monitor registry", t);
        }
        try {
            for (PeerEurekaNode node : this.peerEurekaNodes.getPeerEurekaNodes()) {
                node.shutDown();
            }
        } catch (Throwable t) {
            logger.error("Cannot shutdown ReplicaAwareInstanceRegistry", t);
        }
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String virtualHostname,
                                                boolean secure) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Updates the <em>renewal threshold</em> based on the current number of
     * renewals. The threshold is a percentage as specified in
     * {@link EurekaServerConfig#getRenewalPercentThreshold()} of renewals
     * received per minute {@link #getNumOfRenewsInLastMin()}.
     */
    private void updateRenewalThreshold() {
        try {
            LookupService lookupService = DiscoveryManager.getInstance()
                    .getLookupService();
            Applications apps = lookupService.getApplications();
            int count = 0;
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    if (this.isRegisterable(instance)) {
                        ++count;
                    }
                }
            }
            synchronized (lock) {
                // Update threshold only if the threshold is greater than the
                // current expected threshold of if the self preservation is disabled.
                if ((count * 2) > (EUREKA_SERVER_CONFIG
                        .getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
                        || (!this.isSelfPreservationModeEnabled())) {
                    this.expectedNumberOfRenewsPerMin = count * 2;
                    this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            logger.info("Current renewal threshold is : {}",
                    numberOfRenewsPerMinThreshold);
        } catch (Throwable e) {
            logger.error("Cannot update renewal threshold", e);
        }
    }

    /**
     * Gets the list of all {@link Applications} from the registry in sorted
     * lexical order of {@link Application#getName()}.
     *
     * @return the list of {@link Applications} in lexical order.
     */
    public List<Application> getSortedApplications() {
        List<Application> apps = new ArrayList<Application>(getApplications()
                .getRegisteredApplications());
        Collections.sort(apps, APP_COMPARATOR);
        return apps;
    }

    /**
     * Gets the number of <em>renewals</em> in the last minute.
     *
     * @return a long value representing the number of <em>renewals</em> in the
     *         last minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfReplicationsInLastMin",
            description = "Number of total replications received in the last minute",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public long getNumOfReplicationsInLastMin() {
        return numberOfReplicationsLastMin.getCount();
    }

    /**
     * Checks if the number of renewals is lesser than threshold.
     *
     * @return 0 if the renewals are greater than threshold, 1 otherwise.
     */
    @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public int isBelowRenewThresold() {
        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Gets the threshold for the renewals per minute.
     *
     * @return the integer representing the threshold for the renewals per
     *         minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsPerMinThreshold", type = DataSourceType.GAUGE)
    public int getNumOfRenewsPerMinThreshold() {
        return numberOfRenewsPerMinThreshold;
    }


    /**
     * Checks if an instance is registerable in this region. Instances from
     * other regions are rejected.
     *
     * @param instanceInfo
     *            - the instance info information of the instance
     * @return - true, if it can be registered in this server, false otherwise.
     */
    public boolean isRegisterable(InstanceInfo instanceInfo) {
        DataCenterInfo datacenterInfo = instanceInfo.getDataCenterInfo();
        String serverRegion = EUREKA_CLIENT_CONFIG.getRegion();
        if (AmazonInfo.class.isInstance(datacenterInfo)) {
            AmazonInfo info = AmazonInfo.class.cast(instanceInfo
                    .getDataCenterInfo());
            String availabilityZone = info.get(MetaDataKey.availabilityZone);
            // Can be null for dev environments in non-AWS data center
            if (availabilityZone == null
                    && US_EAST_1.equalsIgnoreCase(serverRegion)) {
                return true;
            } else if ((availabilityZone != null)
                    && (availabilityZone.contains(serverRegion))) {
                // If in the same region as server, then consider it
                // registerable
                return true;
            }
        }
        return true; // Everything non-amazon is registrable.
    }

    /**
     * Replicates all eureka actions to peer eureka nodes except for replication
     * traffic to this node.
     *
     */
    private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {

            if (isReplication) {
                numberOfReplicationsLastMin.increment();
            }
            // If it is a replication already, do not replicate again as this
            // will create a poison replication
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                // If the url represents this host, do not replicate
                // to yourself.
                if (isThisMe(node.getServiceUrl())) {
                    continue;
                }
                replicateInstanceActionsToPeers(action, appName, id, info,
                        newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }

    /**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                            .get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                            false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error(
                    "Cannot replicate information to " + node.getServiceUrl()
                            + " for action " + action.name(), t);
        }
    }

    /**
     * Replicates all ASG status changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateASGInfoToReplicaNodes(final String asgName,
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
        CurrentRequestVersion.set(Version.V2);
        try {
            node.statusUpdate(asgName, newStatus);

        } catch (Throwable e) {
            logger.error(
                    "Cannot replicate ASG status information to "
                            + node.getServiceUrl(), e);
        }
    }

    @Override
    @com.netflix.servo.annotations.Monitor(name = "localRegistrySize",
            description = "Current registry size", type = DataSourceType.GAUGE)
    public long getLocalRegistrySize() {
        return super.getLocalRegistrySize();
    }
}=======
/*
 * Copyright 2012 Netflix, Inc.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *        http://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */

package com.netflix.eureka;

import java.net.URI;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import com.netflix.appinfo.AmazonInfo;
import com.netflix.appinfo.AmazonInfo.MetaDataKey;
import com.netflix.appinfo.ApplicationInfoManager;
import com.netflix.appinfo.DataCenterInfo;
import com.netflix.appinfo.DataCenterInfo.Name;
import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.appinfo.LeaseInfo;
import com.netflix.discovery.DiscoveryManager;
import com.netflix.discovery.EurekaClientConfig;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.LookupService;
import com.netflix.eureka.cluster.PeerEurekaNode;
import com.netflix.eureka.cluster.PeerEurekaNodes;
import com.netflix.eureka.lease.Lease;
import com.netflix.eureka.resources.ASGResource.ASGStatus;
import com.netflix.eureka.util.MeasuredRate;
import com.netflix.servo.DefaultMonitorRegistry;
import com.netflix.servo.annotations.DataSourceType;
import com.netflix.servo.monitor.Monitors;
import com.netflix.servo.monitor.Stopwatch;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static com.netflix.eureka.cluster.PeerEurekaNodes.isThisMe;

/**
 * Handles replication of all operations to {@link AbstractInstanceRegistry} to peer
 * <em>Eureka</em> nodes to keep them all in sync.
 *
 * <p>
 * Primary operations that are replicated are the
 * <em>Registers,Renewals,Cancels,Expirations and Status Changes</em>
 * </p>
 *
 * <p>
 * When the eureka server starts up it tries to fetch all the registry
 * information from the peer eureka nodes.If for some reason this operation
 * fails, the server does not allow the user to get the registry information for
 * a period specified in
 * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}.
 * </p>
 *
 * <p>
 * One important thing to note about <em>renewals</em>.If the renewal drops more
 * than the specified threshold as specified in
 * {@link EurekaServerConfig#getRenewalPercentThreshold()} within a period of
 * {@link EurekaServerConfig#getRenewalThresholdUpdateIntervalMs()}, eureka
 * perceives this as a danger and stops expiring instances.
 * </p>
 *
 * @author Karthik Ranganathan, Greg Kim
 *
 */
public class PeerAwareInstanceRegistryImpl extends AbstractInstanceRegistry implements PeerAwareInstanceRegistry {
    private static final String US_EAST_1 = "us-east-1";

    private static final int PRIME_PEER_NODES_RETRY_MS = 30000;

    private static final int REGISTRY_SYNC_RETRY_MS = 30000;

    private static final Logger logger = LoggerFactory.getLogger(PeerAwareInstanceRegistryImpl.class);

    private static final EurekaServerConfig EUREKA_SERVER_CONFIG = EurekaServerConfigurationManager
            .getInstance().getConfiguration();
    private static final EurekaClientConfig EUREKA_CLIENT_CONFIG = DiscoveryManager
            .getInstance().getEurekaClientConfig();

    private long startupTime = 0;
    private boolean peerInstancesTransferEmptyOnStartup = true;

    public enum Action {
        Heartbeat, Register, Cancel, StatusUpdate, DeleteStatusOverride;

        private com.netflix.servo.monitor.Timer timer = Monitors.newTimer(this.name());

        public com.netflix.servo.monitor.Timer getTimer() {
            return this.timer;
        }

    }

    private static final Comparator<Application> APP_COMPARATOR = new Comparator<Application>() {
        public int compare(Application l, Application r) {
            return l.getName().compareTo(r.getName());
        }
    };

    private final MeasuredRate numberOfReplicationsLastMin = new MeasuredRate(1000 * 60 * 1);


    private final PeerEurekaNodes peerEurekaNodes;

    private Timer timer = new Timer(
            "ReplicaAwareInstanceRegistry - RenewalThresholdUpdater", true);

    private static final PeerAwareInstanceRegistryImpl instance = new PeerAwareInstanceRegistryImpl();

    PeerAwareInstanceRegistryImpl() {
        this.peerEurekaNodes = new PeerEurekaNodes(this, EUREKA_SERVER_CONFIG);

        try {
            Monitors.registerObject(this);
        } catch (Throwable e) {
            logger.warn(
                    "Cannot register the JMX monitor for the InstanceRegistry :",
                    e);
        }
        init();
    }

    public static PeerAwareInstanceRegistryImpl getInstance() {
        return instance;
    }

    /**
     * Set up replica nodes and the task that updates the threshold
     * periodically.
     */
    private void init() {
        peerEurekaNodes.start();
        scheduleRenewalThresholdUpdateTask();
    }

    /**
     * Schedule the task that updates <em>renewal threshold</em> periodically.
     * The renewal threshold would be used to determine if the renewals drop
     * dramatically because of network partition and to protect expiring too
     * many instances at a time.
     *
     */
    private void scheduleRenewalThresholdUpdateTask() {
        timer.schedule(new TimerTask() {

                           @Override
                           public void run() {
                               updateRenewalThreshold();

                           }

                       }, EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs(),
                EUREKA_SERVER_CONFIG.getRenewalThresholdUpdateIntervalMs());
    }

    /**
     * Populates the registry information from a peer eureka node. This
     * operation fails over to other nodes until the list is exhausted if the
     * communication fails.
     */
    public int syncUp() {
        // Copy entire entry from neighboring DS node
        LookupService lookupService = DiscoveryManager.getInstance()
                .getLookupService();
        int count = 0;

        for (int i = 0; ((i < EUREKA_SERVER_CONFIG.getRegistrySyncRetries()) && (count == 0)); i++) {
            Applications apps = lookupService.getApplications();
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    try {
                        if (isRegisterable(instance)) {

                            register(instance, instance.getLeaseInfo()
                                    .getDurationInSecs(), true);
                            count++;
                        }
                    } catch (Throwable t) {
                        logger.error("During DS init copy", t);
                    }
                }
            }
            if (count == 0) {
                try {
                    Thread.sleep(REGISTRY_SYNC_RETRY_MS);
                } catch (InterruptedException e) {
                    logger.warn("Interrupted during registry transfer..");
                    break;
                }
            }
        }
        return count;
    }

    public void openForTraffic(int count) {
        // Renewals happen every 30 seconds and for a minute it should be a
        // factor of 2.
        this.expectedNumberOfRenewsPerMin = count * 2;
        this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                .getRenewalPercentThreshold());
        logger.info("Got " + count + " instances from neighboring DS node");
        logger.info("Renew threshold is: " + numberOfRenewsPerMinThreshold);
        this.startupTime = System.currentTimeMillis();
        if (count > 0) {
            this.peerInstancesTransferEmptyOnStartup = false;
        }
        boolean isAws = (Name.Amazon.equals(ApplicationInfoManager
                .getInstance().getInfo().getDataCenterInfo().getName()));
        if (isAws && EUREKA_SERVER_CONFIG.shouldPrimeAwsReplicaConnections()) {
            logger.info("Priming AWS connections for all replicas..");
            primeAwsReplicas();
        }
        logger.info("Changing status to UP");
        ApplicationInfoManager.getInstance().setInstanceStatus(
                InstanceStatus.UP);
        super.postInit();
    }

    /**
     * Prime connections for Aws replicas.
     * <p>
     * Sometimes when the eureka servers comes up, AWS firewall may not allow
     * the network connections immediately. This will cause the outbound
     * connections to fail, but the inbound connections continue to work. What
     * this means is the clients would have switched to this node (after EIP
     * binding) and so the other eureka nodes will expire all instances that
     * have been switched because of the lack of outgoing heartbeats from this
     * instance.
     * </p>
     * <p>
     * The best protection in this scenario is to block and wait until we are
     * able to ping all eureka nodes successfully atleast once. Until then we
     * won't open up the traffic.
     * </p>
     */
    private void primeAwsReplicas() {
        boolean areAllPeerNodesPrimed = false;
        while (!areAllPeerNodesPrimed) {
            String peerHostName = null;
            try {
                Application eurekaApps = this.getApplication(
                        ApplicationInfoManager.getInstance().getInfo()
                                .getAppName(), false);
                if (eurekaApps == null) {
                    areAllPeerNodesPrimed = true;
                }
                for (PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                    for (InstanceInfo peerInstanceInfo : eurekaApps
                            .getInstances()) {
                        LeaseInfo leaseInfo = peerInstanceInfo.getLeaseInfo();
                        // If the lease is expired - do not worry about priming
                        if (System.currentTimeMillis() > (leaseInfo
                                .getRenewalTimestamp() + (leaseInfo
                                .getDurationInSecs() * 1000))
                                + (2 * 60 * 1000)) {
                            continue;
                        }
                        peerHostName = peerInstanceInfo.getHostName();
                        logger.info(
                                "Trying to send heartbeat for the eureka server at {} to make sure the network "
                                        + "channels are open", peerHostName);
                        // Only try to contact the eureka nodes that are in this
                        // instance's registry - because
                        // the other instances may be legitimately down
                        if (peerHostName.equalsIgnoreCase(new URI(node
                                .getServiceUrl()).getHost())) {
                            node.heartbeat(peerInstanceInfo.getAppName(),
                                    peerInstanceInfo.getId(), peerInstanceInfo,
                                    null, true);
                        }
                    }
                }
                areAllPeerNodesPrimed = true;
            } catch (Throwable e) {
                logger.error("Could not contact " + peerHostName, e);
                try {
                    Thread.sleep(PRIME_PEER_NODES_RETRY_MS);
                } catch (InterruptedException e1) {
                    logger.warn("Interrupted while priming : ", e1);
                    areAllPeerNodesPrimed = true;
                }
            }
        }
    }

    /**
     * Checks to see if the registry access is allowed or the server is in a
     * situation where it does not all getting registry information. The server
     * does not return registry information for a period specified in
     * {@link EurekaServerConfig#getWaitTimeInMsWhenSyncEmpty()}, if it cannot
     * get the registry information from the peer eureka nodes at start up.
     *
     * @return false - if the instances count from a replica transfer returned
     *         zero and if the wait time has not elapsed, o otherwise returns
     *         true
     */
    public boolean shouldAllowAccess(boolean remoteRegionRequired) {
        if (this.peerInstancesTransferEmptyOnStartup) {
            if (!(System.currentTimeMillis() > this.startupTime
                    + EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())) {
                return false;
            }
        }
        if (remoteRegionRequired) {
            for (RemoteRegionRegistry remoteRegionRegistry : this.regionNameVSRemoteRegistry.values()) {
                if (!remoteRegionRegistry.isReadyForServingData()) {
                    return false;
                }
            }
        }
        return true;
    }

    public boolean shouldAllowAccess() {
        return shouldAllowAccess(true);
    }

    /**
     * Gets the list of peer eureka nodes which is the list to replicate
     * information to.
     *
     * @return the list of replica nodes.
     */
    public List<PeerEurekaNode> getReplicaNodes() {
        return Collections.unmodifiableList(peerEurekaNodes.getPeerEurekaNodes());
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#cancel(java.lang.String,
     * java.lang.String, long, boolean)
     */
    @Override
    public boolean cancel(final String appName, final String id,
                          final boolean isReplication) {
        if (super.cancel(appName, id, isReplication)) {
            replicateToPeers(Action.Cancel, appName, id, null, null,
                    isReplication);
            synchronized (lock) {
                if (this.expectedNumberOfRenewsPerMin > 0) {
                    // Since the client wants to cancel it, reduce the threshold
                    // (1
                    // for 30 seconds, 2 for a minute)
                    this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin - 2;
                    this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Registers the information about the {@link InstanceInfo} and replicates
     * this information to all peer eureka nodes. If this is replication event
     * from other replica nodes then it is not replicated.
     *
     * @param info
     *            the {@link InstanceInfo} to be registered and replicated.
     * @param isReplication
     *            true if this is a replication event from other replica nodes,
     *            false otherwise.
     */
    @Override
    public void register(final InstanceInfo info, final boolean isReplication) {
        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
        if (info.getLeaseInfo() != null
                && info.getLeaseInfo().getDurationInSecs() > 0) {
            leaseDuration = info.getLeaseInfo().getDurationInSecs();
        }
        super.register(info, leaseDuration, isReplication);
        replicateToPeers(Action.Register, info.getAppName(), info.getId(),
                info, null, isReplication);
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#renew(java.lang.String,
     * java.lang.String, long, boolean)
     */
    public boolean renew(final String appName, final String id,
                         final boolean isReplication) {
        if (super.renew(appName, id, isReplication)) {
            replicateToPeers(Action.Heartbeat, appName, id, null, null,
                    isReplication);
            return true;
        }
        return false;
    }

    /*
     * (non-Javadoc)
     *
     * @see com.netflix.eureka.InstanceRegistry#statusUpdate(java.lang.String,
     * java.lang.String, com.netflix.appinfo.InstanceInfo.InstanceStatus,
     * java.lang.String, boolean)
     */
    public boolean statusUpdate(final String appName, final String id,
                                final InstanceStatus newStatus, String lastDirtyTimestamp,
                                final boolean isReplication) {
        if (super.statusUpdate(appName, id, newStatus, lastDirtyTimestamp,
                isReplication)) {
            replicateToPeers(Action.StatusUpdate, appName, id, null, newStatus,
                    isReplication);
            return true;
        }
        return false;
    }

    @Override
    public boolean deleteStatusOverride(String appName, String id,
                                        InstanceStatus newStatus,
                                        String lastDirtyTimestamp,
                                        boolean isReplication) {
        if (super.deleteStatusOverride(appName, id, newStatus, lastDirtyTimestamp, isReplication)) {
            replicateToPeers(Action.DeleteStatusOverride, appName, id, null, null, isReplication);
            return true;
        }
        return false;
    }

    /**
     * Replicate the <em>ASG status</em> updates to peer eureka nodes. If this
     * event is a replication from other nodes, then it is not replicated to
     * other nodes.
     *
     * @param asgName
     *            the asg name for which the status needs to be replicated.
     * @param newStatus
     *            the {@link ASGStatus} information that needs to be replicated.
     * @param isReplication
     *            true if this is a replication event from other nodes, false
     *            otherwise.
     */
    public void statusUpdate(final String asgName, final ASGStatus newStatus,
                             final boolean isReplication) {
        // If this is replicated from an other node, do not try to replicate
        // again.
        if (isReplication) {
            return;
        }
        for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
            replicateASGInfoToReplicaNodes(asgName, newStatus, node);

        }
    }

    @Override
    public boolean isLeaseExpirationEnabled() {
        if (!isSelfPreservationModeEnabled()) {
            // The self preservation mode is disabled, hence allowing the instances to expire.
            return true;
        }
        return numberOfRenewsPerMinThreshold > 0 && getNumOfRenewsInLastMin() > numberOfRenewsPerMinThreshold;
    }

    /**
     * Checks to see if the self-preservation mode is enabled.
     *
     * <p>
     * The self-preservation mode is enabled if the expected number of renewals
     * per minute {@link #getNumOfRenewsInLastMin()} is lesser than the expected
     * threshold which is determined by {@link #getNumOfRenewsPerMinThreshold()}
     * . Eureka perceives this as a danger and stops expiring instances as this
     * is most likely because of a network event. The mode is disabled only when
     * the renewals get back to above the threshold or if the flag
     * {@link EurekaServerConfig#shouldEnableSelfPreservation()} is set to
     * false.
     * </p>
     *
     * @return true if the self-preservation mode is enabled, false otherwise.
     */
    public boolean isSelfPreservationModeEnabled() {
        return EUREKA_SERVER_CONFIG.shouldEnableSelfPreservation();
    }

    /**
     * Perform all cleanup and shutdown operations.
     */
    void shutdown() {
        try {
            DefaultMonitorRegistry.getInstance().unregister(
                    Monitors.newObjectMonitor(this));
        } catch (Throwable t) {
            logger.error("Cannot shutdown monitor registry", t);
        }
        try {
            for (PeerEurekaNode node : this.peerEurekaNodes.getPeerEurekaNodes()) {
                node.shutDown();
            }
        } catch (Throwable t) {
            logger.error("Cannot shutdown ReplicaAwareInstanceRegistry", t);
        }
    }

    @Override
    public InstanceInfo getNextServerFromEureka(String virtualHostname,
                                                boolean secure) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Updates the <em>renewal threshold</em> based on the current number of
     * renewals. The threshold is a percentage as specified in
     * {@link EurekaServerConfig#getRenewalPercentThreshold()} of renewals
     * received per minute {@link #getNumOfRenewsInLastMin()}.
     */
    private void updateRenewalThreshold() {
        try {
            LookupService lookupService = DiscoveryManager.getInstance()
                    .getLookupService();
            Applications apps = lookupService.getApplications();
            int count = 0;
            for (Application app : apps.getRegisteredApplications()) {
                for (InstanceInfo instance : app.getInstances()) {
                    if (this.isRegisterable(instance)) {
                        ++count;
                    }
                }
            }
            synchronized (lock) {
                // Update threshold only if the threshold is greater than the
                // current expected threshold of if the self preservation is disabled.
                if ((count * 2) > (EUREKA_SERVER_CONFIG
                        .getRenewalPercentThreshold() * numberOfRenewsPerMinThreshold)
                        || (!this.isSelfPreservationModeEnabled())) {
                    this.expectedNumberOfRenewsPerMin = count * 2;
                    this.numberOfRenewsPerMinThreshold = (int) ((count * 2) * EUREKA_SERVER_CONFIG
                            .getRenewalPercentThreshold());
                }
            }
            logger.info("Current renewal threshold is : {}",
                    numberOfRenewsPerMinThreshold);
        } catch (Throwable e) {
            logger.error("Cannot update renewal threshold", e);
        }
    }

    /**
     * Gets the list of all {@link Applications} from the registry in sorted
     * lexical order of {@link Application#getName()}.
     *
     * @return the list of {@link Applications} in lexical order.
     */
    public List<Application> getSortedApplications() {
        List<Application> apps = new ArrayList<Application>(getApplications()
                .getRegisteredApplications());
        Collections.sort(apps, APP_COMPARATOR);
        return apps;
    }

    /**
     * Gets the number of <em>renewals</em> in the last minute.
     *
     * @return a long value representing the number of <em>renewals</em> in the
     *         last minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfReplicationsInLastMin",
            description = "Number of total replications received in the last minute",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public long getNumOfReplicationsInLastMin() {
        return numberOfReplicationsLastMin.getCount();
    }

    /**
     * Checks if the number of renewals is lesser than threshold.
     *
     * @return 0 if the renewals are greater than threshold, 1 otherwise.
     */
    @com.netflix.servo.annotations.Monitor(name = "isBelowRenewThreshold", description = "0 = false, 1 = true",
            type = com.netflix.servo.annotations.DataSourceType.GAUGE)
    public int isBelowRenewThresold() {
        if ((getNumOfRenewsInLastMin() <= numberOfRenewsPerMinThreshold)
                && ((this.startupTime > 0) && (System.currentTimeMillis() > this.startupTime
                + (EUREKA_SERVER_CONFIG.getWaitTimeInMsWhenSyncEmpty())))) {
            return 1;
        } else {
            return 0;
        }
    }

    /**
     * Gets the threshold for the renewals per minute.
     *
     * @return the integer representing the threshold for the renewals per
     *         minute.
     */
    @com.netflix.servo.annotations.Monitor(name = "numOfRenewsPerMinThreshold", type = DataSourceType.GAUGE)
    public int getNumOfRenewsPerMinThreshold() {
        return numberOfRenewsPerMinThreshold;
    }


    /**
     * Checks if an instance is registerable in this region. Instances from
     * other regions are rejected.
     *
     * @param instanceInfo
     *            - the instance info information of the instance
     * @return - true, if it can be registered in this server, false otherwise.
     */
    public boolean isRegisterable(InstanceInfo instanceInfo) {
        DataCenterInfo datacenterInfo = instanceInfo.getDataCenterInfo();
        String serverRegion = EUREKA_CLIENT_CONFIG.getRegion();
        if (AmazonInfo.class.isInstance(datacenterInfo)) {
            AmazonInfo info = AmazonInfo.class.cast(instanceInfo
                    .getDataCenterInfo());
            String availabilityZone = info.get(MetaDataKey.availabilityZone);
            // Can be null for dev environments in non-AWS data center
            if (availabilityZone == null
                    && US_EAST_1.equalsIgnoreCase(serverRegion)) {
                return true;
            } else if ((availabilityZone != null)
                    && (availabilityZone.contains(serverRegion))) {
                // If in the same region as server, then consider it
                // registerable
                return true;
            }
        }
        return true; // Everything non-amazon is registrable.
    }

    /**
     * Replicates all eureka actions to peer eureka nodes except for replication
     * traffic to this node.
     *
     */
    private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
        Stopwatch tracer = action.getTimer().start();
        try {

            if (isReplication) {
                numberOfReplicationsLastMin.increment();
            }
            // If it is a replication already, do not replicate again as this
            // will create a poison replication
            if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
                return;
            }

            for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
                // If the url represents this host, do not replicate
                // to yourself.
                if (isThisMe(node.getServiceUrl())) {
                    continue;
                }
                replicateInstanceActionsToPeers(action, appName, id, info,
                        newStatus, node);
            }
        } finally {
            tracer.stop();
        }
    }

    /**
     * Replicates all instance changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
        try {
            InstanceInfo infoFromRegistry = null;
            CurrentRequestVersion.set(Version.V2);
            switch (action) {
                case Cancel:
                    node.cancel(appName, id);
                    break;
                case Heartbeat:
                    InstanceStatus overriddenStatus = overriddenInstanceStatusMap
                            .get(id);
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.heartbeat(appName, id, infoFromRegistry, overriddenStatus,
                            false);
                    break;
                case Register:
                    node.register(info);
                    break;
                case StatusUpdate:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                    break;
                case DeleteStatusOverride:
                    infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                    node.deleteStatusOverride(appName, id, infoFromRegistry);
                    break;
            }
        } catch (Throwable t) {
            logger.error(
                    "Cannot replicate information to " + node.getServiceUrl()
                            + " for action " + action.name(), t);
        }
    }

    /**
     * Replicates all ASG status changes to peer eureka nodes except for
     * replication traffic to this node.
     *
     */
    private void replicateASGInfoToReplicaNodes(final String asgName,
                                                final ASGStatus newStatus, final PeerEurekaNode node) {
        CurrentRequestVersion.set(Version.V2);
        try {
            node.statusUpdate(asgName, newStatus);

        } catch (Throwable e) {
            logger.error(
                    "Cannot replicate ASG status information to "
                            + node.getServiceUrl(), e);
        }
    }

    @Override
    @com.netflix.servo.annotations.Monitor(name = "localRegistrySize",
            description = "Current registry size", type = DataSourceType.GAUGE)
    public long getLocalRegistrySize() {
        return super.getLocalRegistrySize();
    }
}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE

    @Override
    public int getRoute53BindRebindRetries() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetries", 3).get();

    }

    @Override
    public int getRoute53BindingRetryIntervalMs() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetryIntervalMs", (5 * 60 * 1000))
                .get();
    }

    @Override
    public long getRoute53DomainTTL() {
        return configInstance.getLongProperty(
                namespace + "route53DomainTTL", 30l)
                .get();
    }

    @Override
    public AwsBindingStrategy getBindingStrategy() {
        return AwsBindingStrategy.valueOf(configInstance.getStringProperty(namespace + "awsBindingStrategy", AwsBindingStrategy.EIP.name()).get().toUpperCase());
    }
||||||| BASE
=======

    @Override
    public String getExperimental(String name) {
        return configInstance.getStringProperty(namespace + "experimental." + name, null).get();
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_7c47165_264020a/rev_7c47165-264020a/eureka-core/src/test/java/com/netflix/eureka/InstanceRegistryTest.java;<<<<<<< MINE
||||||| BASE
package com.netflix.eureka;

import java.util.List;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.Pair;
import org.junit.Assert;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.junit.Assert.assertThat;

/**
 * @author Nitesh Kant
 */
public class InstanceRegistryTest extends AbstractTester {

    @Test
    public void testSoftDepRemoteUp() throws Exception {
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(false));
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(true));
    }

    @Test
    public void testGetAppsFromAllRemoteRegions() throws Exception {
        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from remote registry", REMOTE_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsDeltaFromAllRemoteRegions() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME)); /// local delta
        waitForDeltaToBeRetrieved();
        Applications appDelta = registry.getApplicationDeltasFromMultipleRegions(null);
        List<Application> registeredApplications = appDelta.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 2, registeredApplications.size());
        Application localApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                localApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app in delta.", localApplication);
        Assert.assertEquals("Local registry app instance count in delta not as expected.", 1,
                localApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app in delta", remApplication);
        Assert.assertEquals("Remote registry app instance count  in delta not as expected.", 1,
                remApplication.getInstances().size());
    }

    @Test
    public void testAppsHashCodeAfterRefresh() throws InterruptedException {
        Assert.assertEquals("UP_1_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());

        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        waitForDeltaToBeRetrieved();

        Assert.assertEquals("UP_2_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());
    }

    private void waitForDeltaToBeRetrieved() throws InterruptedException {
        int count = 0;
        System.out.println("Sleeping up to 35 seconds to let the remote registry fetch delta.");
        while (count++ < 35 && !mockRemoteEurekaServer.isSentDelta()) {
            Thread.sleep(1000);
        }
        if (!mockRemoteEurekaServer.isSentDelta()) {
            System.out.println("Waited for 35 seconds but remote server did not send delta");
        }
        // Wait 2 seconds more to be sure the delta was processed
        Thread.sleep(2000);
    }

    @Test
    public void testGetAppsFromLocalRegionOnly() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromLocalRegionOnly();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from local region do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from local registry", LOCAL_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsFromBothRegions() throws Exception {
        registerInstanceLocally(createRemoteInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from both regions do not match", 2, registeredApplications.size());
        Application locaApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                locaApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app", locaApplication);
        Assert.assertEquals("Local registry app instance count not as expected.", 1,
                locaApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app", remApplication);
        Assert.assertEquals("Remote registry app instance count not as expected.", 2,
                remApplication.getInstances().size());

    }

    @Test
    public void testStatusOverrideSetAndRemoval() throws Exception {
        // Regular registration first
        InstanceInfo myInstance = createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME);
        registerInstanceLocally(myInstance);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);

        // Override status
        boolean statusResult = registry.statusUpdate(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.OUT_OF_SERVICE, "0", false);
        assertThat("Couldn't override instance status", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Now remove override
        statusResult = registry.deleteStatusOverride(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.DOWN, "0", false);
        assertThat("Couldn't remove status override", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.DOWN);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);
    }

    private void verifyLocalInstanceStatus(String id, InstanceStatus status) {
        InstanceInfo instanceInfo = registry.getApplication(LOCAL_REGION_APP_NAME).getByInstanceId(id);
        assertThat("InstanceInfo with id " + id + " not found", instanceInfo, is(notNullValue()));
        assertThat("Invalid InstanceInfo state", instanceInfo.getStatus(), is(equalTo(status)));
    }

    private void registerInstanceLocally(InstanceInfo remoteInstance) {
        registry.register(remoteInstance, 10000000, false);
        registeredApps.add(new Pair<String, String>(LOCAL_REGION_APP_NAME, LOCAL_REGION_APP_NAME));
    }

}=======
package com.netflix.eureka;

import java.util.List;

import com.netflix.appinfo.InstanceInfo;
import com.netflix.appinfo.InstanceInfo.InstanceStatus;
import com.netflix.discovery.shared.Application;
import com.netflix.discovery.shared.Applications;
import com.netflix.discovery.shared.Pair;
import org.junit.Assert;
import org.junit.Test;

import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.junit.Assert.assertThat;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.spy;
import static org.mockito.Mockito.when;

/**
 * @author Nitesh Kant
 */
public class InstanceRegistryTest extends AbstractTester {

    @Test
    public void testSoftDepRemoteUp() throws Exception {
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(false));
        Assert.assertTrue("Registry access disallowed when remote region is UP.", registry.shouldAllowAccess(true));
    }

    @Test
    public void testGetAppsFromAllRemoteRegions() throws Exception {
        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from remote registry", REMOTE_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsDeltaFromAllRemoteRegions() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME)); /// local delta
        waitForDeltaToBeRetrieved();
        Applications appDelta = registry.getApplicationDeltasFromMultipleRegions(null);
        List<Application> registeredApplications = appDelta.getRegisteredApplications();
        Assert.assertEquals("Apps size from remote regions do not match", 2, registeredApplications.size());
        Application localApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                localApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app in delta.", localApplication);
        Assert.assertEquals("Local registry app instance count in delta not as expected.", 1,
                localApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app in delta", remApplication);
        Assert.assertEquals("Remote registry app instance count  in delta not as expected.", 1,
                remApplication.getInstances().size());
    }

    @Test
    public void testAppsHashCodeAfterRefresh() throws InterruptedException {
        Assert.assertEquals("UP_1_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());

        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        waitForDeltaToBeRetrieved();

        Assert.assertEquals("UP_2_", registry.getApplicationsFromAllRemoteRegions().getAppsHashCode());
    }

    private void waitForDeltaToBeRetrieved() throws InterruptedException {
        int count = 0;
        System.out.println("Sleeping up to 35 seconds to let the remote registry fetch delta.");
        while (count++ < 35 && !mockRemoteEurekaServer.isSentDelta()) {
            Thread.sleep(1000);
        }
        if (!mockRemoteEurekaServer.isSentDelta()) {
            System.out.println("Waited for 35 seconds but remote server did not send delta");
        }
        // Wait 2 seconds more to be sure the delta was processed
        Thread.sleep(2000);
    }

    @Test
    public void testGetAppsFromLocalRegionOnly() throws Exception {
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromLocalRegionOnly();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from local region do not match", 1, registeredApplications.size());
        Application app = registeredApplications.iterator().next();
        Assert.assertEquals("Added app did not return from local registry", LOCAL_REGION_APP_NAME, app.getName());
        Assert.assertEquals("Returned app did not have the instance", 1, app.getInstances().size());
    }

    @Test
    public void testGetAppsFromBothRegions() throws Exception {
        registerInstanceLocally(createRemoteInstance(LOCAL_REGION_INSTANCE_2_HOSTNAME));
        registerInstanceLocally(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME));

        Applications apps = registry.getApplicationsFromAllRemoteRegions();
        List<Application> registeredApplications = apps.getRegisteredApplications();
        Assert.assertEquals("Apps size from both regions do not match", 2, registeredApplications.size());
        Application locaApplication = null;
        Application remApplication = null;
        for (Application registeredApplication : registeredApplications) {
            if (registeredApplication.getName().equalsIgnoreCase(LOCAL_REGION_APP_NAME)) {
                locaApplication = registeredApplication;
            }
            if (registeredApplication.getName().equalsIgnoreCase(REMOTE_REGION_APP_NAME)) {
                remApplication = registeredApplication;
            }
        }
        Assert.assertNotNull("Did not find local registry app", locaApplication);
        Assert.assertEquals("Local registry app instance count not as expected.", 1,
                locaApplication.getInstances().size());
        Assert.assertNotNull("Did not find remote registry app", remApplication);
        Assert.assertEquals("Remote registry app instance count not as expected.", 2,
                remApplication.getInstances().size());

    }

    @Test
    public void testStatusOverrideSetAndRemoval() throws Exception {
        // Regular registration first
        InstanceInfo myInstance = createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME);
        registerInstanceLocally(myInstance);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);

        // Override status
        boolean statusResult = registry.statusUpdate(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.OUT_OF_SERVICE, "0", false);
        assertThat("Couldn't override instance status", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.OUT_OF_SERVICE);

        // Now remove override
        statusResult = registry.deleteStatusOverride(LOCAL_REGION_APP_NAME, myInstance.getId(), InstanceStatus.DOWN, "0", false);
        assertThat("Couldn't remove status override", statusResult, is(true));
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.DOWN);

        // Register again with status UP (this is what health check is doing)
        registry.register(createLocalInstance(LOCAL_REGION_INSTANCE_1_HOSTNAME), 10000000, false);
        verifyLocalInstanceStatus(myInstance.getId(), InstanceStatus.UP);
    }

    @Test
    public void testEvictionTaskCompensationTime() throws Exception {
        long evictionTaskPeriodNanos = EurekaServerConfigurationManager.getInstance().getConfiguration()
                .getEvictionIntervalTimerInMs() * 1000000;

        AbstractInstanceRegistry.EvictionTask testTask = spy(registry.new EvictionTask());

        when(testTask.getCurrentTimeNano())
                .thenReturn(1l)  // less than the period
                .thenReturn(1l + evictionTaskPeriodNanos)  // exactly 1 period
                .thenReturn(1l + evictionTaskPeriodNanos*2 + 10000000l)  // 10ms longer than 1 period
                .thenReturn(1l + evictionTaskPeriodNanos*3 - 1l);  // less than 1 period

        assertThat(testTask.getCompensationTimeMs(), is(0l));
        assertThat(testTask.getCompensationTimeMs(), is(0l));
        assertThat(testTask.getCompensationTimeMs(), is(10l));
        assertThat(testTask.getCompensationTimeMs(), is(0l));
    }

    private void verifyLocalInstanceStatus(String id, InstanceStatus status) {
        InstanceInfo instanceInfo = registry.getApplication(LOCAL_REGION_APP_NAME).getByInstanceId(id);
        assertThat("InstanceInfo with id " + id + " not found", instanceInfo, is(notNullValue()));
        assertThat("Invalid InstanceInfo state", instanceInfo.getStatus(), is(equalTo(status)));
    }

    private void registerInstanceLocally(InstanceInfo remoteInstance) {
        registry.register(remoteInstance, 10000000, false);
        registeredApps.add(new Pair<String, String>(LOCAL_REGION_APP_NAME, LOCAL_REGION_APP_NAME));
    }

}>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_aa986ae_507bb14/rev_aa986ae-507bb14/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
||||||| BASE
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_aa986ae_507bb14/rev_aa986ae-507bb14/eureka-core/src/test/java/com/netflix/eureka/cluster/ReplicationTaskProcessorTest.java;<<<<<<< MINE
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
import com.netflix.eureka.cluster.ReplicationTask.ProcessingState;
import org.junit.After;
||||||| BASE
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
import com.netflix.eureka.cluster.ReplicationTask.ProcessingState;
import org.junit.After;
=======
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
import com.netflix.eureka.cluster.TestableInstanceReplicationTask.ProcessingState;
import com.netflix.eureka.util.batcher.TaskProcessor.ProcessingResult;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_aa986ae_507bb14/rev_aa986ae-507bb14/eureka-core/src/test/java/com/netflix/eureka/cluster/ClusterSampleData.java;<<<<<<< MINE
    public static final long MAX_PROCESSING_DELAY_MS = 50;

||||||| BASE
    public static final long MAX_PROCESSING_DELAY_MS = 10;

=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/EurekaServerConfig.java;<<<<<<< MINE

    /**
     * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
     * the corresponding configuration can be put into experimental configuration section.
     *
     * @return a property of experimental feature
     */
    String getExperimental(String name);
||||||| BASE
=======

    /**
     * To avoid configuration API pollution when trying new/experimental or features or for the migration process,
     * the corresponding configuration can be put into experimental configuration section.
     *
     * @return a property of experimental feature
     */
    String getExperimental(String name);


    /**
     * Get the configured binding strategy EIP or Route53.
     * @return the configured binding strategy
     */
    AwsBindingStrategy getBindingStrategy();

    /**
     *
     * @return the ttl used to set up the route53 domain if new
     */
    long getRoute53DomainTTL();

    /**
     * Gets the number of times the server should try to bind to the candidate
     * Route53 domain.
     *
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the number of times the server should try to bind to the
     *         candidate Route53 domain.
     */
    int getRoute53BindRebindRetries();

    /**
     * Gets the interval with which the server should check if the Route53 domain is bound
     * and should try to bind in the case if it is already not bound.
     * <p>
     * <em>The changes are effective at runtime.</em>
     * </p>
     *
     * @return the time in milliseconds.
     */
    int getRoute53BindingRetryIntervalMs();
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE
import com.netflix.discovery.shared.transport.EurekaHttpResponse;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
||||||| BASE
import com.netflix.discovery.shared.EurekaHttpClient.HttpResponse;
import com.netflix.eureka.EurekaServerConfig;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.discovery.shared.EurekaHttpClient.HttpResponse;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE
    public void shutdown() {
        batcher.stop();
    }

    private void executeSingle(List<ReplicationTask> tasks) {
        for (ReplicationTask task : tasks) {
            long lastNetworkErrorTime = 0;
            boolean done;
            do {
                done = true;
                try {
                    if (isLate(task)) {
                        continue;
                    }
                    DynamicCounter.increment("Single_" + task.getAction().name() + "_tries");

                    EurekaHttpResponse<?> httpResponse = task.execute();
                    int statusCode = httpResponse.getStatusCode();
                    Object entity = httpResponse.getEntity();
                    if (logger.isDebugEnabled()) {
                        logger.debug("Replication task {} completed with status {}, (includes entity {})", task.getTaskName(), statusCode, entity != null);
                    }
                    if (isSuccess(statusCode)) {
                        DynamicCounter.increment("Single_" + task.getAction().name() + "_success");
                        task.handleSuccess();
                    } else {
                        DynamicCounter.increment("Single_" + task.getAction().name() + "_failure");
                        task.handleFailure(statusCode, entity);
                    }
                } catch (Throwable e) {
                    if (isNetworkConnectException(e)) {
                        long now = System.currentTimeMillis();
                        // We want to retry eagerly, but without flooding log file with tons of error entries.
                        // As tasks are executed by a pool of threads the error logging multiplies. For example:
                        // 20 threads * 100ms delay == 200 error entries / sec worst case
                        // Still we would like to see the exception samples, so we print samples at regular intervals.
                        if (now - lastNetworkErrorTime > 10000) {
                            lastNetworkErrorTime = now;
                            logger.error("Network level connection to peer " + peerId + " for task " + task.getTaskName() + "; retrying after delay", e);
                        }
                        try {
                            Thread.sleep(retrySleepTimeMs);
                        } catch (InterruptedException ignore) {
                        }
                        DynamicCounter.increment(task.getAction().name() + "_retries");
                        done = false;
                    } else {
                        logger.error(peerId + ": " + task.getTaskName() + "Not re-trying this exception because it does not seem to be a network exception", e);
                    }
||||||| BASE
    public void shutdown() {
        batcher.stop();
    }

    private void executeSingle(List<ReplicationTask> tasks) {
        for (ReplicationTask task : tasks) {
            long lastNetworkErrorTime = 0;
            boolean done;
            do {
                done = true;
                try {
                    if (isLate(task)) {
                        continue;
                    }
                    DynamicCounter.increment("Single_" + task.getAction().name() + "_tries");

                    HttpResponse<?> httpResponse = task.execute();
                    int statusCode = httpResponse.getStatusCode();
                    Object entity = httpResponse.getEntity();
                    if (logger.isDebugEnabled()) {
                        logger.debug("Replication task {} completed with status {}, (includes entity {})", task.getTaskName(), statusCode, entity != null);
                    }
                    if (isSuccess(statusCode)) {
                        DynamicCounter.increment("Single_" + task.getAction().name() + "_success");
                        task.handleSuccess();
                    } else {
                        DynamicCounter.increment("Single_" + task.getAction().name() + "_failure");
                        task.handleFailure(statusCode, entity);
                    }
                } catch (Throwable e) {
                    if (isNetworkConnectException(e)) {
                        long now = System.currentTimeMillis();
                        // We want to retry eagerly, but without flooding log file with tons of error entries.
                        // As tasks are executed by a pool of threads the error logging multiplies. For example:
                        // 20 threads * 100ms delay == 200 error entries / sec worst case
                        // Still we would like to see the exception samples, so we print samples at regular intervals.
                        if (now - lastNetworkErrorTime > 10000) {
                            lastNetworkErrorTime = now;
                            logger.error("Network level connection to peer " + peerId + " for task " + task.getTaskName() + "; retrying after delay", e);
                        }
                        try {
                            Thread.sleep(retrySleepTimeMs);
                        } catch (InterruptedException ignore) {
                        }
                        DynamicCounter.increment(task.getAction().name() + "_retries");
                        done = false;
                    } else {
                        logger.error(peerId + ": " + task.getTaskName() + "Not re-trying this exception because it does not seem to be a network exception", e);
                    }
=======
    @Override
    public ProcessingResult process(List<ReplicationTask> tasks) {
        ReplicationList list = createReplicationListOf(tasks);
        try {
            HttpResponse<ReplicationListResponse> response = replicationClient.submitBatchUpdates(list);
            int statusCode = response.getStatusCode();
            if (!isSuccess(statusCode)) {
                if (statusCode == 503) {
                    logger.warn("Server busy (503) HTTP status code received from the peer {}; rescheduling tasks after delay", peerId);
                    return ProcessingResult.Congestion;
                } else {
                    // Unexpected error returned from the server. This should ideally never happen.
                    logger.error("Batch update failure with HTTP status code {}; discarding {} replication tasks", statusCode, tasks.size());
                    return ProcessingResult.PermanentError;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/cluster/ReplicationTaskProcessor.java;<<<<<<< MINE

        Action action = list.getReplicationList().get(0).getAction();
        DynamicCounter.increment("Batch_" + action + "_tries");

        long lastNetworkErrorTime = 0;
        boolean done;
        do {
            done = true;
            try {
                EurekaHttpResponse<ReplicationListResponse> response = replicationClient.submitBatchUpdates(list);
                int statusCode = response.getStatusCode();
                if (!isSuccess(statusCode)) {
                    if (statusCode == 503) {
                        logger.warn("Server busy (503) HTTP status code received from the peer {}; rescheduling tasks after delay", peerId);
                        rescheduleAfterDelay(tasks);
                    } else {
                        // Unexpected error returned from the server. This should ideally never happen.
                        logger.error("Batch update failure with HTTP status code {}; discarding {} replication tasks", statusCode, tasks.size());
                    }
                    return;
                }
                DynamicCounter.increment("Batch_" + action + "_success");

                handleBatchResponse(tasks, response.getEntity().getResponseList());
            } catch (Throwable e) {
                if (isNetworkConnectException(e)) {
                    long now = System.currentTimeMillis();
                    // We want to retry eagerly, but without flooding log file with tons of error entries.
                    // As tasks are executed by a pool of threads the error logging multiplies. For example:
                    // 20 threads * 100ms delay == 200 error entries / sec worst case
                    // Still we would like to see the exception samples, so we print samples at regular intervals
                    if (now - lastNetworkErrorTime > 10000) {
                        lastNetworkErrorTime = now;
                        logger.error("Network level connection to peer " + peerId + "; retrying after delay", e);
                    }

                    try {
                        Thread.sleep(retrySleepTimeMs);
                    } catch (InterruptedException ignore) {
                    }
                    done = false;
                    DynamicCounter.increment("Batch_" + action + "_retries");
                } else {
                    logger.error("Not re-trying this exception because it does not seem to be a network exception", e);
                }
            }
        } while (!done);
||||||| BASE

        Action action = list.getReplicationList().get(0).getAction();
        DynamicCounter.increment("Batch_" + action + "_tries");

        long lastNetworkErrorTime = 0;
        boolean done;
        do {
            done = true;
            try {
                HttpResponse<ReplicationListResponse> response = replicationClient.submitBatchUpdates(list);
                int statusCode = response.getStatusCode();
                if (!isSuccess(statusCode)) {
                    if (statusCode == 503) {
                        logger.warn("Server busy (503) HTTP status code received from the peer {}; rescheduling tasks after delay", peerId);
                        rescheduleAfterDelay(tasks);
                    } else {
                        // Unexpected error returned from the server. This should ideally never happen.
                        logger.error("Batch update failure with HTTP status code {}; discarding {} replication tasks", statusCode, tasks.size());
                    }
                    return;
                }
                DynamicCounter.increment("Batch_" + action + "_success");

                handleBatchResponse(tasks, response.getEntity().getResponseList());
            } catch (Throwable e) {
                if (isNetworkConnectException(e)) {
                    long now = System.currentTimeMillis();
                    // We want to retry eagerly, but without flooding log file with tons of error entries.
                    // As tasks are executed by a pool of threads the error logging multiplies. For example:
                    // 20 threads * 100ms delay == 200 error entries / sec worst case
                    // Still we would like to see the exception samples, so we print samples at regular intervals
                    if (now - lastNetworkErrorTime > 10000) {
                        lastNetworkErrorTime = now;
                        logger.error("Network level connection to peer " + peerId + "; retrying after delay", e);
                    }

                    try {
                        Thread.sleep(retrySleepTimeMs);
                    } catch (InterruptedException ignore) {
                    }
                    done = false;
                    DynamicCounter.increment("Batch_" + action + "_retries");
                } else {
                    logger.error("Not re-trying this exception because it does not seem to be a network exception", e);
                }
            }
        } while (!done);
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-core/src/main/java/com/netflix/eureka/DefaultEurekaServerConfig.java;<<<<<<< MINE

    @Override
    public String getExperimental(String name) {
        return configInstance.getStringProperty(namespace + "experimental." + name, null).get();
    }
||||||| BASE
=======

    @Override
    public String getExperimental(String name) {
        return configInstance.getStringProperty(namespace + "experimental." + name, null).get();
    }

    @Override
    public int getRoute53BindRebindRetries() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetries", 3).get();

    }

    @Override
    public int getRoute53BindingRetryIntervalMs() {
        return configInstance.getIntProperty(
                namespace + "route53BindRebindRetryIntervalMs", (5 * 60 * 1000))
                .get();
    }

    @Override
    public long getRoute53DomainTTL() {
        return configInstance.getLongProperty(
                namespace + "route53DomainTTL", 30l)
                .get();
    }

    @Override
    public AwsBindingStrategy getBindingStrategy() {
        return AwsBindingStrategy.valueOf(configInstance.getStringProperty(namespace + "awsBindingStrategy", AwsBindingStrategy.EIP.name()).get().toUpperCase());
    }
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client-archaius2/src/main/java/com/netflix/discovery/EurekaArchaius2ClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client/src/main/java/com/netflix/discovery/DefaultEurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_2529120_333a91e/rev_2529120-333a91e/eureka-client/src/main/java/com/netflix/discovery/EurekaClientConfig.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b49487b_7fadaa1/rev_b49487b-7fadaa1/eureka-core/src/main/java/com/netflix/eureka/cluster/PeerEurekaNode.java;<<<<<<< MINE
import com.netflix.eureka.registry.PeerAwareInstanceRegistry;
import com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl.Action;
||||||| BASE
import com.netflix.eureka.PeerAwareInstanceRegistry;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
=======
import com.netflix.eureka.PeerAwareInstanceRegistry;
import com.netflix.eureka.PeerAwareInstanceRegistryImpl.Action;
import com.netflix.eureka.lease.Lease;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_b49487b_7fadaa1/rev_b49487b-7fadaa1/eureka-core/src/main/java/com/netflix/eureka/resources/StatusResource.java;<<<<<<< MINE
    @GET
    public StatusInfo getStatusInfo() {
        return statusUtil.getStatusInfo();
||||||| BASE
    private boolean isReplicaAvailable(String myAppName, String url) {

        try {
            String givenHostName = new URI(url).getHost();
            Application app = PeerAwareInstanceRegistryImpl.getInstance()
                    .getApplication(myAppName, false);
            for (InstanceInfo info : app.getInstances()) {
                if (info.getHostName().equals(givenHostName)) {
                    return true;
                }
            }
            givenHostName = new URI(url).getHost();
        } catch (Throwable e) {
            logger.error("Could not determine if the replica is available ", e);
        }
        return false;
=======
    private boolean isReplicaAvailable(String myAppName, String url) {

        try {
            String givenHostName = new URI(url).getHost();
            Application app = PeerAwareInstanceRegistryImpl.getInstance()
                    .getApplication(myAppName, false);
            if (app == null) {
                return false;
            }
            for (InstanceInfo info : app.getInstances()) {
                if (info.getHostName().equals(givenHostName)) {
                    return true;
                }
            }
            givenHostName = new URI(url).getHost();
        } catch (Throwable e) {
            logger.error("Could not determine if the replica is available ", e);
        }
        return false;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_0f89d2a_f35b620/rev_0f89d2a-f35b620/eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_f35b620_0f89d2a/rev_f35b620-0f89d2a/eureka-core/src/main/java/com/netflix/eureka/aws/EIPManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_e7062d2_5e462f7/rev_e7062d2-5e462f7/eureka-client/src/test/java/com/netflix/discovery/guice/EurekaModuleTest.java;<<<<<<< MINE
import com.google.inject.Binding;
import com.google.inject.Key;
||||||| BASE
import com.google.inject.Injector;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_203fa01_9950fce/rev_203fa01-9950fce/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_203fa01_9950fce/rev_203fa01-9950fce/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/eureka/revisions/rev_203fa01_9950fce/rev_203fa01-9950fce/eureka-core/src/main/java/com/netflix/eureka/util/StatusUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/ghostdriver/revisions/rev_30d2ebf_3b872e9/rev_30d2ebf-3b872e9/test/src/test/java/ghostdriver/CookieTest.java;<<<<<<< MINE
import org.openqa.selenium.Cookie;
||||||| BASE
import java.util.Date;
import java.util.Set;

=======

import java.io.IOException;
import java.util.Date;
import java.util.Set;

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/ghostdriver/revisions/rev_30d2ebf_3b872e9/rev_30d2ebf-3b872e9/test/src/test/java/ghostdriver/CookieTest.java;<<<<<<< MINE
    public void shouldBeAbleToAddCookie() {
        WebDriver d = getDriver();
        d.get("http://www.github.com");
||||||| BASE
    public void shouldBeAbleToAddCookie() throws InterruptedException {
        WebDriver d = getDriver();
        d.get("http://www.github.com");
=======
    public void gettingAllCookiesOnANonCookieSettingPage() {
        server.setGetHandler(EMPTY_CALLBACK);
        goToPage();
        assertEquals(0, getCookies().length);
    }

    @Test
    public void deletingAllCookies() {
        server.setGetHandler(COOKIE_SETTING_CALLBACK);
        goToPage();
        driver.manage().deleteAllCookies();

        assertEquals(0, getCookies().length);
    }

    @Test
    public void deletingOneCookie() {
        server.setGetHandler(COOKIE_SETTING_CALLBACK);
        goToPage();

        driver.manage().deleteCookieNamed("test");
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/ghostdriver/revisions/rev_30d2ebf_3b872e9/rev_30d2ebf-3b872e9/test/src/test/java/ghostdriver/CookieTest.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;<<<<<<< MINE
					if ((!match.equalsIgnoreCase("")) && (!p.getDescription().getName().toLowerCase().contains(match))
									&& (!p.getDescription().getDescription().toLowerCase().contains(match)))
					{
						continue;
					}
					
||||||| BASE
=======
					if ((!match.equalsIgnoreCase("")) && (!p.getDescription().getName().toLowerCase().contains(match))
						&& (!p.getDescription().getDescription().toLowerCase().contains(match)))
					{
						continue;
					}

>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_29233cb_52f8582/rev_29233cb-52f8582/Essentials/src/com/earth2me/essentials/commands/Commandhelp.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/api/Economy.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/api/Economy.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/api/Economy.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;<<<<<<< MINE
import org.bukkit.block.CreatureSpawner;
import org.bukkit.craftbukkit.block.CraftCreatureSpawner;
||||||| BASE
import org.bukkit.block.CreatureSpawner;
=======
import org.bukkit.craftbukkit.block.CraftCreatureSpawner;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Essentials.java;<<<<<<< MINE
	public static final String AUTHORS = "Zenexer, ementalo, Aelux, Brettflan, KimKandor, snowleo, ceulemans and Xeology";
	public static final int minBukkitBuildVersion = 953;
	private static final Logger logger = Logger.getLogger("Minecraft");
	private Settings settings;
	private EssentialsPlayerListener playerListener;
	private EssentialsBlockListener blockListener;
	private EssentialsEntityListener entityListener;
	private JailPlayerListener jailPlayerListener;
	private static Essentials instance = null;
	private Spawn spawn;
	private Jail jail;
	private Warps warps;
	private Worth worth;
	private List<IConf> confList;
	public ArrayList bans = new ArrayList();
	public ArrayList bannedIps = new ArrayList();
	private Backup backup;
	private final Map<String, User> users = new HashMap<String, User>();
	private EssentialsTimer timer;
	private EssentialsUpdateTimer updateTimer;
	private boolean registerFallback = true;
	private final Methods paymentMethod = new Methods();
	private final static boolean enableErrorLogging = false;
	private final EssentialsErrorHandler errorHandler = new EssentialsErrorHandler();
||||||| BASE
	public static final String AUTHORS = "Zenexer, ementalo, Aelux, Brettflan, KimKandor, snowleo, ceulemans and Xeology";
	public static final int minBukkitBuildVersion = 860;
	private static final Logger logger = Logger.getLogger("Minecraft");
	private Settings settings;
	private EssentialsPlayerListener playerListener;
	private EssentialsBlockListener blockListener;
	private EssentialsEntityListener entityListener;
	private JailPlayerListener jailPlayerListener;
	private static Essentials instance = null;
	private Spawn spawn;
	private Jail jail;
	private Warps warps;
	private Worth worth;
	private List<IConf> confList;
	public ArrayList bans = new ArrayList();
	public ArrayList bannedIps = new ArrayList();
	private Backup backup;
	private final Map<String, User> users = new HashMap<String, User>();
	private EssentialsTimer timer;
	private EssentialsUpdateTimer updateTimer;
	private boolean registerFallback = true;
	private final Methods paymentMethod = new Methods();
	private final static boolean enableErrorLogging = false;
	private final EssentialsErrorHandler errorHandler = new EssentialsErrorHandler();
=======
	public static final int BUKKIT_VERSION = 974;
	private static final Logger LOGGER = Logger.getLogger("Minecraft");
	private transient ISettings settings;
	private final transient TNTExplodeListener tntListener = new TNTExplodeListener(this);
	private transient Spawn spawn;
	private transient Jail jail;
	private transient Warps warps;
	private transient Worth worth;
	private transient List<IConf> confList;
	private transient Backup backup;
	private transient BanWorkaround bans;
	private transient ItemDb itemDb;
	private transient final Map<String, User> users = new HashMap<String, User>();
	private transient EssentialsUpdateTimer updateTimer;
	private transient final Methods paymentMethod = new Methods();
	private transient final static boolean enableErrorLogging = false;
	private transient final EssentialsErrorHandler errorHandler = new EssentialsErrorHandler();
	private transient IPermissionsHandler permissionsHandler;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_1a715bd_455fbd8/rev_1a715bd-455fbd8/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_34e23e6_daaf966/rev_34e23e6-daaf966/Essentials/src/com/earth2me/essentials/DescParseTickFormat.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_34e23e6_daaf966/rev_34e23e6-daaf966/Essentials/src/com/earth2me/essentials/DescParseTickFormat.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandpowertool.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandpowertool.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandjails.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandjails.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandhome.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandwarp.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandrepair.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/commands/Commandrepair.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ffe19e6_85bf61f/rev_ffe19e6-85bf61f/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/Entry.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/Group.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_512d6a3_7562c77/rev_512d6a3-7562c77/EssentialsGroupBridge/src/com/nijiko/permissions/PermissionHandler.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7cec201_df0d773/rev_7cec201-df0d773/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7cec201_df0d773/rev_7cec201-df0d773/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/commands/Commandworld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Essentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/signs/EssentialsSign.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/Teleport.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8aba67f_d3dace3/rev_8aba67f-d3dace3/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_9a172c7_db9df18/rev_9a172c7-db9df18/Essentials/src/com/earth2me/essentials/commands/Commandenchant.java;<<<<<<< MINE
import com.earth2me.essentials.craftbukkit.EnchantmentFix;
import java.util.*;
||||||| BASE
import com.earth2me.essentials.craftbukkit.EnchantmentFix;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
=======
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_9a172c7_db9df18/rev_9a172c7-db9df18/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;<<<<<<< MINE
import static com.earth2me.essentials.I18n._;
import com.earth2me.essentials.craftbukkit.EnchantmentFix;
||||||| BASE
import com.earth2me.essentials.craftbukkit.EnchantmentFix;
=======
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_9a172c7_db9df18/rev_9a172c7-db9df18/Essentials/src/com/earth2me/essentials/EssentialsConf.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/Essentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a5a2307_293e7b0/rev_a5a2307-293e7b0/Essentials/src/com/earth2me/essentials/IEssentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/commands/Commandbreak.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/storage/AbstractDelayedYamlFileReader.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/storage/AbstractDelayedYamlFileReader.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/storage/AbstractDelayedYamlFileReader.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_4cb7ac8_ce6f6ad/rev_4cb7ac8-ce6f6ad/Essentials/src/com/earth2me/essentials/Essentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsGroupManager/src/org/anjocaido/groupmanager/GroupManager.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/test/com/earth2me/essentials/FakeServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/test/com/earth2me/essentials/FakeServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/test/com/earth2me/essentials/FakeServer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/api/Economy.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawner.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandkillall.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Essentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/textreader/HelpInput.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/textreader/HelpInput.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/textreader/HelpInput.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/OfflinePlayer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignFree.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignFree.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignFree.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignDisposal.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/signs/SignDisposal.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/user/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Jails.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/Jails.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeInventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeWorld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/craftbukkit/FakeWorld.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/Essentials/src/com/earth2me/essentials/IUser.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsUpdate/src/com/earth2me/essentials/update/VersionInfo.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsUpdate/src/com/earth2me/essentials/update/states/InstallationFinishedEvent.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ecbbc9f_6f9654e/rev_ecbbc9f-6f9654e/EssentialsUpdate/src/com/earth2me/essentials/update/states/InstallationFinishedEvent.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/EssentialsSpawn/src/com/earth2me/essentials/spawn/EssentialsSpawnPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsBlockListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Settings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/api/Economy.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalancetop.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalancetop.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandlist.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandlist.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandessentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandsell.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandworth.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandantioch.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandspawnmob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalance.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandbalance.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandwhois.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/commands/Commandeco.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsPlayerListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Kit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Mob.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/EssentialsSign.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/signs/SignTrade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/Util.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/UserData.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/ISettings.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/User.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d83437e_af43197/rev_d83437e-af43197/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_ce1e923_0da3bc3/rev_ce1e923-0da3bc3/EssentialsGroupManager/src/org/anjocaido/groupmanager/permissions/BukkitPermissions.java;<<<<<<< MINE
		/*
		 * Trigger at highest so we tidy up last.
		 */
		@EventHandler(priority = EventPriority.HIGHEST)
||||||| BASE
		@EventHandler(priority = EventPriority.LOWEST)
		public void onPlayerKick(PlayerKickEvent event) {

			Player player = event.getPlayer();
			
			/*
			 * force remove any attachments as bukkit may not
			 */
			removeAttachment(player);
		}

		@EventHandler(priority = EventPriority.LOWEST)
=======
		@EventHandler(priority = EventPriority.HIGHEST)
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_136d60e_f3a2b27/rev_136d60e-f3a2b27/Essentials/src/com/earth2me/essentials/EssentialsEntityListener.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_eed0edd_b37b165/rev_eed0edd-b37b165/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_eed0edd_b37b165/rev_eed0edd-b37b165/Essentials/src/com/earth2me/essentials/signs/SignKit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_eed0edd_b37b165/rev_eed0edd-b37b165/Essentials/src/com/earth2me/essentials/signs/SignWarp.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_c9ef36a_8143b25/rev_c9ef36a-8143b25/Essentials/src/com/earth2me/essentials/commands/Commandmail.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_c9ef36a_8143b25/rev_c9ef36a-8143b25/Essentials/src/com/earth2me/essentials/commands/Commandmail.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_c9ef36a_8143b25/rev_c9ef36a-8143b25/Essentials/src/com/earth2me/essentials/commands/Commandmail.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandsell.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandgive.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandgive.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commanditem.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commanditem.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandhat.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/commands/Commandunlimited.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/storage/BukkitConstructor.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Essentials.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/textreader/KeywordReplacer.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Trade.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Kit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/Kit.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_22ee57c_eabbd39/rev_22ee57c-eabbd39/Essentials/src/com/earth2me/essentials/craftbukkit/InventoryWorkaround.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_a579845_d73bbd4/rev_a579845-d73bbd4/Essentials/src/com/earth2me/essentials/commands/Commandtpaccept.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_d3ca002_df1e4a2/rev_d3ca002-df1e4a2/Essentials/src/com/earth2me/essentials/commands/Commandbook.java;<<<<<<< MINE
			throw new Exception(_("holdBook"));
||||||| BASE
			throw new Exception("You are not holding a writable book.");
=======
			throw new Exception(_("holdBook"));
		}
	}

	private boolean isAuthor(BookMeta bmeta, String player)
	{
		if (bmeta.getAuthor().equalsIgnoreCase(player))
		{
			return true;
>>>>>>> YOURS
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_7bc16a6_8962ce6/rev_7bc16a6-8962ce6/Essentials/src/com/earth2me/essentials/commands/Commandclearinventory.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/commands/Commandpotion.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/MetaItemStack.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/MetaItemStack.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_6ee21e1_e766377/rev_6ee21e1-e766377/Essentials/src/com/earth2me/essentials/MetaItemStack.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/commands/Commandunbanip.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/perm/PermissionsHandler.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/perm/PermissionsHandler.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_8d359a2_f2cb9d8/rev_8d359a2-f2cb9d8/Essentials/src/com/earth2me/essentials/perm/PermissionsHandler.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_46ab4d0_baa9f0a/rev_46ab4d0-baa9f0a/Essentials/src/com/earth2me/essentials/utils/FormatUtil.java;null
/home/paper219/Desktop/analysis/fullsample/projects/essentials/revisions/rev_46ab4d0_baa9f0a/rev_46ab4d0-baa9f0a/Essentials/src/com/earth2me/essentials/utils/FormatUtil.java;null
